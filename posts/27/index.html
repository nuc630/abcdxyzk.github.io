
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/05/15/kernel-net-tcp_urg/">TCP的URG标志和内核实现</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-15T13:51:00+08:00'><span class='date'>2015-05-15</span> <span class='time'>13:51:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/phenix_lord/article/details/42012931">TCP的URG标志和内核实现之一：协议</a><br/>
<a href="http://blog.csdn.net/phenix_lord/article/details/42046125">TCP的URG标志和内核实现之二：发送的实现</a><br/>
<a href="http://blog.csdn.net/phenix_lord/article/details/42065897">TCP的URG标志和内核实现之三：接收的实现</a></p>

<hr />

<h3>TCP的URG标志和内核实现之一：协议</h3>

<p>定义urgent数据的目的：<br/>
urgent机制，是用于通知应用层需要接收urgent data，在urgent data接收完成后，通知应用层urgent data数据接收完毕。相关协议文本RFC793 RFC1122 RFC6093</p>

<h4>哪些数据是urgent data？</h4>

<h5>协议规定</h5>

<p>在TCP报头的URG位有效的时候，通过TCP报头中的urgent pointer来标识urgent data的位置，但是在urgent pointer的解析方式上各个协议文本的描述有差异：</p>

<p>解读一：RFC793  P17，描述是“The urgent pointer points to the sequence number of the octet following the urgent data.”，在P41有描述“This mechanism permits a point in the data stream to be designated as the end of urgent information. Whenever this point is in advance of the receive sequence number (RCV.NXT) at the receiving TCP, that TCP must tell the user to go into &ldquo;urgent mode&rdquo;; when the receive sequence number catches up to the urgent pointer, the TCP must tell user to go”，可以认为是：当前接收的报文中SEQ在SEG.SEQ+Urgent Pointer之前的都是,而urgent pointer是第一个非urgent data（ TCP已经接受，但是还没有提交给应用的数据是不是呢？）</p>

<p>解读二：在P56的描述是“If the urgent flag is set, then SND.UP &lt;-SND.NXT-1 and set the urgent pointer in the outgoing segments”，也就是urgent pointer是最后一个urgent data字节。而在RFC1122中消除了这一歧义：在P84中说明“the urgent pointer points to the sequence number of the LAST octet (not LAST+1) in a sequence of urgent data”</p>

<h5>linux实现</h5>

<p>虽然在RFC1122中消除了这一歧义，linux仍然使用了解读一的解析方式，如果要使用解读二定义的方式，需要使用tcp_stdurg这个配置项。</p>

<h4>urgent data数据能有多长？</h4>

<h5>协议规定</h5>

<p>按照RFC793 P41的描述，长度不受限，RFC1122 P84中，更是明确了“A TCP MUST support a sequence of urgent data of any length”</p>

<h5>linux实现</h5>

<p>其实，linux只支持1BYTE的urgent data</p>

<h4>urgent data与OOB数据</h4>

<p>OOB数据说的是带外数据，也就是这些数据不是放到TCP流供读取的，而是通过额外的接口来获取，linux默认把urgent data实现为OOB数据；而按照协议的规定，urgent data不是out of band data</p>

<p>由于OOB数据的协议和实现上存在很多不确定因素，因此现在已经不建议使用了</p>

<hr />

<h3>TCP的URG标志和内核实现之二：发送的实现</h3>

<p>Linxu内核在默认情况下，把urgent data实现为OOB数据</p>

<h4>发送URG数据的接口</h4>

<p>在内核态，使用kernel_sendmsg/kernel_sendpage完成发送，只不过需要加上MSG_OOB标志，表示要发送的URG数据。</p>

<h4>URG数据发送接口的实现</h4>

<p>分片主要在kernel_sendmsg中完成，在OOB数据的处理上，它和kernel_sendpage是一致</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,  
</span><span class='line'>&#9;&#9;size_t size)  
</span><span class='line'>{  
</span><span class='line'>&#9;。。。。。。。。。。。。。。  
</span><span class='line'>&#9;/*如果flags设置了MSG_OOB该接口其实返回的mss_now关闭了TSO功能*/  
</span><span class='line'>&#9;mss_now = tcp_send_mss(sk, &size_goal, flags);  
</span><span class='line'>&#9;。。。。。。。。。。。。。。  
</span><span class='line'>&#9;while (--iovlen &gt;= 0) {  
</span><span class='line'>&#9;&#9;size_t seglen = iov-&gt;iov_len;  
</span><span class='line'>&#9;&#9;unsigned char __user *from = iov-&gt;iov_base;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;iov++;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;while (seglen &gt; 0) {  
</span><span class='line'>&#9;&#9;&#9;int copy = 0;  
</span><span class='line'>&#9;&#9;&#9;int max = size_goal;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;skb = tcp_write_queue_tail(sk);  
</span><span class='line'>&#9;&#9;&#9;if (tcp_send_head(sk)) {  
</span><span class='line'>&#9;&#9;&#9;&#9;if (skb-&gt;ip_summed == CHECKSUM_NONE)  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;max = mss_now;  
</span><span class='line'>&#9;&#9;&#9;&#9;copy = max - skb-&gt;len;  
</span><span class='line'>&#9;&#9;&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (copy &lt;= 0) {  
</span><span class='line'>new_segment:  
</span><span class='line'>&#9;&#9;&#9;&#9;/* Allocate new segment. If the interface is SG, 
</span><span class='line'>&#9;&#9;&#9;&#9; * allocate skb fitting to single page. 
</span><span class='line'>&#9;&#9;&#9;&#9; */  
</span><span class='line'>&#9;&#9;&#9;&#9;if (!sk_stream_memory_free(sk))  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto wait_for_sndbuf;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;skb = sk_stream_alloc_skb(sk,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;  select_size(sk, sg),  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;  sk-&gt;sk_allocation);  
</span><span class='line'>&#9;&#9;&#9;&#9;if (!skb)  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto wait_for_memory;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;/* 
</span><span class='line'>&#9;&#9;&#9;&#9; * Check whether we can use HW checksum. 
</span><span class='line'>&#9;&#9;&#9;&#9; */  
</span><span class='line'>&#9;&#9;&#9;&#9;if (sk-&gt;sk_route_caps & NETIF_F_ALL_CSUM)  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;skb-&gt;ip_summed = CHECKSUM_PARTIAL;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;skb_entail(sk, skb);  
</span><span class='line'>&#9;&#9;&#9;&#9;copy = size_goal;  
</span><span class='line'>&#9;&#9;&#9;&#9;max = size_goal;  
</span><span class='line'>&#9;&#9;&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* Try to append data to the end of skb. */  
</span><span class='line'>&#9;&#9;&#9;if (copy &gt; seglen)  
</span><span class='line'>&#9;&#9;&#9;&#9;copy = seglen;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* Where to copy to? */  
</span><span class='line'>&#9;&#9;&#9;if (skb_availroom(skb) &gt; 0) {  
</span><span class='line'>&#9;&#9;&#9;&#9;/* We have some space in skb head. Superb! */  
</span><span class='line'>&#9;&#9;&#9;&#9;copy = min_t(int, copy, skb_availroom(skb));  
</span><span class='line'>&#9;&#9;&#9;&#9;err = skb_add_data_nocache(sk, skb, from, copy);  
</span><span class='line'>&#9;&#9;&#9;&#9;if (err)  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto do_fault;  
</span><span class='line'>&#9;&#9;&#9;} else {  
</span><span class='line'>&#9;&#9;&#9;&#9;int merge = 0;  
</span><span class='line'>&#9;&#9;&#9;&#9;int i = skb_shinfo(skb)-&gt;nr_frags;  
</span><span class='line'>&#9;&#9;&#9;&#9;struct page *page = sk-&gt;sk_sndmsg_page;  
</span><span class='line'>&#9;&#9;&#9;&#9;int off;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (page && page_count(page) == 1)  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;sk-&gt;sk_sndmsg_off = 0;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;off = sk-&gt;sk_sndmsg_off;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (skb_can_coalesce(skb, i, page, off) &&  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;off != PAGE_SIZE) {  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;/* We can extend the last page 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; * fragment. */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;merge = 1;  
</span><span class='line'>&#9;&#9;&#9;&#9;} else if (i == MAX_SKB_FRAGS || !sg) {  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;/* Need to add new fragment and cannot 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; * do this because interface is non-SG, 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; * or because all the page slots are 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; * busy. */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tcp_mark_push(tp, skb);  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto new_segment;  
</span><span class='line'>&#9;&#9;&#9;&#9;} else if (page) {  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;if (off == PAGE_SIZE) {  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;put_page(page);  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;sk-&gt;sk_sndmsg_page = page = NULL;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;off = 0;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;}  
</span><span class='line'>&#9;&#9;&#9;&#9;} else  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;off = 0;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (copy &gt; PAGE_SIZE - off)  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;copy = PAGE_SIZE - off;  
</span><span class='line'>&#9;&#9;&#9;&#9;if (!sk_wmem_schedule(sk, copy))  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto wait_for_memory;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (!page) {  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;/* Allocate new cache page. */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;if (!(page = sk_stream_alloc_page(sk)))  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;goto wait_for_memory;  
</span><span class='line'>&#9;&#9;&#9;&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;/* Time to copy data. We are close to 
</span><span class='line'>&#9;&#9;&#9;&#9; * the end! */  
</span><span class='line'>&#9;&#9;&#9;&#9;err = skb_copy_to_page_nocache(sk, from, skb,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;   page, off, copy);  
</span><span class='line'>&#9;&#9;&#9;&#9;if (err) {  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;/* If this page was new, give it to the 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; * socket so it does not get leaked. 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;if (!sk-&gt;sk_sndmsg_page) {  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;sk-&gt;sk_sndmsg_page = page;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;sk-&gt;sk_sndmsg_off = 0;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;}  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto do_error;  
</span><span class='line'>&#9;&#9;&#9;&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;/* Update the skb. */  
</span><span class='line'>&#9;&#9;&#9;&#9;if (merge) {  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;skb_frag_size_add(&skb_shinfo(skb)-&gt;frags[i - 1], copy);  
</span><span class='line'>&#9;&#9;&#9;&#9;} else {  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;skb_fill_page_desc(skb, i, page, off, copy);  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;if (sk-&gt;sk_sndmsg_page) {  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;get_page(page);  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;} else if (off + copy &lt; PAGE_SIZE) {  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;get_page(page);  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;sk-&gt;sk_sndmsg_page = page;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;}  
</span><span class='line'>&#9;&#9;&#9;&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;sk-&gt;sk_sndmsg_off = off + copy;  
</span><span class='line'>&#9;&#9;&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (!copied)  
</span><span class='line'>&#9;&#9;&#9;&#9;TCP_SKB_CB(skb)-&gt;tcp_flags &= ~TCPHDR_PSH;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;tp-&gt;write_seq += copy;  
</span><span class='line'>&#9;&#9;&#9;TCP_SKB_CB(skb)-&gt;end_seq += copy;  
</span><span class='line'>&#9;&#9;&#9;skb_shinfo(skb)-&gt;gso_segs = 0;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;from += copy;  
</span><span class='line'>&#9;&#9;&#9;copied += copy;  
</span><span class='line'>&#9;&#9;&#9;if ((seglen -= copy) == 0 && iovlen == 0)  
</span><span class='line'>&#9;&#9;&#9;&#9;goto out;  
</span><span class='line'>&#9;&#9;&#9;/*对于OOB数据，即使一个分片用光，如果还有 
</span><span class='line'>&#9;&#9;&#9;send_buff和OOB数据，就继续积累分片*/  
</span><span class='line'>&#9;&#9;&#9;if (skb-&gt;len &lt; max || (flags & MSG_OOB))  
</span><span class='line'>&#9;&#9;&#9;&#9;continue;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (forced_push(tp)) {  
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_mark_push(tp, skb);  
</span><span class='line'>&#9;&#9;&#9;&#9;__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);  
</span><span class='line'>&#9;&#9;&#9;} else if (skb == tcp_send_head(sk))  
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_push_one(sk, mss_now);  
</span><span class='line'>&#9;&#9;&#9;continue;  
</span><span class='line'>
</span><span class='line'>wait_for_sndbuf:  
</span><span class='line'>&#9;&#9;&#9;set_bit(SOCK_NOSPACE, &sk-&gt;sk_socket-&gt;flags);  
</span><span class='line'>wait_for_memory:  
</span><span class='line'>&#9;&#9;&#9;if (copied)  
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_push(sk, flags & ~MSG_MORE, mss_now, TCP_NAGLE_PUSH);  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if ((err = sk_stream_wait_memory(sk, &timeo)) != 0)  
</span><span class='line'>&#9;&#9;&#9;&#9;goto do_error;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;mss_now = tcp_send_mss(sk, &size_goal, flags);  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>out:  
</span><span class='line'>&#9;if (copied)  
</span><span class='line'>&#9;&#9;tcp_push(sk, flags, mss_now, tp-&gt;nonagle);  
</span><span class='line'>&#9;release_sock(sk);  
</span><span class='line'>&#9;return copied;  
</span><span class='line'>
</span><span class='line'>do_fault:  
</span><span class='line'>&#9;if (!skb-&gt;len) {  
</span><span class='line'>&#9;&#9;tcp_unlink_write_queue(skb, sk);  
</span><span class='line'>&#9;&#9;/* It is the one place in all of TCP, except connection 
</span><span class='line'>&#9;&#9; * reset, where we can be unlinking the send_head. 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;tcp_check_send_head(sk, skb);  
</span><span class='line'>&#9;&#9;sk_wmem_free_skb(sk, skb);  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>do_error:  
</span><span class='line'>&#9;if (copied)  
</span><span class='line'>&#9;&#9;goto out;  
</span><span class='line'>out_err:  
</span><span class='line'>&#9;err = sk_stream_error(sk, flags, err);  
</span><span class='line'>&#9;release_sock(sk);  
</span><span class='line'>&#9;return err;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>tcp_sendmsg中，涉及对OOB数据的处理主要有：</p>

<h5>1、在调用tcp_send_mss确定分片大小的时候：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_send_mss(struct sock *sk,int *size_goal, int flags)
</span><span class='line'>{
</span><span class='line'>&#9;intmss_now;
</span><span class='line'>&#9;mss_now= tcp_current_mss(sk);
</span><span class='line'>
</span><span class='line'>&#9;/*如果是OOB数据，large_allowed=0，关闭TSO*/
</span><span class='line'>&#9;*size_goal= tcp_xmit_size_goal(sk, mss_now, !(flags & MSG_OOB));
</span><span class='line'>&#9;returnmss_now;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果是OOB数据，其实是关闭了TSO功能，这样做的原因是：天知道各个网卡芯片在执行分片的时候咋个处理TCP报头中的URG标志和urgent point</p>

<h5>2、在确定何时开始执行分片的发送的时候：</h5>

<p>如果是OOB数据，即使当前已经积累了一整个分片，也不会想普通的数据一样执行发送(tcp_push)，而是继续积累直到用户下发的数据全部分片或者snd_buf/内存用尽。</p>

<h5>3、执行tcp_push的时候：</h5>

<p>在用户下发的数据全部分片或者snd_buf/内存用尽后，进入tcp_push执行发送操作(所有的OOB数据，都会通过这个接口来执行发送)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void tcp_push(struct sock*sk, int flags, int mss_now,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9; int nonagle)
</span><span class='line'>{
</span><span class='line'>&#9;if(tcp_send_head(sk)) {
</span><span class='line'>&#9;&#9;structtcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;&#9;if(!(flags & MSG_MORE) || forced_push(tp))
</span><span class='line'>&#9;&#9;&#9;tcp_mark_push(tp,tcp_write_queue_tail(sk));      
</span><span class='line'>&#9;&#9;&#9;  /*tcp_mark_urg设置tp-&gt;snd_up，标识进入OOB数据发送模式，设置urgent point
</span><span class='line'>&#9;&#9;&#9;  指向urgentdata接受后的第一个字符*/
</span><span class='line'>&#9;&#9;tcp_mark_urg(tp,flags);
</span><span class='line'>&#9;&#9;__tcp_push_pending_frames(sk,mss_now,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;  (flags & MSG_MORE) ? TCP_NAGLE_CORK :nonagle);
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>发送处理</h4>

<p>使用struct tcp_sock中的snd_up来标识当前的urgent point，同时也使用该数据来判断当前是否处于urgent data发送模式，在普通数据的发送模式中tcp_sock::snd_up总是和tcp_sock::snd_una相等，只有在有urgent data发送的时候，才在tcp_push&mdash;>tcp_mark_urg中设置为urgentpoint，进入到urgent data的处理模式</p>

<p>在tcp_transmit_skb中的以下代码段负责urgent data相关的处理：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (unlikely(tcp_urg_mode(tp) && before(tcb-&gt;seq, tp-&gt;snd_up))) {  
</span><span class='line'>&#9;if (before(tp-&gt;snd_up, tcb-&gt;seq + 0x10000)) {  
</span><span class='line'>&#9;&#9;th-&gt;urg_ptr = htons(tp-&gt;snd_up - tcb-&gt;seq);  
</span><span class='line'>&#9;&#9;th-&gt;urg = 1;  
</span><span class='line'>&#9;} else if (after(tcb-&gt;seq + 0xFFFF, tp-&gt;snd_nxt)) {  
</span><span class='line'>&#9;&#9;th-&gt;urg_ptr = htons(0xFFFF);  
</span><span class='line'>&#9;&#9;th-&gt;urg = 1;  
</span><span class='line'>&#9;}  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>只要当前待发送的skb的seq在tcp_sock记录的urgent point前面，就需要在报头中对URG标志置位，同时如果tcp_sock记录的urgent point。如果该报文的seq距离大于16为能表示的最大值，就置TCP报头中的urgent point为65535。</p>

<h4>切换回普通模式：</h4>

<p>在收到对方ACK的处理流程tcp_ack&mdash;>tcp_clean_rtx_queue中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (likely(between(tp-&gt;snd_up, prior_snd_una, tp-&gt;snd_una)))  
</span><span class='line'>&#9;tp-&gt;snd_up = tp-&gt;snd_una;  </span></code></pre></td></tr></table></div></figure>


<h4>报文体现</h4>

<p>根据对发送代码的分析，可以看到：如果用户使用MSG_OOB数据发送一段比较长(若干个MSS)的数据，那么线路上的报文应该是分成了若干组，每组由若干个长度为MSS的报文构成，组内的每个报文有一样的urgent pointer，指向下一组报文的起始seq，每一组的长度最长为65535。</p>

<hr />

<h3>TCP的URG标志和内核实现之三：接收的实现</h3>

<p>大致的处理过程</p>

<p>TCP的接收流程：在tcp_v4_do_rcv中的相关处理(网卡收到报文触发)中，会首先通过tcp_check_urg设置tcp_sock的urg_data为TCP_URG_NOTYET(urgent point指向的可能不是本报文，而是后续报文或者前面收到的乱序报文)，并保存最新的urgent data的sequence和对于的1 BYTE urgent data到tcp_sock的urg_data (如果之前的urgent data没有读取，就会被覆盖)。</p>

<p>用户接收流程：在tcp_recvmsg流程中，如果发现当前的skb的数据中有urgent data，首先拷贝urgent data之前的数据，然后tcp_recvmsg退出，提示用户来接收OOB数据；在用户下一次调用tcp_recvmsg来接收数据的时候，会跳过urgent data，并设置urgent data数据接收完成。
相关的数据结构和定义</p>

<p>tcp_sock结构：</p>

<p>1、 urg_data成员，其高8bit为urgent data的接收状态；其低8位为保存的1BYTE urgent数据。urgent data的接收状态对应的宏的含义描述：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#defineTCP_URG_VALID 0x0100  /*urgent data已经读到了tcp_sock::urg_data*/
</span><span class='line'>
</span><span class='line'>#defineTCP_URG_NOTYET   0x0200  /*已经发现有urgent data，还没有读取到tcp_sock::urg_data*/
</span><span class='line'>
</span><span class='line'>#defineTCP_URG_READ       0x0400  /*urgent data已经被用户通过MSG_OOB读取了*/</span></code></pre></td></tr></table></div></figure>


<p>2、 urg_seq成员，为当前的urgent data的sequence</p>

<p>流程详情</p>

<h4>TCP的接收过程</h4>

<p>在tcp_rcv_established的slow_path中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>slow_path:  
</span><span class='line'>&#9;if (len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete_user(sk, skb))  
</span><span class='line'>&#9;&#9;goto csum_error;  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; *  Standard slow path. 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (!tcp_validate_incoming(sk, skb, th, 1))  
</span><span class='line'>&#9;&#9;return 0;  
</span><span class='line'>step5:  
</span><span class='line'>&#9;if (th-&gt;ack &&  
</span><span class='line'>&#9;&#9;tcp_ack(sk, skb, FLAG_SLOWPATH | FLAG_UPDATE_TS_RECENT) &lt; 0)  
</span><span class='line'>&#9;&#9;goto discard;  
</span><span class='line'>&#9;tcp_rcv_rtt_measure_ts(sk, skb);  
</span><span class='line'>&#9;/* 处理紧急数据. */  
</span><span class='line'>&#9;tcp_urg(sk, skb, th);  </span></code></pre></td></tr></table></div></figure>


<p>也就是在报文的CRC验证和sequence验证完成后，就会通过tcp_urg来处理接收到的urgent data ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_urg(struct sock *sk, struct sk_buff *skb, const struct tcphdr *th)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>  
</span><span class='line'>&#9;/*收到了urgent data,则检查和设置urg_data和urg_seq成员*/  
</span><span class='line'>&#9;if (th-&gt;urg)  
</span><span class='line'>&#9;&#9;tcp_check_urg(sk, th);  
</span><span class='line'>  
</span><span class='line'>&#9;/* Do we wait for any urgent data? - normally not... 
</span><span class='line'>&#9;发现了有urgent data，但是还没有保存到tp-&gt;urg_data*/  
</span><span class='line'>&#9;if (tp-&gt;urg_data == TCP_URG_NOTYET) {  
</span><span class='line'>&#9;&#9;u32 ptr = tp-&gt;urg_seq - ntohl(th-&gt;seq) + (th-&gt;doff * 4) -  
</span><span class='line'>&#9;&#9;&#9;  th-&gt;syn;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* Is the urgent pointer pointing into this packet? */  
</span><span class='line'>&#9;&#9;if (ptr &lt; skb-&gt;len) {  
</span><span class='line'>&#9;&#9;&#9;u8 tmp;  
</span><span class='line'>&#9;&#9;&#9;if (skb_copy_bits(skb, ptr, &tmp, 1))  
</span><span class='line'>&#9;&#9;&#9;&#9;BUG();  
</span><span class='line'>&#9;&#9;&#9;tp-&gt;urg_data = TCP_URG_VALID | tmp;  
</span><span class='line'>&#9;&#9;&#9;if (!sock_flag(sk, SOCK_DEAD))  
</span><span class='line'>&#9;&#9;&#9;&#9;sk-&gt;sk_data_ready(sk, 0);  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;}  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>检查和设置urg_data和urg_seq成员的处理函数tcp_check_urg的具体流程</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_check_urg(struct sock *sk, const struct tcphdr *th)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;u32 ptr = ntohs(th-&gt;urg_ptr);  
</span><span class='line'>&#9;/*两种urgent point的解析方式: 
</span><span class='line'>&#9;一是指向urgent data之后的第一个字节 
</span><span class='line'>&#9;二是执行urgent data的结束字节(RFC1122) 
</span><span class='line'>&#9;sysctl_tcp_stdurg被设置表示当前采用的是第二种模式 
</span><span class='line'>&#9;不需要把urgent point -1来指向urgent data的结束字节*/  
</span><span class='line'>&#9;if (ptr && !sysctl_tcp_stdurg)  
</span><span class='line'>&#9;&#9;ptr--;  
</span><span class='line'>&#9;ptr += ntohl(th-&gt;seq);  
</span><span class='line'>  
</span><span class='line'>&#9;/* Ignore urgent data that we've already seen and read.  
</span><span class='line'>&#9;如果copied_seq已经大于urgent point，那么对于从tcp_rcv_established 
</span><span class='line'>&#9;来执行的，前面的tcp_validate_incoming已经拒绝了这种报文( 
</span><span class='line'>&#9;接收窗口外)，这里要处理的是哪种情形?*/  
</span><span class='line'>&#9;if (after(tp-&gt;copied_seq, ptr))  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Do not replay urg ptr. 
</span><span class='line'>&#9; * 
</span><span class='line'>&#9; * NOTE: interesting situation not covered by specs. 
</span><span class='line'>&#9; * Misbehaving sender may send urg ptr, pointing to segment, 
</span><span class='line'>&#9; * which we already have in ofo queue. We are not able to fetch 
</span><span class='line'>&#9; * such data and will stay in TCP_URG_NOTYET until will be eaten 
</span><span class='line'>&#9; * by recvmsg(). Seems, we are not obliged to handle such wicked 
</span><span class='line'>&#9; * situations. But it is worth to think about possibility of some 
</span><span class='line'>&#9; * DoSes using some hypothetical application level deadlock. 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;/*  这种情况什么时候发生?没搞明白*/  
</span><span class='line'>&#9;if (before(ptr, tp-&gt;rcv_nxt))  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Do we already have a newer (or duplicate) urgent pointer?  
</span><span class='line'>&#9;如果当前已经进入urg数据读取模式，且urgent point不大于当前 
</span><span class='line'>&#9;保存的值，那么之前已经开始了读取tp-&gt;urg_seq对应的 
</span><span class='line'>&#9;urgent 数据，无需重复处理了*/  
</span><span class='line'>&#9;if (tp-&gt;urg_data && !after(ptr, tp-&gt;urg_seq))  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Tell the world about our new urgent pointer.*/  
</span><span class='line'>&#9;sk_send_sigurg(sk);  
</span><span class='line'>  
</span><span class='line'>&#9;/* We may be adding urgent data when the last byte read was 
</span><span class='line'>&#9; * urgent. To do this requires some care. We cannot just ignore 
</span><span class='line'>&#9; * tp-&gt;copied_seq since we would read the last urgent byte again 
</span><span class='line'>&#9; * as data, nor can we alter copied_seq until this data arrives 
</span><span class='line'>&#9; * or we break the semantics of SIOCATMARK (and thus sockatmark()) 
</span><span class='line'>&#9; * 
</span><span class='line'>&#9; * NOTE. Double Dutch. Rendering to plain English: author of comment 
</span><span class='line'>&#9; * above did something sort of  send("A", MSG_OOB); send("B", MSG_OOB); 
</span><span class='line'>&#9; * and expect that both A and B disappear from stream. This is _wrong_. 
</span><span class='line'>&#9; * Though this happens in BSD with high probability, this is occasional. 
</span><span class='line'>&#9; * Any application relying on this is buggy. Note also, that fix "works" 
</span><span class='line'>&#9; * only in this artificial test. Insert some normal data between A and B and we will 
</span><span class='line'>&#9; * decline of BSD again. Verdict: it is better to remove to trap 
</span><span class='line'>&#9; * buggy users. 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9; /*用户下一次要读取的数据就是用户还没有读取的urgent数据 
</span><span class='line'>&#9;且当前存在新的用户未读取数据*/  
</span><span class='line'>&#9;if (tp-&gt;urg_seq == tp-&gt;copied_seq && tp-&gt;urg_data &&  
</span><span class='line'>&#9;&#9;!sock_flag(sk, SOCK_URGINLINE) && tp-&gt;copied_seq != tp-&gt;rcv_nxt) {  
</span><span class='line'>&#9;&#9;struct sk_buff *skb = skb_peek(&sk-&gt;sk_receive_queue);  
</span><span class='line'>&#9;&#9;tp-&gt;copied_seq++;  
</span><span class='line'>&#9;&#9;if (skb && !before(tp-&gt;copied_seq, TCP_SKB_CB(skb)-&gt;end_seq)) {  
</span><span class='line'>&#9;&#9;&#9;__skb_unlink(skb, &sk-&gt;sk_receive_queue);  
</span><span class='line'>&#9;&#9;&#9;__kfree_skb(skb);  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;tp-&gt;urg_data = TCP_URG_NOTYET;  
</span><span class='line'>&#9;tp-&gt;urg_seq = ptr;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Disable header prediction. */  
</span><span class='line'>&#9;tp-&gt;pred_flags = 0;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h4>用户接收数据接口</h4>

<h5>用户接收URG数据的接口</h5>

<p>在用户接收数据的tcp_recvmsg函数中，如果用户通过MSG_OOB来接收数据，会进入tcp_recv_urg处理</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_recv_urg(struct sock *sk, struct msghdr *msg, int len, int flags)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>  
</span><span class='line'>&#9;/* No URG data to read.  
</span><span class='line'>&#9;用户已经读取过了*/  
</span><span class='line'>&#9;if (sock_flag(sk, SOCK_URGINLINE) || !tp-&gt;urg_data ||  
</span><span class='line'>&#9;&#9;tp-&gt;urg_data == TCP_URG_READ)  
</span><span class='line'>&#9;&#9;return -EINVAL; /* Yes this is right ! */  
</span><span class='line'>  
</span><span class='line'>&#9;if (sk-&gt;sk_state == TCP_CLOSE && !sock_flag(sk, SOCK_DONE))  
</span><span class='line'>&#9;&#9;return -ENOTCONN;  
</span><span class='line'>&#9;/*当前的tp-&gt;urg_data为合法的数据，可以读取*/  
</span><span class='line'>&#9;if (tp-&gt;urg_data & TCP_URG_VALID) {  
</span><span class='line'>&#9;&#9;int err = 0;  
</span><span class='line'>&#9;&#9;char c = tp-&gt;urg_data;  
</span><span class='line'>&#9;&#9;/*标识urgent data已读*/  
</span><span class='line'>&#9;&#9;if (!(flags & MSG_PEEK))  
</span><span class='line'>&#9;&#9;&#9;tp-&gt;urg_data = TCP_URG_READ;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* Read urgent data. */  
</span><span class='line'>&#9;&#9;msg-&gt;msg_flags |= MSG_OOB;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;if (len &gt; 0) {  
</span><span class='line'>&#9;&#9;&#9;if (!(flags & MSG_TRUNC))  
</span><span class='line'>&#9;&#9;&#9;&#9;err = memcpy_toiovec(msg-&gt;msg_iov, &c, 1);  
</span><span class='line'>&#9;&#9;&#9;len = 1;  
</span><span class='line'>&#9;&#9;} else  
</span><span class='line'>&#9;&#9;&#9;msg-&gt;msg_flags |= MSG_TRUNC;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;return err ? -EFAULT : len;  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;if (sk-&gt;sk_state == TCP_CLOSE || (sk-&gt;sk_shutdown & RCV_SHUTDOWN))  
</span><span class='line'>&#9;&#9;return 0;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Fixed the recv(..., MSG_OOB) behaviour.  BSD docs and 
</span><span class='line'>&#9; * the available implementations agree in this case: 
</span><span class='line'>&#9; * this call should never block, independent of the 
</span><span class='line'>&#9; * blocking state of the socket. 
</span><span class='line'>&#9; * Mike &lt;pall@rz.uni-karlsruhe.de&gt; 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;return -EAGAIN;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h5>用户接收普通数据的接口中的相关处理</h5>

<p>在用户接收数据的tcp_recvmsg函数中，在查找到待拷贝的skb后，首先拷贝urgent data数据前的数据，然后退出接收过程，在用户下一次执行tcp_recvmsg的时候跳过urgent data，设置urgent data读取结束</p>

<p>查找到准备拷贝的skb后的处理：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>found_ok_skb:  
</span><span class='line'>/* Ok so how much can we use? */  
</span><span class='line'>used = skb-&gt;len - offset;  
</span><span class='line'>if (len &lt; used)  
</span><span class='line'>&#9;used = len;  
</span><span class='line'>  
</span><span class='line'>/* 当前有urg_data数据*/  
</span><span class='line'>if (tp-&gt;urg_data) {  
</span><span class='line'>&#9;u32 urg_offset = tp-&gt;urg_seq - *seq;  
</span><span class='line'>&#9;/*urgent data在当前待拷贝的数据范围内*/  
</span><span class='line'>&#9;if (urg_offset &lt; used) {  
</span><span class='line'>&#9;&#9;if (!urg_offset) {/*待拷贝的数据就是urgent data，跨过该urgent data， 
</span><span class='line'>&#9;&#9;只给用户读取后面的数据*/  
</span><span class='line'>&#9;&#9;&#9;if (!sock_flag(sk, SOCK_URGINLINE)) {  
</span><span class='line'>&#9;&#9;&#9;&#9;++*seq;  
</span><span class='line'>&#9;&#9;&#9;&#9;urg_hole++;  
</span><span class='line'>&#9;&#9;&#9;&#9;offset++;  
</span><span class='line'>&#9;&#9;&#9;&#9;used--;  
</span><span class='line'>&#9;&#9;&#9;&#9;if (!used)  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto skip_copy;  
</span><span class='line'>&#9;&#9;&#9;}  
</span><span class='line'>&#9;&#9;}   
</span><span class='line'>&#9;&#9;} else/*指定只拷贝urgent data数据之前的，完成后在下一次循环 
</span><span class='line'>&#9;&#9;开始的位置，会退出循环，返回用户；下一次用户调用tcp_recvmsg 
</span><span class='line'>&#9;&#9;就进入到上面的分支了*/  
</span><span class='line'>&#9;&#9;&#9;used = urg_offset;  
</span><span class='line'>&#9;}  
</span><span class='line'>}   </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>skip_copy:  
</span><span class='line'>&#9;&#9;/*用户读取的数据跨过了urgent point，设置读取结束 
</span><span class='line'>&#9;&#9;开启fast path*/  
</span><span class='line'>&#9;&#9;if (tp-&gt;urg_data && after(tp-&gt;copied_seq, tp-&gt;urg_seq)) {  
</span><span class='line'>&#9;&#9;&#9;tp-&gt;urg_data = 0;  
</span><span class='line'>&#9;&#9;&#9;tcp_fast_path_check(sk);  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;&#9;if (used + offset &lt; skb-&gt;len)  
</span><span class='line'>&#9;&#9;&#9;continue;  </span></code></pre></td></tr></table></div></figure>


<p>在接收完urgent data数据前的所有数据之后， tcp_recvmsg的以下代码片段得到执行，这段代码退出当前接收过程，提示用户有urgent data数据到来，需要用MSG_OOB来接收</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (tp-&gt;urg_data && tp-&gt;urg_seq == *seq) {  
</span><span class='line'>&#9;if (copied)  
</span><span class='line'>&#9;&#9;break;  
</span><span class='line'>&#9;if (signal_pending(current)) {  
</span><span class='line'>&#9;&#9;copied = timeo ? sock_intr_errno(timeo) : -EAGAIN;  
</span><span class='line'>&#9;&#9;break;  
</span><span class='line'>&#9;}  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h3>后记</h3>

<p>TCP的urg数据，由于定义和实现上的混乱，当前已经不建议使用，但是为了兼容之前已经已经存在的实现，该机制会长期在内核中存在，如果不了解该机制及其内核行为，有可能就很难解释一些奇怪的问题：比如某段代码不小心地造成send接口事实上设置了MSG_OOB，就会造成接收端少了一个BYTE。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/05/15/debug-mark-tcp_collapse-bug/">tcp_collapse do not copy headers</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-15T10:08:00+08:00'><span class='date'>2015-05-15</span> <span class='time'>10:08:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>commit b3d6cb92fd190d720a01075c4d20cdca896663fc
</span><span class='line'>Author: Eric Dumazet &lt;edumazet@google.com&gt;
</span><span class='line'>Date:   Mon Sep 15 04:19:53 2014 -0700
</span><span class='line'>
</span><span class='line'>    tcp: do not copy headers in tcp_collapse()
</span><span class='line'>
</span><span class='line'>    tcp_collapse() wants to shrink skb so that the overhead is minimal.
</span><span class='line'>
</span><span class='line'>    Now we store tcp flags into TCP_SKB_CB(skb)-&gt;tcp_flags, we no longer
</span><span class='line'>    need to keep around full headers.
</span><span class='line'>    Whole available space is dedicated to the payload.
</span><span class='line'>
</span><span class='line'>    Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
</span><span class='line'>    Acked-by: Neal Cardwell &lt;ncardwell@google.com&gt;
</span><span class='line'>    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
</span><span class='line'>index 228bf0c..ea92f23 100644
</span><span class='line'>--- a/net/ipv4/tcp_input.c
</span><span class='line'>+++ b/net/ipv4/tcp_input.c
</span><span class='line'>@@ -4535,26 +4535,13 @@ restart:
</span><span class='line'>      return;
</span><span class='line'> 
</span><span class='line'>  while (before(start, end)) {
</span><span class='line'>+     int copy = min_t(int, SKB_MAX_ORDER(0, 0), end - start);
</span><span class='line'>      struct sk_buff *nskb;
</span><span class='line'>-     unsigned int header = skb_headroom(skb);
</span><span class='line'>-     int copy = SKB_MAX_ORDER(header, 0);
</span><span class='line'> 
</span><span class='line'>-     /* Too big header? This can happen with IPv6. */
</span><span class='line'>-     if (copy &lt; 0)
</span><span class='line'>-         return;
</span><span class='line'>-     if (end - start &lt; copy)
</span><span class='line'>-         copy = end - start;
</span><span class='line'>-     nskb = alloc_skb(copy + header, GFP_ATOMIC);
</span><span class='line'>+     nskb = alloc_skb(copy, GFP_ATOMIC);
</span><span class='line'>      if (!nskb)
</span><span class='line'>          return;
</span><span class='line'> 
</span><span class='line'>-     skb_set_mac_header(nskb, skb_mac_header(skb) - skb-&gt;head);
</span><span class='line'>-     skb_set_network_header(nskb, (skb_network_header(skb) -
</span><span class='line'>-                       skb-&gt;head));
</span><span class='line'>-     skb_set_transport_header(nskb, (skb_transport_header(skb) -
</span><span class='line'>-                     skb-&gt;head));
</span><span class='line'>-     skb_reserve(nskb, header);
</span><span class='line'>-     memcpy(nskb-&gt;head, skb-&gt;head, header);
</span><span class='line'>      memcpy(nskb-&gt;cb, skb-&gt;cb, sizeof(skb-&gt;cb));
</span><span class='line'>      TCP_SKB_CB(nskb)-&gt;seq = TCP_SKB_CB(nskb)-&gt;end_seq = start;
</span><span class='line'>      __skb_queue_before(list, skb, nskb);</span></code></pre></td></tr></table></div></figure>


<hr />

<p>这个改进无形中修了一个BUG，但是这BUG正常情况下不会触发，除非我们对skb进行改动导致skb->data - skb->head = 4k时，如果此时内存紧张，且满足tcp_collapse合并条件才触发。</p>

<p>BUG：
tcp_collapse代码中有：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;while (before(start, end)) {
</span><span class='line'>&#9;&#9;struct sk_buff *nskb;
</span><span class='line'>&#9;&#9;unsigned int header = skb_headroom(skb);
</span><span class='line'>&#9;&#9;int copy = SKB_MAX_ORDER(header, 0);
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Too big header? This can happen with IPv6. */
</span><span class='line'>&#9;&#9;if (copy &lt; 0) 
</span><span class='line'>&#9;&#9;&#9;return;
</span><span class='line'>
</span><span class='line'>&#9;&#9;......
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Copy data, releasing collapsed skbs. */
</span><span class='line'>&#9;&#9;while (copy &gt; 0) { 
</span><span class='line'>&#9;&#9;&#9;int offset = start - TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>&#9;&#9;&#9;int size = TCP_SKB_CB(skb)-&gt;end_seq - start;</span></code></pre></td></tr></table></div></figure>


<p>也就是说如果header = 4k，那么copy = 0，那么会一直申请len=0的skb插入到receive队列，直到申请skb失败。这样就会造成tcp_recvmsg出错</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;&#9;skb_queue_walk(&sk-&gt;sk_receive_queue, skb) {
</span><span class='line'>&#9;&#9;&#9;/* Now that we have two receive queues this
</span><span class='line'>&#9;&#9;&#9; * shouldn't happen.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;if (WARN(before(*seq, TCP_SKB_CB(skb)-&gt;seq),
</span><span class='line'>&#9;&#9;&#9;&#9; KERN_INFO "recvmsg bug: copied %X "
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;   "seq %X rcvnxt %X fl %X\n", *seq,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;   TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;   flags))
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;offset = *seq - TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>&#9;&#9;&#9;if (tcp_hdr(skb)-&gt;syn)
</span><span class='line'>&#9;&#9;&#9;&#9;offset--;
</span><span class='line'>&#9;&#9;&#9;if (offset &lt; skb-&gt;len)
</span><span class='line'>&#9;&#9;&#9;&#9;goto found_ok_skb;
</span><span class='line'>&#9;&#9;&#9;if (tcp_hdr(skb)-&gt;fin)
</span><span class='line'>&#9;&#9;&#9;&#9;goto found_fin_ok;
</span><span class='line'>&#9;&#9;&#9;WARN(!(flags & MSG_PEEK), KERN_INFO "recvmsg bug 2: "
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;"copied %X seq %X rcvnxt %X fl %X\n",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;*seq, TCP_SKB_CB(skb)-&gt;seq,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tp-&gt;rcv_nxt, flags);
</span><span class='line'>&#9;&#9;}</span></code></pre></td></tr></table></div></figure>


<p>因为offset = 0, len = 0, if (offset &lt; skb->len)就不符合，报WARN。而且如果申请的len=0的skb过多，会导致一直在这里循环，因为WARN有打印堆栈，执行很慢。</p>

<p>错误如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>WARNING: at net/ipv4/tcp.c:1457 tcp_recvmsg+0x96a/0xc20() (Tainted: G    W  ---------------   )
</span><span class='line'>Hardware name: PowerEdge R620
</span><span class='line'>Modules linked in: sha256_generic ws_st_tcp_cubic(U) ws_st(U) autofs4 i2c_dev i2c_core bonding 8021q garp stp llc be2iscsi iscsi_boot_sysfs ib]
</span><span class='line'>Pid: 6964, comm: squid Tainted: G        W  ---------------    2.6.32-358.6.1.x86_64 #1
</span><span class='line'>Call Trace:
</span><span class='line'> [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
</span><span class='line'> [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
</span><span class='line'> [&lt;ffffffff81069aa8&gt;] ? warn_slowpath_common+0x98/0xc0
</span><span class='line'> [&lt;ffffffff81069bce&gt;] ? warn_slowpath_fmt+0x6e/0x70
</span><span class='line'> [&lt;ffffffff814ce08e&gt;] ? _spin_lock_bh+0x2e/0x40
</span><span class='line'> [&lt;ffffffff813fea53&gt;] ? skb_release_data+0xb3/0x100
</span><span class='line'> [&lt;ffffffff813feb56&gt;] ? __kfree_skb+0x46/0xa0
</span><span class='line'> [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
</span><span class='line'> [&lt;ffffffff813f93c7&gt;] ? sock_common_recvmsg+0x37/0x50
</span><span class='line'> [&lt;ffffffff813f6b05&gt;] ? sock_aio_read+0x185/0x190
</span><span class='line'> [&lt;ffffffff81171912&gt;] ? do_sync_read+0xf2/0x130
</span><span class='line'> [&lt;ffffffff81090e60&gt;] ? autoremove_wake_function+0x0/0x40
</span><span class='line'> [&lt;ffffffff811b4a2c&gt;] ? sys_epoll_wait+0x21c/0x3f0
</span><span class='line'> [&lt;ffffffff8120b3b6&gt;] ? security_file_permission+0x16/0x20
</span><span class='line'> [&lt;ffffffff81171bab&gt;] ? vfs_read+0x18b/0x1a0
</span><span class='line'> [&lt;ffffffff81172df5&gt;] ? sys_read+0x55/0x90
</span><span class='line'> [&lt;ffffffff8100af72&gt;] ? system_call_fastpath+0x16/0x1b
</span><span class='line'>---[ end trace ef9663ba0fc61730 ]---
</span><span class='line'>------------[ cut here ]------------
</span><span class='line'>WARNING: at net/ipv4/tcp.c:1457 tcp_recvmsg+0x96a/0xc20() (Tainted: G        W  ---------------   )
</span><span class='line'>Hardware name: PowerEdge R620
</span><span class='line'>Modules linked in: sha256_generic ws_st_tcp_cubic(U) ws_st(U) autofs4 i2c_dev i2c_core bonding 8021q garp stp llc be2iscsi iscsi_boot_sysfs ib]
</span><span class='line'>Pid: 6964, comm: squid Tainted: G        W  ---------------    2.6.32-358.6.1.x86_64 #1
</span><span class='line'>Call Trace:
</span><span class='line'> [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
</span><span class='line'> [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
</span><span class='line'> [&lt;ffffffff81069aa8&gt;] ? warn_slowpath_common+0x98/0xc0
</span><span class='line'> [&lt;ffffffff81069bce&gt;] ? warn_slowpath_fmt+0x6e/0x70
</span><span class='line'> [&lt;ffffffff814ce08e&gt;] ? _spin_lock_bh+0x2e/0x40
</span><span class='line'> [&lt;ffffffff813fea53&gt;] ? skb_release_data+0xb3/0x100
</span><span class='line'> [&lt;ffffffff813feb56&gt;] ? __kfree_skb+0x46/0xa0
</span><span class='line'> [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
</span><span class='line'> [&lt;ffffffff813f93c7&gt;] ? sock_common_recvmsg+0x37/0x50
</span><span class='line'> [&lt;ffffffff813f6b05&gt;] ? sock_aio_read+0x185/0x190
</span><span class='line'> [&lt;ffffffff81171912&gt;] ? do_sync_read+0xf2/0x130
</span><span class='line'> [&lt;ffffffff81090e60&gt;] ? autoremove_wake_function+0x0/0x40
</span><span class='line'> [&lt;ffffffff811b4a2c&gt;] ? sys_epoll_wait+0x21c/0x3f0
</span><span class='line'> [&lt;ffffffff8120b3b6&gt;] ? security_file_permission+0x16/0x20
</span><span class='line'> [&lt;ffffffff81171bab&gt;] ? vfs_read+0x18b/0x1a0
</span><span class='line'> [&lt;ffffffff81172df5&gt;] ? sys_read+0x55/0x90
</span><span class='line'> [&lt;ffffffff8100af72&gt;] ? system_call_fastpath+0x16/0x1b
</span><span class='line'>---[ end trace ef9663ba0fc61731 ]---
</span><span class='line'>------------[ cut here ]------------
</span><span class='line'>
</span><span class='line'>.......
</span></code></pre></td></tr></table></div></figure>


<p>如果skb申请的不多，很快就能看到tcp_cleanup_rbuf的WARN，仔细观察会发现，这里打印的end_seq和上面的seq是一样的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_cleanup_rbuf(struct sock *sk, int copied)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;int time_to_ack = 0;
</span><span class='line'>
</span><span class='line'>#if TCP_DEBUG
</span><span class='line'>&#9;struct sk_buff *skb = skb_peek(&sk-&gt;sk_receive_queue);
</span><span class='line'>
</span><span class='line'>&#9;WARN(skb && !before(tp-&gt;copied_seq, TCP_SKB_CB(skb)-&gt;end_seq),
</span><span class='line'>&#9;&#9; KERN_INFO "cleanup rbuf bug: copied %X seq %X rcvnxt %X\n",
</span><span class='line'>&#9;&#9; tp-&gt;copied_seq, TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;rcv_nxt);
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/05/11/kernel-net-tcp_queue/">tcp三个接收队列</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-11T15:46:00+08:00'><span class='date'>2015-05-11</span> <span class='time'>15:46:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.cnblogs.com/alreadyskb/p/4386565.html">http://www.cnblogs.com/alreadyskb/p/4386565.html</a></p>

<h4>三个接收队列</h4>

<ul>
<li>tcp协议栈数据接收实现了三个接收缓存分别是prequeue、sk_write_queue、sk_backlog。</li>
</ul>


<p>之所以需要三个接收缓存的原因如下：<br/>
tcp协议栈接收到数据包时struct sock *sk 可能被进程下上文或者中断上下文占用：</p>

<p>  1、如果处于进程上下文sk_lock.owned=1，软中断因为sk_lock.owned=1，所以数据只能暂存在后备队列中（backlog），当进程上下文逻辑处理完成后会回调tcp_v4_do_rcv处理backlog队列作为补偿，具体看tcp_sendmsg 函数 release_sock的实现。</p>

<p>  2、如果当前处于中断上下文，sk_lock.owned=0，那么数据可能被放置到receive_queue或者prequeue，数据优先放置到prequeue中，如果prequeue满了则会放置到receive_queue中，理论上这里有一个队列就行了，但是TCP协议栈为什么要设计两个呢？其实是为了快点结束软中断数据处理流程，软中断处理函数中禁止了进程抢占和其他软中断发生，效率应该是很低下的，如果数据被放置到prequeue中，那么软中断流程很快就结束了，如果放置到receive_queue那么会有很复杂的逻辑需要处理。receive_queue队列的处理在软中断中，prequeue队列的处理则是在进程上下文中。总的来说就是为了提高TCP协议栈的效率。</p>

<h4>后备队列的处理逻辑</h4>

<h5>1、什么时候使用后备队列</h5>

<p>tcp协议栈对struct sock <em>sk有两把锁，第一把是sk_lock.slock，第二把则是sk_lock.owned。sk_lock.slock用于获取struct sock </em>sk对象的成员的修改权限；sk_lock.owned用于区分当前是进程上下文或是软中断上下文，为进程上下文时sk_lock.owned会被置1，中断上下文为0。</p>

<p>如果是要对sk修改，首先是必须拿锁sk_lock.slock，其后是判断当前是软中断或是进程上下文，如果是进程上下文，那么接收到的skb则只能先放置到后备队列中sk_backlog中。如果是软中断上下文则可以放置到prequeue和sk_write_queue中。</p>

<p>代码片段如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;bh_lock_sock_nested(sk);               // 获取第一把锁。
</span><span class='line'>&#9;ret = 0;
</span><span class='line'>&#9;if (!sock_owned_by_user(sk)) {         // 判断第二把锁，区分是处于进程上下文还是软中断上下文。
</span><span class='line'>#ifdef CONFIG_NET_DMA
</span><span class='line'>&#9;&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;&#9;if (!tp-&gt;ucopy.dma_chan && tp-&gt;ucopy.pinned_list)
</span><span class='line'>&#9;&#9;&#9;tp-&gt;ucopy.dma_chan = dma_find_channel(DMA_MEMCPY);
</span><span class='line'>&#9;&#9;if (tp-&gt;ucopy.dma_chan)
</span><span class='line'>&#9;&#9;&#9;ret = tcp_v4_do_rcv(sk, skb);
</span><span class='line'>&#9;&#9;else
</span><span class='line'>#endif
</span><span class='line'>&#9;&#9;{
</span><span class='line'>&#9;&#9;&#9;if (!tcp_prequeue(sk, skb))    // 如果处于中断上下文，则优先放置到prequeue中，如果prequeue满则放置到sk_write_queue中。
</span><span class='line'>&#9;&#9;&#9;&#9;ret = tcp_v4_do_rcv(sk, skb);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;} else if (unlikely(sk_add_backlog(sk, skb,  // 如果是处于进程上下文则直接放置到后备队列中(sk_backlog中)。
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;sk-&gt;sk_rcvbuf + sk-&gt;sk_sndbuf))) {
</span><span class='line'>&#9;&#9;bh_unlock_sock(sk);
</span><span class='line'>&#9;&#9;NET_INC_STATS_BH(net, LINUX_MIB_TCPBACKLOGDROP);
</span><span class='line'>&#9;&#9;goto discard_and_relse;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;bh_unlock_sock(sk);</span></code></pre></td></tr></table></div></figure>


<h5>2、skb怎么add到sk_backlog中</h5>

<p>sk_add_backlog函数用于add sbk到sk_backlog中，所以下面我们分析次函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* The per-socket spinlock must be held here. */
</span><span class='line'>static inline __must_check int sk_add_backlog(struct sock *sk, struct sk_buff *skb,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;   unsigned int limit)
</span><span class='line'>{
</span><span class='line'>&#9;if (sk_rcvqueues_full(sk, skb, limit))  // 判断接收缓存是否已经用完了，很明显sk_backlog的缓存大小也算在了总接收缓存中。
</span><span class='line'>&#9;&#9;return -ENOBUFS;
</span><span class='line'>
</span><span class='line'>&#9;__sk_add_backlog(sk, skb);              // 将skb添加到sk_backlog队列中。
</span><span class='line'>&#9;sk_extended(sk)-&gt;sk_backlog.len += skb-&gt;truesize;  // 更新sk_backlog中已经挂载的数据量。
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* OOB backlog add */
</span><span class='line'>static inline void __sk_add_backlog(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;if (!sk-&gt;sk_backlog.tail) {   // 如果当前sk_backlog为NULL，此时head和tail都指向skb。
</span><span class='line'>&#9;&#9;sk-&gt;sk_backlog.head = sk-&gt;sk_backlog.tail = skb;
</span><span class='line'>&#9;} else {                      // 分支表示sk_backlog中已经有数据了，那么skb直接挂在tail的尾部，之后tail指针后移到skb。
</span><span class='line'>&#9;&#9;sk-&gt;sk_backlog.tail-&gt;next = skb;
</span><span class='line'>&#9;&#9;sk-&gt;sk_backlog.tail = skb;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;skb-&gt;next = NULL;             // 这种很重要，在sk_backlog处理时会用来判断skb是否处理完毕。
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>3、sk_backlog中skb的处理</h5>

<p>很明显sk_backlog的处理必然中进程上下文进行，对于数据接收，进程上下文的接口是tcp_recvmmsg，所以sk_backlog肯定要在tcp_recvmmsg中处理。</p>

<p>tcp_recvmmsg sk_backlog的代码处理片段如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_cleanup_rbuf(sk, copied);
</span><span class='line'>TCP_CHECK_TIMER(sk);
</span><span class='line'>release_sock(sk);</span></code></pre></td></tr></table></div></figure>


<p>release_sock(sk)涉及到sk_backlog处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void release_sock(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;/*
</span><span class='line'>&#9;* The sk_lock has mutex_unlock() semantics:
</span><span class='line'>&#9;*/
</span><span class='line'>&#9;mutex_release(&sk-&gt;sk_lock.dep_map, 1, _RET_IP_);
</span><span class='line'>
</span><span class='line'>&#9;spin_lock_bh(&sk-&gt;sk_lock.slock);   // 获取第一把锁。
</span><span class='line'>&#9;if (sk-&gt;sk_backlog.tail)            // 如果后备队列不为NULL，则开始处理。
</span><span class='line'>&#9;&#9;__release_sock(sk);
</span><span class='line'>
</span><span class='line'>&#9;if (proto_has_rhel_ext(sk-&gt;sk_prot, RHEL_PROTO_HAS_RELEASE_CB) &&
</span><span class='line'>&#9;&#9;&#9;sk-&gt;sk_prot-&gt;release_cb)
</span><span class='line'>&#9;&#9;sk-&gt;sk_prot-&gt;release_cb(sk);
</span><span class='line'>
</span><span class='line'>&#9;sk-&gt;sk_lock.owned = 0;              // 进成上下文skb处理完了，释放第二把锁。
</span><span class='line'>&#9;if (waitqueue_active(&sk-&gt;sk_lock.wq))
</span><span class='line'>&#9;&#9;wake_up(&sk-&gt;sk_lock.wq);
</span><span class='line'>&#9;spin_unlock_bh(&sk-&gt;sk_lock.slock); // 释放第一把锁。
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>__release_sock(sk)</code>是后备队列的真正处理函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void __release_sock(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *skb = sk-&gt;sk_backlog.head;
</span><span class='line'>
</span><span class='line'>&#9;do {
</span><span class='line'>&#9;&#9;sk-&gt;sk_backlog.head = sk-&gt;sk_backlog.tail = NULL;
</span><span class='line'>&#9;&#9;bh_unlock_sock(sk);
</span><span class='line'>
</span><span class='line'>&#9;&#9;do {
</span><span class='line'>&#9;&#9;&#9;struct sk_buff *next = skb-&gt;next;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;skb-&gt;next = NULL;
</span><span class='line'>&#9;&#9;&#9;sk_backlog_rcv(sk, skb);    // skb的处理函数，其实调用的是tcp_v4_do_rcv函数。
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * We are in process context here with softirqs
</span><span class='line'>&#9;&#9;&#9; * disabled, use cond_resched_softirq() to preempt.
</span><span class='line'>&#9;&#9;&#9; * This is safe to do because we've taken the backlog
</span><span class='line'>&#9;&#9;&#9; * queue private:
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;cond_resched_softirq();
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;skb = next;
</span><span class='line'>&#9;&#9;} while (skb != NULL);          // 如果skb=NULL，那么说明之前的sk_backlog已经处理完了。
</span><span class='line'>
</span><span class='line'>&#9;&#9;bh_lock_sock(sk);
</span><span class='line'>&#9;} while ((skb = sk-&gt;sk_backlog.head) != NULL); // 在处理上一个sk_backlog时，可能被软中断中断了，建立了新的sk_backlog，新建立的sk_backlog也将一并被处理。
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9;* Doing the zeroing here guarantee we can not loop forever
</span><span class='line'>&#9;* while a wild producer attempts to flood us.
</span><span class='line'>&#9;*/
</span><span class='line'>&#9;sk_extended(sk)-&gt;sk_backlog.len = 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  一开始重置sk->sk_backlog.head ，sk->sk_backlog.tail为NULL。sk_backlog是一个双链表，head指向了链表头部的skb，而tail则指向了链表尾部的skb。这里之所以置NULL head 和tail，是因为struct sk_buff *skb = sk->sk_backlog.head 提前取到了head指向的skb，之后就可以通过skb->next来获取下一个skb处理，结束的条件是skb->next=NULL，这个是在<code>__sk_add_backlog</code>函数中置位的，也就说对于sk_backlog的处理head和tail指针已经没有用了。</p>

<p>  为什么要置NULLsk->sk_backlog.head ，sk->sk_backlog.tail呢？第一想法是它可能要被重新使用了。那么在什么情况下会被重新使用呢？试想一下当前是在进程上下文，并且sk->sk_lock.slock没有被锁住，那是不是可能被软中断打断呢？如果被软中断打断了是不是要接收数据呢，tcp协议栈为了效率考虑肯定是要接收数据的，前面分析道这种情况的数据必须放置到后备队列中(sk_backlog)，所以可以肯定置NULL sk->sk_backlog.head ，sk->sk_backlog.tail是为了在处理上一个sk_backlog时，能重用sk_backlog，建立一条新的sk_backlog，或许有人会问为什么不直接添加到原先的sk_backlog tail末尾呢？这个问题我也没有想太清楚，或许是同步不好做吧。</p>

<h5>4、skb被处理到哪去了</h5>

<p>  很明显接收的数据最终都将被传递到应用层，在传递到应用层前必须要保证三个接收队列中的数据有序，那么这三个队列是怎么保证数据字节流有序的被递交给应用层呢？三个队列都会调用tcp_v4_do_rcv函数，prequeue和sk_backlog是在tcp_recvmsg中调用tcp_v4_do_rcv函数，也就是进程上下文中调用tcp_v4_do_rcv函数，但会local_bh_disable禁止软中断。如果在tcp_rcv_established, tcp_data_queue中如果刚好数据可以直接copy到用户空间，又会短暂开始软中断local_bh_enable。</p>

<p>  但在tcp_checksum_complete_user、tcp_rcv_established、tcp_data_queue函数中开启软中断将来容易出问题，进入软中断:softirq()+=1; local_bh_enable:softirq()-=2; 所以现在只是软中断中softirq()统计不准，进程中还是准的。但如果以后在软中断中在local_bh_enable之前给softirq()+=1了，那么就会导致软中断被打断，导致软中断执行途中被切走而且永远切不回来。tcp_checksum_complete_user被切走导致收包不成功，tcp_rcv_established、tcp_data_queue函数中如果在tp->copied_seq+=chunk后被切走就会导致tp->copied_seq>tp->rcv_nxt，那么下次收包后就有可能出现tp->copied_seq > sk_write_queue.first.end_seq, 等异常。</p>

<p>  如果仔细分析tcp_v4_do_rcv函数能发现，这个函数能保证数据有序的排列在一起，所以无论是在处理sk_backlog还是prequeue，最终都会调用tcp_v4_do_rcv函数将数据有效地插入到sk_write_queue中，最后被应用层取走。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/05/11/debug-mark-tcp_read_sock_bug/">tcp_read_sock BUG</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-11T10:17:00+08:00'><span class='date'>2015-05-11</span> <span class='time'>10:17:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>commit baff42ab1494528907bf4d5870359e31711746ae
</span><span class='line'>Author: Steven J. Magnani &lt;steve@digidescorp.com&gt;
</span><span class='line'>Date:   Tue Mar 30 13:56:01 2010 -0700
</span><span class='line'>
</span><span class='line'>&#9;net: Fix oops from tcp_collapse() when using splice()
</span><span class='line'>
</span><span class='line'>&#9;tcp_read_sock() can have a eat skbs without immediately advancing copied_seq.
</span><span class='line'>&#9;This can cause a panic in tcp_collapse() if it is called as a result
</span><span class='line'>&#9;of the recv_actor dropping the socket lock.
</span><span class='line'>
</span><span class='line'>&#9;A userspace program that splices data from a socket to either another
</span><span class='line'>&#9;socket or to a file can trigger this bug.
</span><span class='line'>
</span><span class='line'>&#9;Signed-off-by: Steven J. Magnani &lt;steve@digidescorp.com&gt;
</span><span class='line'>&#9;Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
</span><span class='line'>index 6afb6d8..2c75f89 100644
</span><span class='line'>--- a/net/ipv4/tcp.c
</span><span class='line'>+++ b/net/ipv4/tcp.c
</span><span class='line'>@@ -1368,6 +1368,7 @@ int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,
</span><span class='line'>      sk_eat_skb(sk, skb, 0);
</span><span class='line'>      if (!desc-&gt;count)
</span><span class='line'>          break;
</span><span class='line'>+     tp-&gt;copied_seq = seq;
</span><span class='line'>  }
</span><span class='line'>  tp-&gt;copied_seq = seq;
</span><span class='line'> </span></code></pre></td></tr></table></div></figure>


<p>如果在tcp_read_sock中sk_eat_skb时copied_seq没有及时一起修改的话，就会出现copied_seq小于sk_write_queue队列第一个包的seq。<br/>
tcp_read_sock的recv_actor指向的函数(比如tcp_splice_data_recv)是有可能释放sk锁的，如果这时进入收包软中断且内存紧张调用tcp_collapse，<br/>
tcp_collapse中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>start = copied_seq
</span><span class='line'>...
</span><span class='line'>int offset = start - TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>
</span><span class='line'>BUG_ON(offset &lt; 0);</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/05/11/debug-mark-tcp_match_skb_to_sack_bug/">tcp_match_skb_to_sack BUG</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-11T10:09:00+08:00'><span class='date'>2015-05-11</span> <span class='time'>10:09:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>commit 2cd0d743b05e87445c54ca124a9916f22f16742e
</span><span class='line'>Author: Neal Cardwell &lt;ncardwell@google.com&gt;
</span><span class='line'>Date:   Wed Jun 18 21:15:03 2014 -0400
</span><span class='line'>
</span><span class='line'>&#9;tcp: fix tcp_match_skb_to_sack() for unaligned SACK at end of an skb
</span><span class='line'>
</span><span class='line'>&#9;If there is an MSS change (or misbehaving receiver) that causes a SACK
</span><span class='line'>&#9;to arrive that covers the end of an skb but is less than one MSS, then
</span><span class='line'>&#9;tcp_match_skb_to_sack() was rounding up pkt_len to the full length of
</span><span class='line'>&#9;the skb ("Round if necessary..."), then chopping all bytes off the skb
</span><span class='line'>&#9;and creating a zero-byte skb in the write queue.
</span><span class='line'>
</span><span class='line'>&#9;This was visible now because the recently simplified TLP logic in
</span><span class='line'>&#9;bef1909ee3ed1c ("tcp: fixing TLP's FIN recovery") could find that 0-byte
</span><span class='line'>&#9;skb at the end of the write queue, and now that we do not check that
</span><span class='line'>&#9;skb's length we could send it as a TLP probe.
</span><span class='line'>
</span><span class='line'>&#9;Consider the following example scenario:
</span><span class='line'>
</span><span class='line'>&#9; mss: 1000
</span><span class='line'>&#9; skb: seq: 0 end_seq: 4000  len: 4000
</span><span class='line'>&#9; SACK: start_seq: 3999 end_seq: 4000
</span><span class='line'>
</span><span class='line'>&#9;The tcp_match_skb_to_sack() code will compute:
</span><span class='line'>
</span><span class='line'>&#9; in_sack = false
</span><span class='line'>&#9; pkt_len = start_seq - TCP_SKB_CB(skb)-&gt;seq = 3999 - 0 = 3999
</span><span class='line'>&#9; new_len = (pkt_len / mss) * mss = (3999/1000)*1000 = 3000
</span><span class='line'>&#9; new_len += mss = 4000
</span><span class='line'>
</span><span class='line'>&#9;Previously we would find the new_len &gt; skb-&gt;len check failing, so we
</span><span class='line'>&#9;would fall through and set pkt_len = new_len = 4000 and chop off
</span><span class='line'>&#9;pkt_len of 4000 from the 4000-byte skb, leaving a 0-byte segment
</span><span class='line'>&#9;afterward in the write queue.
</span><span class='line'>
</span><span class='line'>&#9;With this new commit, we notice that the new new_len &gt;= skb-&gt;len check
</span><span class='line'>&#9;succeeds, so that we return without trying to fragment.
</span><span class='line'>
</span><span class='line'>&#9;Fixes: adb92db857ee ("tcp: Make SACK code to split only at mss boundaries")
</span><span class='line'>&#9;Reported-by: Eric Dumazet &lt;edumazet@google.com&gt;
</span><span class='line'>&#9;Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
</span><span class='line'>&#9;Cc: Eric Dumazet &lt;edumazet@google.com&gt;
</span><span class='line'>&#9;Cc: Yuchung Cheng &lt;ycheng@google.com&gt;
</span><span class='line'>&#9;Cc: Ilpo Jarvinen &lt;ilpo.jarvinen@helsinki.fi&gt;
</span><span class='line'>&#9;Acked-by: Eric Dumazet &lt;edumazet@google.com&gt;
</span><span class='line'>&#9;Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
</span><span class='line'>index 40661fc..b5c2375 100644
</span><span class='line'>--- a/net/ipv4/tcp_input.c
</span><span class='line'>+++ b/net/ipv4/tcp_input.c
</span><span class='line'>@@ -1162,7 +1162,7 @@ static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,
</span><span class='line'>          unsigned int new_len = (pkt_len / mss) * mss;
</span><span class='line'>          if (!in_sack && new_len &lt; pkt_len) {
</span><span class='line'>              new_len += mss;
</span><span class='line'>-             if (new_len &gt; skb-&gt;len)
</span><span class='line'>+             if (new_len &gt;= skb-&gt;len)
</span><span class='line'>                  return 0;
</span><span class='line'>          }
</span><span class='line'>          pkt_len = new_len;</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/28">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/26">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(40)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>23</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>13</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(51)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~haproxy/?opendiv=tools'>haproxy</a><a href='##' onmousedown=showDiv('tools~haproxy') id='aexp_tools~haproxy'><span class='exp_style' id='exp_tools~haproxy'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~haproxy')) document.getElementById('aexp_tools~haproxy').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(54)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>17</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~cgroup/?opendiv=system'>cgroup</a><a href='##' onmousedown=showDiv('system~cgroup') id='aexp_system~cgroup'><span class='exp_style' id='exp_system~cgroup'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~cgroup')) document.getElementById('aexp_system~cgroup').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~kvm/?opendiv=system'>kvm</a><a href='##' onmousedown=showDiv('system~kvm') id='aexp_system~kvm'><span class='exp_style' id='exp_system~kvm'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~kvm')) document.getElementById('aexp_system~kvm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~namespace/?opendiv=system'>namespace</a><a href='##' onmousedown=showDiv('system~namespace') id='aexp_system~namespace'><span class='exp_style' id='exp_system~namespace'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~namespace')) document.getElementById('aexp_system~namespace').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(163)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~fs/?opendiv=kernel'>fs</a><a href='##' onmousedown=showDiv('kernel~fs') id='aexp_kernel~fs'><span class='exp_style' id='exp_kernel~fs'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~fs')) document.getElementById('aexp_kernel~fs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>33</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>80</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>19</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(22)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(70)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>17</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~perf/?opendiv=debug'>perf</a><a href='##' onmousedown=showDiv('debug~perf') id='aexp_debug~perf'><span class='exp_style' id='exp_debug~perf'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~perf')) document.getElementById('aexp_debug~perf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(27)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>20</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2016/'>2016</a><a href='##' onmousedown=showDiv('2016')><span class='exp_style' id='exp_2016'>[+]</span></a><span class='right_span'>(9)</span></li>
<div id='2016' class='catsub'><li><a href='/blog/cats/2016~03/?opendiv=2016'>2016-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2016~02/?opendiv=2016'>2016-02</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2016~01/?opendiv=2016'>2016-01</a><span class='right_span'>6</span></li>
</div><li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(207)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~12/?opendiv=2015'>2015-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2015~11/?opendiv=2015'>2015-11</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2015~10/?opendiv=2015'>2015-10</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2015~09/?opendiv=2015'>2015-09</a><span class='right_span'>18</span></li>
<li><a href='/blog/cats/2015~08/?opendiv=2015'>2015-08</a><span class='right_span'>25</span></li>
<li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>31</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/03/09/kernel-net-bonding-source/">bonding的源代码分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/09/kernel-net-bonding/">七种网卡绑定模式详解</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/29/kernel-net-connect/">socket建立连接 sys_connect</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/21/kernel-net-udp-sum/">udp checksum</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/21/system-base-init/">Linux系统启动过程分析</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
	<li>
		<a href=http://smilejay.com/ target=_blank>smilejay</a>
	</li>
	<li>
		<a href=http://blog.chinaunix.net/uid/10167808.html target=_blank>godbach</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
