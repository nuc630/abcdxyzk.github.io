
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/03/04/kernel-net-tcp_clean_rtx_queue/">清理重传队列中函数 tcp_clean_rtx_queue</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-04T17:25:00+08:00'><span class='date'>2015-03-04</span> <span class='time'>17:25:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/shanshanpt/article/details/22194029">http://blog.csdn.net/shanshanpt/article/details/22194029</a></p>

<p>如果重传队列中的一些数据已经被确认，那么， 需要从重传队列中清除出去，需要使用这个函数：tcp_clean_rtx_queue</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Remove acknowledged frames from the retransmission queue. If our packet
</span><span class='line'> * is before the ack sequence we can discard it as it's confirmed to have
</span><span class='line'> * arrived at the other end.
</span><span class='line'> */
</span><span class='line'>static int tcp_clean_rtx_queue(struct sock *sk, int prior_fackets)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);   // 获得tcp_sock
</span><span class='line'>&#9;const struct inet_connection_sock *icsk = inet_csk(sk); // 获得连接sock
</span><span class='line'>&#9;struct sk_buff *skb;
</span><span class='line'>&#9;u32 now = tcp_time_stamp;           // 当前时间，用于计算RTT
</span><span class='line'>&#9;int fully_acked = 1;                // 表示数据段是否完全被确认
</span><span class='line'>&#9;int flag = 0;
</span><span class='line'>&#9;u32 pkts_acked = 0;
</span><span class='line'>&#9;u32 reord = tp-&gt;packets_out;        // 发送出去，还在网络上跑，但是还没有被确认的数据包们
</span><span class='line'>&#9;s32 seq_rtt = -1;
</span><span class='line'>&#9;s32 ca_seq_rtt = -1;
</span><span class='line'>&#9;ktime_t last_ackt = net_invalid_timestamp();    // 把last_ackt设置位0
</span><span class='line'>&#9;// 下面就是遍历sk_write_queue队列，遇到snd_una就停止，如果没有更新过，开始就直接退出了
</span><span class='line'>&#9;while ((skb = tcp_write_queue_head(sk)) && skb != tcp_send_head(sk)) {
</span><span class='line'>&#9;&#9;struct tcp_skb_cb *scb = TCP_SKB_CB(skb);   // 获得这个重传队列的一个skb的cb字段
</span><span class='line'>&#9;&#9;u32 end_seq;
</span><span class='line'>&#9;&#9;u32 acked_pcount;
</span><span class='line'>&#9;&#9;u8 sacked = scb-&gt;sacked;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Determine how many packets and what bytes were acked, tso and else */
</span><span class='line'>&#9;&#9;if (after(scb-&gt;end_seq, tp-&gt;snd_una)) {     // 注意这个scb是我们发出去的数据的skb中的一个scb哦！，不是接受到的数据！小心
</span><span class='line'>&#9;&#9;&#9;if (tcp_skb_pcount(skb) == 1 ||         // 这里的意思就是发出去的数据最后一个字节在已经确认的snd_una之后，说明还有没有确认的字节
</span><span class='line'>&#9;&#9;&#9;!after(tp-&gt;snd_una, scb-&gt;seq))          // 如果没有设置了TSO 或者 seq不在snd_una之前，即不是 seq---snd_una---end_seq这样情况
</span><span class='line'>&#9;&#9;&#9;&#9;break;                              // 那么说明没有必要把重传元素去掉，(如果是seq---snd_una---end_seq)那么前面半部分的就可以从队列中删除！！！
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;acked_pcount = tcp_tso_acked(sk, skb);  // 如果只确认了TSO段中的一部分，则从skb删除已经确认的segs，并统计确认了多少段( 1 )
</span><span class='line'>&#9;&#9;&#9;if (!acked_pcount)                      // 处理出错
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;fully_acked = 0;                        // 表示TSO只处理了一部分，其他还没处理完
</span><span class='line'>&#9;&#9;&#9;end_seq = tp-&gt;snd_una;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;acked_pcount = tcp_skb_pcount(skb);     // 即 !after(scb-&gt;end_seq, tp-&gt;snd_una)，说明已经完全确认OK！
</span><span class='line'>&#9;&#9;&#9;end_seq = scb-&gt;end_seq;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* MTU probing checks */
</span><span class='line'>&#9;&#9;if (fully_acked && icsk-&gt;icsk_mtup.probe_size &&      // 探测mtu，暂时不多说
</span><span class='line'>&#9;&#9;!after(tp-&gt;mtu_probe.probe_seq_end, scb-&gt;end_seq)) {
</span><span class='line'>&#9;&#9;&#9;tcp_mtup_probe_success(sk, skb);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;// 下面通过sack的信息得到这是一个被重传的过包
</span><span class='line'>&#9;&#9;if (sacked & TCPCB_RETRANS) {
</span><span class='line'>&#9;&#9;&#9;if (sacked & TCPCB_SACKED_RETRANS)      // 如果之前重传过，&& 之前还没收到回复
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;retrans_out -= acked_pcount;    // 现在需要更新重传的且没有收到ACK的包
</span><span class='line'>&#9;&#9;&#9;flag |= FLAG_RETRANS_DATA_ACKED;        // 重传包收到ACK
</span><span class='line'>&#9;&#9;&#9;ca_seq_rtt = -1;
</span><span class='line'>&#9;&#9;&#9;seq_rtt = -1;
</span><span class='line'>&#9;&#9;&#9;if ((flag & FLAG_DATA_ACKED) || (acked_pcount &gt; 1))
</span><span class='line'>&#9;&#9;&#9;&#9;flag |= FLAG_NONHEAD_RETRANS_ACKED;
</span><span class='line'>&#9;&#9;} else { // 如果此数据段没有被重传过
</span><span class='line'>&#9;&#9;&#9;ca_seq_rtt = now - scb-&gt;when;           // 通过ACK确认获得RTT值
</span><span class='line'>&#9;&#9;&#9;last_ackt = skb-&gt;tstamp;                // 获得skb的发送时间
</span><span class='line'>&#9;&#9;&#9;if (seq_rtt &lt; 0) {
</span><span class='line'>&#9;&#9;&#9;&#9;seq_rtt = ca_seq_rtt;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;if (!(sacked & TCPCB_SACKED_ACKED))     // 如果SACK存在一段没有被确认，那么保存其中序号最小号的
</span><span class='line'>&#9;&#9;&#9;&#9;reord = min(pkts_acked, reord);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (sacked & TCPCB_SACKED_ACKED)            // 如果是有sack标识
</span><span class='line'>&#9;&#9;&#9;tp-&gt;sacked_out -= acked_pcount;         // 那么更新sack的发出没有接受到确认的数量
</span><span class='line'>&#9;&#9;if (sacked & TCPCB_LOST)                    // 如果是丢包标识，那么更新数量
</span><span class='line'>&#9;&#9;&#9;tp-&gt;lost_out -= acked_pcount;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (unlikely(tp-&gt;urg_mode && !before(end_seq, tp-&gt;snd_up)))  // 紧急模式
</span><span class='line'>&#9;&#9;&#9;tp-&gt;urg_mode = 0;
</span><span class='line'>
</span><span class='line'>&#9;&#9;tp-&gt;packets_out -= acked_pcount;            // 发送的包没有确认的数量-=acked_pcount
</span><span class='line'>&#9;&#9;pkts_acked += acked_pcount;                 // 接收到确认的包数量+=acked_pcount
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Initial outgoing SYN's get put onto the write_queue
</span><span class='line'>&#9;&#9; * just like anything else we transmit.  It is not
</span><span class='line'>&#9;&#9; * true data, and if we misinform our callers that
</span><span class='line'>&#9;&#9; * this ACK acks real data, we will erroneously exit
</span><span class='line'>&#9;&#9; * connection startup slow start one packet too
</span><span class='line'>&#9;&#9; * quickly.  This is severely frowned upon behavior.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (!(scb-&gt;flags & TCPCB_FLAG_SYN)) {       // 如果不是SYN握手包
</span><span class='line'>&#9;&#9;&#9;flag |= FLAG_DATA_ACKED;                // 标识是数据确认
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;flag |= FLAG_SYN_ACKED;                 // 标识是SYN包标识
</span><span class='line'>&#9;&#9;&#9;tp-&gt;retrans_stamp = 0;                  // 清除重传戳
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!fully_acked)                           // 如果TSO段没被完全确认，则到此为止
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;tcp_unlink_write_queue(skb, sk);            // 从发送队列上移除这个skb！！！这个函数其实很简单，其实就是从链表中移除这个skb而已
</span><span class='line'>&#9;&#9;sk_wmem_free_skb(sk, skb);                  // 删除skb内存对象
</span><span class='line'>&#9;&#9;tcp_clear_all_retrans_hints(tp);
</span><span class='line'>&#9;}                                               // while循环结束
</span><span class='line'>
</span><span class='line'>&#9;if (skb && (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_SACKED_ACKED))  // 虚假的SACK
</span><span class='line'>&#9;&#9;flag |= FLAG_SACK_RENEGING;
</span><span class='line'>
</span><span class='line'>&#9;if (flag & FLAG_ACKED) {                        // 如果ACK更新了数据，是的snd_una更新了
</span><span class='line'>&#9;&#9;const struct tcp_congestion_ops *ca_ops
</span><span class='line'>&#9;&#9;&#9;= inet_csk(sk)-&gt;icsk_ca_ops;            // 拥塞信息
</span><span class='line'>
</span><span class='line'>&#9;&#9;tcp_ack_update_rtt(sk, flag, seq_rtt);      // 更新RTT
</span><span class='line'>&#9;&#9;tcp_rearm_rto(sk);                          // 重置超时重传计时器
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (tcp_is_reno(tp)) {                      // 如果没有SACK处理
</span><span class='line'>&#9;&#9;&#9;tcp_remove_reno_sacks(sk, pkts_acked);  // 处理乱序的包
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;/* Non-retransmitted hole got filled? That's reordering */
</span><span class='line'>&#9;&#9;&#9;if (reord &lt; prior_fackets)
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_update_reordering(sk, tp-&gt;fackets_out - reord, 0);  // 更新乱序队列大小
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;tp-&gt;fackets_out -= min(pkts_acked, tp-&gt;fackets_out);    // 更新提前确认算法得出的尚未得到确认的包的数量
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (ca_ops-&gt;pkts_acked) {   // 这是一个钩子函数
</span><span class='line'>&#9;&#9;&#9;s32 rtt_us = -1;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* Is the ACK triggering packet unambiguous? */
</span><span class='line'>&#9;&#9;&#9;if (!(flag & FLAG_RETRANS_DATA_ACKED)) {            // 如果是确认了非重传的包
</span><span class='line'>&#9;&#9;&#9;&#9;/* High resolution needed and available? */
</span><span class='line'>&#9;&#9;&#9;&#9;if (ca_ops-&gt;flags & TCP_CONG_RTT_STAMP &&       // 下面都是测量RTT，精读不同而已
</span><span class='line'>&#9;&#9;&#9;&#9;!ktime_equal(last_ackt,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9; net_invalid_timestamp()))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;rtt_us = ktime_us_delta(ktime_get_real(),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;last_ackt);
</span><span class='line'>&#9;&#9;&#9;&#9;else if (ca_seq_rtt &gt; 0)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;rtt_us = jiffies_to_usecs(ca_seq_rtt);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;ca_ops-&gt;pkts_acked(sk, pkts_acked, rtt_us);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>#if FASTRETRANS_DEBUG &gt; 0  // 下面用于调试
</span><span class='line'>&#9;BUG_TRAP((int)tp-&gt;sacked_out &gt;= 0);
</span><span class='line'>&#9;BUG_TRAP((int)tp-&gt;lost_out &gt;= 0);
</span><span class='line'>&#9;BUG_TRAP((int)tp-&gt;retrans_out &gt;= 0);
</span><span class='line'>&#9;if (!tp-&gt;packets_out && tcp_is_sack(tp)) {
</span><span class='line'>&#9;&#9;icsk = inet_csk(sk);
</span><span class='line'>&#9;&#9;if (tp-&gt;lost_out) {
</span><span class='line'>&#9;&#9;&#9;printk(KERN_DEBUG "Leak l=%u %d\n",
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;lost_out, icsk-&gt;icsk_ca_state);
</span><span class='line'>&#9;&#9;&#9;tp-&gt;lost_out = 0;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;if (tp-&gt;sacked_out) {
</span><span class='line'>&#9;&#9;&#9;printk(KERN_DEBUG "Leak s=%u %d\n",
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;sacked_out, icsk-&gt;icsk_ca_state);
</span><span class='line'>&#9;&#9;&#9;tp-&gt;sacked_out = 0;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;if (tp-&gt;retrans_out) {
</span><span class='line'>&#9;&#9;&#9;printk(KERN_DEBUG "Leak r=%u %d\n",
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;retrans_out, icsk-&gt;icsk_ca_state);
</span><span class='line'>&#9;&#9;&#9; tp-&gt;retrans_out = 0;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>#endif
</span><span class='line'>&#9;return flag;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面看一下tcp_tso_acked函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* If we get here, the whole TSO packet has not been acked. */
</span><span class='line'>static u32 tcp_tso_acked(struct sock *sk, struct sk_buff *skb)       // TSO 包并没有全部被确认，现在需要统计已经被确认的数量
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);                                // 获得tcp_sock
</span><span class='line'>&#9;u32 packets_acked;
</span><span class='line'>
</span><span class='line'>&#9;BUG_ON(!after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una));           // seq---end_seq---snd_una  这种情况不可能进来
</span><span class='line'>
</span><span class='line'>&#9;packets_acked = tcp_skb_pcount(skb);                             // TSO段总共包括几个
</span><span class='line'>&#9;if (tcp_trim_head(sk, skb, tp-&gt;snd_una - TCP_SKB_CB(skb)-&gt;seq))  // 对于已经确认的部分，更新skb中的信息。例如len之类信息都变了
</span><span class='line'>&#9;&#9;return 0;                                                    // 然后重新计算出新的剩余的segs
</span><span class='line'>&#9;packets_acked -= tcp_skb_pcount(skb);                            // 之前总的segs - 现在剩余的segs == 被确认的segs
</span><span class='line'>
</span><span class='line'>&#9;if (packets_acked) {
</span><span class='line'>&#9;&#9;BUG_ON(tcp_skb_pcount(skb) == 0);
</span><span class='line'>&#9;&#9;BUG_ON(!before(TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq));
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;return packets_acked;                                            // 返回被确认的数量
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/03/04/kernel-net-ip/">linux TCP/IP协议栈-IP层</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-04T17:03:00+08:00'><span class='date'>2015-03-04</span> <span class='time'>17:03:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.chinaunix.net/uid-22577711-id-3216938.html">linux TCP/IP协议栈 &mdash;ip_rcv()</a><br/>
<a href="http://blog.chinaunix.net/uid-22577711-id-3216949.html">linux TCP/IP协议栈 &mdash;ip_rcv_finish()</a><br/>
<a href="http://blog.chinaunix.net/uid-22577711-id-3218535.html">linux TCP/IP协议栈 &mdash;ip_local_deliver()</a><br/>
<a href="http://blog.chinaunix.net/uid-22577711-id-3218536.html">linux TCP/IP协议栈 &mdash;ip_local_deliver_finish()</a><br/>
<a href="http://blog.chinaunix.net/uid-22577711-id-3218543.html">linux TCP/IP协议栈 &mdash;ip_defrag()</a><br/>
<a href="http://blog.chinaunix.net/uid-22577711-id-3218545.html">linux TCP/IP协议栈 &mdash;ip_find()</a><br/>
<a href="http://blog.chinaunix.net/uid-22577711-id-3218548.html">linux TCP/IP协议栈 &mdash;inet_frag_find()</a></p>

<h4>ip_rcv()</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 主要功能：对IP头部合法性进行严格检查，然后把具体功能交给ip_rcv_finish。*/
</span><span class='line'>int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct iphdr *iph;
</span><span class='line'>&#9;u32 len;
</span><span class='line'>&#9;/* 网络名字空间，忽略 */
</span><span class='line'>&#9;if (dev-&gt;nd_net != &init_net)
</span><span class='line'>&#9;&#9;goto drop;
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; *当网卡处于混杂模式时，收到不是发往该主机的数据包，由net_rx_action()设置。
</span><span class='line'>&#9; *在调用ip_rcv之前，内核会将该数据包交给嗅探器，所以该函数仅丢弃该包。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (skb-&gt;pkt_type == PACKET_OTHERHOST)
</span><span class='line'>&#9;&#9;goto drop;
</span><span class='line'>&#9;/* SNMP所需要的统计数据，忽略 */
</span><span class='line'>&#9;IP_INC_STATS_BH(IPSTATS_MIB_INRECEIVES);
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; *ip_rcv是由netif_receive_skb函数调用，如果嗅探器或者其他的用户对数据包需要进
</span><span class='line'>&#9; *进行处理，则在调用ip_rcv之前，netif_receive_skb会增加skb的引用计数，既该引
</span><span class='line'>&#9; *用计数会大于1。若如此次，则skb_share_check会创建sk_buff的一份拷贝。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL) {
</span><span class='line'>&#9;&#9;IP_INC_STATS_BH(IPSTATS_MIB_INDISCARDS);
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; *pskb_may_pull确保skb-&gt;data指向的内存包含的数据至少为IP头部大小，由于每个
</span><span class='line'>&#9; *IP数据包包括IP分片必须包含一个完整的IP头部。如果小于IP头部大小，则缺失
</span><span class='line'>&#9; *的部分将从数据分片中拷贝。这些分片保存在skb_shinfo(skb)-&gt;frags[]中。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (!pskb_may_pull(skb, sizeof(struct iphdr)))
</span><span class='line'>&#9;&#9;goto inhdr_error;
</span><span class='line'>&#9;/* pskb_may_pull可能会调整skb中的指针，所以需要重新定义IP头部*/
</span><span class='line'>&#9;iph = ip_hdr(skb);
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; *    RFC1122: 3.1.2.2 MUST silently discard any IP frame that fails the checksum.
</span><span class='line'>&#9; *
</span><span class='line'>&#9; *    Is the datagram acceptable?
</span><span class='line'>&#9; *
</span><span class='line'>&#9; *    1.    Length at least the size of an ip header
</span><span class='line'>&#9; *    2.    Version of 4
</span><span class='line'>&#9; *    3.    Checksums correctly. [Speed optimisation for later, skip loopback checksums]
</span><span class='line'>&#9; *    4.    Doesn't have a bogus length
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/* 上面说的很清楚了 */
</span><span class='line'>&#9;if (iph-&gt;ihl &lt; 5 || iph-&gt;version != 4)
</span><span class='line'>&#9;&#9;goto inhdr_error;
</span><span class='line'>&#9;/* 确保IP完整的头部包括选项在内存中 */
</span><span class='line'>&#9;if (!pskb_may_pull(skb, iph-&gt;ihl*4))
</span><span class='line'>&#9;&#9;goto inhdr_error;
</span><span class='line'>&#9;
</span><span class='line'>&#9;iph = ip_hdr(skb);
</span><span class='line'>&#9;/* 验证IP头部的校验和 */
</span><span class='line'>&#9;if (unlikely(ip_fast_csum((u8 *)iph, iph-&gt;ihl)))
</span><span class='line'>&#9;&#9;goto inhdr_error;
</span><span class='line'>&#9;/* IP头部中指示的IP数据包总长度 */
</span><span class='line'>&#9;len = ntohs(iph-&gt;tot_len);
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; *确保skb的数据长度大于等于IP头部中指示的IP数据包总长度及数据包总长度必须
</span><span class='line'>&#9; *大于等于IP头部长度。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (skb-&gt;len &lt; len) {
</span><span class='line'>&#9;&#9;IP_INC_STATS_BH(IPSTATS_MIB_INTRUNCATEDPKTS);
</span><span class='line'>&#9;&#9;goto drop;
</span><span class='line'>&#9;} else if (len &lt; (iph-&gt;ihl*4))
</span><span class='line'>&#9;&#9;goto inhdr_error;
</span><span class='line'>
</span><span class='line'>&#9;/* Our transport medium may have padded the buffer out. Now we know it
</span><span class='line'>&#9; * is IP we can trim to the true length of the frame.
</span><span class='line'>&#9; * Note this now means skb-&gt;len holds ntohs(iph-&gt;tot_len).
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/* 注释说明的很清楚，该函数成功执行完之后，skb-&gt;len = ntohs(iph-&gt;tot_len). */
</span><span class='line'>&#9;if (pskb_trim_rcsum(skb, len)) {
</span><span class='line'>&#9;&#9;IP_INC_STATS_BH(IPSTATS_MIB_INDISCARDS);
</span><span class='line'>&#9;&#9;goto drop;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/* Remove any debris in the socket control block */
</span><span class='line'>&#9;memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
</span><span class='line'>&#9;/* 忽略与netfilter子系统的交互，调用为ip_rcv_finish(skb) */
</span><span class='line'>&#9;return NF_HOOK(PF_INET, NF_IP_PRE_ROUTING, skb, dev, NULL,
</span><span class='line'>&#9;&#9; ip_rcv_finish);
</span><span class='line'>
</span><span class='line'>inhdr_error:
</span><span class='line'>&#9;IP_INC_STATS_BH(IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>drop:
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>out:
</span><span class='line'>&#9;return NET_RX_DROP;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>ip_rcv_finish()</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int ip_rcv_finish(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;const struct iphdr *iph = ip_hdr(skb);
</span><span class='line'>&#9;struct rtable *rt;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; *    Initialise the virtual path cache for the packet. It describes
</span><span class='line'>&#9; *    how the packet travels inside Linux networking.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 通常从外界接收的数据包,skb-&gt;dst不会包含路由信息，暂时还不知道在何处会设置
</span><span class='line'>&#9; * 这个字段。ip_route_input函数会根据路由表设置路由信息，暂时不考虑路由系统。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (skb-&gt;dst == NULL) {
</span><span class='line'>&#9;&#9;int err = ip_route_input(skb, iph-&gt;daddr, iph-&gt;saddr, iph-&gt;tos,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; skb-&gt;dev);
</span><span class='line'>&#9;&#9;if (unlikely(err)) {
</span><span class='line'>&#9;&#9;&#9;if (err == -EHOSTUNREACH)
</span><span class='line'>&#9;&#9;&#9;&#9;IP_INC_STATS_BH(IPSTATS_MIB_INADDRERRORS);
</span><span class='line'>&#9;&#9;&#9;else if (err == -ENETUNREACH)
</span><span class='line'>&#9;&#9;&#9;&#9;IP_INC_STATS_BH(IPSTATS_MIB_INNOROUTES);
</span><span class='line'>&#9;&#9;&#9;goto drop;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>/* 更新流量控制所需要的统计数据，忽略 */
</span><span class='line'>#ifdef CONFIG_NET_CLS_ROUTE
</span><span class='line'>&#9;if (unlikely(skb-&gt;dst-&gt;tclassid)) {
</span><span class='line'>&#9;&#9;struct ip_rt_acct *st = ip_rt_acct + 256*smp_processor_id();
</span><span class='line'>&#9;&#9;u32 idx = skb-&gt;dst-&gt;tclassid;
</span><span class='line'>&#9;&#9;st[idx&0xFF].o_packets++;
</span><span class='line'>&#9;&#9;st[idx&0xFF].o_bytes+=skb-&gt;len;
</span><span class='line'>&#9;&#9;st[(idx&gt;&gt;16)&0xFF].i_packets++;
</span><span class='line'>&#9;&#9;st[(idx&gt;&gt;16)&0xFF].i_bytes+=skb-&gt;len;
</span><span class='line'>&#9;}
</span><span class='line'>#endif
</span><span class='line'>&#9;/* 如果IP头部大于20字节，则表示IP头部包含IP选项，需要进行选项处理.暂时忽略，毕竟很少用 */
</span><span class='line'>&#9;if (iph-&gt;ihl &gt; 5 && ip_rcv_options(skb))
</span><span class='line'>&#9;&#9;goto drop;
</span><span class='line'>
</span><span class='line'>&#9;/* skb-&gt;dst包含路由信息。根据路由类型更新SNMP统计数据 */
</span><span class='line'>&#9;rt = (struct rtable*)skb-&gt;dst;
</span><span class='line'>&#9;if (rt-&gt;rt_type == RTN_MULTICAST)
</span><span class='line'>&#9;&#9;IP_INC_STATS_BH(IPSTATS_MIB_INMCASTPKTS);
</span><span class='line'>&#9;else if (rt-&gt;rt_type == RTN_BROADCAST)
</span><span class='line'>&#9;&#9;IP_INC_STATS_BH(IPSTATS_MIB_INBCASTPKTS);
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * dst_input实际上会调用skb-&gt;dst-&gt;input(skb).input函数会根据路由信息设置为合适的
</span><span class='line'>&#9; * 函数指针，如果是递交到本地的则为ip_local_deliver，若是转发则为ip_forward.
</span><span class='line'>&#9; * 暂时仅先考虑ip_local_deliver。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;return dst_input(skb);
</span><span class='line'>
</span><span class='line'>drop:
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return NET_RX_DROP;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>ip_local_deliver()</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> *     Deliver IP Packets to the higher protocol layers.
</span><span class='line'> */
</span><span class='line'>主要功能：收集IP分片，然后调用ip_local_deliver_finish将一个完整的数据包传送给上层协议。
</span><span class='line'>int ip_local_deliver(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; *    Reassemble IP fragments.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 判断该IP数据包是否是一个分片，如果IP_MF置位，则表示该包是分片之一，其
</span><span class='line'>&#9; * 后还有更多分片，最后一个IP分片未置位IP_MF但是其offset是非0。
</span><span class='line'>&#9; * 如果是一个IP分片，则调用ip_defrag重新组织IP数据包。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (ip_hdr(skb)-&gt;frag_off & htons(IP_MF | IP_OFFSET)) {
</span><span class='line'>&#9;&#9;if (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))
</span><span class='line'>&#9;&#9;&#9;return 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/* 调用ip_local_deliver_finish(skb) */
</span><span class='line'>&#9;return NF_HOOK(PF_INET, NF_IP_LOCAL_IN, skb, skb-&gt;dev, NULL,
</span><span class='line'>&#9;&#9; ip_local_deliver_finish);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>ip_local_deliver_finish()</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 如果忽略掉原始套接字和IPSec，则该函数仅仅是根据IP头部中的协议字段选择上层L4协议，并交给它来处理 */
</span><span class='line'>static int ip_local_deliver_finish(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;/* 跳过IP头部 */
</span><span class='line'>&#9;__skb_pull(skb, ip_hdrlen(skb));
</span><span class='line'>
</span><span class='line'>&#9;/* Point into the IP datagram, just past the header. */
</span><span class='line'>&#9;/* 设置传输层头部位置 */
</span><span class='line'>&#9;skb_reset_transport_header(skb);
</span><span class='line'>
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;/* Note: See raw.c and net/raw.h, RAWV4_HTABLE_SIZE==MAX_INET_PROTOS */
</span><span class='line'>&#9;&#9;int protocol = ip_hdr(skb)-&gt;protocol;
</span><span class='line'>&#9;&#9;int hash;
</span><span class='line'>&#9;&#9;struct sock *raw_sk;
</span><span class='line'>&#9;&#9;struct net_protocol *ipprot;
</span><span class='line'>
</span><span class='line'>&#9;resubmit:
</span><span class='line'>&#9;/* 这个hash根本不是哈希值，仅仅只是inet_protos数组中的下表而已 */
</span><span class='line'>&#9;&#9;hash = protocol & (MAX_INET_PROTOS - 1);
</span><span class='line'>&#9;&#9;raw_sk = sk_head(&raw_v4_htable[hash]);
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* If there maybe a raw socket we must check - if not we
</span><span class='line'>&#9;&#9; * don't care less
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;/* 原始套接字？？ 忽略... */
</span><span class='line'>&#9;&#9;if (raw_sk && !raw_v4_input(skb, ip_hdr(skb), hash))
</span><span class='line'>&#9;&#9;&#9;raw_sk = NULL;
</span><span class='line'>&#9;/* 查找注册的L4层协议处理结构。 */
</span><span class='line'>&#9;&#9;if ((ipprot = rcu_dereference(inet_protos[hash])) != NULL) {
</span><span class='line'>&#9;&#9;&#9;int ret;
</span><span class='line'>&#9;/* 启用了安全策略，则交给IPSec */
</span><span class='line'>&#9;&#9;&#9;if (!ipprot-&gt;no_policy) {
</span><span class='line'>&#9;&#9;&#9;&#9;if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;nf_reset(skb);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;/* 调用L4层协议处理函数 */
</span><span class='line'>&#9;/* 通常会是tcp_v4_rcv, udp_rcv, icmp_rcv和igmp_rcv */
</span><span class='line'>&#9;/* 如果注册了其他的L4层协议处理，则会进行相应的调用。 */
</span><span class='line'>&#9;&#9;&#9;ret = ipprot-&gt;handler(skb);
</span><span class='line'>&#9;&#9;&#9;if (ret &lt; 0) {
</span><span class='line'>&#9;&#9;&#9;&#9;protocol = -ret;
</span><span class='line'>&#9;&#9;&#9;&#9;goto resubmit;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;IP_INC_STATS_BH(IPSTATS_MIB_INDELIVERS);
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;if (!raw_sk) {    /* 无原始套接字，提交给IPSec */
</span><span class='line'>&#9;&#9;&#9;&#9;if (xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;IP_INC_STATS_BH(IPSTATS_MIB_INUNKNOWNPROTOS);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;icmp_send(skb, ICMP_DEST_UNREACH,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9; ICMP_PROT_UNREACH, 0);
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;&#9;IP_INC_STATS_BH(IPSTATS_MIB_INDELIVERS);
</span><span class='line'>&#9;&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'> out:
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>ip_defrag()</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Process an incoming IP datagram fragment. */
</span><span class='line'>int ip_defrag(struct sk_buff *skb, u32 user)
</span><span class='line'>{
</span><span class='line'>&#9;struct ipq *qp;
</span><span class='line'>
</span><span class='line'>&#9;IP_INC_STATS_BH(IPSTATS_MIB_REASMREQDS);
</span><span class='line'>
</span><span class='line'>&#9;/* Start by cleaning up the memory. */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 首先检查所有IP分片所消耗的内存是否大于系统允许的最高阀值，如果是，则调用
</span><span class='line'>&#9; * ip_evictor()丢弃未完全到达的IP分片，从最旧的分片开始释放。此举一来是为了节
</span><span class='line'>&#9; * 约内存，二来是未了防止黑客的恶意攻击。使分片在系统中累计，降低系统性能。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (atomic_read(&ip4_frags.mem) &gt; ip4_frags_ctl.high_thresh)
</span><span class='line'>&#9;&#9;ip_evictor();
</span><span class='line'>
</span><span class='line'>&#9;/* Lookup (or create) queue header */
</span><span class='line'>&#9;/* 如果该分片是数据报的第一个分片，则ip_find返回一个新的队列来搜集分片，否则
</span><span class='line'>&#9; * 返回其所属于的分片队列。 */
</span><span class='line'>&#9;if ((qp = ip_find(ip_hdr(skb), user)) != NULL) {
</span><span class='line'>&#9;&#9;int ret;
</span><span class='line'>
</span><span class='line'>&#9;&#9;spin_lock(&qp-&gt;q.lock);
</span><span class='line'>&#9;/* 将该分片加入到队列中，重组分片队列，如果所有的包都收到了，则该函数
</span><span class='line'>&#9; * 负责重组IP包 */
</span><span class='line'>&#9;&#9;ret = ip_frag_queue(qp, skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;spin_unlock(&qp-&gt;q.lock);
</span><span class='line'>&#9;&#9;ipq_put(qp);    /* 引用计数减1 */
</span><span class='line'>&#9;&#9;return ret;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;IP_INC_STATS_BH(IPSTATS_MIB_REASMFAILS);
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return -ENOMEM;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>ip_find()</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Find the correct entry in the "incomplete datagrams" queue for
</span><span class='line'> * this IP datagram, and create new one, if nothing is found.
</span><span class='line'> */
</span><span class='line'>/* u32 user这个参数有点迷惑，其表示以何种理由需要对数据包进行重组，在ip_local_deliver的调用序列当中，这个值是IP_DEFRAG_LOCAL_DELIVER。*/
</span><span class='line'>static inline struct ipq *ip_find(struct iphdr *iph, u32 user)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_frag_queue *q;
</span><span class='line'>&#9;struct ip4_create_arg arg;
</span><span class='line'>&#9;unsigned int hash;
</span><span class='line'>
</span><span class='line'>&#9;arg.iph = iph;
</span><span class='line'>&#9;arg.user = user;
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * hash算法，该算法除了使用所给的这四个参数之外，还使用了一个随机值
</span><span class='line'>&#9; * ip4_frags.rnd,，其初始化为
</span><span class='line'>&#9; * (u32) ((num_physpages ^ (num_physpages&gt;&gt;7)) ^ (jiffies ^ (jiffies &gt;&gt; 6)));
</span><span class='line'>&#9; * 这是为了防止黑客根据固定的hash算法，通过设置ip头部的这些字段，生成同样
</span><span class='line'>&#9; * HASH值，从而使某一HASH队列长度急剧增大而影响性能。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;hash = ipqhashfn(iph-&gt;id, iph-&gt;saddr, iph-&gt;daddr, iph-&gt;protocol);
</span><span class='line'>&#9;/* 若存在该分片所属的分片队列则返回这个队列，否则创建一个新的队列 */
</span><span class='line'>&#9;q = inet_frag_find(&ip4_frags, &arg, hash);
</span><span class='line'>&#9;if (q == NULL)
</span><span class='line'>&#9;&#9;goto out_nomem;
</span><span class='line'>
</span><span class='line'>&#9;return container_of(q, struct ipq, q);
</span><span class='line'>
</span><span class='line'>out_nomem:
</span><span class='line'>&#9;LIMIT_NETDEBUG(KERN_ERR "ip_frag_create: no memory left !\n");
</span><span class='line'>&#9;return NULL;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>inet_frag_find()</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct inet_frag_queue *inet_frag_find(struct inet_frags *f, void *key,
</span><span class='line'>&#9;&#9;unsigned int hash)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_frag_queue *q;
</span><span class='line'>&#9;struct hlist_node *n;
</span><span class='line'>
</span><span class='line'>&#9;/* f-&gt;lock是读写锁，先搜索是否存在该IP分段所属的队列 */
</span><span class='line'>&#9;read_lock(&f-&gt;lock);
</span><span class='line'>&#9;hlist_for_each_entry(q, n, &f-&gt;hash[hash], list) { /* 扫描该HASH槽中所有节点 */
</span><span class='line'>&#9;/* f-&gt;match中match字段在ipfrag_init中初始化为ip4_frag_match函数。*/
</span><span class='line'>&#9;/* 对比分片队列中的散列字段和user是否和key相等，key指向的是struct ip4_create_arg
</span><span class='line'>&#9; * 结构，包含IP头部和user字段。 */
</span><span class='line'>&#9;&#9;if (f-&gt;match(q, key)) {
</span><span class='line'>&#9;&#9;&#9;atomic_inc(&q-&gt;refcnt);     /* 若找到，则增加该队列引用计数。 */
</span><span class='line'>&#9;&#9;&#9;read_unlock(&f-&gt;lock);
</span><span class='line'>&#9;&#9;&#9;return q;                /* 返回该队列 */
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;read_unlock(&f-&gt;lock);
</span><span class='line'>&#9;/* 该分片是第一个IP分片，创建一个新的分片队列并添加到合适的HASH队列 */
</span><span class='line'>&#9;return inet_frag_create(f, key, hash);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/03/03/kernel-mm-slab2/">Linux slab 分配器</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-03T17:32:00+08:00'><span class='date'>2015-03-03</span> <span class='time'>17:32:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.linuxidc.com/Linux/2012-06/62965.htm">Linux Slab分配器(一)-概述</a><br/>
<a href="http://www.linuxidc.com/Linux/2012-06/62966.htm">Linux Slab分配器(二)-初始化</a><br/>
<a href="http://www.linuxidc.com/Linux/2012-06/63109.htm">Linux Slab分配器(三)-创建缓存</a><br/>
<a href="http://www.linuxidc.com/Linux/2012-06/63138.htm">Linux Slab分配器(四)-分配对象</a></p>

<h2>一、概述</h2>

<p>  slab分配器是Linux内存管理中非常重要和复杂的一部分，其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内碎片，而且处理速度也太慢。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统。slab分配对象时，会使用最近释放的对象内存块，因此其驻留在CPU高速缓存的概率较高。</p>

<h5>用于描述和管理cache的数据结构是struct kmem_cache</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct kmem_cache {  
</span><span class='line'>/* 1) per-cpu data, touched during every alloc/free */  
</span><span class='line'>&#9;/*per-CPU数据，记录了本地高速缓存的信息，也用于跟踪最近释放的对象，每次分配和释放都要直接访问它*/  
</span><span class='line'>&#9;struct array_cache *array[NR_CPUS];   
</span><span class='line'>/* 2) Cache tunables. Protected by cache_chain_mutex */  
</span><span class='line'>&#9;unsigned int batchcount;  /*本地高速缓存转入或转出的大批对象数量*/  
</span><span class='line'>&#9;unsigned int limit;       /*本地高速缓存中空闲对象的最大数目*/  
</span><span class='line'>&#9;unsigned int shared;  
</span><span class='line'>
</span><span class='line'>&#9;unsigned int buffer_size;/*管理对象的大小*/  
</span><span class='line'>&#9;u32 reciprocal_buffer_size;/*buffer_size的倒数值*/  
</span><span class='line'>/* 3) touched by every alloc & free from the backend */  
</span><span class='line'>
</span><span class='line'>&#9;unsigned int flags;          /* 高速缓存的永久标识*/  
</span><span class='line'>&#9;unsigned int num;         /* 一个slab所包含的对象数目 */  
</span><span class='line'>
</span><span class='line'>/* 4) cache_grow/shrink */  
</span><span class='line'>&#9;/* order of pgs per slab (2^n) */  
</span><span class='line'>&#9;unsigned int gfporder;   /*一个slab包含的连续页框数的对数*/  
</span><span class='line'>
</span><span class='line'>&#9;/* force GFP flags, e.g. GFP_DMA */  
</span><span class='line'>&#9;gfp_t gfpflags;          /*与伙伴系统交互时所提供的分配标识*/  
</span><span class='line'>
</span><span class='line'>&#9;size_t colour;         /* 颜色的个数*/  
</span><span class='line'>&#9;unsigned int colour_off; /* 着色的偏移量 */  
</span><span class='line'>
</span><span class='line'>&#9;/*如果将slab描述符存储在外部，该指针指向存储slab描述符的cache, 
</span><span class='line'>&#9;  否则为NULL*/  
</span><span class='line'>&#9;struct kmem_cache *slabp_cache;  
</span><span class='line'>&#9;unsigned int slab_size;  /*slab管理区的大小*/  
</span><span class='line'>&#9;unsigned int dflags;     /*动态标识*/  
</span><span class='line'>
</span><span class='line'>&#9;/* constructor func */  
</span><span class='line'>&#9;void (*ctor)(void *obj); /*创建高速缓存时的构造函数指针*/  
</span><span class='line'>
</span><span class='line'>/* 5) cache creation/removal */  
</span><span class='line'>&#9;const char *name;         /*高速缓存名*/  
</span><span class='line'>&#9;struct list_head next;    /*用于将高速缓存链入cache chain*/  
</span><span class='line'>
</span><span class='line'>/* 6) statistics */  
</span><span class='line'>#ifdef CONFIG_DEBUG_SLAB /*一些用于调试用的变量*/   
</span><span class='line'>&#9;unsigned long num_active;  
</span><span class='line'>&#9;unsigned long num_allocations;  
</span><span class='line'>&#9;unsigned long high_mark;  
</span><span class='line'>&#9;unsigned long grown;  
</span><span class='line'>&#9;unsigned long reaped;  
</span><span class='line'>&#9;unsigned long errors;  
</span><span class='line'>&#9;unsigned long max_freeable;  
</span><span class='line'>&#9;unsigned long node_allocs;  
</span><span class='line'>&#9;unsigned long node_frees;  
</span><span class='line'>&#9;unsigned long node_overflow;  
</span><span class='line'>&#9;atomic_t allochit;  
</span><span class='line'>&#9;atomic_t allocmiss;  
</span><span class='line'>&#9;atomic_t freehit;  
</span><span class='line'>&#9;atomic_t freemiss;  
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * If debugging is enabled, then the allocator can add additional 
</span><span class='line'>&#9; * fields and/or padding to every object. buffer_size contains the total 
</span><span class='line'>&#9; * object size including these internal fields, the following two 
</span><span class='line'>&#9; * variables contain the offset to the user object and its size. 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;int obj_offset;  
</span><span class='line'>&#9;int obj_size;  
</span><span class='line'>#endif /* CONFIG_DEBUG_SLAB */   
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * We put nodelists[] at the end of kmem_cache, because we want to size 
</span><span class='line'>&#9; * this array to nr_node_ids slots instead of MAX_NUMNODES 
</span><span class='line'>&#9; * (see kmem_cache_init()) 
</span><span class='line'>&#9; * We still use [MAX_NUMNODES] and not [1] or [0] because cache_cache 
</span><span class='line'>&#9; * is statically defined, so we reserve the max number of nodes. 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9; /*struct kmem_list3用于组织该高速缓存中的slab*/  
</span><span class='line'>&#9;struct kmem_list3 *nodelists[MAX_NUMNODES];  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * Do not add fields after nodelists[] 
</span><span class='line'>&#9; */  
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct kmem_list3 {  
</span><span class='line'>&#9;struct list_head slabs_partial;/*slab链表，包含空闲对象和已分配对象的slab描述符*/  
</span><span class='line'>&#9;struct list_head slabs_full;   /*slab链表，只包含非空闲的slab描述符*/  
</span><span class='line'>&#9;struct list_head slabs_free;   /*slab链表，只包含空闲的slab描述符*/  
</span><span class='line'>&#9;unsigned long free_objects;    /*高速缓存中空闲对象的个数*/  
</span><span class='line'>&#9;unsigned int free_limit;       /*空闲对象的上限*/  
</span><span class='line'>&#9;unsigned int colour_next;       /*下一个slab使用的颜色*/  
</span><span class='line'>&#9;spinlock_t list_lock;  
</span><span class='line'>&#9;struct array_cache *shared; /* shared per node */  
</span><span class='line'>&#9;struct array_cache **alien; /* on other nodes */  
</span><span class='line'>&#9;unsigned long next_reap;    /* updated without locking */  
</span><span class='line'>&#9;int free_touched;       /* updated without locking */  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<h5>描述和管理单个slab的结构是struct slab</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct slab {  
</span><span class='line'>&#9;struct list_head list;  /*用于将slab链入kmem_list3的链表*/  
</span><span class='line'>&#9;unsigned long colouroff;/*该slab的着色偏移*/  
</span><span class='line'>&#9;void *s_mem;            /*指向slab中的第一个对象*/  
</span><span class='line'>&#9;unsigned int inuse;     /*已分配出去的对象*/  
</span><span class='line'>&#9;kmem_bufctl_t free;     /*下一个空闲对象的下标*/  
</span><span class='line'>&#9;unsigned short nodeid;  /*节点标识号*/  
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>




</div>
  
  
    <footer>
      <a rel="full-article" target="_blank" href="/blog/2015/03/03/kernel-mm-slab2/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/03/03/kernel-mm-slab1/">Linux slab 分配器剖析</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-03T17:15:00+08:00'><span class='date'>2015-03-03</span> <span class='time'>17:15:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/">http://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/</a></p>

<h4>动态内存管理</h4>

<p>内存管理的目标是提供一种方法，为实现各种目的而在各个用户之间实现内存共享。内存管理方法应该实现以下两个功能：<br/>
1. 最小化管理内存所需的时间
2. 最大化用于一般应用的可用内存（最小化管理开销）</p>

<p>  内存管理实际上是一种关于权衡的零和游戏。您可以开发一种使用少量内存进行管理的算法，但是要花费更多时间来管理可用内存。也可以开发一个算法来有效地管理内存，但却要使用更多的内存。最终，特定应用程序的需求将促使对这种权衡作出选择。</p>

<p>  每个内存管理器都使用了一种基于堆的分配策略。在这种方法中，大块内存（称为 堆）用来为用户定义的目的提供内存。当用户需要一块内存时，就请求给自己分配一定大小的内存。堆管理器会查看可用内存的情况（使用特定算法）并返回一块内存。搜索过程中使用的一些算法有 first-fit（在堆中搜索到的第一个满足请求的内存块 ）和 best-fit（使用堆中满足请求的最合适的内存块）。当用户使用完内存后，就将内存返回给堆。</p>

<p>  这种基于堆的分配策略的根本问题是碎片（fragmentation）。当内存块被分配后，它们会以不同的顺序在不同的时间返回。这样会在堆中留下一些洞，需要花一些时间才能有效地管理空闲内存。这种算法通常具有较高的内存使用效率（分配需要的内存），但是却需要花费更多时间来对堆进行管理。</p>

<p>  另外一种方法称为 buddy memory allocation，是一种更快的内存分配技术，它将内存划分为 2 的幂次方个分区，并使用 best-fit 方法来分配内存请求。当用户释放内存时，就会检查 buddy 块，查看其相邻的内存块是否也已经被释放。如果是的话，将合并内存块以最小化内存碎片。这个算法的时间效率更高，但是由于使用 best-fit 方法的缘故，会产生内存浪费。</p>

<p>本文将着重介绍 Linux 内核的内存管理，尤其是 slab 分配提供的机制。</p>

<h4>slab 缓存</h4>

<p>  Linux 所使用的 slab 分配器的基础是 Jeff Bonwick 为 SunOS 操作系统首次引入的一种算法。Jeff 的分配器是围绕对象缓存进行的。在内核中，会为有限的对象集（例如文件描述符和其他常见结构）分配大量内存。Jeff 发现对内核中普通对象进行初始化所需的时间超过了对其进行分配和释放所需的时间。因此他的结论是不应该将内存释放回一个全局的内存池，而是将内存保持为针对特定目而初始化的状态。例如，如果内存被分配给了一个互斥锁，那么只需在为互斥锁首次分配内存时执行一次互斥锁初始化函数（mutex_init）即可。后续的内存分配不需要执行这个初始化函数，因为从上次释放和调用析构之后，它已经处于所需的状态中了。</p>

<p>Linux slab 分配器使用了这种思想和其他一些思想来构建一个在空间和时间上都具有高效性的内存分配器。</p>

<p>图 1 给出了 slab 结构的高层组织结构。在最高层是 cache_chain，这是一个 slab 缓存的链接列表。这对于 best-fit 算法非常有用，可以用来查找最适合所需要的分配大小的缓存（遍历列表）。cache_chain 的每个元素都是一个 kmem_cache 结构的引用（称为一个 cache）。它定义了一个要管理的给定大小的对象池。</p>

<p><img src="/images/kernel/2015-03-03-1.gif" alt="" /></p>

<p>每个缓存都包含了一个 slabs 列表，这是一段连续的内存块（通常都是页面）。存在 3 种 slab：</p>

<p>slabs_full<br/>
   完全分配的 slab <br/>
slabs_partial<br/>
   部分分配的 slab<br/>
slabs_empty<br/>
   空 slab，或者没有对象被分配</p>

<p>  注意 slabs_empty 列表中的 slab 是进行回收（reaping）的主要备选对象。正是通过此过程，slab 所使用的内存被返回给操作系统供其他用户使用。</p>

<p>  slab 列表中的每个 slab 都是一个连续的内存块（一个或多个连续页），它们被划分成一个个对象。这些对象是从特定缓存中进行分配和释放的基本元素。注意 slab 是 slab 分配器进行操作的最小分配单位，因此如果需要对 slab 进行扩展，这也就是所扩展的最小值。通常来说，每个 slab 被分配为多个对象。</p>

<p>  由于对象是从 slab 中进行分配和释放的，因此单个 slab 可以在 slab 列表之间进行移动。例如，当一个 slab 中的所有对象都被使用完时，就从 slabs_partial 列表中移动到 slabs_full 列表中。当一个 slab 完全被分配并且有对象被释放后，就从 slabs_full 列表中移动到 slabs_partial 列表中。当所有对象都被释放之后，就从 slabs_partial 列表移动到 slabs_empty 列表中。</p>

<h5>slab 背后的动机</h5>

<p>  与传统的内存管理模式相比， slab 缓存分配器提供了很多优点。首先，内核通常依赖于对小对象的分配，它们会在系统生命周期内进行无数次分配。slab 缓存分配器通过对类似大小的对象进行缓存而提供这种功能，从而避免了常见的碎片问题。slab 分配器还支持通用对象的初始化，从而避免了为同一目而对一个对象重复进行初始化。最后，slab 分配器还可以支持硬件缓存对齐和着色，这允许不同缓存中的对象占用相同的缓存行，从而提高缓存的利用率并获得更好的性能。</p>

<h4>API 函数</h4>

<p>现在来看一下能够创建新 slab 缓存、向缓存中增加内存、销毁缓存的应用程序接口（API）以及 slab 中对对象进行分配和释放操作的函数。</p>

<p>第一个步骤是创建 slab 缓存结构，您可以将其静态创建为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct struct kmem_cache *my_cachep;</span></code></pre></td></tr></table></div></figure>


<p>然后其他 slab 缓存函数将使用该引用进行创建、删除、分配等操作。kmem_cache 结构包含了每个中央处理器单元（CPU）的数据、一组可调整的（可以通过 proc 文件系统访问）参数、统计信息和管理 slab 缓存所必须的元素。</p>

<h5>kmem_cache_create</h5>

<p>内核函数 kmem_cache_create 用来创建一个新缓存。这通常是在内核初始化时执行的，或者在首次加载内核模块时执行。其原型定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct kmem_cache *
</span><span class='line'>kmem_cache_create( const char *name, size_t size, size_t align,
</span><span class='line'>&#9;&#9;&#9;unsigned long flags;
</span><span class='line'>&#9;&#9;&#9;void (*ctor)(void*, struct kmem_cache *, unsigned long),
</span><span class='line'>&#9;&#9;&#9;void (*dtor)(void*, struct kmem_cache *, unsigned long));</span></code></pre></td></tr></table></div></figure>


<p>name 参数定义了缓存名称，proc 文件系统（在 /proc/slabinfo 中）使用它标识这个缓存。 size 参数指定了为这个缓存创建的对象的大小， align 参数定义了每个对象必需的对齐。 flags 参数指定了为缓存启用的选项。这些标志如表 1 所示。</p>

<p>表 1. kmem_cache_create 的部分选项（在 flags 参数中指定）<br/>
选项                  说明<br/>
SLAB_RED_ZONE       在对象头、尾插入标志，用来支持对缓冲区溢出的检查。<br/>
SLAB_POISON         使用一种己知模式填充 slab，允许对缓存中的对象进行监视（对象属对象所有，不过可以在外部进行修改）。<br/>
SLAB_HWCACHE_ALIGN  指定缓存对象必须与硬件缓存行对齐。</p>

<p>ctor 和 dtor 参数定义了一个可选的对象构造器和析构器。构造器和析构器是用户提供的回调函数。当从缓存中分配新对象时，可以通过构造器进行初始化。</p>

<p>在创建缓存之后， kmem_cache_create 函数会返回对它的引用。注意这个函数并没有向缓存分配任何内存。相反，在试图从缓存（最初为空）分配对象时，refill 操作将内存分配给它。当所有对象都被使用掉时，也可以通过相同的操作向缓存添加内存。</p>

<h5>kmem_cache_destroy</h5>

<p>内核函数 kmem_cache_destroy 用来销毁缓存。这个调用是由内核模块在被卸载时执行的。在调用这个函数时，缓存必须为空。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void kmem_cache_destroy( struct kmem_cache *cachep );</span></code></pre></td></tr></table></div></figure>


<h5>kmem_cache_alloc</h5>

<p>要从一个命名的缓存中分配一个对象，可以使用 kmem_cache_alloc 函数。调用者提供了从中分配对象的缓存以及一组标志：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void kmem_cache_alloc( struct kmem_cache *cachep, gfp_t flags );</span></code></pre></td></tr></table></div></figure>


<p>这个函数从缓存中返回一个对象。注意如果缓存目前为空，那么这个函数就会调用 cache_alloc_refill 向缓存中增加内存。 kmem_cache_alloc 的 flags 选项与 kmalloc 的 flags 选项相同。表 2 给出了标志选项的部分列表。</p>

<p>表 2. kmem_cache_alloc 和 kmalloc 内核函数的标志选项<br/>
标志              说明<br/>
GFP_USER        为用户分配内存（这个调用可能会睡眠）。<br/>
GFP_KERNEL      从内核 RAM 中分配内存（这个调用可能会睡眠）。<br/>
GFP_ATOMIC      使该调用强制处于非睡眠状态（对中断处理程序非常有用）。<br/>
GFP_HIGHUSER    从高端内存中分配内存。</p>

<h5>kmem_cache_zalloc</h5>

<p>内核函数 kmem_cache_zalloc 与 kmem_cache_alloc 类似，只不过它对对象执行 memset 操作，用来在将对象返回调用者之前对其进行清除操作。</p>

<h5>kmem_cache_free</h5>

<p>要将一个对象释放回 slab，可以使用 kmem_cache_free。调用者提供了缓存引用和要释放的对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void kmem_cache_free( struct kmem_cache *cachep, void *objp );</span></code></pre></td></tr></table></div></figure>


<h5>kmalloc 和 kfree</h5>

<p>内核中最常用的内存管理函数是 kmalloc 和 kfree 函数。这两个函数的原型如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void *kmalloc( size_t size, int flags );
</span><span class='line'>void kfree( const void *objp );</span></code></pre></td></tr></table></div></figure>


<p>注意在 kmalloc 中，惟一两个参数是要分配的对象的大小和一组标志（请参看 表 2 中的部分列表）。但是 kmalloc 和 kfree 使用了类似于前面定义的函数的 slab 缓存。kmalloc 没有为要从中分配对象的某个 slab 缓存命名，而是循环遍历可用缓存来查找可以满足大小限制的缓存。找到之后，就（使用 <code>__kmem_cache_alloc</code>）分配一个对象。要使用 kfree 释放对象，从中分配对象的缓存可以通过调用 virt_to_cache 确定。这个函数会返回一个缓存引用，然后在 <code>__cache_free</code> 调用中使用该引用释放对象。</p>

<h5>其他函数</h5>

<p>slab 缓存 API 还提供了其他一些非常有用的函数。 kmem_cache_size 函数会返回这个缓存所管理的对象的大小。您也可以通过调用 kmem_cache_name 来检索给定缓存的名称（在创建缓存时定义）。缓存可以通过释放其中的空闲 slab 进行收缩。这可以通过调用 kmem_cache_shrink 实现。注意这个操作（称为回收）是由内核定期自动执行的（通过 kswapd）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned int kmem_cache_size( struct kmem_cache *cachep );
</span><span class='line'>const char *kmem_cache_name( struct kmem_cache *cachep );
</span><span class='line'>int kmem_cache_shrink( struct kmem_cache *cachep );</span></code></pre></td></tr></table></div></figure>


<h4>slab 缓存的示例用法</h4>

<p>下面的代码片断展示了创建新 slab 缓存、从缓存中分配和释放对象然后销毁缓存的过程。首先，必须要定义一个 kmem_cache 对象，然后对其进行初始化（请参看清单 1）。这个特定的缓存包含 32 字节的对象，并且是硬件缓存对齐的（由标志参数 SLAB_HWCACHE_ALIGN 定义）。<br/>
清单 1. 创建新 slab 缓存</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct kmem_cache *my_cachep;
</span><span class='line'>
</span><span class='line'>static void init_my_cache( void )
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>&#9;my_cachep = kmem_cache_create( 
</span><span class='line'>&#9;&#9;&#9;&#9;"my_cache",            /* Name */
</span><span class='line'>&#9;&#9;&#9;&#9;32,                    /* Object Size */
</span><span class='line'>&#9;&#9;&#9;&#9;0,                     /* Alignment */
</span><span class='line'>&#9;&#9;&#9;&#9;SLAB_HWCACHE_ALIGN,    /* Flags */
</span><span class='line'>&#9;&#9;&#9;&#9;NULL, NULL );          /* Constructor/Deconstructor */
</span><span class='line'>
</span><span class='line'>&#9;return;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>使用所分配的 slab 缓存，您现在可以从中分配一个对象了。清单 2 给出了一个从缓存中分配和释放对象的例子。它还展示了两个其他函数的用法。<br/>
清单 2. 分配和释放对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int slab_test( void )
</span><span class='line'>{
</span><span class='line'>&#9;void *object;
</span><span class='line'>
</span><span class='line'>&#9;printk( "Cache name is %s\n", kmem_cache_name( my_cachep ) );
</span><span class='line'>&#9;printk( "Cache object size is %d\n", kmem_cache_size( my_cachep ) );
</span><span class='line'>
</span><span class='line'>&#9;object = kmem_cache_alloc( my_cachep, GFP_KERNEL );
</span><span class='line'>&#9;if (object) {
</span><span class='line'>&#9;&#9;kmem_cache_free( my_cachep, object );
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后，清单 3 演示了 slab 缓存的销毁。调用者必须确保在执行销毁操作过程中，不要从缓存中分配对象。<br/>
清单 3. 销毁 slab 缓存</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void remove_my_cache( void )
</span><span class='line'>{
</span><span class='line'>&#9;if (my_cachep) kmem_cache_destroy( my_cachep );
</span><span class='line'>&#9;return;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>slab 的 proc 接口</h3>

<p>  proc 文件系统提供了一种简单的方法来监视系统中所有活动的 slab 缓存。这个文件称为 /proc/slabinfo，它除了提供一些可以从用户空间访问的可调整参数之外，还提供了有关所有 slab 缓存的详细信息。当前版本的 slabinfo 提供了一个标题，这样输出结果就更具可读性。对于系统中的每个 slab 缓存来说，这个文件提供了对象数量、活动对象数量以及对象大小的信息（除了每个 slab 的对象和页面之外）。另外还提供了一组可调整的参数和 slab 数据。</p>

<p>  要调优特定的 slab 缓存，可以简单地向 /proc/slabinfo 文件中以字符串的形式回转 slab 缓存名称和 3 个可调整的参数。下面的例子展示了如何增加 limit 和 batchcount 的值，而保留 shared factor 不变（格式为 “cache name limit batchcount shared factor”）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># echo "my_cache 128 64 8" &gt; /proc/slabinfo</span></code></pre></td></tr></table></div></figure>


<p>limit 字段表示每个 CPU 可以缓存的对象的最大数量。 batchcount 字段是当缓存为空时转换到每个 CPU 缓存中全局缓存对象的最大数量。 shared 参数说明了对称多处理器（Symmetric MultiProcessing，SMP）系统的共享行为。</p>

<p>注意您必须具有超级用户的特权才能在 proc 文件系统中为 slab 缓存调优参数。</p>

<h4>SLOB 分配器</h4>

<p>对于小型的嵌入式系统来说，存在一个 slab 模拟层，名为 SLOB。这个 slab 的替代品在小型嵌入式 Linux 系统中具有优势，但是即使它保存了 512KB 内存，依然存在碎片和难于扩展的问题。在禁用 CONFIG_SLAB 时，内核会回到这个 SLOB 分配器中。更多信息请参看 参考资料 一节。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/02/11/kernel-base-param/">Linux 内核引导参数简介</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-02-11T15:16:00+08:00'><span class='date'>2015-02-11</span> <span class='time'>15:16:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>概述</h3>

<p>  内核引导参数大体上可以分为两类：一类与设备无关、另一类与设备有关。与设备有关的引导参数多如牛毛，需要你自己阅读内核中的相应驱动程序源码以获取其能够接受的引导参数。比如，如果你想知道可以向 AHA1542 SCSI 驱动程序传递哪些引导参数，那么就查看 drivers/scsi/aha1542.c 文件，一般在前面 100 行注释里就可以找到所接受的引导参数说明。大多数参数是通过"__setup(&hellip; , &hellip;)&ldquo;函数设置的，少部分是通过"early_param(&hellip; , &hellip;)"函数设置的，逗号前的部分就是引导参数的名称，后面的部分就是处理这些参数的函数名。</p>

<p>[提示]你可以在源码树的根目录下试一试下面两个命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grep -r '\b__setup *(' *
</span><span class='line'>grep -r '\bearly_param *(' *</span></code></pre></td></tr></table></div></figure>


<p>格式上，多个参数之间用空格分割，参数值是一个逗号分割的列表，并且参数值中不能包含空白。</p>

<p>正确：ether=9,0x300,0xd0000,0xd4000,eth0  root=/dev/sda2<br/>
错误：ether = 9, 0x300, 0xd0000, 0xd4000, eth0  root = /dev/sda2</p>

<p>注意，所有引导参数都是大小写敏感的！</p>

<p>在内核运行起来之后，可以通过 cat /proc/cmdline 命令查看当初使用的引导参数以及相应的值。</p>

<h3>内核模块</h3>

<p>对于模块而言，引导参数只能用于直接编译到核心中的模块，格式是"模块名.参数=值"，比如"usbcore.blinkenlights=1"。动态加载的模块则可以在 modprobe 命令行上指定相应的参数值，比如"modprobe usbcore blinkenlights=1"。</p>

<p>可以使用"modinfo -p ${modulename}&ldquo;命令显示可加载模块的所有可用参数。已经加载到内核中的模块会在 /sys/module/${modulename}/parameters/ 中显示出其参数，并且某些参数的值还可以在运行时通过"echo -n ${value} > /sys/module/${modulename}/parameters/${parm}"进行修改。</p>

<h3>内核如何处理引导参数</h3>

<p>绝大部分的内核引导参数的格式如下(每个参数的值列表中最多只能有十项)：</p>

<p>name[=value_1][,value_2]&hellip;[,value_10]</p>

<p>如果"name"不能被识别并且满足"name=value"的格式，那么将被解译为一个环境变量(比如"TERM=linux"或"BOOT_IMAGE=vmlinuz.bak")，否则将被原封不动的传递给 init 程序(比如"single")。</p>

<p>内核可以接受的参数个数没有限制，但是整个命令行的总长度(参数/值/空格全部包含在内)却是有限制的，定义在 include/asm/setup.h 中的 COMMAND_LINE_SIZE 宏中(对于X86_64而言是2048)。</p>

<h3>内核引导参数精选</h3>

<p>由于引导参数多如牛毛，本文不可能涉及全部，因此本文只基于 X86_64 平台以及 Linux-3.13.2 精选了一些与设备无关的引导参数以及少部分与设备有关的引导参数，过时的参数、非x86平台参数、与设备有关的参数，基本上都被忽略了。</p>

<p>[提示]内核源码树下的 Documentation/kernel-parameters.txt 和 Documentation/x86/x86_64/boot-options.txt 文件列出了所有可用的引导参数，并作了简要说明。</p>

<h4>标记说明</h4>

<p>并不是所有的参数都是永远可用的，只有在特定的模块存在并且相应的硬件也存在的情况下才可用。引导参数上面的方括号说明了其依赖关系，其中使用的标记解释如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ACPI     开启了高级配置与电源接口(CONFIG_ACPI)支持
</span><span class='line'>AGP      开启了AGP(CONFIG_AGP)支持
</span><span class='line'>APIC     开启了高级可编程中断控制器支持(2000年以后的CPU都支持)
</span><span class='line'>APPARMOR 开启了AppArmor(CONFIG_SECURITY_APPARMOR)支持
</span><span class='line'>DRM      开启了Direct Rendering Manager(CONFIG_DRM)支持
</span><span class='line'>EFI      开启了EFI分区(CONFIG_EFI_PARTITION)支持
</span><span class='line'>EVM      开启了Extended Verification Module(CONFIG_EVM)支持
</span><span class='line'>FB       开启了帧缓冲设备(CONFIG_FB)支持
</span><span class='line'>HIBERNATION  开启了"休眠到硬盘"(CONFIG_HIBERNATION)支持
</span><span class='line'>HPET_MMAP    允许对HPET寄存器进行映射(CONFIG_HPET_MMAP)
</span><span class='line'>HW       存在相应的硬件设备
</span><span class='line'>IOMMU    开启了IOMMU(CONFIG_IOMMU_SUPPORT)支持
</span><span class='line'>IOSCHED  开启了多个不同的I/O调度程序(CONFIG_IOSCHED_*)
</span><span class='line'>IPV6     开启了IPv6(CONFIG_IPV6)支持
</span><span class='line'>IP_PNP   开启了自动获取IP的协议(DHCP,BOOTP,RARP)支持
</span><span class='line'>IP_VS_FTP    开启了IPVS FTP协议连接追踪(CONFIG_IP_VS_FTP)支持
</span><span class='line'>KVM      开启了KVM(CONFIG_KVM_*)支持
</span><span class='line'>LIBATA   开启了libata(CONFIG_ATA)驱动支持
</span><span class='line'>LOOP     开启了回环设备(CONFIG_BLK_DEV_LOOP)支持
</span><span class='line'>MCE      开启了Machine Check Exception(CONFIG_X86_MCE)支持
</span><span class='line'>MOUSE    开启了鼠标(CONFIG_INPUT_MOUSEDEV)支持
</span><span class='line'>MSI      开启了PCI MSI(CONFIG_PCI_MSI)支持
</span><span class='line'>NET      开启了网络支持
</span><span class='line'>NETFILTER    开启了Netfilter(CONFIG_NETFILTER)支持
</span><span class='line'>NFS      开启了NFS(网络文件系统)支持
</span><span class='line'>NUMA     开启了NUMA(CONFIG_NUMA)支持
</span><span class='line'>PCI      开启了PCI总线(CONFIG_PCI)支持
</span><span class='line'>PCIE     开启了PCI-Express(CONFIG_PCIEPORTBUS)支持
</span><span class='line'>PNP      开启了即插即用(CONFIG_PNP)支持
</span><span class='line'>PV_OPS   内核本身是半虚拟化的(paravirtualized)
</span><span class='line'>RAID     开去了软RAID(CONFIG_BLK_DEV_MD)支持
</span><span class='line'>SECURITY 开启了多个不同的安全模型(CONFIG_SECURITY)
</span><span class='line'>SELINUX  开启了SELinux(CONFIG_SECURITY_SELINUX)支持
</span><span class='line'>SLUB     开启了SLUB内存分配管理器(CONFIG_SLUB)
</span><span class='line'>SMP      开启了对称多处理器(CONFIG_SMP)支持
</span><span class='line'>TPM      开启了可信赖平台模块(CONFIG_TCG_TPM)支持
</span><span class='line'>UMS      开启了USB大容量存储设备(CONFIG_USB_STORAGE)支持
</span><span class='line'>USB      开启了USB(CONFIG_USB_SUPPORT)支持
</span><span class='line'>USBHID   开启了USB HID(CONFIG_USB_HID)支持
</span><span class='line'>VMMIO    开启了使用内存映射机制的virtio设备驱动(CONFIG_VIRTIO_MMIO)
</span><span class='line'>VT       开启了虚拟终端(CONFIG_VT)支持</span></code></pre></td></tr></table></div></figure>


<p>此外，下面的标记在含义上与上面的有所不同：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>BUGS    用于解决某些特定硬件的缺陷
</span><span class='line'>KNL     是一个内核启动参数
</span><span class='line'>BOOT    是一个引导程序参数</span></code></pre></td></tr></table></div></figure>


<p>标记为"BOOT"的参数实际上由引导程序(例如GRUB)使用，对内核本身没有直接的意义。如果没有特别的需求，请不要修改此类参数的语法，更多信息请阅读 Documentation/x86/boot.txt 文档。</p>

<p>说明：下文中的 [KMG] 后缀表示 210, 220, 230 的含义。</p>

<h3>控制台与终端</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[KNL]
</span><span class='line'>console=设备及选项
</span><span class='line'>&#9;设置输出控制台使用的设备及选项。例如：ttyN 表示使用第N个虚拟控制台。其它用法主要针对嵌入式环境(Documentation/serial-console.txt)。
</span><span class='line'>[KNL]
</span><span class='line'>consoleblank=秒数
</span><span class='line'>&#9;控制台多长时间无操作后黑屏，默认值是600秒，设为0表示禁止黑屏。
</span><span class='line'>[HW]
</span><span class='line'>no_console_suspend
</span><span class='line'>&#9;永远也不要将控制台进入休眠状态。因为当控制台进入休眠之后，所有内核的消息就都看不见了(包括串口与VGA)。开启此参数有助于调试系统在休眠/唤醒中发生的故障。
</span><span class='line'>[VT]
</span><span class='line'>vt.default_utf8={0|1}
</span><span class='line'>&#9;是否将所有TTY都默认设置为UTF-8模式。默认值"1"表示将所有新打开的终端都设置为UTF-8模式。</span></code></pre></td></tr></table></div></figure>


<h3>日志与调试</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>earlyprintk=设备[,keep]
</span><span class='line'>&#9;使用哪个设备显示早期的引导信息，主要用于调试硬件故障。此选项默认并未开启，因为在某些情况下并不能正常工作。
</span><span class='line'>&#9;在传统的控制台初始化之前，在哪个设备上显示内核日志信息。不使用此参数，那么你将永远没机会看见这些信息。
</span><span class='line'>&#9;在尾部加上",keep"选项表示在真正的内核控制台初始化并接管系统后，不会抹掉本选项消息的显示。
</span><span class='line'>&#9;earlyprintk=vga 表示在VGA上显示内核日志信息，这是最常用的选项，但不能用于EFI环境。
</span><span class='line'>&#9;earlyprintk=efi v3.13新增，表示将错误日志写入EFI framebuffer，专用于EFI环境。
</span><span class='line'>&#9;earlyprintk=xen 仅可用于XEN的半虚拟化客户机。
</span><span class='line'>loglevel={0|1|2|3|4|5|6|7}
</span><span class='line'>&#9;设置内核日志的级别，所有小于该数字的内核信息(具有更高优先级的信息)都将在控制台上显示出来。这个级别可以使用 klogd 程序或者修改 /proc/sys/kernel/printk 文件进行调整。取值范围是"0"(不显示任何信息)到"7"(显示所有级别的信息)。建议至少设为"4"(WARNING)。[提示]级别"7"要求编译时加入了调试支持。
</span><span class='line'>[KNL]
</span><span class='line'>ignore_loglevel
</span><span class='line'>&#9;忽略内核日志等级的设置，向控制台输出所有内核消息。仅用于调试目的。
</span><span class='line'>[KNL]
</span><span class='line'>debug
</span><span class='line'>&#9;将引导过程中的所有调试信息都显示在控制台上。相当于设置"loglevel=7"(DEBUG)。
</span><span class='line'>[KNL]
</span><span class='line'>quiet
</span><span class='line'>&#9;静默模式。相当于设置"loglevel=4"(WARNING)。
</span><span class='line'>log_buf_len=n[KMG]
</span><span class='line'>&#9;内核日志缓冲区的大小。"n"必须是2的整数倍(否则会被自动上调到最接近的2的整数倍)。该值也可以通过内核配置选项CONFIG_LOG_BUF_SHIFT来设置。
</span><span class='line'>[KNL]
</span><span class='line'>initcall_debug
</span><span class='line'>&#9;跟踪所有内核初始化过程中调用的函数。有助于诊断内核在启动过程中死在了那个函数上面。
</span><span class='line'>kstack=N
</span><span class='line'>&#9;在内核异常(oops)时，应该打印出内核栈中多少个字(word)到异常转储中。仅供调试使用。
</span><span class='line'>[KNL]
</span><span class='line'>kmemleak={on|off}
</span><span class='line'>&#9;是否开启检测内核内存泄漏的功能(CONFIG_DEBUG_KMEMLEAK)，默认为"on"，仅供调试使用。
</span><span class='line'>&#9;检测方法类似于跟踪内存收集器，一个内核线程每10分钟(默认值)扫描内存，并打印发现新的未引用的对象的数量。
</span><span class='line'>[KNL]
</span><span class='line'>memtest=整数
</span><span class='line'>&#9;设置内存测试(CONFIG_MEMTEST)的轮数。"0"表示禁止测试。仅在你确实知道这是什么东西并且确实需要的时候再开启。
</span><span class='line'>norandmaps
</span><span class='line'>&#9;默认情况下，内核会随机化程序的启动地址，也就是每一次分配给程序的虚拟地址空间都不一样，主要目的是为了防止缓冲区溢出攻击。但是这也给程序调试增加了麻烦，此参数(相当于"echo 0 &gt; /proc/sys/kernel/randomize_va_space")的目的就是禁用该功能以方便调试。
</span><span class='line'>[PNP]
</span><span class='line'>pnp.debug=1
</span><span class='line'>&#9;开启PNP调试信息(需要内核已开启CONFIG_PNP_DEBUG_MESSAGES选项)，仅用于调试目的。也可在运行时通过 /sys/module/pnp/parameters/debug 来控制。
</span><span class='line'>show_msr=CPU数
</span><span class='line'>&#9;显示启动时由BIOS初始化的MSR(Model-Specific Register)寄存器设置。CPU数设为"1"表示仅显示"boot CPU"的设置。
</span><span class='line'>printk.time={0|1}
</span><span class='line'>&#9;是否在每一行printk输出前都加上时间戳，仅供调试使用。默认值是"0"(不添加)
</span><span class='line'>boot_delay=毫秒数
</span><span class='line'>&#9;在启动过程中，为每一个printk动作延迟指定的毫秒数，取值范围是[0-10000](最大10秒)，超出这个范围将等价于"0"(无延迟)。仅用于调试目的。
</span><span class='line'>pause_on_oops=秒数
</span><span class='line'>&#9;当内核发生异常时，挂起所有CPU的时间。当异常信息太多，屏幕持续滚动时，这个选项就很有用处了。主要用于调试目的。</span></code></pre></td></tr></table></div></figure>


<h3>异常检测与处理</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[MCE]
</span><span class='line'>mce=off
</span><span class='line'>&#9;彻底禁用MCE(CONFIG_X86_MCE)
</span><span class='line'>[MCE]
</span><span class='line'>mce=dont_log_ce
</span><span class='line'>&#9;不为已纠正错误(corrected error)记录日志。
</span><span class='line'>[MCE]
</span><span class='line'>mce=容错级别[,超时]
</span><span class='line'>&#9;容错级别(还可通过sysfs设置)：
</span><span class='line'>&#9;0 在出现未能纠正的错误时panic，记录所有已纠正的错误
</span><span class='line'>&#9;1(默认值) 在出现未能纠正的错误时panic或SIGBUS，记录所有已纠正的错误
</span><span class='line'>&#9;2 在出现未能纠正的错误时SIGBUS或记录日志，记录所有已纠正的错误
</span><span class='line'>&#9;3 从不panic或SIGBUS，记录所有日志。仅用于调试目的。
</span><span class='line'>&#9;超时(单位是微秒[百万分之一秒])：在machine check时等待其它CPU的时长，"0"表示不等待。
</span><span class='line'>[ACPI]
</span><span class='line'>erst_disable
</span><span class='line'>&#9;禁用ERST(Error Record Serialization Table)支持。主要用于解决某些有缺陷的BIOS导致的ERST故障。
</span><span class='line'>[ACPI]
</span><span class='line'>hest_disable
</span><span class='line'>&#9;禁用HEST(Hardware Error Source Table)支持。主要用于解决某些有缺陷的BIOS导致的HEST故障。
</span><span class='line'>[KNL]
</span><span class='line'>nosoftlockup
</span><span class='line'>&#9;禁止内核进行软死锁检测
</span><span class='line'>[KNL]
</span><span class='line'>softlockup_panic={0|1}
</span><span class='line'>&#9;是否在检测到软死锁(soft-lockup)的时候让内核panic，其默认值由 CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE 确定
</span><span class='line'>[KNL]
</span><span class='line'>nowatchdog
</span><span class='line'>&#9;禁止硬死锁检测(NMI watchdog)
</span><span class='line'>[KNL,BUGS]
</span><span class='line'>nmi_watchdog={0|panic|nopanic}
</span><span class='line'>&#9;配置nmi_watchdog(不可屏蔽中断看门狗)。更多信息可查看"lockup-watchdogs.txt"文档。
</span><span class='line'>&#9;0 表示关闭看门狗；
</span><span class='line'>&#9;panic 表示出现看门狗超时(长时间没喂狗)的时候触发内核错误，通常和"panic="配合使用，以实现在系统出现锁死的时候自动重启。
</span><span class='line'>&#9;nopanic 正好相反，表示即使出现看门狗超时(长时间没喂狗)，也不触发内核错误。
</span><span class='line'>unknown_nmi_panic
</span><span class='line'>&#9;在收到未知的NMI(不可屏蔽中断)时直接panic
</span><span class='line'>oops=panic
</span><span class='line'>&#9;在内核oops时直接panic(而默认是仅仅杀死oops进程[这样做会有很小的概率导致死锁])，而且这同样也会导致在发生MCE(CONFIG_X86_MCE)时直接panic。主要目的是和"panic="参数连用以实现自动重启。
</span><span class='line'>[KNL]
</span><span class='line'>panic=秒数
</span><span class='line'>&#9;内核在遇到panic时等待重启的行为：
</span><span class='line'>&#9;秒数&gt;0 等待指定的秒数后重启
</span><span class='line'>&#9;秒数=0(默认值) 只是简单的挂起，而永不重启
</span><span class='line'>&#9;秒数&lt;0 立即重启</span></code></pre></td></tr></table></div></figure>


<h3>时钟(Timer)</h3>

<p>时钟(Timer)的功能有两个：(1)定时触发中断；(2)维护和读取当前时间。</p>

<p>x86_64平台常见的时钟硬件有以下这些：<br/>
RTC(Real Time Clock) 实时时钟的独特之处在于，RTC是主板上一块电池供电的CMOS芯片(精度一般只到秒级)，RTC(Clock)吐出来的是"时刻"(例如"2014-2-22 23:38:44")，而其他硬件时钟(Timer)吐出来的是"时长"(我走过了XX个周期，按照我的频率，应该是10秒钟)。<br/>
PIT(Programmable Interval Timer) PIT是最古老的时钟源，产生周期性的时钟中断(IRQ0)，精度在100-1000Hz，现在基本已经被HPET取代。<br/>
APIC Timer 这是PIT针对多CPU环境的升级，每个CPU上都有一个APIC Timer(而PIT则是所有CPU共享的)，但是它经常有BUG且精度也不高(3MHz左右)，所实际很少使用。<br/>
ACPI Timer(Power Management Timer) 它唯一的功能就是为每个时钟周期提供一个时间戳，用于提供与处理器速度无关的可靠时间戳。但其精度并不高(3.579545MHz)。<br/>
HPET(High Precision Event Timer) HPET提供了更高的精度(14.31818MHz)以及更宽的计数器(64位)。HPET可以替代前述除RTC之外的所有时钟硬件(Timer)，因为它既能定时触发中断，又能维护和读取当前时间。一个HPET包含了一个固定频率的数值递增的计数器以及3-32个独立计数器，每个计数器又包含了一个比较器和一个寄存器，当两者数值相等时就会触发中断。HPET的出现将允许删除芯片组中的一些冗余的旧式硬件。2006年之后的主板基本都已支持HPET。<br/>
TSC(Time Stamp Counter) TSC是位于CPU里面的一个64位寄存器，与传统的周期性时钟不同，TSC并不触发中断，它是以计数器形式存在的单步递增性时钟。也就是说，周期性时钟是通过周期性触发中断达到计时目的，如心跳一般。而单步递增时钟则不发送中断，取而代之的是由软件自己在需要的时候去主动读取TSC寄存器的值来获得时间。TSC的精度(纳秒级)远超HPET并且速度更快，但仅能在较新的CPU(Sandy Bridge之后)上使用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[HW,ACPI]
</span><span class='line'>acpi_skip_timer_override
</span><span class='line'>&#9;用于解决某些有缺陷的Nvidia nForce2 BIOS中的计时器覆盖问题(例如开启ACPI后频繁死机或时钟故障)。
</span><span class='line'>[HW,ACPI]
</span><span class='line'>acpi_use_timer_override
</span><span class='line'>&#9;用于解决某些有缺陷的Nvidia nForce5 BIOS中的计时器覆盖问题(例如开启ACPI后频繁死机或时钟故障)。
</span><span class='line'>[APIC]
</span><span class='line'>no_timer_check
</span><span class='line'>&#9;禁止运行内核中时钟IRQ源缺陷检测代码。主要用于解决某些AMD平台的CPU占用过高以及时钟过快的故障。
</span><span class='line'>pmtmr=十六进制端口号
</span><span class='line'>&#9;手动指定pmtimer(CONFIG_X86_PM_TIMER)的I/O端口(16进制值)，例如：pmtmr=0x508
</span><span class='line'>acpi_pm_good
</span><span class='line'>&#9;跳过pmtimer(CONFIG_X86_PM_TIMER)的bug检测，强制内核认为这台机器的pmtimer没有毛病。用于解决某些有缺陷的BIOS导致的故障。
</span><span class='line'>[APIC]
</span><span class='line'>apicpmtimer
</span><span class='line'>&#9;使用pmtimer(CONFIG_X86_PM_TIMER)来校准APIC timer。此参数隐含了"apicmaintimer"。用于PIT timer彻底坏掉的场合。
</span><span class='line'>[APIC]
</span><span class='line'>apicmaintimer
</span><span class='line'>noapicmaintimer
</span><span class='line'>&#9;apicmaintimer 将APIC timer用于计时(而不是PIT/HPET中断)。这主要用于PIT/HPET中断不可靠的场合。
</span><span class='line'>&#9;noapicmaintimer 不将APIC timer用于计时(而是使用PIT/HPET中断)。这是默认值。但有时候依然需要明确指定。
</span><span class='line'>[APIC]
</span><span class='line'>lapic_timer_c2_ok
</span><span class='line'>&#9;按照ACPI规范的要求，local APIC Timer 不能在C2休眠状态下关闭，但可以在C3休眠状态下关闭。但某些BIOS(主要是AMD平台)会在向操作系统报告CPU进入C2休眠状态时，实际进入C3休眠状态。因此，内核默认采取了保守的假定：认为 local APIC Timer 在C2/C3状态时皆处于关闭状态。如果你确定你的BIOS没有这个问题，那么可以使用此参数明确告诉内核，即使CPU在C2休眠状态，local APIC Timer 也依然可用。
</span><span class='line'>[APIC]
</span><span class='line'>noapictimer
</span><span class='line'>&#9;禁用CPU Local APIC Timer
</span><span class='line'>enable_timer_pin_1
</span><span class='line'>disable_timer_pin_1
</span><span class='line'>&#9;开启/关闭APIC定时器的PIN1，内核将尽可能自动探测正确的值。但有时需要手动指定以解决某些有缺陷的ATI芯片组故障。
</span><span class='line'>clocksource={jiffies|acpi_pm|hpet|tsc}
</span><span class='line'>&#9;强制使用指定的时钟源，以代替内核默认的时钟源。
</span><span class='line'>&#9;jiffies 最差的时钟源，只能作为最后的选择。
</span><span class='line'>&#9;acpi_pm [ACPI]符合ACPI规范的主板都提供的硬件时钟源(CONFIG_X86_PM_TIMER)，提供3.579545MHz固定频率，这是传统的硬件时钟发生器。
</span><span class='line'>&#9;hpet 一种取代传统"acpi_pm"的高精度硬件时钟源(CONFIG_HPET)，提供14.31818MHz固定频率。2007年以后的芯片组一般都支持。
</span><span class='line'>&#9;tsc TSC(Time Stamp Counter)的主体是位于CPU里面的一个64位TSC寄存器，与传统的以中断形式存在的周期性时钟不同，TSC是以计数器形式存在的单步递增性时钟，两者的区别在于，周期性时钟是通过周期性触发中断达到计时目的，如心跳一般。而单步递增时钟则不发送中断，取而代之的是由软件自己在需要的时候去主动读取TSC寄存器的值来获得时间。TSC的精度更高并且速度更快，但仅能在较新的CPU(Sandy Bridge之后)上使用。
</span><span class='line'>[KNL]
</span><span class='line'>highres={"on"|"off"}
</span><span class='line'>&#9;启用(默认值)还是禁用高精度定时器模式。主要用于关闭主板上有故障的高精度时钟源。
</span><span class='line'>nohpet
</span><span class='line'>&#9;禁用HPET timer(CONFIG_HPET)
</span><span class='line'>[HPET_MMAP]
</span><span class='line'>hpet_mmap
</span><span class='line'>&#9;v3.13新增，默认允许对HPET寄存器进行映射，相当于开启了内核CONFIG_HPET_MMAP_DEFAULT选项。需要注意的是，某些包含HPET硬件寄存器的页中同时还含有其他不该暴露给用户的信息。
</span><span class='line'>notsc
</span><span class='line'>tsc=reliable
</span><span class='line'>tsc=noirqtime
</span><span class='line'>&#9;设置TSC时钟源的属性。
</span><span class='line'>&#9;notsc 表示不将TSC用作"wall time"时钟源，主要用于不能在多个CPU之间保持正确同步的SMP系统。
</span><span class='line'>&#9;tsc=reliable 表示TSC时钟源是绝对稳定的，关闭启动时和运行时的稳定性检查。用于在某些老旧硬件/虚拟化环境使用TSC时钟源。
</span><span class='line'>&#9;tsc=noirqtime 不将TSC用于统计进程IRQ时间。主要用于在RDTSC速度较慢的CPU上禁止内核的CONFIG_IRQ_TIME_ACCOUNTING功能。
</span><span class='line'>&#9;关于"TSC时钟源"，详见"clocksource="参数的说明。</span></code></pre></td></tr></table></div></figure>


<h3>中断</h3>

<p>常见的中断控制器有两种：传统的8259A和新式的APIC，前者也被称为"PIC"。8259A只适合单CPU的场合，而APIC则能够把中断传递给系统中的每个CPU，从而充分挖掘SMP体系结构的并行性。所以8259A已经被淘汰了。APIC系统由3部分组成：APIC总线(前端总线)、IO-APIC(南桥)、本地APIC(CPU)。每个CPU中集成了一个本地APIC，负责传递中断信号到处理器。而IO-APIC是系统芯片组中一部分，负责收集来自I/O设备的中断信号并发送到本地APIC。APIC总线则是连接IO-APIC和各个本地APIC的桥梁。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[SMP,APIC]
</span><span class='line'>noapic
</span><span class='line'>&#9;禁止使用IO-APIC(输入输出高级可编程输入控制器)，主要用于解决某些有缺陷的BIOS导致的APIC故障。
</span><span class='line'>[APIC]
</span><span class='line'>nolapic
</span><span class='line'>disableapic
</span><span class='line'>&#9;禁止使用local APIC。主要用于解决某些有缺陷的BIOS导致的APIC故障。"nolapic"是为了保持传统习惯的兼容写法，与"disableapic"的含义相同。
</span><span class='line'>[APIC]
</span><span class='line'>nox2apic
</span><span class='line'>&#9;关闭x2APIC支持(CONFIG_X86_X2APIC)
</span><span class='line'>[APIC]
</span><span class='line'>x2apic_phys
</span><span class='line'>&#9;在支持x2apic的平台上使用physical模式代替默认的cluster模式。
</span><span class='line'>[KNL]
</span><span class='line'>threadirqs
</span><span class='line'>&#9;强制线程化所有的中断处理器(明确标记为IRQF_NO_THREAD的除外)
</span><span class='line'>[SMP,APIC]
</span><span class='line'>pirq=
</span><span class='line'>&#9;手动指定mp-table的设置。此参数仅对某些有缺陷的、具备多个IO-APIC的高端主板有意义。详见Documentation/x86/i386/IO-APIC.txt文档
</span><span class='line'>[HW]
</span><span class='line'>irqfixup
</span><span class='line'>&#9;用于修复简单的中断问题：当一个中断没有被处理时搜索所有可用的中断处理器。用于解决某些简单的固件缺陷。
</span><span class='line'>[HW]
</span><span class='line'>irqpoll
</span><span class='line'>&#9;用于修复高级的中断问题：当一个中断没有被处理时搜索所有可用的中断处理器，并且对每个时钟中断都进行搜索。用于解决某些严重的固件缺陷。</span></code></pre></td></tr></table></div></figure>


<h3>ACPI</h3>

<p>高级配置与电源管理接口(Advanced Configuration and Power Interface)是提供操作系统与应用程序管理所有电源管理接口，包括了各种软件和硬件方面的规范。2004年推出3.0规范；2009年推出4.0规范；2011年推出5.0规范。2013年之后新的ACPI规格将由UEFI论坛制定。ACPI可以实现的功能包括：电源管理；性能管理；配置与即插即用；系统事件；温度管理；电池管理；SMBus控制器；嵌入式控制器。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[HW,ACPI]
</span><span class='line'>acpi={force|off|noirq|strict|rsdt|nocmcff|copy_dsdt}
</span><span class='line'>&#9;ACPI的总开关。
</span><span class='line'>&#9;force 表示强制启用ACPI(即使BIOS中已关闭)；
</span><span class='line'>&#9;off 表示强制禁用ACPI(即使BIOS中已开启)；
</span><span class='line'>&#9;noirq 表示不要将ACPI用于IRQ路由；
</span><span class='line'>&#9;strict 表示严格要求系统遵循ACPI规格(降低兼容性)；
</span><span class='line'>&#9;rsdt 表示使用老旧的RSDT(Root System Description Table)代替较新的XSDT(Extended System Description Table)；
</span><span class='line'>&#9;copy_dsdt 表示将DSDT(Differentiated System Description Table)复制到内存中。
</span><span class='line'>&#9;更多信息可参考Documentation/power/runtime_pm.txt以及"pci=noacpi"。
</span><span class='line'>[HW,ACPI]
</span><span class='line'>acpi_backlight={vendor|video}
</span><span class='line'>&#9;选择屏幕背光亮度调节驱动。
</span><span class='line'>&#9;video(默认值)表示使用通用的ACPI video.ko驱动(CONFIG_ACPI_VIDEO)，该驱动仅可用于集成显卡。
</span><span class='line'>&#9;vendor表示使用厂商特定的ACPI驱动(thinkpad_acpi,sony_acpi等)。
</span><span class='line'>&#9;详见Documentation/acpi/video_extension.txt文档。
</span><span class='line'>[HW,ACPI]
</span><span class='line'>acpi_os_name="字符串"
</span><span class='line'>&#9;告诉ACPI BIOS操作系统的名称。
</span><span class='line'>&#9;常用于哄骗有缺陷的BIOS，让其以为运行的是Windows系统而不是Linux系统。
</span><span class='line'>&#9;"Linux" = Linux
</span><span class='line'>&#9;"Microsoft Windows" = Windows 98
</span><span class='line'>&#9;"Windows 2000" = Windows 2000
</span><span class='line'>&#9;"Windows 2001" = Windows XP
</span><span class='line'>&#9;"Windows 2001 SP2" = Windows XP SP2
</span><span class='line'>&#9;"Windows 2001.1" = Windows Server 2003
</span><span class='line'>&#9;"Windows 2001.1 SP1" = Windows Server 2003 SP1
</span><span class='line'>&#9;"Windows 2006" = Windows Vista
</span><span class='line'>&#9;"Windows 2006 SP1" = Windows Vista SP1
</span><span class='line'>&#9;"Windows 2006.1" = Windows Server 2008
</span><span class='line'>&#9;"Windows 2009" = Windows 7 / Windows Server 2008 R2
</span><span class='line'>&#9;"Windows 2012" = Windows 8 / Windows Server 2012
</span><span class='line'>&#9;"Windows 2013" = Windows 8.1 / Windows Server 2012 R2
</span><span class='line'>[HW,ACPI]
</span><span class='line'>acpi_osi="字符串"
</span><span class='line'>&#9;对于较新的内核(Linux-2.6.23之后)而言，当BIOS询问内核："你是Linux吗?"，内核都会回答"No"，但历史上(Linux-2.6.22及更早版本)内核会如实回答"Yes"，结果造成很多BIOS兼容性问题(主要是电源管理方面)。具体故事的细节请到内核源码文件drivers/acpi/osl.c中搜索"The story of _OSI(Linux)"注释。
</span><span class='line'>&#9;此参数用于修改内核中的操作系统接口字符串(_OSI string)列表默认值，这样当BIOS向内核询问："你是xxx吗?"的时候，内核就可以根据修改后的列表中是否存在"xxx"回答"Yes"或"No"了，主要用于解决BIOS兼容性问题导致的故障(例如屏幕亮度调整)。
</span><span class='line'>&#9;acpi_osi="Linux"表示添加"Linux"；
</span><span class='line'>&#9;acpi_osi="!Linux"表示删除"Linux"；
</span><span class='line'>&#9;acpi_osi=!* 表示删除所有字符串(v3.13新增)，可以和多个acpi_osi="Linux"格式联合使用；
</span><span class='line'>&#9;acpi_osi=! 表示删除所有内置的字符串(v3.13新增)，可以和多个acpi_osi="Linux"格式联合使用；
</span><span class='line'>&#9;acpi_osi= 表示禁用所有字符串，仅可单独使用(不能联合使用)。
</span><span class='line'>[HW,ACPI]
</span><span class='line'>acpi_serialize
</span><span class='line'>&#9;强制内核以串行方式执行AML(ACPI Machine Language)字节码。用于解决某些有缺陷的BIOS导致的故障。
</span><span class='line'>[ACPI]
</span><span class='line'>acpi_enforce_resources={strict|lax|no}
</span><span class='line'>&#9;检查驱动程序和ACPI操作区域(SystemIO,SystemMemory)之间资源冲突的方式。
</span><span class='line'>&#9;strict(默认值)禁止任何驱动程序访问已被ACPI声明为"受保护"的操作区域，这是最安全的方式，可以从根本上避免冲突。
</span><span class='line'>&#9;lax允许驱动程序访问已被ACPI声明的保护区域(但会显示一个警告)。这可能会造成冲突，但是可以兼容某些老旧且脑残的驱动程序(例如某些硬件监控驱动)。
</span><span class='line'>&#9;no表示根本不声明任何ACPI保护区域，也就是完全允许任意驱动程序访问ACPI操作区域。
</span><span class='line'>[ACPI]
</span><span class='line'>pnpacpi=off
</span><span class='line'>&#9;禁用ACPI的即插即用功能，转而使用古董的PNPBIOS来代替。</span></code></pre></td></tr></table></div></figure>


<h3>休眠与唤醒</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[HW,ACPI]
</span><span class='line'>acpi_sleep={s3_bios,s3_mode,s3_beep,s4_nohwsig,old_ordering,nonvs,sci_force_enable}
</span><span class='line'>&#9;ACPI休眠选项。
</span><span class='line'>&#9;(1)s3_bios和s3_mode与显卡有关。计算机从S3状态(挂起到内存)恢复时，硬件需要被正确的初始化。这对大多数硬件都不是问题，但因为显卡是由BIOS初始化的，内核无法获取必要的恢复信息(仅存在于BIOS中，内核无法读取)，所以这里就提供了两个选项，以允许内核通过两种不同的方式来恢复显卡，更多细节请参考Documentation/power/video.txt文档。
</span><span class='line'>&#9;(2)s3_beep主要用于调试，它让PC喇叭在内核的实模式入口点被调用时发出响声。
</span><span class='line'>&#9;(3)s4_nohwsig用于关闭ACPI硬件签名功能，某些有缺陷的BIOS会因为这个原因导致从S4状态(挂起到硬盘)唤醒时失败。
</span><span class='line'>&#9;(4)old_ordering用于兼容古董级的ACPI 1.0 BIOS
</span><span class='line'>&#9;(5)nonvs表示阻止内核在挂起/唤醒过程中保存/恢复ACPI NVS内存信息，主要用于解决某些有缺陷的BIOS导致的挂起/唤醒故障。
</span><span class='line'>&#9;(6)sci_force_enable表示由内核直接设置SCI_EN(ACPI模式开关)的状态，主要用于解决某些有缺陷的BIOS导致的从S1/S3状态唤醒时的故障。
</span><span class='line'>[HIBERNATION]
</span><span class='line'>noresume
</span><span class='line'>&#9;禁用内核的休眠到硬盘功能(CONFIG_HIBERNATION)，也就是不从先前的休眠状态中恢复(即使该状态已经被保存在了硬盘的swap分区上)，并且清楚先前已经保存的休眠状态(如果有的话)。
</span><span class='line'>[HIBERNATION]
</span><span class='line'>hibernate={noresume|nocompress}
</span><span class='line'>&#9;设置休眠/唤醒属性：
</span><span class='line'>&#9;noresume 表示禁用唤醒，也就是在启动过程中无视任何已经存在的休眠镜像，完全重新启动。
</span><span class='line'>&#9;nocompress 表示禁止对休眠镜像进行压缩/解压。
</span><span class='line'>[HIBERNATION]
</span><span class='line'>resume={ /dev/swap | PARTUUID=uuid | major:minor | hex }
</span><span class='line'>&#9;告诉内核被挂起的内存镜像存放在那个磁盘分区(默认值是CONFIG_PM_STD_PARTITION)。
</span><span class='line'>&#9;假定内存镜像存放在"/dev/sdc15"分区上，该分区的 UUID=0123456789ABCDEF ，其主设备号是"8"，次设备号是"47"，那么这4种表示法应该分别这样表示：
</span><span class='line'>&#9;resume=/dev/sdc15 (这是内核设备名称，有可能与用户空间的设备名称不同)
</span><span class='line'>&#9;resume=PARTUUID=0123456789ABCDEF
</span><span class='line'>&#9;resume=08:47
</span><span class='line'>&#9;resume=082F
</span><span class='line'>[HIBERNATION]
</span><span class='line'>resume_offset=整数
</span><span class='line'>&#9;指定swap header所在位置的偏移量(单位是PAGE_SIZE)，偏移量的计算基准点是"resume="分区的起点。
</span><span class='line'>&#9;仅在使用swap文件(而不是分区)的时候才需要此参数。详见Documentation/power/swsusp-and-swap-files.txt文档
</span><span class='line'>[HIBERNATION]
</span><span class='line'>resumedelay=秒数
</span><span class='line'>&#9;在读取resume文件(设备)之前延迟的秒数，主要用于等待那些反应速度较慢的异步检测的设备就绪(例如USB/MMC)。
</span><span class='line'>[HIBERNATION]
</span><span class='line'>resumewait
</span><span class='line'>&#9;在resume设备没有就绪之前无限等待，主要用于等待那些反应速度较慢的异步检测的设备就绪(例如USB/MMC)。</span></code></pre></td></tr></table></div></figure>


<h3>温度控制</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[HW,ACPI]
</span><span class='line'>thermal.act=摄氏度
</span><span class='line'>&#9;-1 禁用所有"主动散热"标志点(active trip point)
</span><span class='line'>&#9;正整数 强制设置所有的最低"主动散热"标志点的温度值，单位是摄氏度。
</span><span class='line'>&#9;详见Documentation/thermal/sysfs-api.txt文档。
</span><span class='line'>[HW,ACPI]
</span><span class='line'>thermal.psv=摄氏度
</span><span class='line'>&#9;-1 禁用所有"被动散热"标志点(passive trip point)
</span><span class='line'>&#9;正整数 强制设置所有的"被动散热"标志点的温度值，单位是摄氏度。
</span><span class='line'>&#9;详见Documentation/thermal/sysfs-api.txt文档。
</span><span class='line'>[HW,ACPI]
</span><span class='line'>thermal.crt=摄氏度
</span><span class='line'>&#9;-1 禁用所有"紧急"标志点(critical trip point)
</span><span class='line'>&#9;正整数 强制设置所有的"紧急"标志点的温度值，单位是摄氏度。
</span><span class='line'>&#9;详见Documentation/thermal/sysfs-api.txt文档。
</span><span class='line'>[HW,ACPI]
</span><span class='line'>thermal.nocrt=1
</span><span class='line'>&#9;禁止在ACPI热区(thermal zone)温度达到"紧急"标志点时采取任何动作。
</span><span class='line'>[HW,ACPI]
</span><span class='line'>thermal.off=1
</span><span class='line'>&#9;彻底关闭ACPI热量控制(CONFIG_ACPI_THERMAL)
</span><span class='line'>[HW,ACPI]
</span><span class='line'>thermal.tzp=整数
</span><span class='line'>&#9;设置ACPI热区(thermal zone)的轮询速度：
</span><span class='line'>&#9;0(默认值) 不轮询
</span><span class='line'>&#9;正整数 轮询间隔，单位是十分之一秒。</span></code></pre></td></tr></table></div></figure>


<h3>CPU节能</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[KNL]
</span><span class='line'>nohz={on|off}
</span><span class='line'>&#9;启用/禁用内核的dynamic ticks特性。默认值是"on"。
</span><span class='line'>[KNL,BOOT]
</span><span class='line'>nohz_full=CPU列表
</span><span class='line'>&#9;在内核"CONFIG_NO_HZ_FULL=y"的前提下，指定哪些CPU核心可以进入完全无滴答状态。
</span><span class='line'>&#9;"CPU列表"是一个逗号分隔的CPU编号(从0开始计数)，也可以使用"-"界定一个范围。例如"0,2,4-7"等价于"0,2,4,5,6,7"
</span><span class='line'>&#9;[注意](1)"boot CPU"(通常都是"0"号CPU)会无条件的从列表中剔除。(2)这里列出的CPU编号必须也要同时列进"rcu_nocbs=..."参数中。
</span><span class='line'>[HW,ACPI]
</span><span class='line'>processor.nocst
</span><span class='line'>&#9;不使用_CST方法检测C-states，而是用老旧的FADT方法检测。
</span><span class='line'>[HW,ACPI]
</span><span class='line'>processor.max_cstate={0|1|2|3|4|5|6|7|8|9}
</span><span class='line'>&#9;无视ACPI表报告的值，强制指定CPU的最大C-state值(必须是一个有效值)：C0为正常状态，其他则为不同的省电模式(数字越大表示CPU休眠的程度越深/越省电)。"9"表示无视所有的DMI黑名单限制。
</span><span class='line'>[KNL,HW,ACPI]
</span><span class='line'>intel_idle.max_cstate=[0|正整数]
</span><span class='line'>&#9;设置intel_idle驱动(CONFIG_INTEL_IDLE)允许使用的最大C-state深度。"0"表示禁用intel_idle驱动，转而使用通用的acpi_idle驱动(CONFIG_CPU_IDLE)
</span><span class='line'>idle=poll
</span><span class='line'>idle=halt
</span><span class='line'>idle=nomwait
</span><span class='line'>&#9;对CPU进入休眠状态的额外设置。
</span><span class='line'>&#9;poll 从根本上禁用休眠功能(也就是禁止进入C-states状态)，可以略微提升一些CPU性能，但是却需要多消耗许多电力，得不偿失。不推荐使用。
</span><span class='line'>&#9;halt 表示直接使用HALT指令让CPU进入C1/C1E休眠状态，但是不再继续进入C2/C3以及更深的休眠状态。此选项兼容性最好，唤醒速度也最快。但是电力消耗并不最低。
</span><span class='line'>&#9;nomwait 表示进入休眠状态时禁止使用CPU的MWAIT指令。MWAIT是专用于Intel超线程技术的线程同步指令，有助于提升CPU的超线程效能，但对于不具备超线程技术的CPU没有意义。
</span><span class='line'>&#9;[提示]可以同时使用halt和nomwait，也就是"idle=halt idle=nomwait"(但不是：idle=halt,nomwait)
</span><span class='line'>intel_pstate=disable
</span><span class='line'>&#9;禁用 Intel CPU 的 P-state 驱动(CONFIG_X86_INTEL_PSTATE)，也就是Intel CPU专用的频率调节器驱动</span></code></pre></td></tr></table></div></figure>


<h3>PCI与PCIE</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[PCI]
</span><span class='line'>pci=选项[,选项...]
</span><span class='line'>&#9;指定各种PCI子系统选项：
</span><span class='line'>&#9;earlydump 在内核做出任何改变之前，首先转储出PCI配置空间。主要用于调试目的。
</span><span class='line'>&#9;off 不检测PCI总线，也就是关闭所有PCI设备。
</span><span class='line'>&#9;conf1 强制使用"PCI配置机制1"(目前的事实标准)
</span><span class='line'>&#9;conf2 强制使用"PCI配置机制2"(已被抛弃的老古董)
</span><span class='line'>&#9;noaer [PCIE]禁止使用CONFIG_PCIEAER功能(PCI Express Root Port Advanced Error Reporting)
</span><span class='line'>&#9;nodomains 禁止支持多个PCI root domain(也就是PCI总线域[PCI segment])
</span><span class='line'>&#9;nommconf 禁止使用通过MMCONFIG(CONFIG_PCI_MMCONFIG)方式访问PCI配置空间，MMCONFIG是PCI Express引入的新总线枚举方式。
</span><span class='line'>&#9;check_enable_amd_mmconf 在 AMD family 10h CPU 上检查并启用正确配置的MMIO以访问PCI配置空间
</span><span class='line'>&#9;nomsi [MSI]在全系统范围内禁止MSI中断(CONFIG_PCI_MSI)的使用
</span><span class='line'>&#9;noioapicquirk [APIC]禁止屏蔽任何boot中断(CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS)，以确保boot IRQ永远可用。应该永远不需要使用此选项。
</span><span class='line'>&#9;ioapicreroute [APIC]允许将boot IRQ重新路由到主IO-APIC(相当于开启CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS)，用于修复某些芯片组bug(在某些情况下会发送多余的"boot IRQ")。
</span><span class='line'>&#9;noioapicreroute [APIC]禁止将boot IRQ重新路由到主IO-APIC(相当于关闭CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS)，不建议使用此项。
</span><span class='line'>&#9;rom 为扩展ROM分配地址空间。使用此选项要小心，因为某些设备在ROM与其它资源之间共享地址译码器。
</span><span class='line'>&#9;norom 即使BIOS没有为扩展ROM分配地址空间，也禁止内核为扩展ROM分配地址空间。
</span><span class='line'>&#9;nobar 即使BIOS没有为BAR分配地址空间，也禁止内核为BAR分配地址空间。
</span><span class='line'>&#9;irqmask=0xMMMM 指定允许自动分配到PCI设备的IRQ位掩码，目的是为了避免使用那些被ISA设备占用的IRQ。
</span><span class='line'>&#9;pirqaddr=0xAAAAA 如果PIRQ表(通常情况下由BIOS生成)在F0000h-100000h范围之外，此选项可用于明确指定其物理地址。
</span><span class='line'>&#9;lastbus=N 通过扫描N号总线来扫描全部总线。如果内核不能找到第二条总线，可以通过此方法明确告知其位置。
</span><span class='line'>&#9;assign-busses 总是使用内核自己生成的PCI总线号码替代固件自己生成的值。
</span><span class='line'>&#9;usepirqmask 优先使用可能存在于BIOS $PIR表中的IRQ掩码。某些有缺陷的BIOS需要这个选项(例如HP Pavilion N5400和Omnibook XE3笔记本)。此选项仅在noioapicreroute(相当于关闭CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS)的前提下有效。
</span><span class='line'>&#9;noacpi 不为IRQ路由或PCI扫描使用ACPI
</span><span class='line'>&#9;use_crs 使用来自ACPI的PCI主桥的窗口信息。在2008年之后的BIOS上，这是默认值，如果需要明确使用此项，请当做bug上报开发者。
</span><span class='line'>&#9;nocrs 忽略来自ACPI的PCI主桥的窗口信息，如果需要明确使用此项，请当做bug上报开发者。
</span><span class='line'>&#9;routeirq 对所有PCI设备使用IRQ路由。这个通常是由内核的pci_enable_device()函数完成，所以此项仅为那些忘记调用此函数的驱动提供的临时解决方案。
</span><span class='line'>&#9;skip_isa_align 不对齐ISA IO起始地址，这样就可以处理更多的PCI卡
</span><span class='line'>&#9;noearly 不做任何"early type 1"扫描，这样许多针对主板缺陷的检测将被禁止，同时某些IOMMU驱动也会失效。仅用于解决某些有缺陷的主板故障。
</span><span class='line'>&#9;bfsort 按照宽度优先(breadth-first)的顺序对PCI设备进行排序。目的是为了以与2.4内核兼容的方式获取设备序号。
</span><span class='line'>&#9;nobfsort 不按宽度优先(breadth-first)的顺序对PCI设备进行排序。
</span><span class='line'>&#9;pcie_bus_tune_off 不对PCIe MPS(Max Payload Size)进行调整，而是使用BIOS配置好的默认值。
</span><span class='line'>&#9;pcie_bus_safe 将每个设备的MPS都设为root complex下所有设备支持的MPS中的最大值
</span><span class='line'>&#9;pcie_bus_perf 将设备的MPS设为其上级总线允许的最大MPS，同时将MRRS(Max Read Request Size)设为能支持的最大值(但不能大于设备或总线所支持的MPS值)
</span><span class='line'>&#9;pcie_bus_peer2peer 将每个设备的MPS都设为最安全的"128B"，以确保支持所有设备之间的点对点DMA，同时也能保证热插入(hot-added)设备能够正常工作，但代价是可能会造成性能损失。
</span><span class='line'>&#9;cbiosize=nn[KMG] 从CardBus桥的IO窗口中保留的固定长度的总线空间(bus space)，默认值是256B。
</span><span class='line'>&#9;cbmemsize=nn[KMG] 从CardBus桥的内存窗口中保留的固定长度的总线空间(bus space)，默认值是64MB。
</span><span class='line'>&#9;resource_alignment=[对齐规则@][域:]总线:插槽.功能[; ...] 为重新分配已对齐的内存资源指定对齐方式与设备。如果未指定对齐规则，那么将使用PAGE_SIZE作为对齐规则。也可以通过指定PCI-PCI桥来扩展资源窗口(resource windows)。
</span><span class='line'>&#9;ecrc={bios|on|off} 启用/禁用PCIe ECRC(事务层的端对端CRC校验)。默认值是"bios"(使用BIOS/固件的设定)。
</span><span class='line'>&#9;hpiosize=nn[KMG] 为热插拔桥的IO窗口保留的固定总线空间的大小，默认值是256B。
</span><span class='line'>&#9;hpmemsize=nn[KMG] 为热插拔桥的内存窗口保留的固定总线空间的大小，默认值是2MB。
</span><span class='line'>&#9;realloc={on|off} 当BIOS分配的PCI桥资源太小而无法满足所有子设备的需求时，是否由内核重新分配PCI桥资源。没有默认值(内核的默认值为"undefined")
</span><span class='line'>&#9;realloc 等价于"realloc=on"
</span><span class='line'>&#9;noari 不使用PCIe ARI
</span><span class='line'>&#9;pcie_scan_all 扫描所有可能的PCIe设备。默认只在每个PCIe下游端口扫描一个设备。
</span><span class='line'>[PCIE]
</span><span class='line'>pcie_hp=nomsi
</span><span class='line'>&#9;禁止PCIe本地热插拔使用MSI(CONFIG_PCI_MSI)，这将导致所有PCIe端口使用INTx中断提供热插拔服务。
</span><span class='line'>[PCIE]
</span><span class='line'>pcie_ports={auto|native|compat}
</span><span class='line'>&#9;PCIe端口处理方式：
</span><span class='line'>&#9;auto 由BIOS来决定是否使用关联在PCIe端口上的本地PCIe服务(PME, hot-plug, AER)
</span><span class='line'>&#9;native 无条件的使用关联在PCIe端口上的本地PCIe服务(PME, hot-plug, AER)
</span><span class='line'>&#9;compat 禁用PCIe端口驱动，同时将PCIe端口当做PCI-to-PCI桥处理。
</span><span class='line'>[PCIE]
</span><span class='line'>pcie_aspm={off|force}
</span><span class='line'>&#9;强制启用/禁用PCIe Active State Power Management(CONFIG_PCIEASPM)。内核的默认值取决于内核"Default ASPM policy"的配置。
</span><span class='line'>&#9;off 强制禁用
</span><span class='line'>&#9;force 即使设备声明不支持ASPM也强制启用(可能会导致系统锁死)。
</span><span class='line'>[PCIE]
</span><span class='line'>pcie_pme=nomsi
</span><span class='line'>&#9;禁止本地PCIe PME信号使用MSI(CONFIG_PCI_MSI)，这将导致所有PCIe root端口使用INTx中断提供所有服务。</span></code></pre></td></tr></table></div></figure>


<h3>LIBATA</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[LIBATA]
</span><span class='line'>libata.noacpi
</span><span class='line'>&#9;在libata驱动休眠/唤醒过程中禁止使用ACPI。主要用于解决某些有缺陷的BIOS导致的硬盘假死问题。
</span><span class='line'>[LIBATA]
</span><span class='line'>libata.dma=整数
</span><span class='line'>&#9;控制DMA特性的使用
</span><span class='line'>&#9;libata.dma=0 表示完全禁止所有SATA/PATA端口使用DMA
</span><span class='line'>&#9;libata.dma=1 表示仅允许SATA/PATA硬盘使用DMA
</span><span class='line'>&#9;libata.dma=2 表示仅允许ATAPI(CDROM)使用DMA
</span><span class='line'>&#9;libata.dma=4 表示仅允许CF卡使用DMA
</span><span class='line'>&#9;上述1,2,4实际上是位掩码，可以组合使用，例如 libata.dma=3 表示允许硬盘和CDROM使用DMA，但是禁止CF卡使用DMA
</span><span class='line'>[LIBATA]
</span><span class='line'>libata.ignore_hpa={0|1}
</span><span class='line'>&#9;是否忽略HPA(Host Protected Area)的限制。"0"(默认值)表示不忽略；"1"表示忽略(也就是可以使用整个磁盘空间)
</span><span class='line'>[LIBATA]
</span><span class='line'>libata.force=PORT[.DEVICE]:VAL,PORT[.DEVICE]:VAL,...
</span><span class='line'>&#9;手动强制指定libata的配置。
</span><span class='line'>&#9;其中的"PORT[.DEVICE]"是libata驱动在控制台上以相同格式显示出来的ATA ID字符串(PORT和DEVICE都是十进制数字)，下面是两个实例("1.00","2.00")：
</span><span class='line'>
</span><span class='line'>&#9;ata1.00: ATAPI: VBOX CD-ROM, 1.0, max UDMA/133
</span><span class='line'>&#9;ata2.00: ATA-6: VBOX HARDDISK, 1.0, max UDMA/133
</span><span class='line'>
</span><span class='line'>&#9;如果不指定DEVICE部分，那么就表示适用于该PORT端口上的所有设备。
</span><span class='line'>&#9;VAL部分用来强制设定设备属性：
</span><span class='line'>&#9;40c, 80c, short40c, unk, ign, sata 这些都用于指定线缆类型
</span><span class='line'>&#9;1.5Gbps, 3.0Gbps 这些都用于指定SATA连接速度
</span><span class='line'>&#9;noncq, ncq 关闭还是开启NCQ功能
</span><span class='line'>&#9;dump_id 转储IDENTIFY数据
</span><span class='line'>&#9;pio[0-7], mwdma[0-4], udma[0-7](或者这么写也一样：udma[16,25,33,44,66,100,133]) 数据传输模式
</span><span class='line'>&#9;nohrst, nosrst, norst 只禁止硬重置,只禁止软重置,同时禁止硬重置和软重置
</span><span class='line'>&#9;rstonce 在热拔连接恢复(hot-unplug link recovery)过程中仅尝试一次重置
</span><span class='line'>&#9;atapi_dmadir 开启 ATAPI DMADIR bridge 支持
</span><span class='line'>&#9;disable 禁用该设备</span></code></pre></td></tr></table></div></figure>


<h3>键盘/鼠标/触摸板</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[HW]
</span><span class='line'>atkbd.set={2|3}
</span><span class='line'>&#9;设置atkbd驱动(CONFIG_KEYBOARD_ATKBD)的键盘类型：2(默认值)表示AT键盘；3 表示PS/2键盘。
</span><span class='line'>[HW]
</span><span class='line'>atkbd.reset
</span><span class='line'>&#9;在初始化AT或PS/2键盘时重置键盘状态。常用于解决从休眠状态唤醒后键盘失效的故障。
</span><span class='line'>[HW]
</span><span class='line'>atkbd.softraw={0|1}
</span><span class='line'>&#9;当键盘按键被按下时，是返回原始的扫描码(Scancode)还是经过转换之后的键码(Keycode)。常用于解决某些功能键(例如Fn键)故障。
</span><span class='line'>&#9;0 表示返回原始的扫描码(Scancode)
</span><span class='line'>&#9;1(默认值)表示返回转换之后的键码(Keycode)
</span><span class='line'>[USBHID]
</span><span class='line'>usbhid.mousepoll=毫秒数
</span><span class='line'>&#9;USB鼠标的轮询时间间隔，单位是毫秒。默认值是"10"，也就是每秒轮询100次，相当于100Hz
</span><span class='line'>[MOUSE]
</span><span class='line'>mousedev.tap_time=毫秒数
</span><span class='line'>&#9;手指触碰和离开触摸板的最大时间间隔，只有小于此间隔的触碰才会被当成鼠标左键单击。此参数仅对工作在绝对模式的触摸板有意义。
</span><span class='line'>[MOUSE]
</span><span class='line'>mousedev.xres=正整数
</span><span class='line'>mousedev.yres=正整数
</span><span class='line'>&#9;触摸板的水平(X)/垂直(Y)方向的分辨率。</span></code></pre></td></tr></table></div></figure>


<h3>USB</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[USB]
</span><span class='line'>nousb
</span><span class='line'>&#9;禁用USB子系统(CONFIG_USB_SUPPORT)
</span><span class='line'>[USB]
</span><span class='line'>usbcore.authorized_default={-1|0|1}
</span><span class='line'>&#9;USB设备的默认授权规则：
</span><span class='line'>&#9;-1(默认值) 对除无线USB之外的设备默认授权
</span><span class='line'>&#9;0 对所有设备都默认不授权
</span><span class='line'>&#9;1 对所有设备都默认授权
</span><span class='line'>[USB]
</span><span class='line'>usbcore.autosuspend=秒数
</span><span class='line'>&#9;让USB设备(新检测到的设备以及空闲设备)进入自动休眠前的延迟秒数。默认为2秒。
</span><span class='line'>&#9;如果将秒数设为负数，则表示永不进入自动休眠状态。
</span><span class='line'>[USB]
</span><span class='line'>usbcore.initial_descriptor_timeout=毫秒数
</span><span class='line'>&#9;等待设备回应初始化64位USB_REQ_GET_DESCRIPTOR请求的超时时间。默认值是"5000"，也就是5秒。
</span><span class='line'>[USB]
</span><span class='line'>usbcore.blinkenlights={0|1}
</span><span class='line'>&#9;是否让所有的USB集线器(HUB)上的LED指示灯闪烁。默认值"0"表示不闪烁，"1"表示闪烁。
</span><span class='line'>[USB]
</span><span class='line'>usbcore.usbfs_snoop={0|1}
</span><span class='line'>&#9;是否在在日志中记录所有的usbfs traffic信息。默认值"0"表示不记录，"1"表示记录。
</span><span class='line'>[USB]
</span><span class='line'>usbcore.old_scheme_first={0|1}
</span><span class='line'>&#9;是否优先使用老旧的USB设备初始化方法。默认值"0"表示不优先使用。
</span><span class='line'>[USB]
</span><span class='line'>usbcore.use_both_schemes={0|1}
</span><span class='line'>&#9;是否在第一种USB设备初始化方法失败之后，继续尝试第二种方法。默认值"1"表示继续尝试第二种方法。
</span><span class='line'>[USB]
</span><span class='line'>usbcore.usbfs_memory_mb=[0-2047]
</span><span class='line'>&#9;由usbfs分配的缓存上限。取值范围是[0-2047]，默认值是"16"，单位是"MB"。
</span><span class='line'>[UMS]
</span><span class='line'>usb-storage.delay_use=秒数
</span><span class='line'>&#9;在扫描新USB存储设备上的逻辑单元(Logical Unit)前暂停的秒数。默认值是"5"秒。
</span><span class='line'>[UMS]
</span><span class='line'>usb-storage.quirks=VID:PID:Flags[,VID:PID:Flags]...
</span><span class='line'>&#9;设置一系列的修正项(quirk)，用于增补或者改写内核内置的unusual_devs列表内容。该列表用于修正各种有缺陷的USB存储设备的怪毛病。
</span><span class='line'>&#9;多个修正项之间用逗号分隔，修正项的格式是"VID:PID:Flags"，其中VID和PID的含义分别是4位16进制数表示的"Vendor ID"与"Product ID"。
</span><span class='line'>&#9;而Flags则是一组字符的组合，其中的每个字符都对应一个具有特定含义的修正(quirk)标记：
</span><span class='line'>&#9;a = SANE_SENSE (收集超过18字节的传感器数据)
</span><span class='line'>&#9;b = BAD_SENSE (不收集超过18字节的传感器数据)
</span><span class='line'>&#9;c = FIX_CAPACITY (无条件的将设备报告的扇区数(容量)减少一个扇区)
</span><span class='line'>&#9;d = NO_READ_DISC_INFO (不使用 READ_DISC_INFO 命令)
</span><span class='line'>&#9;e = NO_READ_CAPACITY_16 (不使用 READ_CAPACITY_16 命令)
</span><span class='line'>&#9;h = CAPACITY_HEURISTICS (如果设备报告的扇区数(容量)是奇数，那么就减少一个扇区)
</span><span class='line'>&#9;i = IGNORE_DEVICE (不绑定此设备)
</span><span class='line'>&#9;l = NOT_LOCKABLE (不要尝试锁定/解锁可弹出媒体)
</span><span class='line'>&#9;m = MAX_SECTORS_64 (每次传输最大不超过64个扇区(32KB)的数据)
</span><span class='line'>&#9;n = INITIAL_READ10 (强制重试初始的 READ(10) 命令(如果最初一次读取失败的话))
</span><span class='line'>&#9;o = CAPACITY_OK (完全信任设备报告的扇区数(容量))
</span><span class='line'>&#9;p = WRITE_CACHE (默认开启设备写入缓存[不怕数据丢失的风险])
</span><span class='line'>&#9;r = IGNORE_RESIDUE (不相信设备报告的[容量]剩余值)
</span><span class='line'>&#9;s = SINGLE_LUN (此设备只有一个逻辑单元(Logical Unit))
</span><span class='line'>&#9;w = NO_WP_DETECT (不检测设备是否有写保护)
</span><span class='line'>&#9;例如：usb-storage.quirks=0419:aaf5:rl,0421:0433:rc
</span><span class='line'>[USB]
</span><span class='line'>uhci-hcd.ignore_oc={0|1}
</span><span class='line'>&#9;是否忽略"电流超限"(overcurrent)事件。
</span><span class='line'>&#9;0(默认值) 不忽略
</span><span class='line'>&#9;1 忽略。某些有缺陷的主板会在USB端口未连接任何设备时，报告很多虚假的"电流超限"事件。设为"1"之后可以避免在内核日志中出现大量的"电流超限"警告，但同时，真实的"电流超限"事件也会被一并忽略。</span></code></pre></td></tr></table></div></figure>


<h3>IOMMU</h3>

<p>IOMMU非常类似于MMU，主要有如下功能：(1)IO地址转换[在64位系统上支持32位设备]；(2)分散-聚集(scatter-gather)支持[简化驱动程序的编写]；(3)DMA重映射与IRQ重映射[简化了IO设备的虚拟化]。</p>

<p>Linux内核当前的DMA映射有如下4种具体实现：<br/>
(1)在内存不足3G的机器上，根本不使用任何IOMMU功能，因为根本没必要。内核消息："PCI-DMA: Disabling IOMMU"<br/>
(2)基于GART(CONFIG_GART_IOMMU)的硬件IOMMU。内核消息："PCI-DMA: using GART IOMMU"<br/>
(3)如果内存大于3G同时机器上又没有IOMMU硬件(或者用了"iommu=soft")，那么就使用软件模拟的IOMMU(CONFIG_BOUNCE)。内核消息："PCI-DMA: Using software bounce buffering for IO (SWIOTLB)&ldquo;<br/>
(4)基于IBM Calgary硬件的IOMMU，仅用于IBM pSeries/xSeries系列服务器。内核消息："PCI-DMA: Using Calgary IOMMU&rdquo;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[IOMMU]
</span><span class='line'>iommu={off,force,noforce,soft}
</span><span class='line'>&#9;通用IOMMU设置：
</span><span class='line'>&#9;off 彻底关闭IOMMU功能
</span><span class='line'>&#9;force 强制使用硬件IOMMU，即使硬件可能有缺陷(例如VIA芯片组)或者根本没有必要这样做(例如内存不足3G)。
</span><span class='line'>&#9;noforce(默认) 在内存不足3G的机器上，不使用硬件IOMMU，因为根本没有必要。
</span><span class='line'>&#9;soft(Intel平台的默认值) 使用通过软件模拟的IOMMU(SWIOTLB)，同时禁止使用硬件IOMMU(即使存在)。
</span><span class='line'>[IOMMU]
</span><span class='line'>iommu=[SIZE][,allowed][,fullflush|nofullflush][,leak[=NUM]][,memaper[=N]|noaperture][,noagp][,merge|nomerge][,forcesac][,panic][,allowdac|nodac][,calgary]
</span><span class='line'>&#9;仅适用于硬件IOMMU(GART与Calgary)的设置：
</span><span class='line'>&#9;SIZE 重映射区域的大小，单位是字节。
</span><span class='line'>&#9;allowed 含义与"force"相同，即使硬件可能有缺陷(例如VIA芯片组)也强制使用硬件IOMMU
</span><span class='line'>&#9;fullflush(默认) 每次分配时都刷新IOMMU
</span><span class='line'>&#9;nofullflush 不刷新IOMMU
</span><span class='line'>&#9;leak=NUM 开启IOMMU泄漏跟踪(CONFIG_IOMMU_LEAK)，NUM是的泄漏页数(默认值是20)。
</span><span class='line'>&#9;memaper=N 在RAM中分配的固有窗口(own aperture)的大小，算法是 2N*32MB，N的默认值是"1"，也就是64MB。
</span><span class='line'>&#9;noaperture 禁止IOMMU使用AGP的"aperture"。
</span><span class='line'>&#9;noagp 不初始化AGP驱动，使用完全的"aperture"。
</span><span class='line'>&#9;merge 强制"scatter-gather"合并，隐含了"force"，这是一个实验性选项。
</span><span class='line'>&#9;nomerge 禁止"scatter-gather"合并
</span><span class='line'>&#9;forcesac 对于少于40位的掩码强制使用单地址周期(single-address cycle)，这是一个实验性选项。
</span><span class='line'>&#9;panic 当IOMMU益处时，允许panic
</span><span class='line'>&#9;allowdac 将32位PCI地址用两个时钟周期推入64位地址，这就是DAC的作用。
</span><span class='line'>&#9;nodac 禁用DAC，也就是所有4GB以上的DMA将强制通过IOMMU(硬件的或模拟的)
</span><span class='line'>&#9;calgary 使用IBM Calgary IOMMU
</span><span class='line'>swiotlb=页数[,force]
</span><span class='line'>&#9;仅适用于软件IOMMU(CONFIG_BOUNCE)的设置：
</span><span class='line'>&#9;页数 为"IO bounce buffer"预先保留的页数，每个页的大小是128K
</span><span class='line'>&#9;force 强制所有IO都透过软件IOMMU
</span><span class='line'>[AMD-IOMMU]
</span><span class='line'>amd_iommu={fullflush|off|force_isolation}
</span><span class='line'>&#9;向AMD IOMMU驱动(CONFIG_AMD_IOMMU)传递参数
</span><span class='line'>&#9;fullflush 表示当IO/TLB项被取消映射的时候立即刷新IO/TLB项(严格模式，速度较慢)，否则将仅在IO/TLB项被重用之前进行刷新(宽松模式，速度更快)
</span><span class='line'>&#9;off 表示彻底禁用AMD IOMMU功能
</span><span class='line'>&#9;force_isolation 表示为所有设备强制启用IOMMU隔离(映射)，这样IOMMU驱动就不再需要自己去发起隔离请求。注意：此选项不会覆盖"iommu=pt"
</span><span class='line'>[Intel-IOMMU]
</span><span class='line'>intel_iommu={on,off,igfx_off,forcedac,strict,sp_off}
</span><span class='line'>&#9;Intel-IOMMU驱动(CONFIG_INTEL_IOMMU)的主要功能就是DMA重映射，该参数用于设置其特性。
</span><span class='line'>&#9;on 开启Intel-IOMMU驱动
</span><span class='line'>&#9;off 关闭Intel-IOMMU驱动
</span><span class='line'>&#9;igfx_off 关闭Intel集成显卡的DMA重映射功能(默认值为开启)
</span><span class='line'>&#9;forcedac 强制PCI设备使用DAC，而禁止进行地址转换(默认值为允许)
</span><span class='line'>&#9;strict 禁止批量刷写IOTLB(默认值为允许)
</span><span class='line'>&#9;sp_off 关闭super page支持(默认值为开启)
</span><span class='line'>[Intel-IOMMU]
</span><span class='line'>intremap={on,off,nosid,no_x2apic_optout}
</span><span class='line'>&#9;设置中断重映射功能：
</span><span class='line'>&#9;on(默认值)开启中断重映射
</span><span class='line'>&#9;off 关闭中断重映射
</span><span class='line'>&#9;nosid 重映射时不对SID(Source ID)做检查
</span><span class='line'>&#9;no_x2apic_optout 无视BIOS的设置，强制禁用x2APIC特性，主要用于解决某些对x2APIC支持有缺陷的BIOS导致的故障</span></code></pre></td></tr></table></div></figure>


<h3>虚拟化</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[PV_OPS]
</span><span class='line'>noreplace-paravirt
</span><span class='line'>&#9;禁止使用内核通用的半虚拟化接口paravirt_ops，主要用于解决某些在Virtual PC上安装或运行Linux的故障。
</span><span class='line'>[VMMIO]
</span><span class='line'>virtio_mmio.device=size@baseaddr:irq[:id]
</span><span class='line'>&#9;实例化virtio-mmio设备(CONFIG_VIRTIO_MMIO)。可以多次使用以实例化多个设备。
</span><span class='line'>&#9;size 大小(可以使用K,M,G后缀)
</span><span class='line'>&#9;baseaddr 物理基准地址(physical base address)
</span><span class='line'>&#9;irq 中断号(将会被传递给request_irq())
</span><span class='line'>&#9;id(可选) platform设备号(device id)
</span><span class='line'>&#9;例子：virtio_mmio.device=1K@0x100b0000:48:7
</span><span class='line'>[KVM]
</span><span class='line'>kvm.ignore_msrs={0|1}
</span><span class='line'>&#9;是否忽略客户机对未经处理的MSR(unhandled MSR)的访问。"0"(默认值)表示不忽略但是会注入#GP；"1"表示忽略。
</span><span class='line'>[KVM]
</span><span class='line'>kvm.mmu_audit={0|1}
</span><span class='line'>&#9;是否允许在运行时对KVM MMU进行审计。"0"(默认值)表示禁止审计；"1"表示允许审计。
</span><span class='line'>[KVM,AMD]
</span><span class='line'>kvm-amd.nested={0|1}
</span><span class='line'>&#9;是否允许嵌套虚拟化(在虚拟机内再创建虚拟机)。"0"表示禁止嵌套；"1"(默认值)表示允许嵌套。
</span><span class='line'>[KVM,AMD]
</span><span class='line'>kvm-amd.npt={0|1}
</span><span class='line'>&#9;是否允许客户机使用嵌套页表(Nested Page Table)。"0"表示禁止使用；"1"(默认值)表示允许使用。
</span><span class='line'>[KVM,Intel]
</span><span class='line'>kvm-intel.ept={0|1}
</span><span class='line'>&#9;是否允许客户机使用扩展页表(Extended Page Table)。"0"表示禁止使用；"1"(默认值)表示允许使用。
</span><span class='line'>[KVM,Intel]
</span><span class='line'>kvm-intel.emulate_invalid_guest_state={0|1}
</span><span class='line'>&#9;是否允许仿真无效的客户机状态。"0"(默认值)表示禁止仿真；"1"表示允许仿真。
</span><span class='line'>[KVM,Intel]
</span><span class='line'>kvm-intel.flexpriority={0|1}
</span><span class='line'>&#9;是否允许使用FlexPriority技术(TPR[Task Priority Register] shadow)。"0"表示禁止使用；"1"(默认值)表示允许使用。
</span><span class='line'>[KVM,Intel]
</span><span class='line'>kvm-intel.nested={0|1}
</span><span class='line'>&#9;是否允许VMX嵌套(nVMX)。"0"(默认值)表示禁止；"1"表示允许。
</span><span class='line'>[KVM,Intel]
</span><span class='line'>kvm-intel.unrestricted_guest={0|1}
</span><span class='line'>&#9;是否允许使用"unrestricted guest"技术。"0"表示禁止使用；"1"(默认值)表示允许使用。
</span><span class='line'>[KVM,Intel]
</span><span class='line'>kvm-intel.vpid={0|1}
</span><span class='line'>&#9;是否允许使用"Virtual Processor Identification"(tagged TLB)技术。"0"表示禁止使用；"1"(默认值)表示允许使用。</span></code></pre></td></tr></table></div></figure>


<h3>内存</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[KNL,BOOT]
</span><span class='line'>mem=nn[KMG]
</span><span class='line'>&#9;强制指定内核使用多少数量的内存。仅在你想限定内存使用量时，才需要指定这个参数。同时为了避免PCI设备使用指定范围之外的内存，你还应该配合"memmap="一起使用。
</span><span class='line'>[KNL]
</span><span class='line'>memmap=exactmap
</span><span class='line'>&#9;表示将要使用随后的"memmap=..."等参数进行精确的E820内存映射(因为有时候E820报告的并不准确)，同时禁止内核进行任何自动的探测。比如对于一个4G内存的机器可能是："memmap=exactmap memmap=640K@0 memmap=4095M@1M"。
</span><span class='line'>[KNL]
</span><span class='line'>memmap=nn[KMG]@ss[KMG]
</span><span class='line'>&#9;强制只使用从ss开始的nn长度的特定内存区域。可以多次使用以指定多个区域。
</span><span class='line'>[KNL,ACPI]
</span><span class='line'>memmap=nn[KMG]#ss[KMG]
</span><span class='line'>&#9;强制将从ss开始的nn长度的特定内存区域标记为ACPI数据。
</span><span class='line'>[KNL,ACPI]
</span><span class='line'>memmap=nn[KMG]$ss[KMG]
</span><span class='line'>&#9;强制保留(不使用)从ss开始的nn长度的特定内存区域。
</span><span class='line'>[KNL,BUGS]
</span><span class='line'>reserve=起点,长度[,起点,长度]...
</span><span class='line'>&#9;禁止设备驱动程序自动探测某些iomem区域，因为某些设计不良的硬件会导致自动探测失败或出错。此外，还可以用于人为禁止内核初始化某些端口上的设备。
</span><span class='line'>&#9;内核会将此处指定的iomem区域标记为"reserved"(意为"已经在此处找到设备")，从而将该区域保留。
</span><span class='line'>&#9;因为设备驱动不应该去侦测标记为"reserved"的区域，除非另一个启动参数明确地指示它这样做，所以此参数经常和其它启动参数一起使用：
</span><span class='line'>&#9;用"reserve="保留一段区域禁止所有其他驱动的探测，同时再明确指定一个驱动去检测被保留的区域。例如：
</span><span class='line'>
</span><span class='line'>&#9;reserve=0x300,32  blah=0x300
</span><span class='line'>
</span><span class='line'>&#9;的意思是：除了允许"blah"驱动探测 0x300 之外，禁止任何其他驱动探测 0x300-0x31f 区域。
</span><span class='line'>&#9;绝大部份的机器都不需要此参数。只有真正有缺陷的硬件或特殊情况才会需要使用它。
</span><span class='line'>&#9;[注意]每个"reserve="参数最多可以指定4个保留区域，如果你有异常复杂的需求，可以使用多重"reserve="来指定。
</span><span class='line'>reservelow=nn[K]
</span><span class='line'>&#9;设置为BIOS保留的底端地址空间数量。
</span><span class='line'>memory_corruption_check={0|1}
</span><span class='line'>&#9;是否开启低位内存脏数据检查(CONFIG_X86_CHECK_BIOS_CORRUPTION)。某些有bug的BIOS经常会在执行系统休眠/唤醒之类动作的时候，破坏内存中前64k的内容。如果始终检查到错误,那么就应该通过"memmap="参数来避免使用这段内存。
</span><span class='line'>memory_corruption_check_size=字节数
</span><span class='line'>&#9;低位内存脏数据检查(CONFIG_X86_CHECK_BIOS_CORRUPTION)的内存范围。默认值是"64K"，表示"0-64K"这个内存范围。
</span><span class='line'>memory_corruption_check_period=秒数
</span><span class='line'>&#9;低位内存脏数据检查(CONFIG_X86_CHECK_BIOS_CORRUPTION)的周期。默认值是60秒。设为"0"则表示禁止这种周期性的检查。
</span><span class='line'>[KNL,BOOT]
</span><span class='line'>vmalloc=nn[KMG]
</span><span class='line'>&#9;强制指定vmalloc区域的大小。可用于增加vmalloc区域的最小尺寸(x86默认128MB)，也可以用于减少vmalloc的大小，增加更多的空间用于直接映射内核RAM。
</span><span class='line'>[SLUB]
</span><span class='line'>slub_min_order=整数
</span><span class='line'>slub_max_order=整数
</span><span class='line'>&#9;SLUB页块最小与最大order数(默认值分别是"0"与"3")，当然slub_min_order必须小于slub_max_order。每一个slab需要2order个物理页框。过高的值可能会导致内存溢出错误。详见Documentation/vm/slub.txt
</span><span class='line'>[SLUB]
</span><span class='line'>slub_min_objects=整数
</span><span class='line'>&#9;每个slab的最小object总数目(默认值是"4")。详见Documentation/vm/slub.txt
</span><span class='line'>[SLUB]
</span><span class='line'>slub_nomerge
</span><span class='line'>&#9;禁止合并大小相近的多个slab，主要用于调试目的。
</span><span class='line'>[KNL]
</span><span class='line'>dhash_entries=正整数
</span><span class='line'>&#9;设置内核目录项缓存中哈希表默认项数。仅供内核专家使用。
</span><span class='line'>[KNL]
</span><span class='line'>ihash_entries=正整数
</span><span class='line'>&#9;内核会在内存中缓存一定数量的inode结构来加速文件访问，每个inode对应一个文件(不同于文件系统中的inode概念)，包含文件访问权限/属主/组/大小/生成时间/访问时间/最后修改时间等信息。这些inode保存在一个哈希表中。
</span><span class='line'>&#9;这个值用于指定这个哈希表的最大项数。你可以根据自己硬盘上可能被访问的文件数量对默认值进行调整(注意需要考虑哈希值的碰撞)。仅供内核专家使用。
</span><span class='line'>[KNL]
</span><span class='line'>transparent_hugepage={always|madvise|never}
</span><span class='line'>&#9;设置透明大内存页(CONFIG_TRANSPARENT_HUGEPAGE)的默认用法：
</span><span class='line'>&#9;always 表示总是对所有应用程序启用透明大内存页支持
</span><span class='line'>&#9;madvise 表示仅对明确要求该特性的程序启用
</span><span class='line'>&#9;never 表示彻底禁用。
</span><span class='line'>&#9;其默认值由内核的编译时设置决定。详见"Documentation/vm/transhuge.txt"文档。
</span><span class='line'>[HW]
</span><span class='line'>default_hugepagesz={2M|1G}
</span><span class='line'>&#9;默认的HugeTLB页大小。若未指定，那么其默认值就是CPU自身的默认值。
</span><span class='line'>&#9;大多数现代计算机体系结构提供对多页面大小的支持，比如X86_64支持4K和2M(要求CPU带有"pse"标记)以及1G(要求CPU带有"pdpe1gb"标记)。
</span><span class='line'>&#9;因此Linux将物理内存划分成许多固定大小的页面(默认为4K)，每个页对应一个page结构，这些结构组成一个mem_map[]数组。TLB(Translation Lookaside Buffer)是虚拟地址到物理地址的翻译缓冲区，这种缓冲区在处理器上是很宝贵的，操作系统总是尝试将有限的TLB资源发挥到极致。特别是能够轻松获得若干G内存的时候(大于4G)，这种优化就显得尤为关键。而HugeTLB特性则允许将某些页的尺寸增大到2MB或1GB，从而大大减小TLB的尺寸，提高缓冲区的命中率，进而提升内存性能。
</span><span class='line'>[HW]
</span><span class='line'>hugepagesz={2M|1G}
</span><span class='line'>&#9;指定HugeTLB页的大小，通常与"hugepages="联合使用(可使用多次)，为不同尺寸的大页分别预留不同的数量。
</span><span class='line'>&#9;例如：hugepagesz=2M hugepages=128 hugepagesz=1G hugepages=8
</span><span class='line'>&#9;注意：1GB的大页只能在命令行上使用"hugepages="预先分配，且分配之后不可在运行时释放。
</span><span class='line'>[HW]
</span><span class='line'>hugepages=正整数
</span><span class='line'>&#9;在启动时分配的HugeTLB页数量，仅在内核开启了CONFIG_HUGETLBFS之后有效。
</span><span class='line'>gbpages
</span><span class='line'>nogbpages
</span><span class='line'>&#9;是否允许内核页表对大小为1GB的Hugepages进行直接映射(CONFIG_DIRECT_GBPAGES)。当"CONFIG_DIRECT_GBPAGES=y"时，默认值是"gbpages"。
</span><span class='line'>vdso={0|1|2}
</span><span class='line'>&#9;vdso=0 禁用VDSO(Virtual Dynamic Shared Object)映射
</span><span class='line'>&#9;vdso=1 启用VDSO(Virtual Dynamic Shared Object)映射，这是"CONFIG_COMPAT_VDSO=n"时的默认值。
</span><span class='line'>&#9;vdso=2 将VDSO(Virtual Dynamic Shared Object)映射到旧式的确定性地址，这是"CONFIG_COMPAT_VDSO=y"时的默认值。
</span><span class='line'>vdso32={0|1|2}
</span><span class='line'>&#9;vdso32=0 禁用32位VDSO(Virtual Dynamic Shared Object)映射
</span><span class='line'>&#9;vdso32=1 启用32位VDSO(Virtual Dynamic Shared Object)映射，这是"CONFIG_COMPAT_VDSO=n"时的默认值。
</span><span class='line'>&#9;vdso32=2 将32位VDSO(Virtual Dynamic Shared Object)映射到旧式的确定性地址，这是"CONFIG_COMPAT_VDSO=y"时的默认值。</span></code></pre></td></tr></table></div></figure>


<h3>MTRR与PAT</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enable_mtrr_cleanup
</span><span class='line'>disable_mtrr_cleanup
</span><span class='line'>&#9;开启/关闭MTRR cleanup(CONFIG_MTRR_SANITIZER)特性。
</span><span class='line'>mtrr_chunk_size=nn[KMG]
</span><span class='line'>&#9;用于"MTRR cleanup"(CONFIG_MTRR_SANITIZER)功能，设置允许的最大连续块尺寸(也就是uncacheable项)。
</span><span class='line'>mtrr_gran_size=nn[KMG]
</span><span class='line'>&#9;用于"MTRR cleanup"(CONFIG_MTRR_SANITIZER)功能，设置MTRR块的粒度(每块的大小)。默认值是"1"。较大的值可以防止小的对齐耗尽MTRR。
</span><span class='line'>mtrr_spare_reg_nr=N
</span><span class='line'>&#9;用于"MTRR cleanup"(CONFIG_MTRR_SANITIZER)功能，设置备用MTRR项的编号。也就是告诉内核reg0N可以被清理或改写(参见"/proc/mtrr"文件)，默认值是"1"。
</span><span class='line'>nopat
</span><span class='line'>&#9;禁用PAT支持(CONFIG_X86_PAT)。主要用于解决某PAT故障导致的无法正常启动或者显卡驱动不能正常工作的问题。</span></code></pre></td></tr></table></div></figure>


<h3>图形与显示</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[AGP]
</span><span class='line'>agp={off|try_unsupported}
</span><span class='line'>&#9;off 表示关闭内核的AGP(CONFIG_AGP)支持；
</span><span class='line'>&#9;try_unsupported 表示尝试驱动那些不受支持的芯片(可能会导致系统崩溃或数据错误)
</span><span class='line'>[HW,DRM]
</span><span class='line'>gamma=浮点数
</span><span class='line'>&#9;设置显示器的Gamma值。
</span><span class='line'>video.brightness_switch_enabled={0|1}
</span><span class='line'>&#9;[背景知识]如果ACPI video.ko驱动(CONFIG_ACPI_VIDEO)能够收到用户通过键盘热键触发的ACPI事件(这需要固件的帮助)，video.ko将会把收到的ACPI事件转化为一个"key"类型输入事件，并通过其创建的输入设备发送到用户空间，这样用户空间的工具就可以通过sysfs接口去修改显示器的亮度。这是传统的做法。
</span><span class='line'>&#9;但是从v3.13内核开始，新增了此参数，并且其默认值为"1"，表示video.ko驱动除了向用户空间传递事件之外，还要自己在内核层去改变显示器的亮度。
</span><span class='line'>&#9;如果设为"0"则表示不在内核层改变显示器的亮度，依然留给用户层的工具去通过sysfs接口修改。
</span><span class='line'>&#9;详见Documentation/acpi/video_extension.txt文档。
</span><span class='line'>[DRM]
</span><span class='line'>i915.invert_brightness={-1|0|1}
</span><span class='line'>&#9;反转显示器背光亮度控制变量(brightness)的含义。
</span><span class='line'>&#9;通常情况下，brightness的值为"0"表示关闭背光(全黑)，随着brightness的值增大到最大值，表示最大亮度。
</span><span class='line'>&#9;但是通过这个参数，可以反转brightness的含义，让"0"表示最亮，而随着brightness值的递增亮度逐渐降低，直到最大值关闭背光(全黑)。
</span><span class='line'>&#9;-1 表示绝不反转其含义，也就是"0"始终表示关闭，最大值始终表示最亮。
</span><span class='line'>&#9;0 表示内核不对此变量的含义加以干预，使用机器自身的默认含义。
</span><span class='line'>&#9;1 表示强制反转其含义，也就是"0"始终表示最亮，最大值始终表示关闭。
</span><span class='line'>&#9;此选项常用于解决某些使用Intel集显/核显(CONFIG_DRM_I915)的电脑在启动时黑屏的问题。
</span><span class='line'>[FB]
</span><span class='line'>logo.nologo
</span><span class='line'>&#9;在系统启动时不显示Linux的企鹅标志图(企鹅数=CPU核心数)</span></code></pre></td></tr></table></div></figure>


<h3>网络</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[IPV6]
</span><span class='line'>disable_ipv6={0|1}
</span><span class='line'>&#9;是否在所有网络接口上禁用IPv6支持：0(默认值)表示在所有网络接口上开启IPv6支持；1 表示在所有网络接口上关闭IPv6支持。
</span><span class='line'>[IPV6]
</span><span class='line'>autoconf={0|1}
</span><span class='line'>&#9;是否在所有网络接口上开启IPv6地址自动配置。
</span><span class='line'>&#9;0 表示禁止自动配置，这样就只有IPv6回环地址(::1)和"link-local"地址会被自动添加到网络接口上。如果你不想从路由器公告(Router Advertisements)中的地址前缀自动生成IPv6地址，可以使用此项。
</span><span class='line'>&#9;1(默认值) 表示在所有网络接口上开启IPv6地址自动配置
</span><span class='line'>[IP_PNP]
</span><span class='line'>ip=[client-ip:server-ip:gateway-ip:netmask:hostname:device:]autoconf[:dns0-ip:dns1-ip]
</span><span class='line'>&#9;此参数告诉内核如何在启动过程中配置网卡的IP地址及路由表(而不是在启动完成后依赖用户空间的脚本去配置)。仅在内核已启用了CONFIG_IP_PNP的前提下有效。通常用于需要将NFS挂载为根文件系统(CONFIG_ROOT_NFS)的场合。
</span><span class='line'>&#9;此参数有以下4种用法：
</span><span class='line'>&#9;(1)ip={off|none}或者没有使用"ip"参数。这是默认值，表示彻底关闭自动配置功能。
</span><span class='line'>&#9;(2)ip={dhcp|bootp|rarp|any} 表示内核全自动完成所有配置工作(也就是将所有字段设为各自的默认值)。各选项的含义参见下面对autoconf字段的说明。
</span><span class='line'>&#9;(3)将autoconf字段设为{off|none}之一，并明确指定所有其它字段。表示全静态配置，也就是手动指定各字段的值(禁止自动检测)。
</span><span class='line'>&#9;(4)将autoconf字段设为{dhcp|bootp|rarp|any}之一，并明将部分字段留空(字段分割符":"不能省略)。表示半自动配置，也就是将留空的字段设为各自的默认值(自动检测)，而将手动指定的字段设为指定的值(禁止自动检测)。
</span><span class='line'>&#9;各字段的说明如下：
</span><span class='line'>&#9;client-ip NFS客户端IP地址。若留空，其默认值将通过自动检测获取。
</span><span class='line'>&#9;server-ip NFS服务器IP地址。该字段仅在需要将NFS挂载为根文件系统(root=/dev/nfs)的时候才是必须的。如果使用RARP检测client-ip并且此字段非空，那么将仅接受指定服务器的应答。若留空，其默认值将通过自动检测获取(也就是自动配置服务器的地址)。
</span><span class='line'>&#9;gateway-ip 网关的IP地址。仅在NFS服务器位于不同子网的时候才是必须的。若留空，其默认值将通过自动检测获取。
</span><span class='line'>&#9;netmask 子网掩码。若留空，其默认值将通过自动检测获取(根据client-ip所属的地址类型[A/B/C之类])。
</span><span class='line'>&#9;hostname NFS客户端的主机名。若留空，其默认值将通过自动检测获取(client-ip的ASCII表示形式)。
</span><span class='line'>&#9;device 使用的网卡。若留空，其默认值将通过自动检测获取：若有多个网卡，那么将通过所有网卡同时发送自动配置请求包，并将最先接收到应答的网卡设为默认网卡。
</span><span class='line'>&#9;autoconf 自动配置方式。{off|none}表示不使用自动配置(必须手动指定个字段的值)；{dhcp|bootp|rarp}分别表示只使用DHCP/BOOTP/RARP协议进行自动配置(当然内核必须支持指定的协议)；"any"表示使用内核支持的所有自动配置协议(同时发送不同协议的自动配置请求包，以最先接收到的应答为准)。 dns0-ip 主DNS服务器IP地址。若留空，其默认值将通过自动检测获取。其值将通过 /proc/net/pnp 导出到用户空间。在嵌入式系统上，/etc/resolv.conf 常常是到 /proc/net/pnp 的软连接。
</span><span class='line'>&#9;dns1-ip 辅DNS服务器IP地址。其它同上。
</span><span class='line'>[KNL,NET]
</span><span class='line'>rhash_entries=正整数
</span><span class='line'>&#9;设置内核路由缓冲区哈希表的大小，仅供内核网络专家使用。
</span><span class='line'>[KNL,NET]
</span><span class='line'>thash_entries=正整数
</span><span class='line'>&#9;设置内核允许使用的TCP链接哈希表的大小。
</span><span class='line'>[KNL,NET]
</span><span class='line'>uhash_entries=正整数
</span><span class='line'>&#9;设置内核允许使用的UDP/UDP-Lite链接哈希表的大小。
</span><span class='line'>[NETFILTER]
</span><span class='line'>nf_conntrack.acct={0|1}
</span><span class='line'>&#9;是否允许对连接追踪(CONFIG_NF_CONNTRACK)流进行记账。"0"(默认值)表示禁止记账，"1"表示允许记账。</span></code></pre></td></tr></table></div></figure>


<h3>块设备与磁盘阵列</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>blkdevparts=
</span><span class='line'>&#9;手动设置块设备分区表(而不是从块设备读取)，主要用于嵌入式环境或分区表损坏恢复的场合。详情参见Documentation/block/cmdline-partition.txt文档
</span><span class='line'>[EFI]
</span><span class='line'>gpt
</span><span class='line'>&#9;强制将拥有有效GPT签名但同时又包含无效"保护MBR"的磁盘当做GPT格式的磁盘。
</span><span class='line'>[IOSCHED]
</span><span class='line'>elevator={"bfq"|"cfq"|"deadline"|"noop"}
</span><span class='line'>&#9;指定默认的IO调度器
</span><span class='line'>[LOOP]
</span><span class='line'>loop.max_loop=[0-256]
</span><span class='line'>&#9;在系统启动时无条件的预先创建的回环(loopback)设备数，默认值由CONFIG_BLK_DEV_LOOP_MIN_COUNT决定。如果你使用util-linux-2.21以上版本,建议设为"0"(loop设备将通过/dev/loop-control动态创建)。
</span><span class='line'>[HW,RAID]
</span><span class='line'>raid={autodetect|noautodetect,partitionable|part}
</span><span class='line'>&#9;明确向内核的MD驱动(CONFIG_BLK_DEV_MD)传递RAID配置属性
</span><span class='line'>&#9;autodetect|noautodetect 表示内核是否应该自动检测RAID模式(CONFIG_MD_AUTODETECT)。如果关闭了自动检测，那么必须使用"md="明确告诉内核RAID模式及配置。
</span><span class='line'>&#9;partitionable|part 两者含义相同，都表示内核应该将组装之后得到的RAID设备视为"可分区"设备。
</span><span class='line'>[HW,RAID]
</span><span class='line'>md=N,dev0,dev1,...
</span><span class='line'>&#9;明确向内核的MD驱动(CONFIG_BLK_DEV_MD)传递RAID配置信息，并将列出的设备(dev0,dev1,...)组装为 /dev/mdN 阵列(表现为一个块设备文件)。
</span><span class='line'>&#9;建议仅在根文件系统位于RAID上的情况下使用这个参数。其他非根文件系统的RAID最好在系统启动后(挂载完根之后)再组装。
</span><span class='line'>&#9;N 可以是 0,1,2,3,...,255 中的任意一个整数，表示被创建的md设备的编号，例如：
</span><span class='line'>
</span><span class='line'>&#9;md=2,/dev/sda,/dev/sdb,/dev/sdc,/dev/sdd
</span><span class='line'>
</span><span class='line'>&#9;表示将 /dev/sda,/dev/sdb,/dev/sdc,/dev/sdd 组装成 /dev/md2 块设备(至于RAID级别之类的信息则由存储在超级块中的元数据提供)。
</span><span class='line'>&#9;[提示]2.6.28之前的老版本内核对创建的阵列还有所谓"可分区阵列"和"不可分区阵列"的区别，具体表现是：如果在N前加上字母"d"，则表示所创建的阵列是一个可分区阵列，否则就是不可分区阵列。不过现在已经没有这个区别了，所有创建的阵列都是可分区的，因此"d"也就没有存在的必要了。</span></code></pre></td></tr></table></div></figure>


<h3>根文件系统</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[KNL]
</span><span class='line'>root=字符串
</span><span class='line'>&#9;指定根文件系统的所在位置。通常这是一个必须明确设置的参数。
</span><span class='line'>&#9;"字符串"可以使用如下几种形式：
</span><span class='line'>&#9;XXxx 一个16进制数，其中"XX"是主设备号，"xx"是次设备号。例如"/dev/sdc15"(主设备号是"8"，次设备号是"47")，可以表示成"082F"。
</span><span class='line'>&#9;/dev/nfs 表示使用由nfsroot参数指定的NFS磁盘，仅在根文件系统位于NFS文件系统上的时候才使用。
</span><span class='line'>&#9;/dev/disk 表示一块完整的无分区块设备。比如：/dev/md0 /dev/loop0 /dev/sdb /dev/mmcblk0
</span><span class='line'>&#9;/dev/diskN 表示disk磁盘的第N(十进制)个分区。这是最常见的用法，比如：/dev/sda2 /dev/ubda1 /dev/xvda13
</span><span class='line'>&#9;/dev/diskpN 含义与上面的一样，也表示disk磁盘的第N(十进制)个分区，但是用于disk本身以数字结尾的情况(避免混淆)。比如：/dev/md0p3 /dev/emd/0p2 /dev/mmcblk0p1
</span><span class='line'>&#9;PARTUUID=00112233-4455-6677-8899-AABBCCDDEEFF 仅用于EFI/GPT格式的磁盘，表示分区表中UUID值为"00112233-4455-6677-8899-AABBCCDDEEFF"的分区。[提示]可以使用blkid查看"PARTUUID"。
</span><span class='line'>&#9;PARTUUID=SSSSSSSS-PP 仅用于传统的MSDOS分区表。"SSSSSSSS"是用16进制表示的32位"NT disk signature"，"PP"是用16进制表示的分区号。比如：PARTUUID=97531ACF-02 可能相当于 /dev/sda2 
</span><span class='line'>&#9;PARTUUID=XXXX/PARTNROFF=N 表示以UUID="XXXX"的分区为基准，偏移N个分区。假定 /dev/sdb5 的UUID=XXXX，那么 PARTUUID=XXXX/PARTNROFF=3 就表示 /dev/sdb8 ，而 PARTUUID=XXXX/PARTNROFF=-3 则表示 /dev/sdb2
</span><span class='line'>&#9;major:minor 由一对十进制数组成，其中major是主设备号，minor是次设备号。例如"/dev/sdc15"(主设备号是"8"，次设备号是"47")，可以表示成"8:47"。
</span><span class='line'>&#9;LABEL=??? 表示卷标为"???"的分区。比如：root=LABEL=/ 。不过这种格式并不被内核直接支持，仅是发行版通过initramfs中的脚本添加了这种格式的支持而已。所以并不通用。
</span><span class='line'>[KNL]
</span><span class='line'>rootfstype=文件系统类型
</span><span class='line'>&#9;指定根文件系统的类型。例如："xfs"或"ext4"之类
</span><span class='line'>[KNL]
</span><span class='line'>rootflags=挂载选项
</span><span class='line'>&#9;设置根文件系统的挂载选项，比如"noatime,ro"。各种不同的文件系统所能使用的选项各不相同，可以参考 mount 程序的选项。
</span><span class='line'>[KNL]
</span><span class='line'>ro
</span><span class='line'>rw
</span><span class='line'>&#9;以只读(ro)/读写(rw)模式挂载根文件系统
</span><span class='line'>[KNL]
</span><span class='line'>rootdelay=秒数
</span><span class='line'>&#9;在挂载根文件系统前延迟多少秒，主要用于等待那些反应速度较慢的异步检测的设备就绪(例如USB/MMC/FireWire)。
</span><span class='line'>[KNL]
</span><span class='line'>rootwait
</span><span class='line'>&#9;在根文件系统就绪之前无限等待。主要用于等待那些反应速度较慢的异步检测的设备就绪(例如USB/MMC/FireWire)。</span></code></pre></td></tr></table></div></figure>


<h3>系统初始化(init)</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[KNL]
</span><span class='line'>init=文件全路径
</span><span class='line'>&#9;指定内核挂载根文件系统后运行的第一个用户空间程序的绝对路径。默认为"/sbin/init"。
</span><span class='line'>[KNL]
</span><span class='line'>rdinit=全路径
</span><span class='line'>&#9;设置从initramfs中运行的第一个用户空间程序的绝对路径，默认为"/init"。
</span><span class='line'>&#9;[注意]一旦使用了initramfs并且成功的运行了其中的"/init"，所有"init"以及与根文件系统相关的参数(包括"nfsroot")对内核而言都将失效。
</span><span class='line'>&#9;initramfs中的脚本必须自己分析各个内核引导参数(/proc/cmdline)并完成根文件系统的挂载与切换，当然也包括启动真正的"init"进程。
</span><span class='line'>[KNL]
</span><span class='line'>S
</span><span class='line'>&#9;以单用户模式运行"init"。注意，这不是一个真正的内核参数，只是给initramfs中的脚本用的。所以并不通用。
</span><span class='line'>
</span><span class='line'>NFS(网络文件系统)
</span><span class='line'>
</span><span class='line'>[NFS]
</span><span class='line'>lockd.nlm_grace_period=秒数
</span><span class='line'>&#9;为NFS锁管理器指定宽限时间，单位是秒。取值范围在[0-240]？
</span><span class='line'>[NFS]
</span><span class='line'>lockd.nlm_tcpport=端口号
</span><span class='line'>&#9;为NFS锁管理器指定TCP端口
</span><span class='line'>[NFS]
</span><span class='line'>lockd.nlm_timeout=秒数
</span><span class='line'>&#9;为NFS锁管理器指定默认超时时间，单位是秒。默认值是10秒。取值范围在[3-20]？
</span><span class='line'>[NFS]
</span><span class='line'>lockd.nlm_udpport=端口号
</span><span class='line'>&#9;为NFS锁管理器指定UDP端口
</span><span class='line'>[NFS]
</span><span class='line'>nfsroot=[server-ip:]root-dir[,nfs-options]
</span><span class='line'>&#9;指定NFS根文件系统的位置。如果没有设置此参数，那么将使用"/tftpboot/本机IP"(默认值)作为根文件系统，并使用默认的NFS挂载选项。
</span><span class='line'>&#9;server-ip NFS服务器IP地址。其默认值是"ip"参数中的server-ip字段的值。
</span><span class='line'>&#9;root-dir 作为根文件系统挂载的NFS服务器的目录。如果其中包含"%s"，那么将会被替换为本机IP地址的ASCII表示形式。
</span><span class='line'>&#9;nfs-options 标准的NFS文件系统挂载选项(例如"ro")，多个选项之间使用逗号分隔。下面是默认使用的值：
</span><span class='line'>
</span><span class='line'>&#9;  port     = 由NFS服务器的portmap守护进程给出
</span><span class='line'>&#9;  rsize    = 4096
</span><span class='line'>&#9;  wsize    = 4096
</span><span class='line'>&#9;  timeo    = 7
</span><span class='line'>&#9;  retrans  = 3
</span><span class='line'>&#9;  acregmin = 3
</span><span class='line'>&#9;  acregmax = 60
</span><span class='line'>&#9;  acdirmin = 30
</span><span class='line'>&#9;  acdirmax = 60
</span><span class='line'>&#9;  flags    = hard,nointr,noposix,cto,ac
</span><span class='line'>
</span><span class='line'>[NFS]
</span><span class='line'>nfsrootdebug
</span><span class='line'>&#9;在启动过程中，在内核日志里显示详细的NFS相关的调试信息(挂载选项、服务器IP地址、根文件系统路径等)，以方便调试和故障诊断。
</span><span class='line'>[NFS]
</span><span class='line'>nfs.callback_tcpport=端口号
</span><span class='line'>&#9;设置NFSv4回复通道(callback channel)监听的TCP端口
</span><span class='line'>[NFS]
</span><span class='line'>nfs.cache_getent=路径
</span><span class='line'>&#9;设置用于更新NFS客户端缓存项的程序的路径。默认值是"/sbin/nfs_cache_getent"。
</span><span class='line'>[NFS]
</span><span class='line'>nfs.cache_getent_timeout=秒数
</span><span class='line'>&#9;尝试更新缓存项超时秒数，超过指定时间仍未更新成功则视为更新失败。默认值是15秒。
</span><span class='line'>[NFS]
</span><span class='line'>nfs.idmap_cache_timeout=秒数
</span><span class='line'>&#9;设置idmapper缓存项的最大寿命，单位是秒。
</span><span class='line'>[NFS]
</span><span class='line'>nfs.enable_ino64={0|1}
</span><span class='line'>&#9;是否开启64位inode号。"0"表示NFS客户端将会为readdir()与stat()系统调用模拟一个32位inode号(而不是返回真实的64位inode号)。"1"(默认值)表示返回真实的64位inode号。
</span><span class='line'>[NFSv4.1]
</span><span class='line'>nfs.max_session_slots=正整数
</span><span class='line'>&#9;设置NFS客户端尝试和服务器端协商的最大会话slot数。这也同时限定了客户端能够像服务器端发送的最大并发RPC请求数。默认值是64。将此值设置为比max_tcp_slot_table_limit大是没有价值的。
</span><span class='line'>[NFSv4]
</span><span class='line'>nfs.nfs4_unique_id=字符串
</span><span class='line'>&#9;指定NFSv4客户端插入到nfs_client_id4字符串中的额外的唯一标识字符串。这通常是一个在系统安装时自动生成的UUID。
</span><span class='line'>[NFSv4.1]
</span><span class='line'>nfs.send_implementation_id={0|1}
</span><span class='line'>&#9;是否在exchange_id请求中包含客户端实现识别信息(implementation identification information)。"0"表示不发送，默认值"1"表示发送。
</span><span class='line'>[NFSv4]
</span><span class='line'>nfs.recover_lost_locks={0|1}
</span><span class='line'>&#9;v3.12新增。是否尝试恢复服务器上由于租约超时而丢失的锁。需要注意的是，这样做很有可能会导致数据错误，因为无法保证超时后的锁文件未被更改。默认值"0"表示不做这样的尝试，而"1"则表示尝试恢复(这是v3.11及之前内核的默认行为)。
</span><span class='line'>[NFSv4]
</span><span class='line'>nfs.nfs4_disable_idmapping={0|1}
</span><span class='line'>&#9;默认值"1"表示在使用了"sec=sys"挂载选项的情况下，RPC身份认证和NFS操作都使用数字化的uid/gid。这会导致idmapping被禁用，从而让NFSv2/v3向NFSv4的迁移变得更加容易。客户端将会自动检测不支持此种操作模式的服务器，并回退到使用idmapper的模式。"0"表示禁止这种行为。
</span><span class='line'>[NFSv4]
</span><span class='line'>nfsd.nfs4_disable_idmapping={0|1}
</span><span class='line'>&#9;默认值"1"表示NFSv4服务器与那些使用auth_sys的客户端之间只使用数字化的uid/gid(包括发送与接收)，从而让NFSv2/v3向NFSv4的迁移变得更加容易。"0"表示禁止这种行为。</span></code></pre></td></tr></table></div></figure>


<h3>模块功能</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nomodule
</span><span class='line'>&#9;禁用内核模块加载功能(CONFIG_MODULES)。
</span><span class='line'>[KNL]
</span><span class='line'>module.sig_enforce
</span><span class='line'>&#9;强制内核在加载模块时检查模块签名(CONFIG_MODULE_SIG)，并且只接受具有合法签名的模块。如果内核开启了CONFIG_MODULE_SIG_FORCE，那么无论是否使用此参数，都将强制检查模块的签名。</span></code></pre></td></tr></table></div></figure>


<h3>安全</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>no_file_caps
</span><span class='line'>&#9;要求内核无视文件的权限。这样，执行文件的唯一途径就只有：由root去执行或者setuid root
</span><span class='line'>noexec={on|off}
</span><span class='line'>noexec32={on|off}
</span><span class='line'>&#9;是否允许将某部分内存映射为"禁止执行"，这是一种防止数据缓冲区溢出攻击的保护措施(也就是WinXP SP2曾经大力宣传的数据执行保护功能)，建议保持默认值"on"。
</span><span class='line'>&#9;[说明]noexec对32bit代码以及64bit代码都有约束力，而noexec32只针对32bit代码。
</span><span class='line'>nosmap
</span><span class='line'>&#9;禁用SMAP(CONFIG_X86_SMAP)支持。SMAP是Intel从Haswell微架构开始引入的一种新特征，用途是禁止内核因为自身错误意外访问用户空间的数据，以避免一些内核漏洞所导致的安全隐患。
</span><span class='line'>nosmep
</span><span class='line'>&#9;禁用SMEP(Supervisor Mode Execution Prevention)支持。SMEP与SMAP类似，也是Intel从Haswell微架构开始引入的一种新特征，用途是禁止内核因为自身错误意外执行用户空间的代码。以避免一些内核漏洞所导致的安全隐患。
</span><span class='line'>nordrand
</span><span class='line'>&#9;即使CPU支持(CONFIG_ARCH_RANDOM)，也禁止内核使用RDRAND指令(不过用户空间依然可以使用此指令)。由于很多人怀疑RDRAND指令所依赖的硬件随机数生成器所使用的加密标准(NIST SP800-90)被NSA植入了后门，所以提供了该参数以禁用它，不过大神Torvalds不以为然。
</span><span class='line'>vsyscall={emulate|native|none}
</span><span class='line'>&#9;控制vsyscall系统调用(调用固定的地址0xffffffffff600x00)的行为。大多数静态链接的可执行程序和老旧的Glibc会使用这个系统调用。因为vsyscall始终位于固定的地址，所以很容易被攻击者利用。
</span><span class='line'>&#9;emulate(默认值) 捕捉vsyscalls系统调用，并对其进行安全的模拟。这是比较安全的选项，但效率并不最高。
</span><span class='line'>&#9;native 将vsyscall系统调用直接转变成本地syscall指令，这比模拟方式效率稍微高一些。但是很容易被攻击。
</span><span class='line'>&#9;none 完全禁用vsyscall系统调用。这是最安全的选项，但是有可能会导致系统工作异常。
</span><span class='line'>[EVM]
</span><span class='line'>evm="fix"
</span><span class='line'>&#9;不管当前的完整性状态如何，都允许更新"security.evm"。
</span><span class='line'>[SECURITY]
</span><span class='line'>security={selinux|smack|tomoyo|apparmor|yama}
</span><span class='line'>&#9;选择启用的安全模块。仅在内核同时开启了多个安全模块的情况下才有意义。
</span><span class='line'>[SELINUX]
</span><span class='line'>selinux={0|1}
</span><span class='line'>&#9;是否在启动时就开启SELinux功能(CONFIG_SECURITY_SELINUX_BOOTPARAM)："0"表示关闭，"1"表示开启。
</span><span class='line'>&#9;默认值由内核在编译时确定(CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE)。
</span><span class='line'>&#9;即使设为"1"，随后也可以通过 /selinux/disable 在加载安全策略前禁止SELinux功能。
</span><span class='line'>[SELINUX]
</span><span class='line'>enforcing={0|1}
</span><span class='line'>&#9;是否在启动时强制启用SELinux规则。
</span><span class='line'>&#9;"0"(默认值)表示仅仅做记录违规操作日志而不真正拒绝违规操作；
</span><span class='line'>&#9;"1"表示真正拒绝违规操作并做记录违规操作日志。
</span><span class='line'>&#9;该参数还可以在运行时通过 /selinux/enforce 进行修改
</span><span class='line'>[SELINUX]
</span><span class='line'>checkreqprot={0|1}
</span><span class='line'>&#9;设置"checkreqprot"标记的初始值。
</span><span class='line'>&#9;"0"表示由内核强制执行检查保护(包括其中隐含的所有执行保护)
</span><span class='line'>&#9;"1"表示由应用程序自己主动请求执行检查保护
</span><span class='line'>&#9;默认值由内核在编译时确定，也可以在运行时通过 /selinux/checkreqprot 修改
</span><span class='line'>[APPARMOR]
</span><span class='line'>apparmor={0|1}
</span><span class='line'>&#9;是否在启动时就开启AppArmor功能(CONFIG_SECURITY_APPARMOR)："0"表示关闭，"1"表示开启。
</span><span class='line'>&#9;默认值由内核在编译时确定(CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE)。</span></code></pre></td></tr></table></div></figure>


<h3>多CPU与CPU间调度</h3>

<p>SMP(对称多处理器)系统中，所有的CPU共享全部资源(总线，内存，I/O等)，最大的特点就是所有资源共享，多个CPU之间没有区别。NUMA(非一致内存访问)的基本特征是具有多个CPU节点，每个CPU节点由多个CPU组成，并且具有独立的本地内存与I/O槽口等。因此，虽然每个CPU都可以访问整个系统的内存，但是访问本地节点内存的速度远远高于访问其它节点的内存。详见《SMP/NUMA/MPP体系结构对比》</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[SMP]
</span><span class='line'>nosmp
</span><span class='line'>&#9;强制禁用SMP，这是个已被反对使用的旧参数
</span><span class='line'>[SMP]
</span><span class='line'>maxcpus=整数
</span><span class='line'>&#9;最大允许使用的CPU核心数。"0"表示禁用SMP特性(等价于已被反对使用的旧"nosmp"参数)，同时也禁用IO APIC；正整数"n"表示最大允许使用n个CPU核心。
</span><span class='line'>[SMP]
</span><span class='line'>nr_cpus=正整数
</span><span class='line'>&#9;允许SMP内核支持的最大CPU核心数(等价于CONFIG_NR_CPUS)。配合CPU热插拔(CONFIG_HOTPLUG_CPU)，可在运行时增加CPU数目。
</span><span class='line'>cpu0_hotplug
</span><span class='line'>&#9;强制允许CPU0(boot CPU)热插拔(CONFIG_BOOTPARAM_HOTPLUG_CPU0)。下列特性必须依赖于cpu0，所此参数应谨慎使用：
</span><span class='line'>&#9;(1)从休眠状态(S3,S4)唤醒以及从运行状态进入休眠状态
</span><span class='line'>&#9;(2)PIC中断，也就是某些情况下，关机和重启也会依赖于cpu0
</span><span class='line'>[SMP]
</span><span class='line'>additional_cpus=整数
</span><span class='line'>&#9;最大允许热插拔的CPU数量。默认值由BIOS决定。相见Documentation/x86/x86_64/cpu-hotplug-spec
</span><span class='line'>[NUMA]
</span><span class='line'>numa={off|noacpi}
</span><span class='line'>&#9;off 关闭NUMA支持，也就是让所有内存都只属于同一个节点。
</span><span class='line'>&#9;noacpi 不为NUMA解析ACPI SRAT表
</span><span class='line'>[KNL]
</span><span class='line'>numa_balancing={enable|disable}
</span><span class='line'>&#9;启用/禁用NUMA均衡(CONFIG_NUMA_BALANCING)，其默认值由CONFIG_NUMA_BALANCING_DEFAULT_ENABLED决定
</span><span class='line'>[KNL,BOOT]
</span><span class='line'>numa_zonelist_order={zone|node|default}
</span><span class='line'>&#9;设置NUMA的zonelist顺序。这里设置的值还可以在运行中通过sysctl来修改。详见Documentation/sysctl/vm.txt
</span><span class='line'>[KNL,SMP]
</span><span class='line'>isolcpus=CPU编号列表
</span><span class='line'>&#9;将列表中的CPU从内核SMP平衡和调度算法中剔除。
</span><span class='line'>&#9;[注意]提出后并不是绝对不能再使用该CPU的，操作系统仍然可以强制指定特定的进程使用哪个CPU(可以通过taskset来做到)。
</span><span class='line'>&#9;该参数的目的主要是用于实现特定cpu只运行特定进程的目的。
</span><span class='line'>&#9;CPU编号从"0"开始计数，列表的表示方法有三种：
</span><span class='line'>&#9;numA,numB,...,numN
</span><span class='line'>&#9;numA-numN
</span><span class='line'>&#9;以及上述两种表示方法的组合：
</span><span class='line'>&#9;numA,...,numM-numN
</span><span class='line'>&#9;例如：0,3,4-7,9
</span><span class='line'>[KNL,SMP]
</span><span class='line'>relax_domain_level={-1|0|1|2|3|4|5}
</span><span class='line'>&#9;设置CPUSET调度域(sched domain)的默认级别。大于此级别的调度域层次将禁用闲时均衡和唤醒均衡，而其余级别的调度域都开启。
</span><span class='line'>&#9;-1(默认值) 使用系统的默认值(取决于不同的硬件架构)或者由其他的请求确定，也就是不人为指定默认级别。
</span><span class='line'>&#9;0 禁用所有调度域的闲时均衡和唤醒均衡
</span><span class='line'>&#9;1 超线程域(siblings)，也就是同一个物理核心内的不同超线程
</span><span class='line'>&#9;2 核域(cores)，也就是同一个物理CPU中不同的核心
</span><span class='line'>&#9;3 节点域(node)，对于NUMA系统来说就是同一个NUMA节点内，对于non-NUMA系统来说这是整个系统范围
</span><span class='line'>&#9;4 节点组域(chunk of node)，仅适用于NUMA系统，表示在一组特定的NUMA节点范围内
</span><span class='line'>&#9;5 全系统(system wide)，全部系统范围内
</span><span class='line'>&#9;详见Documentation/cgroups/cpusets.txt文档</span></code></pre></td></tr></table></div></figure>


<h3>控制组(Control Group)</h3>

<p>Cgroup(CONFIG_CGROUPS)是一种进程管理机制，也是内核的资源分配框架。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[KNL]
</span><span class='line'>cgroup_disable="控制器名称"
</span><span class='line'>&#9;禁用cgroup中特定的控制器名称。目前只支持一个"memory"控制器。
</span><span class='line'>noautogroup
</span><span class='line'>&#9;禁止自动创建进程组(CONFIG_SCHED_AUTOGROUP)，服务器环境可以考虑使用此参数。
</span><span class='line'>[KNL]
</span><span class='line'>swapaccount={0|1}
</span><span class='line'>&#9;是否统计换入(swap in)内存的资源。"0"表示不统计，"1"表示统计。详见Documentation/cgroups/memory.txt文档。</span></code></pre></td></tr></table></div></figure>


<h3>EFI/UEFI</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>noefi
</span><span class='line'>&#9;禁用EFI支持(CONFIG_EFI)。
</span><span class='line'>[EFI]
</span><span class='line'>add_efi_memmap
</span><span class='line'>&#9;将EFI内存映像包括在内核的可用物理内存映像之中
</span><span class='line'>pstore.backend=efivars
</span><span class='line'>&#9;将"efivars"(CONFIG_EFI_VARS_PSTORE)用作pstore内存文件系统的后端。</span></code></pre></td></tr></table></div></figure>


<h3>杂项</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[IP_VS_FTP]
</span><span class='line'>ports=portA,portB,...
</span><span class='line'>&#9;IPVS(IP Virtual Server) FTP帮助模块所使用的端口，最多允许指定8个。默认值是"21"。
</span><span class='line'>io_delay={0x80|0xed|udelay|none}
</span><span class='line'>&#9;设置IO延迟方式
</span><span class='line'>&#9;0x80(CONFIG_IO_DELAY_0X80) 传统的Linux IO延迟方式,久经考验,也最安全
</span><span class='line'>&#9;0xed(CONFIG_IO_DELAY_0XED) 基于0xed端口的IO延迟方式,主要是为了避免和基于0x80端口的主板诊断卡冲突
</span><span class='line'>&#9;udelay(CONFIG_IO_DELAY_UDELAY) 使用内核端udelay()函数作为延迟方法(简单的延迟2微秒).可以不占用任何IO端口空间.
</span><span class='line'>&#9;none(CONFIG_IO_DELAY_NONE) 不使用任何port-IO延迟机制.只要你的机器不是老古董,这个应该是首选.
</span><span class='line'>[KNL]
</span><span class='line'>reboot=[mode][,type][,force]
</span><span class='line'>&#9;指定系统重启的方式：
</span><span class='line'>&#9;mode 用于指定重启模式，可以使用如下2种模式之一：warm(热重启[跳过内存检测]), cold(冷重启[检测并重新初始化所有硬件])
</span><span class='line'>&#9;type 用于指定重启类型，可以使用如下4种类型之一：bios(为热重启使用CPU reboot vector), acpi(优先使用FADT中的ACPI RESET_REG,若失败再转kbd), kbd(使用键盘控制器冷重启,这是默认值), triple, efi(优先使用EFI提供的reset_system运行时服务,若失败再转kbd)
</span><span class='line'>&#9;结尾的"force"表示在重启时不停用其它的CPU，在某些情况下可以让reboot更可靠。
</span><span class='line'>[KNL]
</span><span class='line'>reset_devices
</span><span class='line'>&#9;强制驱动程序在初始化底层设备的过程中重置设备
</span><span class='line'>[KNL]
</span><span class='line'>rcu_nocbs=
</span><span class='line'>&#9;在"CONFIG_RCU_NOCB_CPU=y"的情况下,指定哪些CPU是No-CB CPU
</span><span class='line'>[KNL]
</span><span class='line'>nodelayacct
</span><span class='line'>&#9;禁止在针对每个进程的统计信息中包含进程等候系统资源(cpu,IO同步,内存交换等)所花费的时间，相当于禁用CONFIG_TASK_DELAY_ACCT模块。
</span><span class='line'>[KNL]
</span><span class='line'>sysfs.deprecated={0|1}
</span><span class='line'>&#9;为了兼容旧版本的应用程序而保留过时的sysfs特性(CONFIG_SYSFS_DEPRECATED)，其默认值由CONFIG_SYSFS_DEPRECATED_V2确定。</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/35">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/33">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(39)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>22</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>13</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(52)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~haproxy/?opendiv=tools'>haproxy</a><a href='##' onmousedown=showDiv('tools~haproxy') id='aexp_tools~haproxy'><span class='exp_style' id='exp_tools~haproxy'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~haproxy')) document.getElementById('aexp_tools~haproxy').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(51)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~cgroup/?opendiv=system'>cgroup</a><a href='##' onmousedown=showDiv('system~cgroup') id='aexp_system~cgroup'><span class='exp_style' id='exp_system~cgroup'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~cgroup')) document.getElementById('aexp_system~cgroup').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~kvm/?opendiv=system'>kvm</a><a href='##' onmousedown=showDiv('system~kvm') id='aexp_system~kvm'><span class='exp_style' id='exp_system~kvm'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~kvm')) document.getElementById('aexp_system~kvm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~namespace/?opendiv=system'>namespace</a><a href='##' onmousedown=showDiv('system~namespace') id='aexp_system~namespace'><span class='exp_style' id='exp_system~namespace'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~namespace')) document.getElementById('aexp_system~namespace').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(156)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~fs/?opendiv=kernel'>fs</a><a href='##' onmousedown=showDiv('kernel~fs') id='aexp_kernel~fs'><span class='exp_style' id='exp_kernel~fs'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~fs')) document.getElementById('aexp_kernel~fs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>33</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>74</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>19</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(20)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(66)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~perf/?opendiv=debug'>perf</a><a href='##' onmousedown=showDiv('debug~perf') id='aexp_debug~perf'><span class='exp_style' id='exp_debug~perf'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~perf')) document.getElementById('aexp_debug~perf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(26)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(199)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~11/?opendiv=2015'>2015-11</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2015~10/?opendiv=2015'>2015-10</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2015~09/?opendiv=2015'>2015-09</a><span class='right_span'>18</span></li>
<li><a href='/blog/cats/2015~08/?opendiv=2015'>2015-08</a><span class='right_span'>25</span></li>
<li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>31</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/17/kernel-net-ixgbe/">ixgbe</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/17/kernel-net-cubic/">cubic</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/17/kernel-net-iptables/">iptables</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/17/command-curl/">curl命令</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/17/command-alias/">alias命令</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
	<li>
		<a href=http://smilejay.com/ target=_blank>smilejay</a>
	</li>
	<li>
		<a href=http://blog.chinaunix.net/uid/10167808.html target=_blank>godbach</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
