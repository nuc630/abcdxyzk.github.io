
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/10/22/tools-LD_PRELOAD/">LD_PRELOAD环境变量</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-10-22T16:08:00+08:00'><span class='date'>2013-10-22</span> <span class='time'>16:08:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在Linux的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。</p>

<p>我们知道，Linux的用的都是glibc，有一个叫libc.so.6的文件，这是几乎所有Linux下命令的动态链接中，其中有标准C的各种函数。对于GCC而言，默认情况下，所编译的程序中对标准C函数的链接，都是通过动态链接方式来链接libc.so.6这个函数库的。</p>

<p>OK。还是让我用一个例子来看一下用LD_PRELOAD来hack别人的程序。</p>

<h5>示例一</h5>

<p>我们写下面一段例程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 文件名：verifypasswd.c */
</span><span class='line'>/* 这是一段判断用户口令的程序，其中使用到了标准C函数strcmp*/
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>&#9;char passwd[] = "password";
</span><span class='line'>&#9;if (argc &lt; 2) {
</span><span class='line'>&#9;&#9;printf("usage: %s &lt;password&gt;/n", argv[0]);
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (!strcmp(passwd, argv[1])) {
</span><span class='line'>&#9;&#9;printf("Correct Password!/n");
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;printf("Invalid Password!/n");
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在上面这段程序中，我们使用了strcmp函数来判断两个字符串是否相等。下面，我们使用一个动态函数库来重载strcmp函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 文件名：hack.c */
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>int strcmp(const char *s1, const char *s2)
</span><span class='line'>{
</span><span class='line'>&#9;printf("hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;/n", s1, s2);
</span><span class='line'>&#9;/* 永远返回0，表示两个字符串相等 */
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gcc -o verifypasswd verifypasswd.c
</span><span class='line'>$ gcc -shared -o hack.so hack.c</span></code></pre></td></tr></table></div></figure>


<p>测试一下程序：（得到正确结果）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ./verifypasswd asdf
</span><span class='line'>Invalid Password!</span></code></pre></td></tr></table></div></figure>


<h5>设置LD_PRELOAD变量：</h5>

<p>（使我们重写过的strcmp函数的hack.so成为优先载入链接库）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export LD_PRELOAD="./hack.so"</span></code></pre></td></tr></table></div></figure>


<p>再次运行程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ./verifypasswd  asdf
</span><span class='line'>hack function invoked. s1=&lt;password&gt; s2=&lt;asdf&gt;
</span><span class='line'>Correct Password!</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，<br/>
1）我们的hack.so中的strcmp被调用了。<br/>
2）主程序中运行结果被影响了。<br/>
如果这是一个系统登录程序，那么这也就意味着我们用任意口令都可以进入系统了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/10/15/tools-thunderbird/">Thunderbird</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-10-15T10:10:00+08:00'><span class='date'>2013-10-15</span> <span class='time'>10:10:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>Mozilla Thunderbird 最小化附加组建</h4>

<p>在工具->附加组建中<br/>
1、搜索minimize，安装firetray<br/>
2、firetray 首选项->邮件->邮件通知类型   选第二个：显示新邮件图示<br/>
不想最小化到托盘： firetray 首选项->视窗   去掉第二个勾选</p>

<h4>Mozilla Thunderbird 导入导出邮件</h4>

<p>一种Mozilla Thunderbird的扩展ImportExportTools。<br/>
<a href="https://addons.mozilla.org/zh-CN/thunderbird/addon/importexporttools/">https://addons.mozilla.org/zh-CN/thunderbird/addon/importexporttools/</a></p>

<h5>安装流程 （本地安装）</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 进入Mozilla Thunderbird
</span><span class='line'>2 点击菜单栏的“工具”-&gt;“附加软件”
</span><span class='line'>3 从附加组件搜索框旁边的选项按钮中，选择“从文件安装附加组件...”选项
</span><span class='line'>4 选择本地文件（ImportExportTools-X.X.xpi）位置 安装
</span><span class='line'>5 安装完成 重启Mozilla Thunderbird</span></code></pre></td></tr></table></div></figure>


<h5>如何用呢</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 进入Mozilla Thunderbird
</span><span class='line'>2 右键“收件箱”
</span><span class='line'>3 “导入/导出”
</span><span class='line'>4 “汇出此资料夹所以的邮件” 进行选择格式
</span><span class='line'>5 汇出完成 查看本地文件夹</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/10/10/debug-stap-inodewatch/">如何知道文件被那个进程写</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-10-10T16:27:00+08:00'><span class='date'>2013-10-10</span> <span class='time'>16:27:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一个文件正在被进程写 我想查看这个进程 文件一直在增大 找不到谁在写 使用lsof也没找到</p>

<p>这个问题挺有普遍性的，解决方法应该很多，这里我给大家提个比较直观的方法。</p>

<p>linux下每个文件都会在某个块设备上存放，当然也都有相应的inode, 那么透过vfs.write我们就可以知道谁在不停的写入特定的设备上的inode。</p>

<p>幸运的是systemtap的安装包里带了inodewatch.stp，位于/usr/local/share/doc/systemtap/examples/io目录下，就是用来这个用途的。</p>

<p>我们来看下代码：</p>

<p>$ cat inodewatch.stp</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /usr/bin/env stap
</span><span class='line'> 
</span><span class='line'>probe vfs.write, vfs.read
</span><span class='line'>{
</span><span class='line'>&#9;# dev and ino are defined by vfs.write and vfs.read
</span><span class='line'>&#9;if (dev == MKDEV($1,$2) # major/minor device
</span><span class='line'>&#9;&#9;&& ino == $3)
</span><span class='line'>&#9;printf ("%s(%d) %s 0x%x/%u\n",
</span><span class='line'>&#9;&#9;execname(), pid(), probefunc(), dev, ino)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个脚本的使用方法如下： stap  inodewatch.stp major minor ino</p>

<p>下面我们构造个场景： dd不停的写入一个文件，查出这个文件的ino, 以及它所在设备的major, minor, 运行stap脚本就可以得到答案。</p>

<p>场景交代好了，我们来演示下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pwd
</span><span class='line'>/home/chuba
</span><span class='line'>$ df
</span><span class='line'>Filesystem           1K-blocks      Used Available Use% Mounted on
</span><span class='line'>...
</span><span class='line'>/dev/sdb1            1621245336 825209568 713681236  54% /home
</span><span class='line'>...
</span><span class='line'>$ ls -al /dev/sdb1
</span><span class='line'>brw-rw---- 1 root disk 8, 17 Oct 24 11:22 /dev/sdb1 
</span><span class='line'>$ rm -f test.dat && dd if=/dev/zero of=test.dat
</span><span class='line'>^C9912890+0 records in
</span><span class='line'>9912890+0 records out
</span><span class='line'>5075399680 bytes (5.1 GB) copied, 26.8189 s, 189 MB/s</span></code></pre></td></tr></table></div></figure>


<p>这个终端模拟文件的不停写入，同时在另外一个终端查验谁干的。这里我们已经知道设备的major/minor为8/17</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ stat -c '%i' test.dat
</span><span class='line'>25337884
</span><span class='line'>$ sudo stap /usr/local/share/doc/systemtap/examples/io/inodewatch.stp 8 17 25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>看到了吧，dd是罪魁祸首，pid是740</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/10/10/debug-debugfs/">通过blktrace, debugfs分析磁盘IO</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-10-10T16:25:00+08:00'><span class='date'>2013-10-10</span> <span class='time'>16:25:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>如何通过blktrace+debugfs找到发生IO的文件，然后再结合自己的应用程序，分析出这些IO到底是 谁产生的，最终目的当然是尽量减少不必要的IO干扰，提高程序的性能。</p>

<p>blktrace是Jens Axobe写的一个跟踪IO请求的工具，Linux系统发起的IO请求都可以通过blktrace捕获并分析，关于这个工具的介绍请自行google之，这里推荐我们部门的<a href="http://blog.yufeng.info/">褚霸</a>同学的blog，里面有好几篇文章分别介绍了blktrace, blkparse以及blkiomon等工具的使用。</p>

<p>debugfs是ext2, ext3, ext4文件系统提供的文件系统访问工具，通过它我们可以不通过mount文件系统而直接访问文件系统的内容，它是e2fsprogs的一部分，默认应该都是安装的，详细的说明可以通过man debugfs得到。</p>

<p>下面我来演示一下如何通过这两个工具的配合来找到磁盘IO的源头。</p>

<p>先看一个简单的例子：<br/>
在一个终端会输入如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while [ 1 ];do dd if=/dev/zero of=test_file bs=4k count=20 seek=$RANDOM oflag=sync;done</span></code></pre></td></tr></table></div></figure>


<p>随机的在test_file里面写数据造成较大的IO压力，现在看看如何通过blktrace和debugfs抓到它。</p>

<p>1、通过iostat观察到有很大的磁盘压力</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
</span><span class='line'>sdb               0.00  2759.00    0.00 3515.50     0.00 50196.00    14.28     0.90    0.26   0.24  85.70</span></code></pre></td></tr></table></div></figure>


<p>2、我们看到sdb压力很大，这时候就需要通过blktrace抓取对应盘的数据<br/>
  blktrace /dev/sdb   有IO压力的时候一会儿就可以了，通过ctrl+c停止抓取。<br/>
  blktrace是需要debugfs支持的，如果系统提示debugfs没有mount，需要先mount上<br/>
  mount -t debugfs none /sys/kernel/debug 再执行blktrace命令</p>

<p>3、将blktrace抓出来的二进制文件转成文本格式。<br/>
  blkparse sdb.blktrace.* > 1.log<br/>
或blktrace  -d /dev/sda -o - |blkparse -i - > 1.log</p>

<p>4、开始分析日志</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  grep ‘ A ‘ 1.log|head -n 5
</span><span class='line'>
</span><span class='line'>8,16   0       39     0.001242727  2872  A  WS 420143 + 8 &lt;- (8,17) 420080
</span><span class='line'>8,16   0       52     0.001361766  2872  A  WS 420151 + 8 &lt;- (8,17) 420088
</span><span class='line'>8,16   0       65     0.001440210  2872  A  WS 420159 + 8 &lt;- (8,17) 420096
</span><span class='line'>8,16   0       78     0.001518207  2872  A  WS 420167 + 8 &lt;- (8,17) 420104
</span><span class='line'>8,16   0       91     0.001596083  2872  A  WS 420175 + 8 &lt;- (8,17) 420112</span></code></pre></td></tr></table></div></figure>


<p>为啥要grep ‘ A ‘呢？因为这条信息是上层一个读写请求进入到Linux IO协议栈的第一步，只有在这里我们可以看到清晰的请求原始信息。比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>8,16   0       39     0.001242727  2872  A  WS 420143 + 8 &lt;- (8,17) 420080</span></code></pre></td></tr></table></div></figure>


<p>这条说明是设备（8，17）也就是sdb1上产生的扇区为420080的写请求（读请求的话会在WS对应的位置出现‘R’），长度是8，它被映射到（8，16）上位置为420143。这个IO请求的完整生命周期是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 8,16   0       39     0.001242727  2872  A  WS 420143 + 8 &lt;- (8,17) 420080
</span><span class='line'> 8,16   0       41     0.001244984  2872  G  WS 420143 + 8 [dd]
</span><span class='line'> 8,16   0       43     0.001246609  2872  I  WS 420143 + 8 [dd]
</span><span class='line'> 8,16   0       45     0.001255064  2872  D  WS 420143 + 8 [dd]
</span><span class='line'> 8,16   0       46     0.001325168     0  C  WS 420143 + 8 [0]</span></code></pre></td></tr></table></div></figure>


<p>可以看到从’ A ‘的下一条开始都是以整个设备的扇区号为标识的，不方便我们找到对应的分区。</p>

<p>5、下面就开始通过debugfs来分析这条读写请求的来源了。
(8, 17)是sdb1, 420080是扇区号(IO层的基本单位是扇区sector，大小是512bytes)，而文件系统层是通过块block来管理的，一般的 ext3,ext4的块block大小是4096[1]，由此可得这个请求对应到文件系统的块block号是420080/8=52510, debugfs提供了命令icheck可以通过block号找到它对应的文件的inode。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#debugfs -R ‘icheck 52510′ /dev/sdb1
</span><span class='line'>debugfs 1.43-WIP (1-Aug-2012)
</span><span class='line'>Block Inode number
</span><span class='line'>52510 12</span></code></pre></td></tr></table></div></figure>


<p>6、通过inode number找到对应的文件名，很幸运，debugfs又提供了另外一条命令ncheck可以找到inode对应的文件名[2]。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#debugfs -R ‘ncheck 12′ /dev/sdb1
</span><span class='line'>debugfs 1.43-WIP (1-Aug-2012)
</span><span class='line'>Inode Pathname
</span><span class='line'>12 //test_file</span></code></pre></td></tr></table></div></figure>


<p>大家可以看到，我们现在已经成功找到了test_file这个文件啦，至此块设备层和文件系统层的分析工作已经结束了，下面就可以结合应用看看为啥会对这个文件有如此频繁的读写操作了！</p>

<p>[1] 块大小实际上也能够通过debugfs来得到。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>debugfs -R ‘stats’ /dev/sdb1|grep “Block size”</span></code></pre></td></tr></table></div></figure>


<p>[2] 有的同学找到的inode number是8，然后却无法找到对应的文件名。这是因为8是ext3/4文件系统中的日志文件的inode，它是隐藏文件，所以无法找到，可以再试试其他的block号哦！</p>

<p>根据inode你就可以找到对应的文件是什么了<br/>
find / -inum your_inode</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/27/kernel-net-tcp-timer/">内核tcp的定时器管理</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-27T16:11:00+08:00'><span class='date'>2013-09-27</span> <span class='time'>16:11:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h5>在内核中tcp协议栈有6种类型的定时器：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 重传定时器。
</span><span class='line'>2 delayed ack定时器
</span><span class='line'>3 零窗口探测定时器
</span><span class='line'>上面三种定时器都是作为tcp状态机的一部分来实现的。
</span><span class='line'>4 keep-alive 定时器 主要是管理established状态的连接。
</span><span class='line'>5 time_wait定时器 主要是用来客户端关闭时的time_wait状态用到。
</span><span class='line'>6 syn-ack定时器(主要是用在listening socket) 管理新的连接请求时所用到。</span></code></pre></td></tr></table></div></figure>


<h5>而在内核中，tcp协议栈管理定时器主要有下面4个函数：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inet_csk_reset_xmit_timer    这个函数是用来重启定时器
</span><span class='line'>inet_csk_clear_xmit_timer 这个函数用来删除定时器。
</span><span class='line'>上面两个函数都是针对状态机里面的定时器。
</span><span class='line'>tcp_set_keepalive 这个函数是用来管理keepalive 定时器的接口。
</span><span class='line'>tcp_synack_timer  这个函数是用来管理syn_ack定时器的接口。</span></code></pre></td></tr></table></div></figure>


<h5>先来看定时器的初始化。</h5>

<p>首先是在tcp_v4_init_sock中对定时器的初始化，它会调用tcp_init_xmit_timers，我们就先来看这个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_init_xmit_timers(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;inet_csk_init_xmit_timers(sk, &tcp_write_timer, &tcp_delack_timer, &tcp_keepalive_timer);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到这个函数很简单，就是调用inet_csk_init_xmit_timers,然后把3个定时器的回掉函数传递进去，下面我们来看inet_csk_init_xmit_timers。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void inet_csk_init_xmit_timers(struct sock *sk,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;void (*retransmit_handler)(unsigned long),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;void (*delack_handler)(unsigned long),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;void (*keepalive_handler)(unsigned long))
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>&#9;//安装定时器，设置定时器的回掉函数。
</span><span class='line'>&#9;setup_timer(&icsk-&gt;icsk_retransmit_timer, retransmit_handler, (unsigned long)sk);
</span><span class='line'>&#9;setup_timer(&icsk-&gt;icsk_delack_timer, delack_handler, (unsigned long)sk);
</span><span class='line'>&#9;setup_timer(&sk-&gt;sk_timer, keepalive_handler, (unsigned long)sk);
</span><span class='line'>&#9;icsk-&gt;icsk_pending = icsk-&gt;icsk_ack.pending = 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我 们可以看到icsk->icsk_retransmit_timer定时器，也就是重传定时器的回调函数是tcp_write_timer,而 icsk->icsk_delack_timer定时器也就是delayed-ack 定时器的回调函数是tcp_delack_timer,最后sk->sk_timer也就是keepalive定时器的回掉函数是 tcp_keepalive_timer.<br/>
这里还有一个要注意的，tcp_write_timer还会处理0窗口定时器。<br/>
这里有关内核定时器的一些基础的东西我就不介绍了，想了解的可以去看下ldd第三版。<br/>
接下来我们就来一个个的分析这6个定时器，首先是重传定时器。<br/>
我们知道4层最终调用tcp_xmit_write来讲数据发送到3层，并且tcp是字节流的，因此每次他总是发送一段数据到3层，而每次当它发送完毕(返回正确),则它就会启动重传定时器，我们来看代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_write_xmit(struct sock *sk, unsigned int mss_now, int nonagle,
</span><span class='line'>&#9;&#9;&#9;  int push_one, gfp_t gfp)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;struct sk_buff *skb;
</span><span class='line'>&#9;unsigned int tso_segs, sent_pkts;
</span><span class='line'>&#9;int cwnd_quota;
</span><span class='line'>&#9;int result;
</span><span class='line'>
</span><span class='line'>.............................................
</span><span class='line'>
</span><span class='line'>&#9;while ((skb = tcp_send_head(sk))) {
</span><span class='line'>..................................................
</span><span class='line'>
</span><span class='line'>&#9;&#9;//可以看到只有当传输成功，我们才会走到下面的函数。
</span><span class='line'>&#9;&#9;if (unlikely(tcp_transmit_skb(sk, skb, 1, gfp)))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Advance the send_head.  This one is sent out.
</span><span class='line'>&#9;&#9; * This call will increment packets_out.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;//最终在这个函数中启动重传定时器。
</span><span class='line'>&#9;&#9;tcp_event_new_data_sent(sk, skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;tcp_minshall_update(tp, mss_now, skb);
</span><span class='line'>&#9;&#9;sent_pkts++;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (push_one)
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;}
</span><span class='line'>...........................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在我们来看tcp_event_new_data_sent,如何启动定时器的.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_event_new_data_sent(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;unsigned int prior_packets = tp-&gt;packets_out;
</span><span class='line'>
</span><span class='line'>&#9;tcp_advance_send_head(sk, skb);
</span><span class='line'>&#9;tp-&gt;snd_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>
</span><span class='line'>&#9;/* Don't override Nagle indefinately with F-RTO */
</span><span class='line'>&#9;if (tp-&gt;frto_counter == 2)
</span><span class='line'>&#9;&#9;tp-&gt;frto_counter = 3;
</span><span class='line'>&#9;//关键在这里.
</span><span class='line'>&#9;tp-&gt;packets_out += tcp_skb_pcount(skb);
</span><span class='line'>&#9;if (!prior_packets)
</span><span class='line'>&#9;&#9;inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到只有当prior_packets为0时才会重启定时器,而prior_packets则是发送未确认的段的个数,也就是说如果发送了很多段,如果前面的段没有确认,那么后面发送的时候不会重启这个定时器.<br/>
我们要知道，定时器的间隔是通过rtt来得到的，具体的算法，可以看下tcp/ip详解。<br/>
当 启动了重传定时器，我们就会等待ack的到来，如果超时还没到来，那么就调用重传定时器的回调函数，否则最终会调用tcp_rearm_rto来删除或者 重启定时器，这个函数是在tcp_ack()->tcp_clean_rtx_queue()中被调用的。tcp_ack是专门用来处理ack。<br/>
这个函数很简单，就是通过判断packets_out，这个值表示当前还未确认的段的个数。然后来进行相关操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_rearm_rto(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>&#9;//为0说明所有的传输的段都已经acked。此时remove定时器。否则重启定时器。
</span><span class='line'>&#9;if (!tp-&gt;packets_out) {
</span><span class='line'>&#9;&#9;inet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;  inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  接下来来看tcp_write_timer的实现。这个函数主要是通过icsk->icsk_pending来判断是那个定时器导致超时，这里只有两 种，一种是ICSK_TIME_RETRANS，也就是重传定时器，另一种是ICSK_TIME_PROBE0也就是0窗口定时器。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define ICSK_TIME_RETRANS   1   /* Retransmit timer */
</span><span class='line'>#define ICSK_TIME_PROBE0    3   /* Zero window probe timer */
</span><span class='line'>static void tcp_write_timer(unsigned long data)
</span><span class='line'>{
</span><span class='line'>&#9;struct sock *sk = (struct sock *)data;
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>&#9;int event;
</span><span class='line'>
</span><span class='line'>&#9;//首先加锁。
</span><span class='line'>&#9;bh_lock_sock(sk);
</span><span class='line'>&#9;//如果是进程空间则什么也不做。
</span><span class='line'>&#9;if (sock_owned_by_user(sk)) {
</span><span class='line'>&#9;&#9;/* Try again later */
</span><span class='line'>&#9;&#9;sk_reset_timer(sk, &icsk-&gt;icsk_retransmit_timer, jiffies + (HZ / 20));
</span><span class='line'>&#9;&#9;goto out_unlock;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//如果状态为close或者icsk_pending为空，则什么也不做。
</span><span class='line'>&#9;if (sk-&gt;sk_state == TCP_CLOSE || !icsk-&gt;icsk_pending)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;//如果超时时间已经过了，则重启定时器。
</span><span class='line'>
</span><span class='line'>&#9;if (time_after(icsk-&gt;icsk_timeout, jiffies)) {
</span><span class='line'>&#9;&#9;sk_reset_timer(sk, &icsk-&gt;icsk_retransmit_timer, icsk-&gt;icsk_timeout);
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//取出定时器类型。
</span><span class='line'>&#9;event = icsk-&gt;icsk_pending;
</span><span class='line'>&#9;icsk-&gt;icsk_pending = 0;
</span><span class='line'>
</span><span class='line'>&#9;//通过判断event来确定进入那个函数进行处理。
</span><span class='line'>&#9;switch (event) {
</span><span class='line'>&#9;case ICSK_TIME_RETRANS:
</span><span class='line'>&#9;&#9;tcp_retransmit_timer(sk);
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;case ICSK_TIME_PROBE0:
</span><span class='line'>&#9;&#9;tcp_probe_timer(sk);
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;TCP_CHECK_TIMER(sk);
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>&#9;sk_mem_reclaim(sk);
</span><span class='line'>out_unlock:
</span><span class='line'>&#9;bh_unlock_sock(sk);
</span><span class='line'>&#9;sock_put(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们这里只看重传定时器，0窗口定时器后面紧接着会介绍。<br/>
tcp_retransmit_timer,这个函数用来处理数据段的重传。<br/>
这里要注意，重传的时候为了防止确认二义性，使用karn算法，也就是定时器退避策略。下面的代码最后部分会修改定时器的值，这里是增加一倍。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_retransmit_timer(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>&#9;//如果没有需要确认的段，则什么也不做。
</span><span class='line'>&#9;if (!tp-&gt;packets_out)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;WARN_ON(tcp_write_queue_empty(sk));
</span><span class='line'>
</span><span class='line'>&#9;/**首先进行一些合法性判断，其中:
</span><span class='line'>&#9; * snd_wnd为窗口大小。
</span><span class='line'>&#9; * sock_flag用来判断sock的状态。
</span><span class='line'>&#9; * 最后一个判断是当前的连接状态不能处于syn_sent和syn_recv状态,也就是连接还未建
</span><span class='line'>&#9; * 立状态.
</span><span class='line'>&#9;if (!tp-&gt;snd_wnd && !sock_flag(sk, SOCK_DEAD) &&
</span><span class='line'>&#9;&#9;!((1 &lt;&lt; sk-&gt;sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV))) {
</span><span class='line'>&#9;&#9;//tcp_time_stamp也就是jifes，而rcv_tstamp表示最后一个ack接收的时间，也就是最后一次对端确认的时间。因此这两个时间之差不能大于tcp_rto_max,因为tcp_rto_max为我们重传定时器的间隔时间的最大值。
</span><span class='line'>&#9;&#9;if (tcp_time_stamp - tp-&gt;rcv_tstamp &gt; TCP_RTO_MAX) {
</span><span class='line'>&#9;&#9;&#9;tcp_write_err(sk);
</span><span class='line'>&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//这个函数用来进入loss状态，也就是进行一些拥塞以及流量的控制。
</span><span class='line'>&#9;&#9;tcp_enter_loss(sk, 0);
</span><span class='line'>&#9;&#9;//现在开始重传skb。
</span><span class='line'>&#9;&#9;tcp_retransmit_skb(sk, tcp_write_queue_head(sk));
</span><span class='line'>&#9;&#9;__sk_dst_reset(sk);
</span><span class='line'>&#9;&#9;//然后重启定时器，继续等待ack的到来。
</span><span class='line'>&#9;&#9;goto out_reset_timer;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//程序到达这里说明上面的校验失败，因此下面这个函数用来判断我们重传需要的次数。如果超过了重传次数，直接跳转到out。
</span><span class='line'>&#9;if (tcp_write_timeout(sk))
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;//到达这里说明我们重传的次数还没到。icsk-&gt;icsk_retransmits表示重传的次数。
</span><span class='line'>&#9;if (icsk-&gt;icsk_retransmits == 0) {
</span><span class='line'>&#9;&#9;//这里其实也就是收集一些统计信息。
</span><span class='line'>&#9;&#9;int mib_idx;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (icsk-&gt;icsk_ca_state == TCP_CA_Disorder) {
</span><span class='line'>&#9;&#9;&#9;if (tcp_is_sack(tp))
</span><span class='line'>&#9;&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPSACKFAILURES;
</span><span class='line'>&#9;&#9;&#9;else
</span><span class='line'>&#9;&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPRENOFAILURES;
</span><span class='line'>&#9;&#9;} else if (icsk-&gt;icsk_ca_state == TCP_CA_Recovery) {
</span><span class='line'>&#9;&#9;&#9;if (tcp_is_sack(tp))
</span><span class='line'>&#9;&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPSACKRECOVERYFAIL;
</span><span class='line'>&#9;&#9;&#9;else
</span><span class='line'>&#9;&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPRENORECOVERYFAIL;
</span><span class='line'>&#9;&#9;} else if (icsk-&gt;icsk_ca_state == TCP_CA_Loss) {
</span><span class='line'>&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPLOSSFAILURES;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPTIMEOUTS;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;NET_INC_STATS_BH(sock_net(sk), mib_idx);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//是否使用f-rto算法。
</span><span class='line'>&#9;if (tcp_use_frto(sk)) {
</span><span class='line'>&#9;&#9;tcp_enter_frto(sk);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;//否则处理sack.
</span><span class='line'>&#9;&#9;tcp_enter_loss(sk, 0);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;// 再次尝试重传队列的第一个段。
</span><span class='line'>&#9;if (tcp_retransmit_skb(sk, tcp_write_queue_head(sk)) &gt; 0) {
</span><span class='line'>&#9;&#9;//重传失败。
</span><span class='line'>&#9;&#9;if (!icsk-&gt;icsk_retransmits)
</span><span class='line'>&#9;&#9;&#9;icsk-&gt;icsk_retransmits = 1;
</span><span class='line'>&#9;&#9;inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;  min(icsk-&gt;icsk_rto, TCP_RESOURCE_PROBE_INTERVAL),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;  TCP_RTO_MAX);
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//icsk-&gt;icsk_backoff主要用在零窗口定时器。
</span><span class='line'>&#9;icsk-&gt;icsk_backoff++;
</span><span class='line'>&#9;//icsk_retransmits也就是重试次数。
</span><span class='line'>&#9;icsk-&gt;icsk_retransmits++;
</span><span class='line'>
</span><span class='line'>out_reset_timer:
</span><span class='line'>&#9;//计算rto，并重启定时器，这里使用karn算法，也就是下次超时时间增加一倍/
</span><span class='line'>&#9;icsk-&gt;icsk_rto = min(icsk-&gt;icsk_rto &lt;&lt; 1, TCP_RTO_MAX);
</span><span class='line'>&#9;//重启定时器，可以看到超时时间就是我们上面的icsk_rto.
</span><span class='line'>&#9;inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, icsk-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>&#9;if (icsk-&gt;icsk_retransmits &gt; sysctl_tcp_retries1)
</span><span class='line'>&#9;&#9;__sk_dst_reset(sk);
</span><span class='line'>
</span><span class='line'>out:;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面我们来看tcp_write_timeout，它用来判断重传次数是否已经到了。这里主要分为两个分支，一个是状态为syn_sent或者syn_recv状态，一个是另外的状态。而这里系统设置的重传次数一共有4种。<br/>
1 sysctl_tcp_syn_retries，它表示syn分节的重传次数。<br/>
2 sysctl_tcp_retries1 它表示的是最大的重试次数，当超过了这个值，我们就需要检测路由表了。<br/>
3 sysctl_tcp_retries2 这个值也是表示重试最大次数，只不过这个值一般要比上面的值大。和上面那个不同的是，当重试次数超过这个值，我们就必须放弃重试了。<br/>
4 sysctl_tcp_orphan_retries 主要是针对孤立的socket(也就是已经从进程上下文中删除了，可是还有一些清理工作没有完成).对于这种socket，我们重试的最大的次数就是它。<br/>
下面来看代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_write_timeout(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>&#9;//retry_untry表示我们需要重传的最大次数。
</span><span class='line'>&#9;int retry_until;
</span><span class='line'>
</span><span class='line'>&#9;//判断socket状态。
</span><span class='line'>&#9;if ((1 &lt;&lt; sk-&gt;sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
</span><span class='line'>&#9;&#9;if (icsk-&gt;icsk_retransmits)
</span><span class='line'>&#9;&#9;&#9;dst_negative_advice(&sk-&gt;sk_dst_cache);
</span><span class='line'>&#9;&#9;//设置重传最大值
</span><span class='line'>&#9;&#9;retry_until = icsk-&gt;icsk_syn_retries ? : sysctl_tcp_syn_retries;
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;//是否需要检测路由表。
</span><span class='line'>&#9;&#9;if (icsk-&gt;icsk_retransmits &gt;= sysctl_tcp_retries1) {
</span><span class='line'>&#9;&#9;&#9;/* Black hole detection */
</span><span class='line'>&#9;&#9;&#9;tcp_mtu_probing(icsk, sk);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;dst_negative_advice(&sk-&gt;sk_dst_cache);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//设置重传最大次数为sysctl_tcp_retries2
</span><span class='line'>&#9;&#9;retry_until = sysctl_tcp_retries2;
</span><span class='line'>&#9;&#9;if (sock_flag(sk, SOCK_DEAD)) {
</span><span class='line'>&#9;&#9;&#9;//表示是一个孤立的socket。
</span><span class='line'>&#9;&#9;&#9;const int alive = (icsk-&gt;icsk_rto &lt; TCP_RTO_MAX);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;//从tcp_orphan_retries(这个函数中会通过sysctl_tcp_orphan_retries来进行计算)中取得重传最大次数。
</span><span class='line'>&#9;&#9;&#9;retry_until = tcp_orphan_retries(sk, alive);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (tcp_out_of_resources(sk, alive || icsk-&gt;icsk_retransmits &lt; retry_until))
</span><span class='line'>&#9;&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//最终进行判断，如果重传次数已到则返回1,否则为0.
</span><span class='line'>&#9;if (icsk-&gt;icsk_retransmits &gt;= retry_until) {
</span><span class='line'>&#9;&#9;/* Has it gone just too far? */
</span><span class='line'>&#9;&#9;tcp_write_err(sk);
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面来介绍下tcp_enter_loss，这个函数主要用来标记丢失的段(也就是没有acked的段),然后通过执行slow start来降低传输速率.<br/>
有关slow start以及Congestion avoidance算法描述可以看rfc2001:<br/>
<a href="http://www.faqs.org/rfcs/rfc2001.html">http://www.faqs.org/rfcs/rfc2001.html</a></p>

<p>下面4个算法主要是用来对拥塞进行控制的，这四个算法其实都是彼此相连的。slow start和Congestion avoidance使用了相同的机制，他们都涉及到了拥塞窗口的定义。其中拥塞窗口限制着传输的长度，它的大小根据拥塞程度上升或者下降。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Slow start
</span><span class='line'>Congestion avoidance
</span><span class='line'>Fast re-transmit
</span><span class='line'>Fast recovery</span></code></pre></td></tr></table></div></figure>


<p>然后下面主要是介绍了slow start和Congestion avoidance的一些实现细节。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CWND - Sender side limit
</span><span class='line'>RWND - Receiver side limit
</span><span class='line'>Slow start threshold ( SSTHRESH ) - Used to determine whether slow start is used or congestion avoidance
</span><span class='line'>When starting, probe slowly - IW &lt;= 2 * SMSS
</span><span class='line'>Initial size of SSTHRESH can be arbitrarily high, as high as the RWND
</span><span class='line'>Use slow start when SSTHRESH &gt; CWND. Else, use Congestion avoidance
</span><span class='line'>Slow start - CWND is increased by an amount less than or equal to the SMSS for every ACK
</span><span class='line'>Congestion avoidance - CWND += SMSS*SMSS/CWND
</span><span class='line'>When loss is detected - SSTHRESH = max( FlightSize/2, 2*SMSS )</span></code></pre></td></tr></table></div></figure>


<p>这里要注意在slow start中，窗口的大小是指数级的增长的。并且当cwnd(拥塞窗口)小于等于ssthresh，就是slow start模式，否则就执行Congestion avoidance。</p>

<h5>现在我们来看tcp_enter_loss的实现。</h5>

<p>首先来介绍下下面要用到的几个关键域的含义。<br/>
1 icsk->icsk_ca_state 这个域表示拥塞控制的状态。<br/>
2 tp->snd_una 这个域表示tcp滑动窗口中的发送未确认的第一个字节的序列号。<br/>
3 tp->prior_ssthresh 这个域表示前一个snd_ssthresh得大小，也就是说每次改变snd_ssthresh前都要保存老的snd_ssthresh到这个域。<br/>
4 tp->snd_ssthresh  slow start开始时的threshold大小<br/>
5 tp->snd_cwnd_cnt 这个域表示拥塞窗口的大小。<br/>
6 TCP_SKB_CB(skb)->sacked tcp数据中的sack标记。<br/>
7 tp->high_seq 拥塞开始时，snd_nxt的大小。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_enter_loss(struct sock *sk, int how)
</span><span class='line'>{
</span><span class='line'>&#9;const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&#9;/* 1 拥塞控制状态小于TCP_CA_Disorder
</span><span class='line'>&#9; * 2 发送未确认的序列号等于拥塞开始时的下一个将要发送的序列号
</span><span class='line'>&#9; * 3 状态为TCP_CA_Loss，并且还未重新传输过。
</span><span class='line'>&#9; * 如果有一个满足说明有数据丢失,因此降低threshold。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (icsk-&gt;icsk_ca_state &lt;= TCP_CA_Disorder || tp-&gt;snd_una == tp-&gt;high_seq ||
</span><span class='line'>&#9;&#9;(icsk-&gt;icsk_ca_state == TCP_CA_Loss && !icsk-&gt;icsk_retransmits)) {
</span><span class='line'>&#9;&#9;//保存老的snd_ssthresh。
</span><span class='line'>&#9;&#9;tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk);
</span><span class='line'>&#9;&#9;//减小snd_ssthresh
</span><span class='line'>&#9;&#9;tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);
</span><span class='line'>&#9;&#9;//设置拥塞状态。
</span><span class='line'>&#9;&#9;tcp_ca_event(sk, CA_EVENT_LOSS);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//设置拥塞窗口大小
</span><span class='line'>&#9;tp-&gt;snd_cwnd    = 1;
</span><span class='line'>&#9;tp-&gt;snd_cwnd_cnt   = 0;
</span><span class='line'>&#9;//设置时间
</span><span class='line'>&#9;tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
</span><span class='line'>
</span><span class='line'>&#9;tp-&gt;bytes_acked = 0;
</span><span class='line'>&#9;//清空所有相关的计数器。
</span><span class='line'>&#9;tcp_clear_retrans_partial(tp);
</span><span class='line'>
</span><span class='line'>&#9;if (tcp_is_reno(tp))
</span><span class='line'>&#9;&#9;tcp_reset_reno_sack(tp);
</span><span class='line'>
</span><span class='line'>&#9;if (!how) {
</span><span class='line'>&#9;&#9;/* Push undo marker, if it was plain RTO and nothing
</span><span class='line'>&#9;&#9; * was retransmitted. */
</span><span class='line'>&#9;&#9;tp-&gt;undo_marker = tp-&gt;snd_una;
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;tp-&gt;sacked_out = 0;
</span><span class='line'>&#9;&#9;tp-&gt;fackets_out = 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;tcp_clear_all_retrans_hints(tp);
</span><span class='line'>
</span><span class='line'>&#9;//遍历sock的write队列。
</span><span class='line'>&#9;tcp_for_write_queue(skb, sk) {
</span><span class='line'>&#9;&#9;if (skb == tcp_send_head(sk))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;//判断sack段。
</span><span class='line'>&#9;&#9;if (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_RETRANS)
</span><span class='line'>&#9;&#9;&#9;tp-&gt;undo_marker = 0;
</span><span class='line'>&#9;&#9;TCP_SKB_CB(skb)-&gt;sacked &= (~TCPCB_TAGBITS)|TCPCB_SACKED_ACKED;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//如果how为1,则说明不管sack段，此时标记所有的段为丢失(sack的意思去看tcp/ip详解).
</span><span class='line'>&#9;&#9;if (!(TCP_SKB_CB(skb)-&gt;sacked&TCPCB_SACKED_ACKED) || how) {
</span><span class='line'>&#9;&#9;&#9;//设置sack段。
</span><span class='line'>&#9;&#9;&#9;TCP_SKB_CB(skb)-&gt;sacked &= ~TCPCB_SACKED_ACKED;
</span><span class='line'>&#9;&#9;&#9;TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST;
</span><span class='line'>&#9;&#9;&#9;//update 相关的域。
</span><span class='line'>&#9;&#9;&#9;tp-&gt;lost_out += tcp_skb_pcount(skb);
</span><span class='line'>&#9;&#9;&#9;tp-&gt;retransmit_high = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;tcp_verify_left_out(tp);
</span><span class='line'>&#9;//设置当前的reordering的长度
</span><span class='line'>&#9;tp-&gt;reordering = min_t(unsigned int, tp-&gt;reordering,
</span><span class='line'>&#9;&#9;&#9;&#9;   sysctl_tcp_reordering);
</span><span class='line'>&#9;//设置拥塞状态。
</span><span class='line'>&#9;tcp_set_ca_state(sk, TCP_CA_Loss);
</span><span class='line'>&#9;tp-&gt;high_seq = tp-&gt;snd_nxt;
</span><span class='line'>&#9;//由于我们修改了拥塞窗口，因此设置ecn状态。
</span><span class='line'>&#9;TCP_ECN_queue_cwr(tp);
</span><span class='line'>&#9;/* Abort F-RTO algorithm if one is in progress */
</span><span class='line'>&#9;tp-&gt;frto_counter = 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接 下来来看零窗口探测定时器。至于为什么会出现零窗口，这里就不阐述了，详细的可以去看tcp/ip详解。我们知道当0窗口之后,客户机会等待服务器端的窗 口打开报文，可是由于ip是不可靠的，有可能这个报文会丢失，因此就需要客户机发送一个探测段，用来提醒服务器及时汇报当前的窗口大小。这里我们知道当对 端接收窗口关闭后，我们这边的发送窗口也会关闭，此时不能发送任何一般的数据，除了探测段。<br/>
在内核中是通过tcp_ack_probe来控制零窗口的定时器的。也就是说接收到对端的窗口报告数据后，会进入这个函数。我们来看实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_ack_probe(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;const struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&#9;//首先判断是否对端的接收窗口是否已经有空间。
</span><span class='line'>&#9;if (!after(TCP_SKB_CB(tcp_send_head(sk))-&gt;end_seq, tcp_wnd_end(tp))) {
</span><span class='line'>&#9;&#9;//如果有空间则删除零窗口探测定时器。
</span><span class='line'>&#9;&#9;icsk-&gt;icsk_backoff = 0;
</span><span class='line'>&#9;&#9;inet_csk_clear_xmit_timer(sk, ICSK_TIME_PROBE0);
</span><span class='line'>&#9;&#9;/* Socket must be waked up by subsequent tcp_data_snd_check().
</span><span class='line'>&#9;&#9; * This function is not for random using!
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;//否则启动定时器。
</span><span class='line'>&#9;&#9;inet_csk_reset_xmit_timer(sk, ICSK_TIME_PROBE0,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;  min(icsk-&gt;icsk_rto &lt;&lt; icsk-&gt;icsk_backoff, TCP_RTO_MAX),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;  TCP_RTO_MAX);
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们知道零窗口定时器和重传的定时器是一个定时器，只不过在回调函数中，进行event判断，从而进入不同的处理。而它调用的是tcp_probe_timer函数。<br/>
这个函数主要就是用来发送探测包，我们来看它的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_probe_timer(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;int max_probes;
</span><span class='line'>&#9;/* 1 tp-&gt;packets_out不为0说明，当定时器被安装之后，对端的接收窗口已经被打开。这* 时就不需要传输探测包。
</span><span class='line'>&#9; * 2 tcp_send_head用来检测是否有新的段被传输。
</span><span class='line'>&#9; * 如果上面有一个满足，则不需要发送探测包，并直接返回。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (tp-&gt;packets_out || !tcp_send_head(sk)) {
</span><span class='line'>&#9;&#9;icsk-&gt;icsk_probes_out = 0;
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//设置最大的重试次数。
</span><span class='line'>&#9;max_probes = sysctl_tcp_retries2;
</span><span class='line'>
</span><span class='line'>&#9;//这里的处理和上面的tcp_write_timeout很类似。
</span><span class='line'>&#9;if (sock_flag(sk, SOCK_DEAD)) {
</span><span class='line'>&#9;&#9;const int alive = ((icsk-&gt;icsk_rto &lt;&lt; icsk-&gt;icsk_backoff) &lt; TCP_RTO_MAX);
</span><span class='line'>
</span><span class='line'>&#9;&#9;max_probes = tcp_orphan_retries(sk, alive);
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (tcp_out_of_resources(sk, alive || icsk-&gt;icsk_probes_out &lt;= max_probes))
</span><span class='line'>&#9;&#9;&#9;return;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//如果重试次数大于最大的重试次数，则报错。
</span><span class='line'>&#9;if (icsk-&gt;icsk_probes_out &gt; max_probes) {
</span><span class='line'>&#9;&#9;tcp_write_err(sk);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;/* Only send another probe if we didn't close things up. */
</span><span class='line'>&#9;//否则发送探测包。这个函数里面会发送探测包，并重启定时器。
</span><span class='line'>&#9;&#9;tcp_send_probe0(sk);
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然 后来看delay ack定时器。所谓的delay ack也就是ack不会马上发送，而是等待一段时间和数据一起发送，这样就减少了一个数据包的发送。这里一般是将ack包含在tcp option中发送的。这里的定时器就是用来控制这段时间，如果定时器到期，都没有数据要发送给对端，此时单独发送这个ack。如果在定时器时间内，有数 据要发送，此时这个ack和数据一起发送给对端。<br/>
前面我们知道delay ack定时器的回调函数是tcp_delack_timer。在分析这个函数之前，我们先来看下这个定时器是什么时候被启动的。<br/>
首先我们知道内核接收数据都是在tcp_rcv_eastablished实现的，当我们接收完数据后，此时进入是否进行delay ack.<br/>
在tcp_rcv_eastablished最终会调用__tcp_ack_snd_check进行判断。<br/>
可以看到这个函数很简单，就是判断是否需要发送delay ack，如果是则tcp_send_delayed_ack，否则直接发送ack恢复给对端。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>/* 1 第一个判断表示多于一个的段在等待ack，并且我们的receive buf有足够的空间，
</span><span class='line'> *   这是因为这种情况，表明应用程序读取比较快，而对端的发送速度依赖于ack的到达时间，* 因此我们不希望对端减慢速度。
</span><span class='line'> * 2 这个sock处在quickack 模式
</span><span class='line'> * 3 我们有 out-of-order数据,此时必须马上给对端以确认。
</span><span class='line'> *   当上面的任意一个为真，则立即发送ack。
</span><span class='line'>**/
</span><span class='line'>&#9;if (((tp-&gt;rcv_nxt - tp-&gt;rcv_wup) &gt; inet_csk(sk)-&gt;icsk_ack.rcv_mss
</span><span class='line'>&#9;&#9; /* ... and right edge of window advances far enough.
</span><span class='line'>&#9;&#9;  * (tcp_recvmsg() will send ACK otherwise). Or...
</span><span class='line'>&#9;&#9;  */
</span><span class='line'>&#9;&#9; && __tcp_select_window(sk) &gt;= tp-&gt;rcv_wnd) ||
</span><span class='line'>&#9;&#9;/* We ACK each frame or... */
</span><span class='line'>&#9;&#9;tcp_in_quickack_mode(sk) ||
</span><span class='line'>&#9;&#9;/* We have out of order data. */
</span><span class='line'>&#9;&#9;(ofo_possible && skb_peek(&tp-&gt;out_of_order_queue))) {
</span><span class='line'>&#9;&#9;/* Then ack it now */
</span><span class='line'>&#9;&#9;tcp_send_ack(sk);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;/* Else, send delayed ack. */
</span><span class='line'>&#9;&#9;//在这里启动定时器。
</span><span class='line'>&#9;&#9;tcp_send_delayed_ack(sk);
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面还有一个tcp_in_quickack_mode，这个函数我们说了，它是用来判断是否处在quickack 模式。<br/>
来看这个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_in_quickack_mode(const struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>&#9;return icsk-&gt;icsk_ack.quick && !icsk-&gt;icsk_ack.pingpong;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中icsk->icsk_ack.pingpong域被设置的情况只有当tcp连接是交互式的，比如telnet等等。icsk->icsk_ack.quick表示能够 quickack的数量。
然后我们来看tcp_delack_timer的实现。<br/>
在看之前，我们要知道icsk->icsk_ack.pending表示的是当前的ack的状态。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_delack_timer(unsigned long data)
</span><span class='line'>{
</span><span class='line'>&#9;struct sock *sk = (struct sock *)data;
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>&#9;bh_lock_sock(sk);
</span><span class='line'>&#9;//用户进程正在使用，则等会再尝试。
</span><span class='line'>&#9;if (sock_owned_by_user(sk)) {
</span><span class='line'>&#9;&#9;/* Try again later. */
</span><span class='line'>&#9;&#9;icsk-&gt;icsk_ack.blocked = 1;
</span><span class='line'>&#9;&#9;NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKLOCKED);
</span><span class='line'>&#9;&#9;sk_reset_timer(sk, &icsk-&gt;icsk_delack_timer, jiffies + TCP_DELACK_MIN);
</span><span class='line'>&#9;&#9;goto out_unlock;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;sk_mem_reclaim_partial(sk);
</span><span class='line'>
</span><span class='line'>&#9;//判断sock状态 以及ack的状态。如果是close或者已经处在ICSK_ACK_TIMER，则直接跳出。
</span><span class='line'>&#9;if (sk-&gt;sk_state == TCP_CLOSE || !(icsk-&gt;icsk_ack.pending & ICSK_ACK_TIMER))
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;//如果已经超时，则重启定时器，并退出。
</span><span class='line'>&#9;if (time_after(icsk-&gt;icsk_ack.timeout, jiffies)) {
</span><span class='line'>&#9;&#9;sk_reset_timer(sk, &icsk-&gt;icsk_delack_timer, icsk-&gt;icsk_ack.timeout);
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//清除ack状态。
</span><span class='line'>&#9;icsk-&gt;icsk_ack.pending &= ~ICSK_ACK_TIMER;
</span><span class='line'>
</span><span class='line'>&#9;//开始遍历prequeue。此时主要的目的是为了调用tcp_rcv_eastablished.这里会调用tcp_ack_snd_check来发送ack。
</span><span class='line'>&#9;if (!skb_queue_empty(&tp-&gt;ucopy.prequeue)) {
</span><span class='line'>&#9;&#9;struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>&#9;&#9;NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSCHEDULERFAILED);
</span><span class='line'>
</span><span class='line'>&#9;&#9;//遍历prequeue队列，发送未发送的ack。
</span><span class='line'>&#9;&#9;while ((skb = __skb_dequeue(&tp-&gt;ucopy.prequeue)) != NULL)
</span><span class='line'>&#9;&#9;&#9;sk_backlog_rcv(sk, skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;tp-&gt;ucopy.memory = 0;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//检测是否有ack还需要被发送。也就是处于ICSK_ACK_SCHED状态的ack
</span><span class='line'>&#9;if (inet_csk_ack_scheduled(sk)) {
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!icsk-&gt;icsk_ack.pingpong) {
</span><span class='line'>&#9;&#9;&#9;/* Delayed ACK missed: inflate ATO. */
</span><span class='line'>&#9;&#9;&#9;icsk-&gt;icsk_ack.ato = min(icsk-&gt;icsk_ack.ato &lt;&lt; 1, icsk-&gt;icsk_rto);
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;//到这里说明已经长时间没有通信，并且处于交互模式。这个时候我们需要关闭pingpong模式。
</span><span class='line'>&#9;&#9;&#9;icsk-&gt;icsk_ack.pingpong = 0;
</span><span class='line'>&#9;&#9;&#9;icsk-&gt;icsk_ack.ato      = TCP_ATO_MIN;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//立即发送ack。
</span><span class='line'>&#9;&#9;tcp_send_ack(sk);
</span><span class='line'>&#9;&#9;NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKS);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;TCP_CHECK_TIMER(sk);
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>&#9;if (tcp_memory_pressure)
</span><span class='line'>&#9;&#9;sk_mem_reclaim(sk);
</span><span class='line'>out_unlock:
</span><span class='line'>&#9;bh_unlock_sock(sk);
</span><span class='line'>&#9;sock_put(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/70">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/68">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(40)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>23</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>13</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(51)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~haproxy/?opendiv=tools'>haproxy</a><a href='##' onmousedown=showDiv('tools~haproxy') id='aexp_tools~haproxy'><span class='exp_style' id='exp_tools~haproxy'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~haproxy')) document.getElementById('aexp_tools~haproxy').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(53)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~cgroup/?opendiv=system'>cgroup</a><a href='##' onmousedown=showDiv('system~cgroup') id='aexp_system~cgroup'><span class='exp_style' id='exp_system~cgroup'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~cgroup')) document.getElementById('aexp_system~cgroup').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~kvm/?opendiv=system'>kvm</a><a href='##' onmousedown=showDiv('system~kvm') id='aexp_system~kvm'><span class='exp_style' id='exp_system~kvm'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~kvm')) document.getElementById('aexp_system~kvm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~namespace/?opendiv=system'>namespace</a><a href='##' onmousedown=showDiv('system~namespace') id='aexp_system~namespace'><span class='exp_style' id='exp_system~namespace'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~namespace')) document.getElementById('aexp_system~namespace').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(159)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~fs/?opendiv=kernel'>fs</a><a href='##' onmousedown=showDiv('kernel~fs') id='aexp_kernel~fs'><span class='exp_style' id='exp_kernel~fs'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~fs')) document.getElementById('aexp_kernel~fs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>33</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>76</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>19</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(22)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(70)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>17</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~perf/?opendiv=debug'>perf</a><a href='##' onmousedown=showDiv('debug~perf') id='aexp_debug~perf'><span class='exp_style' id='exp_debug~perf'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~perf')) document.getElementById('aexp_debug~perf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(27)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>20</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2016/'>2016</a><a href='##' onmousedown=showDiv('2016')><span class='exp_style' id='exp_2016'>[+]</span></a><span class='right_span'>(4)</span></li>
<div id='2016' class='catsub'><li><a href='/blog/cats/2016~01/?opendiv=2016'>2016-01</a><span class='right_span'>4</span></li>
</div><li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(207)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~12/?opendiv=2015'>2015-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2015~11/?opendiv=2015'>2015-11</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2015~10/?opendiv=2015'>2015-10</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2015~09/?opendiv=2015'>2015-09</a><span class='right_span'>18</span></li>
<li><a href='/blog/cats/2015~08/?opendiv=2015'>2015-08</a><span class='right_span'>25</span></li>
<li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>31</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/12/kernel-base-rtc/">linux 实时时钟（RTC）驱动</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/12/debug-kdump-rtc/">kdump时间错误</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/06/debug-mark-rtc/">CentOS 5.x安装新内核之后时钟混乱问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/06/system-base-time/">linux系统时间和硬件时钟问题(date和hwclock)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/27/kernel-net-test-tool/">Web压力测试工具</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
	<li>
		<a href=http://smilejay.com/ target=_blank>smilejay</a>
	</li>
	<li>
		<a href=http://blog.chinaunix.net/uid/10167808.html target=_blank>godbach</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
