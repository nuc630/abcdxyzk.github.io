
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/10/10/debug-debugfs/">通过blktrace, debugfs分析磁盘IO</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-10-10T16:25:00+08:00'><span class='date'>2013-10-10</span> <span class='time'>16:25:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>如何通过blktrace+debugfs找到发生IO的文件，然后再结合自己的应用程序，分析出这些IO到底是 谁产生的，最终目的当然是尽量减少不必要的IO干扰，提高程序的性能。</p>

<p>blktrace是Jens Axobe写的一个跟踪IO请求的工具，Linux系统发起的IO请求都可以通过blktrace捕获并分析，关于这个工具的介绍请自行google之，这里推荐我们部门的<a href="http://blog.yufeng.info/">褚霸</a>同学的blog，里面有好几篇文章分别介绍了blktrace, blkparse以及blkiomon等工具的使用。</p>

<p>debugfs是ext2, ext3, ext4文件系统提供的文件系统访问工具，通过它我们可以不通过mount文件系统而直接访问文件系统的内容，它是e2fsprogs的一部分，默认应该都是安装的，详细的说明可以通过man debugfs得到。</p>

<p>下面我来演示一下如何通过这两个工具的配合来找到磁盘IO的源头。</p>

<p>先看一个简单的例子：<br/>
在一个终端会输入如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while [ 1 ];do dd if=/dev/zero of=test_file bs=4k count=20 seek=$RANDOM oflag=sync;done</span></code></pre></td></tr></table></div></figure>


<p>随机的在test_file里面写数据造成较大的IO压力，现在看看如何通过blktrace和debugfs抓到它。</p>

<p>1、通过iostat观察到有很大的磁盘压力</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
</span><span class='line'>sdb               0.00  2759.00    0.00 3515.50     0.00 50196.00    14.28     0.90    0.26   0.24  85.70</span></code></pre></td></tr></table></div></figure>


<p>2、我们看到sdb压力很大，这时候就需要通过blktrace抓取对应盘的数据<br/>
  blktrace /dev/sdb   有IO压力的时候一会儿就可以了，通过ctrl+c停止抓取。<br/>
  blktrace是需要debugfs支持的，如果系统提示debugfs没有mount，需要先mount上<br/>
  mount -t debugfs none /sys/kernel/debug 再执行blktrace命令</p>

<p>3、将blktrace抓出来的二进制文件转成文本格式。<br/>
  blkparse sdb.blktrace.* > 1.log<br/>
或blktrace  -d /dev/sda -o - |blkparse -i - > 1.log</p>

<p>4、开始分析日志</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  grep ‘ A ‘ 1.log|head -n 5
</span><span class='line'>
</span><span class='line'>8,16   0       39     0.001242727  2872  A  WS 420143 + 8 &lt;- (8,17) 420080
</span><span class='line'>8,16   0       52     0.001361766  2872  A  WS 420151 + 8 &lt;- (8,17) 420088
</span><span class='line'>8,16   0       65     0.001440210  2872  A  WS 420159 + 8 &lt;- (8,17) 420096
</span><span class='line'>8,16   0       78     0.001518207  2872  A  WS 420167 + 8 &lt;- (8,17) 420104
</span><span class='line'>8,16   0       91     0.001596083  2872  A  WS 420175 + 8 &lt;- (8,17) 420112</span></code></pre></td></tr></table></div></figure>


<p>为啥要grep ‘ A ‘呢？因为这条信息是上层一个读写请求进入到Linux IO协议栈的第一步，只有在这里我们可以看到清晰的请求原始信息。比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>8,16   0       39     0.001242727  2872  A  WS 420143 + 8 &lt;- (8,17) 420080</span></code></pre></td></tr></table></div></figure>


<p>这条说明是设备（8，17）也就是sdb1上产生的扇区为420080的写请求（读请求的话会在WS对应的位置出现‘R’），长度是8，它被映射到（8，16）上位置为420143。这个IO请求的完整生命周期是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 8,16   0       39     0.001242727  2872  A  WS 420143 + 8 &lt;- (8,17) 420080
</span><span class='line'> 8,16   0       41     0.001244984  2872  G  WS 420143 + 8 [dd]
</span><span class='line'> 8,16   0       43     0.001246609  2872  I  WS 420143 + 8 [dd]
</span><span class='line'> 8,16   0       45     0.001255064  2872  D  WS 420143 + 8 [dd]
</span><span class='line'> 8,16   0       46     0.001325168     0  C  WS 420143 + 8 [0]</span></code></pre></td></tr></table></div></figure>


<p>可以看到从’ A ‘的下一条开始都是以整个设备的扇区号为标识的，不方便我们找到对应的分区。</p>

<p>5、下面就开始通过debugfs来分析这条读写请求的来源了。
(8, 17)是sdb1, 420080是扇区号(IO层的基本单位是扇区sector，大小是512bytes)，而文件系统层是通过块block来管理的，一般的 ext3,ext4的块block大小是4096[1]，由此可得这个请求对应到文件系统的块block号是420080/8=52510, debugfs提供了命令icheck可以通过block号找到它对应的文件的inode。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#debugfs -R ‘icheck 52510′ /dev/sdb1
</span><span class='line'>debugfs 1.43-WIP (1-Aug-2012)
</span><span class='line'>Block Inode number
</span><span class='line'>52510 12</span></code></pre></td></tr></table></div></figure>


<p>6、通过inode number找到对应的文件名，很幸运，debugfs又提供了另外一条命令ncheck可以找到inode对应的文件名[2]。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#debugfs -R ‘ncheck 12′ /dev/sdb1
</span><span class='line'>debugfs 1.43-WIP (1-Aug-2012)
</span><span class='line'>Inode Pathname
</span><span class='line'>12 //test_file</span></code></pre></td></tr></table></div></figure>


<p>大家可以看到，我们现在已经成功找到了test_file这个文件啦，至此块设备层和文件系统层的分析工作已经结束了，下面就可以结合应用看看为啥会对这个文件有如此频繁的读写操作了！</p>

<p>[1] 块大小实际上也能够通过debugfs来得到。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>debugfs -R ‘stats’ /dev/sdb1|grep “Block size”</span></code></pre></td></tr></table></div></figure>


<p>[2] 有的同学找到的inode number是8，然后却无法找到对应的文件名。这是因为8是ext3/4文件系统中的日志文件的inode，它是隐藏文件，所以无法找到，可以再试试其他的block号哦！</p>

<p>根据inode你就可以找到对应的文件是什么了<br/>
find / -inum your_inode</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/27/kernel-net-tcp-timer/">内核tcp的定时器管理</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-27T16:11:00+08:00'><span class='date'>2013-09-27</span> <span class='time'>16:11:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h5>在内核中tcp协议栈有6种类型的定时器：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 重传定时器。
</span><span class='line'>2 delayed ack定时器
</span><span class='line'>3 零窗口探测定时器
</span><span class='line'>上面三种定时器都是作为tcp状态机的一部分来实现的。
</span><span class='line'>4 keep-alive 定时器 主要是管理established状态的连接。
</span><span class='line'>5 time_wait定时器 主要是用来客户端关闭时的time_wait状态用到。
</span><span class='line'>6 syn-ack定时器(主要是用在listening socket) 管理新的连接请求时所用到。</span></code></pre></td></tr></table></div></figure>


<h5>而在内核中，tcp协议栈管理定时器主要有下面4个函数：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inet_csk_reset_xmit_timer    这个函数是用来重启定时器
</span><span class='line'>inet_csk_clear_xmit_timer 这个函数用来删除定时器。
</span><span class='line'>上面两个函数都是针对状态机里面的定时器。
</span><span class='line'>tcp_set_keepalive 这个函数是用来管理keepalive 定时器的接口。
</span><span class='line'>tcp_synack_timer  这个函数是用来管理syn_ack定时器的接口。</span></code></pre></td></tr></table></div></figure>


<h5>先来看定时器的初始化。</h5>

<p>首先是在tcp_v4_init_sock中对定时器的初始化，它会调用tcp_init_xmit_timers，我们就先来看这个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_init_xmit_timers(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    inet_csk_init_xmit_timers(sk, &tcp_write_timer, &tcp_delack_timer, &tcp_keepalive_timer);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到这个函数很简单，就是调用inet_csk_init_xmit_timers,然后把3个定时器的回掉函数传递进去，下面我们来看inet_csk_init_xmit_timers。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void inet_csk_init_xmit_timers(struct sock *sk,
</span><span class='line'>                    void (*retransmit_handler)(unsigned long),
</span><span class='line'>                    void (*delack_handler)(unsigned long),
</span><span class='line'>                    void (*keepalive_handler)(unsigned long))
</span><span class='line'>{
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>    //安装定时器，设置定时器的回掉函数。
</span><span class='line'>    setup_timer(&icsk-&gt;icsk_retransmit_timer, retransmit_handler, (unsigned long)sk);
</span><span class='line'>    setup_timer(&icsk-&gt;icsk_delack_timer, delack_handler, (unsigned long)sk);
</span><span class='line'>    setup_timer(&sk-&gt;sk_timer, keepalive_handler, (unsigned long)sk);
</span><span class='line'>    icsk-&gt;icsk_pending = icsk-&gt;icsk_ack.pending = 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我 们可以看到icsk->icsk_retransmit_timer定时器，也就是重传定时器的回调函数是tcp_write_timer,而 icsk->icsk_delack_timer定时器也就是delayed-ack 定时器的回调函数是tcp_delack_timer,最后sk->sk_timer也就是keepalive定时器的回掉函数是 tcp_keepalive_timer.<br/>
这里还有一个要注意的，tcp_write_timer还会处理0窗口定时器。<br/>
这里有关内核定时器的一些基础的东西我就不介绍了，想了解的可以去看下ldd第三版。<br/>
接下来我们就来一个个的分析这6个定时器，首先是重传定时器。<br/>
我们知道4层最终调用tcp_xmit_write来讲数据发送到3层，并且tcp是字节流的，因此每次他总是发送一段数据到3层，而每次当它发送完毕(返回正确),则它就会启动重传定时器，我们来看代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_write_xmit(struct sock *sk, unsigned int mss_now, int nonagle,
</span><span class='line'>              int push_one, gfp_t gfp)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>    unsigned int tso_segs, sent_pkts;
</span><span class='line'>    int cwnd_quota;
</span><span class='line'>    int result;
</span><span class='line'>
</span><span class='line'>.............................................
</span><span class='line'>
</span><span class='line'>    while ((skb = tcp_send_head(sk))) {
</span><span class='line'>..................................................
</span><span class='line'>
</span><span class='line'>        //可以看到只有当传输成功，我们才会走到下面的函数。
</span><span class='line'>        if (unlikely(tcp_transmit_skb(sk, skb, 1, gfp)))
</span><span class='line'>            break;
</span><span class='line'>
</span><span class='line'>        /* Advance the send_head.  This one is sent out.
</span><span class='line'>         * This call will increment packets_out.
</span><span class='line'>         */
</span><span class='line'>        //最终在这个函数中启动重传定时器。
</span><span class='line'>        tcp_event_new_data_sent(sk, skb);
</span><span class='line'>
</span><span class='line'>        tcp_minshall_update(tp, mss_now, skb);
</span><span class='line'>        sent_pkts++;
</span><span class='line'>
</span><span class='line'>        if (push_one)
</span><span class='line'>            break;
</span><span class='line'>    }
</span><span class='line'>...........................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在我们来看tcp_event_new_data_sent,如何启动定时器的.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_event_new_data_sent(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    unsigned int prior_packets = tp-&gt;packets_out;
</span><span class='line'>
</span><span class='line'>    tcp_advance_send_head(sk, skb);
</span><span class='line'>    tp-&gt;snd_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>
</span><span class='line'>    /* Don't override Nagle indefinately with F-RTO */
</span><span class='line'>    if (tp-&gt;frto_counter == 2)
</span><span class='line'>        tp-&gt;frto_counter = 3;
</span><span class='line'>    //关键在这里.
</span><span class='line'>    tp-&gt;packets_out += tcp_skb_pcount(skb);
</span><span class='line'>    if (!prior_packets)
</span><span class='line'>        inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到只有当prior_packets为0时才会重启定时器,而prior_packets则是发送未确认的段的个数,也就是说如果发送了很多段,如果前面的段没有确认,那么后面发送的时候不会重启这个定时器.<br/>
我们要知道，定时器的间隔是通过rtt来得到的，具体的算法，可以看下tcp/ip详解。<br/>
当 启动了重传定时器，我们就会等待ack的到来，如果超时还没到来，那么就调用重传定时器的回调函数，否则最终会调用tcp_rearm_rto来删除或者 重启定时器，这个函数是在tcp_ack()->tcp_clean_rtx_queue()中被调用的。tcp_ack是专门用来处理ack。<br/>
这个函数很简单，就是通过判断packets_out，这个值表示当前还未确认的段的个数。然后来进行相关操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_rearm_rto(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>    //为0说明所有的传输的段都已经acked。此时remove定时器。否则重启定时器。
</span><span class='line'>    if (!tp-&gt;packets_out) {
</span><span class='line'>        inet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);
</span><span class='line'>    } else {
</span><span class='line'>        inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
</span><span class='line'>                      inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  接下来来看tcp_write_timer的实现。这个函数主要是通过icsk->icsk_pending来判断是那个定时器导致超时，这里只有两 种，一种是ICSK_TIME_RETRANS，也就是重传定时器，另一种是ICSK_TIME_PROBE0也就是0窗口定时器。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define ICSK_TIME_RETRANS   1   /* Retransmit timer */
</span><span class='line'>#define ICSK_TIME_PROBE0    3   /* Zero window probe timer */
</span><span class='line'>static void tcp_write_timer(unsigned long data)
</span><span class='line'>{
</span><span class='line'>    struct sock *sk = (struct sock *)data;
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    int event;
</span><span class='line'>
</span><span class='line'>    //首先加锁。
</span><span class='line'>    bh_lock_sock(sk);
</span><span class='line'>    //如果是进程空间则什么也不做。
</span><span class='line'>    if (sock_owned_by_user(sk)) {
</span><span class='line'>        /* Try again later */
</span><span class='line'>        sk_reset_timer(sk, &icsk-&gt;icsk_retransmit_timer, jiffies + (HZ / 20));
</span><span class='line'>        goto out_unlock;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //如果状态为close或者icsk_pending为空，则什么也不做。
</span><span class='line'>    if (sk-&gt;sk_state == TCP_CLOSE || !icsk-&gt;icsk_pending)
</span><span class='line'>        goto out;
</span><span class='line'>    //如果超时时间已经过了，则重启定时器。
</span><span class='line'>
</span><span class='line'>    if (time_after(icsk-&gt;icsk_timeout, jiffies)) {
</span><span class='line'>        sk_reset_timer(sk, &icsk-&gt;icsk_retransmit_timer, icsk-&gt;icsk_timeout);
</span><span class='line'>        goto out;
</span><span class='line'>    }
</span><span class='line'>    //取出定时器类型。
</span><span class='line'>    event = icsk-&gt;icsk_pending;
</span><span class='line'>    icsk-&gt;icsk_pending = 0;
</span><span class='line'>
</span><span class='line'>    //通过判断event来确定进入那个函数进行处理。
</span><span class='line'>    switch (event) {
</span><span class='line'>    case ICSK_TIME_RETRANS:
</span><span class='line'>        tcp_retransmit_timer(sk);
</span><span class='line'>        break;
</span><span class='line'>    case ICSK_TIME_PROBE0:
</span><span class='line'>        tcp_probe_timer(sk);
</span><span class='line'>        break;
</span><span class='line'>    }
</span><span class='line'>    TCP_CHECK_TIMER(sk);
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>    sk_mem_reclaim(sk);
</span><span class='line'>out_unlock:
</span><span class='line'>    bh_unlock_sock(sk);
</span><span class='line'>    sock_put(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们这里只看重传定时器，0窗口定时器后面紧接着会介绍。<br/>
tcp_retransmit_timer,这个函数用来处理数据段的重传。<br/>
这里要注意，重传的时候为了防止确认二义性，使用karn算法，也就是定时器退避策略。下面的代码最后部分会修改定时器的值，这里是增加一倍。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_retransmit_timer(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>    //如果没有需要确认的段，则什么也不做。
</span><span class='line'>    if (!tp-&gt;packets_out)
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    WARN_ON(tcp_write_queue_empty(sk));
</span><span class='line'>
</span><span class='line'>    /**首先进行一些合法性判断，其中:
</span><span class='line'>     * snd_wnd为窗口大小。
</span><span class='line'>     * sock_flag用来判断sock的状态。
</span><span class='line'>     * 最后一个判断是当前的连接状态不能处于syn_sent和syn_recv状态,也就是连接还未建
</span><span class='line'>     * 立状态.
</span><span class='line'>    if (!tp-&gt;snd_wnd && !sock_flag(sk, SOCK_DEAD) &&
</span><span class='line'>        !((1 &lt;&lt; sk-&gt;sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV))) {
</span><span class='line'>        //tcp_time_stamp也就是jifes，而rcv_tstamp表示最后一个ack接收的时间，也就是最后一次对端确认的时间。因此这两个时间之差不能大于tcp_rto_max,因为tcp_rto_max为我们重传定时器的间隔时间的最大值。
</span><span class='line'>        if (tcp_time_stamp - tp-&gt;rcv_tstamp &gt; TCP_RTO_MAX) {
</span><span class='line'>            tcp_write_err(sk);
</span><span class='line'>            goto out;
</span><span class='line'>        }
</span><span class='line'>        //这个函数用来进入loss状态，也就是进行一些拥塞以及流量的控制。
</span><span class='line'>        tcp_enter_loss(sk, 0);
</span><span class='line'>        //现在开始重传skb。
</span><span class='line'>        tcp_retransmit_skb(sk, tcp_write_queue_head(sk));
</span><span class='line'>        __sk_dst_reset(sk);
</span><span class='line'>        //然后重启定时器，继续等待ack的到来。
</span><span class='line'>        goto out_reset_timer;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //程序到达这里说明上面的校验失败，因此下面这个函数用来判断我们重传需要的次数。如果超过了重传次数，直接跳转到out。
</span><span class='line'>    if (tcp_write_timeout(sk))
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    //到达这里说明我们重传的次数还没到。icsk-&gt;icsk_retransmits表示重传的次数。
</span><span class='line'>    if (icsk-&gt;icsk_retransmits == 0) {
</span><span class='line'>        //这里其实也就是收集一些统计信息。
</span><span class='line'>        int mib_idx;
</span><span class='line'>
</span><span class='line'>        if (icsk-&gt;icsk_ca_state == TCP_CA_Disorder) {
</span><span class='line'>            if (tcp_is_sack(tp))
</span><span class='line'>                mib_idx = LINUX_MIB_TCPSACKFAILURES;
</span><span class='line'>            else
</span><span class='line'>                mib_idx = LINUX_MIB_TCPRENOFAILURES;
</span><span class='line'>        } else if (icsk-&gt;icsk_ca_state == TCP_CA_Recovery) {
</span><span class='line'>            if (tcp_is_sack(tp))
</span><span class='line'>                mib_idx = LINUX_MIB_TCPSACKRECOVERYFAIL;
</span><span class='line'>            else
</span><span class='line'>                mib_idx = LINUX_MIB_TCPRENORECOVERYFAIL;
</span><span class='line'>        } else if (icsk-&gt;icsk_ca_state == TCP_CA_Loss) {
</span><span class='line'>            mib_idx = LINUX_MIB_TCPLOSSFAILURES;
</span><span class='line'>        } else {
</span><span class='line'>            mib_idx = LINUX_MIB_TCPTIMEOUTS;
</span><span class='line'>        }
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), mib_idx);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //是否使用f-rto算法。
</span><span class='line'>    if (tcp_use_frto(sk)) {
</span><span class='line'>        tcp_enter_frto(sk);
</span><span class='line'>    } else {
</span><span class='line'>        //否则处理sack.
</span><span class='line'>        tcp_enter_loss(sk, 0);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 再次尝试重传队列的第一个段。
</span><span class='line'>    if (tcp_retransmit_skb(sk, tcp_write_queue_head(sk)) &gt; 0) {
</span><span class='line'>        //重传失败。
</span><span class='line'>        if (!icsk-&gt;icsk_retransmits)
</span><span class='line'>            icsk-&gt;icsk_retransmits = 1;
</span><span class='line'>        inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
</span><span class='line'>                      min(icsk-&gt;icsk_rto, TCP_RESOURCE_PROBE_INTERVAL),
</span><span class='line'>                      TCP_RTO_MAX);
</span><span class='line'>        goto out;
</span><span class='line'>    }
</span><span class='line'>    //icsk-&gt;icsk_backoff主要用在零窗口定时器。
</span><span class='line'>    icsk-&gt;icsk_backoff++;
</span><span class='line'>    //icsk_retransmits也就是重试次数。
</span><span class='line'>    icsk-&gt;icsk_retransmits++;
</span><span class='line'>
</span><span class='line'>out_reset_timer:
</span><span class='line'>    //计算rto，并重启定时器，这里使用karn算法，也就是下次超时时间增加一倍/
</span><span class='line'>    icsk-&gt;icsk_rto = min(icsk-&gt;icsk_rto &lt;&lt; 1, TCP_RTO_MAX);
</span><span class='line'>    //重启定时器，可以看到超时时间就是我们上面的icsk_rto.
</span><span class='line'>    inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, icsk-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>    if (icsk-&gt;icsk_retransmits &gt; sysctl_tcp_retries1)
</span><span class='line'>        __sk_dst_reset(sk);
</span><span class='line'>
</span><span class='line'>out:;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面我们来看tcp_write_timeout，它用来判断重传次数是否已经到了。这里主要分为两个分支，一个是状态为syn_sent或者syn_recv状态，一个是另外的状态。而这里系统设置的重传次数一共有4种。<br/>
1 sysctl_tcp_syn_retries，它表示syn分节的重传次数。<br/>
2 sysctl_tcp_retries1 它表示的是最大的重试次数，当超过了这个值，我们就需要检测路由表了。<br/>
3 sysctl_tcp_retries2 这个值也是表示重试最大次数，只不过这个值一般要比上面的值大。和上面那个不同的是，当重试次数超过这个值，我们就必须放弃重试了。<br/>
4 sysctl_tcp_orphan_retries 主要是针对孤立的socket(也就是已经从进程上下文中删除了，可是还有一些清理工作没有完成).对于这种socket，我们重试的最大的次数就是它。<br/>
下面来看代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_write_timeout(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    //retry_untry表示我们需要重传的最大次数。
</span><span class='line'>    int retry_until;
</span><span class='line'>
</span><span class='line'>    //判断socket状态。
</span><span class='line'>    if ((1 &lt;&lt; sk-&gt;sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
</span><span class='line'>        if (icsk-&gt;icsk_retransmits)
</span><span class='line'>            dst_negative_advice(&sk-&gt;sk_dst_cache);
</span><span class='line'>        //设置重传最大值
</span><span class='line'>        retry_until = icsk-&gt;icsk_syn_retries ? : sysctl_tcp_syn_retries;
</span><span class='line'>    } else {
</span><span class='line'>        //是否需要检测路由表。
</span><span class='line'>        if (icsk-&gt;icsk_retransmits &gt;= sysctl_tcp_retries1) {
</span><span class='line'>            /* Black hole detection */
</span><span class='line'>            tcp_mtu_probing(icsk, sk);
</span><span class='line'>
</span><span class='line'>            dst_negative_advice(&sk-&gt;sk_dst_cache);
</span><span class='line'>        }
</span><span class='line'>        //设置重传最大次数为sysctl_tcp_retries2
</span><span class='line'>        retry_until = sysctl_tcp_retries2;
</span><span class='line'>        if (sock_flag(sk, SOCK_DEAD)) {
</span><span class='line'>            //表示是一个孤立的socket。
</span><span class='line'>            const int alive = (icsk-&gt;icsk_rto &lt; TCP_RTO_MAX);
</span><span class='line'>
</span><span class='line'>            //从tcp_orphan_retries(这个函数中会通过sysctl_tcp_orphan_retries来进行计算)中取得重传最大次数。
</span><span class='line'>            retry_until = tcp_orphan_retries(sk, alive);
</span><span class='line'>
</span><span class='line'>            if (tcp_out_of_resources(sk, alive || icsk-&gt;icsk_retransmits &lt; retry_until))
</span><span class='line'>                return 1;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //最终进行判断，如果重传次数已到则返回1,否则为0.
</span><span class='line'>    if (icsk-&gt;icsk_retransmits &gt;= retry_until) {
</span><span class='line'>        /* Has it gone just too far? */
</span><span class='line'>        tcp_write_err(sk);
</span><span class='line'>        return 1;
</span><span class='line'>    }
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面来介绍下tcp_enter_loss，这个函数主要用来标记丢失的段(也就是没有acked的段),然后通过执行slow start来降低传输速率.<br/>
有关slow start以及Congestion avoidance算法描述可以看rfc2001:<br/>
<a href="http://www.faqs.org/rfcs/rfc2001.html">http://www.faqs.org/rfcs/rfc2001.html</a></p>

<p>下面4个算法主要是用来对拥塞进行控制的，这四个算法其实都是彼此相连的。slow start和Congestion avoidance使用了相同的机制，他们都涉及到了拥塞窗口的定义。其中拥塞窗口限制着传输的长度，它的大小根据拥塞程度上升或者下降。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Slow start
</span><span class='line'>Congestion avoidance
</span><span class='line'>Fast re-transmit
</span><span class='line'>Fast recovery</span></code></pre></td></tr></table></div></figure>


<p>然后下面主要是介绍了slow start和Congestion avoidance的一些实现细节。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CWND - Sender side limit
</span><span class='line'>RWND - Receiver side limit
</span><span class='line'>Slow start threshold ( SSTHRESH ) - Used to determine whether slow start is used or congestion avoidance
</span><span class='line'>When starting, probe slowly - IW &lt;= 2 * SMSS
</span><span class='line'>Initial size of SSTHRESH can be arbitrarily high, as high as the RWND
</span><span class='line'>Use slow start when SSTHRESH &gt; CWND. Else, use Congestion avoidance
</span><span class='line'>Slow start - CWND is increased by an amount less than or equal to the SMSS for every ACK
</span><span class='line'>Congestion avoidance - CWND += SMSS*SMSS/CWND
</span><span class='line'>When loss is detected - SSTHRESH = max( FlightSize/2, 2*SMSS )</span></code></pre></td></tr></table></div></figure>


<p>这里要注意在slow start中，窗口的大小是指数级的增长的。并且当cwnd(拥塞窗口)小于等于ssthresh，就是slow start模式，否则就执行Congestion avoidance。</p>

<h5>现在我们来看tcp_enter_loss的实现。</h5>

<p>首先来介绍下下面要用到的几个关键域的含义。<br/>
1 icsk->icsk_ca_state 这个域表示拥塞控制的状态。<br/>
2 tp->snd_una 这个域表示tcp滑动窗口中的发送未确认的第一个字节的序列号。<br/>
3 tp->prior_ssthresh 这个域表示前一个snd_ssthresh得大小，也就是说每次改变snd_ssthresh前都要保存老的snd_ssthresh到这个域。<br/>
4 tp->snd_ssthresh  slow start开始时的threshold大小<br/>
5 tp->snd_cwnd_cnt 这个域表示拥塞窗口的大小。<br/>
6 TCP_SKB_CB(skb)->sacked tcp数据中的sack标记。<br/>
7 tp->high_seq 拥塞开始时，snd_nxt的大小。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_enter_loss(struct sock *sk, int how)
</span><span class='line'>{
</span><span class='line'>    const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    /* 1 拥塞控制状态小于TCP_CA_Disorder
</span><span class='line'>     * 2 发送未确认的序列号等于拥塞开始时的下一个将要发送的序列号
</span><span class='line'>     * 3 状态为TCP_CA_Loss，并且还未重新传输过。
</span><span class='line'>     * 如果有一个满足说明有数据丢失,因此降低threshold。
</span><span class='line'>     */
</span><span class='line'>    if (icsk-&gt;icsk_ca_state &lt;= TCP_CA_Disorder || tp-&gt;snd_una == tp-&gt;high_seq ||
</span><span class='line'>        (icsk-&gt;icsk_ca_state == TCP_CA_Loss && !icsk-&gt;icsk_retransmits)) {
</span><span class='line'>        //保存老的snd_ssthresh。
</span><span class='line'>        tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk);
</span><span class='line'>        //减小snd_ssthresh
</span><span class='line'>        tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);
</span><span class='line'>        //设置拥塞状态。
</span><span class='line'>        tcp_ca_event(sk, CA_EVENT_LOSS);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //设置拥塞窗口大小
</span><span class='line'>    tp-&gt;snd_cwnd    = 1;
</span><span class='line'>    tp-&gt;snd_cwnd_cnt   = 0;
</span><span class='line'>    //设置时间
</span><span class='line'>    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
</span><span class='line'>
</span><span class='line'>    tp-&gt;bytes_acked = 0;
</span><span class='line'>    //清空所有相关的计数器。
</span><span class='line'>    tcp_clear_retrans_partial(tp);
</span><span class='line'>
</span><span class='line'>    if (tcp_is_reno(tp))
</span><span class='line'>        tcp_reset_reno_sack(tp);
</span><span class='line'>
</span><span class='line'>    if (!how) {
</span><span class='line'>        /* Push undo marker, if it was plain RTO and nothing
</span><span class='line'>         * was retransmitted. */
</span><span class='line'>        tp-&gt;undo_marker = tp-&gt;snd_una;
</span><span class='line'>    } else {
</span><span class='line'>        tp-&gt;sacked_out = 0;
</span><span class='line'>        tp-&gt;fackets_out = 0;
</span><span class='line'>    }
</span><span class='line'>    tcp_clear_all_retrans_hints(tp);
</span><span class='line'>
</span><span class='line'>    //遍历sock的write队列。
</span><span class='line'>    tcp_for_write_queue(skb, sk) {
</span><span class='line'>        if (skb == tcp_send_head(sk))
</span><span class='line'>            break;
</span><span class='line'>        //判断sack段。
</span><span class='line'>        if (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_RETRANS)
</span><span class='line'>            tp-&gt;undo_marker = 0;
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;sacked &= (~TCPCB_TAGBITS)|TCPCB_SACKED_ACKED;
</span><span class='line'>
</span><span class='line'>        //如果how为1,则说明不管sack段，此时标记所有的段为丢失(sack的意思去看tcp/ip详解).
</span><span class='line'>        if (!(TCP_SKB_CB(skb)-&gt;sacked&TCPCB_SACKED_ACKED) || how) {
</span><span class='line'>            //设置sack段。
</span><span class='line'>            TCP_SKB_CB(skb)-&gt;sacked &= ~TCPCB_SACKED_ACKED;
</span><span class='line'>            TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST;
</span><span class='line'>            //update 相关的域。
</span><span class='line'>            tp-&gt;lost_out += tcp_skb_pcount(skb);
</span><span class='line'>            tp-&gt;retransmit_high = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    tcp_verify_left_out(tp);
</span><span class='line'>    //设置当前的reordering的长度
</span><span class='line'>    tp-&gt;reordering = min_t(unsigned int, tp-&gt;reordering,
</span><span class='line'>                   sysctl_tcp_reordering);
</span><span class='line'>    //设置拥塞状态。
</span><span class='line'>    tcp_set_ca_state(sk, TCP_CA_Loss);
</span><span class='line'>    tp-&gt;high_seq = tp-&gt;snd_nxt;
</span><span class='line'>    //由于我们修改了拥塞窗口，因此设置ecn状态。
</span><span class='line'>    TCP_ECN_queue_cwr(tp);
</span><span class='line'>    /* Abort F-RTO algorithm if one is in progress */
</span><span class='line'>    tp-&gt;frto_counter = 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接 下来来看零窗口探测定时器。至于为什么会出现零窗口，这里就不阐述了，详细的可以去看tcp/ip详解。我们知道当0窗口之后,客户机会等待服务器端的窗 口打开报文，可是由于ip是不可靠的，有可能这个报文会丢失，因此就需要客户机发送一个探测段，用来提醒服务器及时汇报当前的窗口大小。这里我们知道当对 端接收窗口关闭后，我们这边的发送窗口也会关闭，此时不能发送任何一般的数据，除了探测段。<br/>
在内核中是通过tcp_ack_probe来控制零窗口的定时器的。也就是说接收到对端的窗口报告数据后，会进入这个函数。我们来看实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_ack_probe(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    const struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    //首先判断是否对端的接收窗口是否已经有空间。
</span><span class='line'>    if (!after(TCP_SKB_CB(tcp_send_head(sk))-&gt;end_seq, tcp_wnd_end(tp))) {
</span><span class='line'>        //如果有空间则删除零窗口探测定时器。
</span><span class='line'>        icsk-&gt;icsk_backoff = 0;
</span><span class='line'>        inet_csk_clear_xmit_timer(sk, ICSK_TIME_PROBE0);
</span><span class='line'>        /* Socket must be waked up by subsequent tcp_data_snd_check().
</span><span class='line'>         * This function is not for random using!
</span><span class='line'>         */
</span><span class='line'>    } else {
</span><span class='line'>        //否则启动定时器。
</span><span class='line'>        inet_csk_reset_xmit_timer(sk, ICSK_TIME_PROBE0,
</span><span class='line'>                      min(icsk-&gt;icsk_rto &lt;&lt; icsk-&gt;icsk_backoff, TCP_RTO_MAX),
</span><span class='line'>                      TCP_RTO_MAX);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们知道零窗口定时器和重传的定时器是一个定时器，只不过在回调函数中，进行event判断，从而进入不同的处理。而它调用的是tcp_probe_timer函数。<br/>
这个函数主要就是用来发送探测包，我们来看它的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_probe_timer(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    int max_probes;
</span><span class='line'>    /* 1 tp-&gt;packets_out不为0说明，当定时器被安装之后，对端的接收窗口已经被打开。这* 时就不需要传输探测包。
</span><span class='line'>     * 2 tcp_send_head用来检测是否有新的段被传输。
</span><span class='line'>     * 如果上面有一个满足，则不需要发送探测包，并直接返回。
</span><span class='line'>     */
</span><span class='line'>    if (tp-&gt;packets_out || !tcp_send_head(sk)) {
</span><span class='line'>        icsk-&gt;icsk_probes_out = 0;
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //设置最大的重试次数。
</span><span class='line'>    max_probes = sysctl_tcp_retries2;
</span><span class='line'>
</span><span class='line'>    //这里的处理和上面的tcp_write_timeout很类似。
</span><span class='line'>    if (sock_flag(sk, SOCK_DEAD)) {
</span><span class='line'>        const int alive = ((icsk-&gt;icsk_rto &lt;&lt; icsk-&gt;icsk_backoff) &lt; TCP_RTO_MAX);
</span><span class='line'>
</span><span class='line'>        max_probes = tcp_orphan_retries(sk, alive);
</span><span class='line'>
</span><span class='line'>        if (tcp_out_of_resources(sk, alive || icsk-&gt;icsk_probes_out &lt;= max_probes))
</span><span class='line'>            return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //如果重试次数大于最大的重试次数，则报错。
</span><span class='line'>    if (icsk-&gt;icsk_probes_out &gt; max_probes) {
</span><span class='line'>        tcp_write_err(sk);
</span><span class='line'>    } else {
</span><span class='line'>        /* Only send another probe if we didn't close things up. */
</span><span class='line'>    //否则发送探测包。这个函数里面会发送探测包，并重启定时器。
</span><span class='line'>        tcp_send_probe0(sk);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然 后来看delay ack定时器。所谓的delay ack也就是ack不会马上发送，而是等待一段时间和数据一起发送，这样就减少了一个数据包的发送。这里一般是将ack包含在tcp option中发送的。这里的定时器就是用来控制这段时间，如果定时器到期，都没有数据要发送给对端，此时单独发送这个ack。如果在定时器时间内，有数 据要发送，此时这个ack和数据一起发送给对端。<br/>
前面我们知道delay ack定时器的回调函数是tcp_delack_timer。在分析这个函数之前，我们先来看下这个定时器是什么时候被启动的。<br/>
首先我们知道内核接收数据都是在tcp_rcv_eastablished实现的，当我们接收完数据后，此时进入是否进行delay ack.<br/>
在tcp_rcv_eastablished最终会调用__tcp_ack_snd_check进行判断。<br/>
可以看到这个函数很简单，就是判断是否需要发送delay ack，如果是则tcp_send_delayed_ack，否则直接发送ack恢复给对端。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>/* 1 第一个判断表示多于一个的段在等待ack，并且我们的receive buf有足够的空间，
</span><span class='line'> *   这是因为这种情况，表明应用程序读取比较快，而对端的发送速度依赖于ack的到达时间，* 因此我们不希望对端减慢速度。
</span><span class='line'> * 2 这个sock处在quickack 模式
</span><span class='line'> * 3 我们有 out-of-order数据,此时必须马上给对端以确认。
</span><span class='line'> *   当上面的任意一个为真，则立即发送ack。
</span><span class='line'>**/
</span><span class='line'>    if (((tp-&gt;rcv_nxt - tp-&gt;rcv_wup) &gt; inet_csk(sk)-&gt;icsk_ack.rcv_mss
</span><span class='line'>         /* ... and right edge of window advances far enough.
</span><span class='line'>          * (tcp_recvmsg() will send ACK otherwise). Or...
</span><span class='line'>          */
</span><span class='line'>         && __tcp_select_window(sk) &gt;= tp-&gt;rcv_wnd) ||
</span><span class='line'>        /* We ACK each frame or... */
</span><span class='line'>        tcp_in_quickack_mode(sk) ||
</span><span class='line'>        /* We have out of order data. */
</span><span class='line'>        (ofo_possible && skb_peek(&tp-&gt;out_of_order_queue))) {
</span><span class='line'>        /* Then ack it now */
</span><span class='line'>        tcp_send_ack(sk);
</span><span class='line'>    } else {
</span><span class='line'>        /* Else, send delayed ack. */
</span><span class='line'>        //在这里启动定时器。
</span><span class='line'>        tcp_send_delayed_ack(sk);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面还有一个tcp_in_quickack_mode，这个函数我们说了，它是用来判断是否处在quickack 模式。<br/>
来看这个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_in_quickack_mode(const struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    return icsk-&gt;icsk_ack.quick && !icsk-&gt;icsk_ack.pingpong;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中icsk->icsk_ack.pingpong域被设置的情况只有当tcp连接是交互式的，比如telnet等等。icsk->icsk_ack.quick表示能够 quickack的数量。
然后我们来看tcp_delack_timer的实现。<br/>
在看之前，我们要知道icsk->icsk_ack.pending表示的是当前的ack的状态。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_delack_timer(unsigned long data)
</span><span class='line'>{
</span><span class='line'>    struct sock *sk = (struct sock *)data;
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>    bh_lock_sock(sk);
</span><span class='line'>    //用户进程正在使用，则等会再尝试。
</span><span class='line'>    if (sock_owned_by_user(sk)) {
</span><span class='line'>        /* Try again later. */
</span><span class='line'>        icsk-&gt;icsk_ack.blocked = 1;
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKLOCKED);
</span><span class='line'>        sk_reset_timer(sk, &icsk-&gt;icsk_delack_timer, jiffies + TCP_DELACK_MIN);
</span><span class='line'>        goto out_unlock;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    sk_mem_reclaim_partial(sk);
</span><span class='line'>
</span><span class='line'>    //判断sock状态 以及ack的状态。如果是close或者已经处在ICSK_ACK_TIMER，则直接跳出。
</span><span class='line'>    if (sk-&gt;sk_state == TCP_CLOSE || !(icsk-&gt;icsk_ack.pending & ICSK_ACK_TIMER))
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    //如果已经超时，则重启定时器，并退出。
</span><span class='line'>    if (time_after(icsk-&gt;icsk_ack.timeout, jiffies)) {
</span><span class='line'>        sk_reset_timer(sk, &icsk-&gt;icsk_delack_timer, icsk-&gt;icsk_ack.timeout);
</span><span class='line'>        goto out;
</span><span class='line'>    }
</span><span class='line'>    //清除ack状态。
</span><span class='line'>    icsk-&gt;icsk_ack.pending &= ~ICSK_ACK_TIMER;
</span><span class='line'>
</span><span class='line'>    //开始遍历prequeue。此时主要的目的是为了调用tcp_rcv_eastablished.这里会调用tcp_ack_snd_check来发送ack。
</span><span class='line'>    if (!skb_queue_empty(&tp-&gt;ucopy.prequeue)) {
</span><span class='line'>        struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSCHEDULERFAILED);
</span><span class='line'>
</span><span class='line'>        //遍历prequeue队列，发送未发送的ack。
</span><span class='line'>        while ((skb = __skb_dequeue(&tp-&gt;ucopy.prequeue)) != NULL)
</span><span class='line'>            sk_backlog_rcv(sk, skb);
</span><span class='line'>
</span><span class='line'>        tp-&gt;ucopy.memory = 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //检测是否有ack还需要被发送。也就是处于ICSK_ACK_SCHED状态的ack
</span><span class='line'>    if (inet_csk_ack_scheduled(sk)) {
</span><span class='line'>
</span><span class='line'>        if (!icsk-&gt;icsk_ack.pingpong) {
</span><span class='line'>            /* Delayed ACK missed: inflate ATO. */
</span><span class='line'>            icsk-&gt;icsk_ack.ato = min(icsk-&gt;icsk_ack.ato &lt;&lt; 1, icsk-&gt;icsk_rto);
</span><span class='line'>        } else {
</span><span class='line'>            //到这里说明已经长时间没有通信，并且处于交互模式。这个时候我们需要关闭pingpong模式。
</span><span class='line'>            icsk-&gt;icsk_ack.pingpong = 0;
</span><span class='line'>            icsk-&gt;icsk_ack.ato      = TCP_ATO_MIN;
</span><span class='line'>        }
</span><span class='line'>        //立即发送ack。
</span><span class='line'>        tcp_send_ack(sk);
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKS);
</span><span class='line'>    }
</span><span class='line'>    TCP_CHECK_TIMER(sk);
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>    if (tcp_memory_pressure)
</span><span class='line'>        sk_mem_reclaim(sk);
</span><span class='line'>out_unlock:
</span><span class='line'>    bh_unlock_sock(sk);
</span><span class='line'>    sock_put(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/21/ubuntu-dota2/">ubuntu dota2</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-21T23:51:00+08:00'><span class='date'>2013-09-21</span> <span class='time'>23:51:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ERROR- You are missing the following 32-bit libraries, and Steam may not run:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib</span></code></pre></td></tr></table></div></figure>


<p>无法输入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export LC_CTYPE="en_US.UTF-8" && steam</span></code></pre></td></tr></table></div></figure>


<h4>一、集显</h4>

<p>  ubuntu下，如果是intel的核心显卡，mesa低于9.2版本的话，会出现看不见树和看不见英雄的情况
  这时候就要更新mesa到9.2，mesa9.2支持3.6之后的内核版本，如果内核低于3.6，就要先更新内核
  ubuntu的解决办法:
  查看当前mesa版本：glxinfo |grep -i opengl
  查看当前内核版本：uname -a</p>

<p>  sudo add-apt-repository ppa:xorg-edgers/ppa
  sudo apt-get update
  sudo apt-get install linux-generic-lts-raring  (更新内核)
  sudo apt-get dist-upgrade mesa                 (更新mesa)
  然后就是重启系统</p>

<h4>二、独显</h4>

<p>ubuntu 装独显 <a href="/blog/2013/03/26/ubuntu-use-nvidia/">ubuntu 12.04 N卡双显卡</a></p>

<p>如果你想用独显玩dota2, 那么你需要用optirun steam来启动steam客户端，然后再启动游戏，这样游戏就是通过独显来渲染的。你也可以用普通的steam命令来启动steam，然后在dota2 游戏的属性中，加入启动方式optirun %command。 这样只有在启动游戏之后独显才会工作。</p>

<p>用optirun -b primus %command%(记得要装primus)，效果更好。 // 用%command%在启动时画面会显示不全，但是好像用%command好像又不会用独显了</p>

<p>primus默认是有垂直同步的，帧数当然会低，加个vblank_mode=0绝对秒杀virtualgl</p>

<p>不能用vblank_mode=0 optirun -b primus programme做桥接启动程序，这样会拉低许多显卡性能，
使用vblank_mode=0 primusrun programme，性能就上来了，我这里确实比optirun提高30%左右</p>

<hr />

<h5>1打开启动选项输入框</h5>

<h5>2 输入所选命令（使用多个命令是中间用空格隔开，例如 -novid -international -console  ）</h5>

<p>-novid （去除开始动画）<br/>
-console（命令面板）<br/>
-high （使dota2 的cpu和内存使用级为最高,也就是说让dota2 可以优先其他程序使用内存）<br/>
-windowed （窗口模式）</p>

<h5>dota 2 console 命令</h5>

<h6>1首先开启命令面板</h6>

<h6>2输入常用命令</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>net_graph 1 （ 网络状况显示）
</span><span class='line'>    再来就是改变位置，有些人不喜欢显示在左边，这个时候可以输入：
</span><span class='line'>　　net_graphpos 1
</span><span class='line'>　　这样显示的数据就会变到右边
</span><span class='line'>　　
</span><span class='line'>　　net_graphpos 2
</span><span class='line'>　　这样会变成中间
</span><span class='line'>　　
</span><span class='line'>　　net_graphpos 3
</span><span class='line'>　　这样会变成左边
</span><span class='line'>
</span><span class='line'>dota_minimap_hero_size 650 （英雄在小地图上的大小 650 为正常值，可自行更改）
</span><span class='line'>dota_force_right_click_attack 1 (英雄可以右键直接反补）
</span><span class='line'>dota_hud_healthbars 1 （去掉生命条上的分隔）
</span><span class='line'>dota_health_per_vertical_marker 250 （更改每一个分隔代表的血量 默认为250）
</span><span class='line'>dota_disable_range_finder 0  （随时显示你的施法距离）（很有用）
</span><span class='line'>dota_camera_accelerate 49 （任意调整观看视角）（没用过）
</span><span class='line'>
</span><span class='line'>dota2 一共有数百种命令，包括血的颜色，屏蔽某种声音等等，但是比较实际的就是这几种，其他的就不列举了。
</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>Dota2 录像下载失败</h4>

<p>无法打开录像文件,请确保没有其他进程已打开此文件。</p>

<p>在XXX\Steam\SteamApps\common\dota 2 beta\dota目录下新建一个名为replays的文件夹即可</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>net_graphheight "64"
</span><span class='line'>这个等于是设置高度位置 大家如果分屏率不同 可以修改数字来决定位置 数字越小 会往下移动 
</span><span class='line'>
</span><span class='line'>net_graphinsetbottom "437"
</span><span class='line'>这个等于是设置地步位置 大家如果分屏率不同 可以修改数字来决定位置 数字越小 会往上移动 
</span><span class='line'>
</span><span class='line'>net_graphinsetleft "0"
</span><span class='line'>因为已经设置右边 这个保持0就OK 但是也记得输入一次 以防万一 
</span><span class='line'>
</span><span class='line'>net_graphinsetright "-83"
</span><span class='line'>设置右边距离 记住这里是"-83" 不是83 负数越高 越往右 大家可以根据自己的需要改变数字 
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>net_graphproportionalfont "0"
</span><span class='line'>这个是关键 字体比例问题 默认是1 设定为0以后 就会变成我图中那样的小字 
</span><span class='line'>
</span><span class='line'>net_graphtext "1"
</span><span class='line'>这个没什么大问题 字体样式</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/09/kernel-net-rx/">接收包的主流程</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-09T18:10:00+08:00'><span class='date'>2013-09-09</span> <span class='time'>18:10:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_v4_rcv(struct sk_buff *skb)    linux/net/ipv4/tcp_ipv4.c #1611</span></code></pre></td></tr></table></div></figure>


<p>  //tcp刚刚收到从ipv4发上来的包<br/>
  （struct tcphdr: 定义在/include/net/tcp.h中，即包的tcp首部，不包括options部分）<br/>
  （struct sock ：定义在/include/net/sock.h中，即表示socket）<br/>
  检查skb->pkt_type != PACKET_HOST 则丢弃<br/>
  检查th->doff &lt; sizeof(struct tcphdr) / 4，即首部大小不合理，则丢弃<br/>
  检查checksum</p>

<p>  （TCP_SKB_CB(skb)：定义在tcp.h是获取一个实际指向skb->cb[0]的tcp_skb_cb类型指针；将到达的首部剥离后，从中拷贝一些信息到这个变量，供tcp控制功能使用；tcp_skb_cb是在tcp刚收到时填写在包中的）<br/>
  注意：<br/>
        1. tcp_skb_cb->end_seq = seq + th->fin + th->fin + len-doff*4<br/>
        2. when 和 sacked 没有被赋值</p>

<p>  sk = __inet_lookup(&hellip;) 从一个hash表中获取该收包对应的sock结构，根据源IP地址+端口，目的IP地址+端口，inet_iif检查sk->sk_state == TCP_TIME_WAIT，TCP在该状态下则丢弃任何接收到的包并转入后续的特殊处理（未看，和关闭连接的状态迁移有关需要后续来看$），马上准备进入CLOSED状态了；<br/>
  检查sk_filter(sk,skb)，则被过滤器阻拦，丢弃<br/>
  检查!sock_owned_by_user(sk)，不明白sock->sk_lock的意义是什么，只有检查满足才能进入接收，否则 sk_add_backlog(sk, skb)将该sk_buff记录进sk_backlog队列；（注意这部操作加锁了！）<br/>
（struct tcp_sock *tp = tcp_sk(sk)：tcp_sock定义在tcp.h中，通过tcp_sk直接将sock指针转换为tcp_sock型）</p>

<p>  ret = tcp_v4_do_rcv(sk, skb) 进入进一步接收处理！<br/>
（之后的异常操作未看）</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)    linux/net/ipv4/tcp_ipv4.c #1542</span></code></pre></td></tr></table></div></figure>


<p>  //在正常状态下由tcp_v4_rcv调用，进一步进行针对接收包的处理<br/>
  检查sk->sk_state == TCP_ESTABLISHED<br/>
    则tcp_rcv_established(sk, skb, skb->h.th, skb->len)，连接已经建立，则进入进一步接收处理！<br/>
  检查sk->sk_state == TCP_LISTEN，<br/>
    则struct sock *nsk = tcp_v4_hnd_req(sk, skb);    //该函数中判断能否找到已有的连接请求，如果有则说明接收到的是一个ack并在其中创建一个新的sock即nsk；如果没有则说明接收到的是 syn，nsk即为sk；<br/>
  if(nsk!=sk) tcp_child_process(sk,nsk,skb)    //当nsk==sk时，接收的是SYN，不进行此步直接进入tcp_rcv_state_process；否则是ack说明已经创建好了的nsk，在 tcp_child_process对nsk进行tcp_rcv_state_process状态转移处理；<br/>
  tcp_rcv_state_process(sk, skb, skb->h.th, skb->len); 非常重要函数！处理tcp的状态转移<br/>
  reset: tcp_v4_send_reset(rsk, skb);    reset，未看$<br/>
  discard: kfree_skb(skb);</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_rcv_established(struct sock *sk, struct sk_buff *skb,struct tcphdr *th, unsigned len)    linux/net/ipv4/tcp_input.c #3881</span></code></pre></td></tr></table></div></figure>


<p>Header Prediction：基于效率的考虑，将包的处理后续阶段分为fast path和slow path两种，前者用于普通的包，后者用于特殊的包；该header prediction即用于区分两种包的流向。<br/>
1.(tcp_flag_word(th) &amp; TCP_HP_BITS) == tp->pred_flags 判断标志位是不是正常情况；tcp_flag_word返回指向tcphdr的第三个32位基址（即length前面），而TCP_HP_BITS是把 PSH标志位给屏蔽掉即该位值不影响流向；所以总的来说pred_flag应该等于0xS?10 &lt;&lt; 16 + snd_wnd（那么pred_flag是在tcp_fast_path_check或tcp_fast_path_on中更新值的）<br/>
2.TCP_SKB_CB(skb)->seq == tp->rcv_nxt 判断所收包是否为我们正想要接收的，非乱序包<br/>
3.*ptr != htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16) | (TCPOPT_TIMESTAMP &lt;&lt; 8) | TCPOLEN_TIMESTAMP) 若包中没有正常的timestamp选项则转入slow path
 timestamp选项处理： 从包中的ts选项中获取数据，以此刷新tp->rx_opt的saw_tstamp,rcv_tsval,rcv_tsecr域；ts选项含三个 32bit，其中后两个分别记录着tsval和tsecr；（注意，ts_recent并不在此处更新，在后面的tcp_store_ts_recent 中更新）<br/>
  struct tcp_options_received: 定义在tcp.h中，其中saw_tstamp表明timestamp选项是否有效，ts_recent_stamp是我们最近一次更新 ts_recent的时间，ts_recent是下一次回显的时戳一般等于下次发包中的rcv_tsecr；rcv_tsval是该data从发端发出时的时戳值，rcv_tsecr是回显时间戳（即该ack对应的data或者该data对应的上次ack中的ts_tsval值），（注意两端时钟无需同步；当ack被收端推迟时，所回复的ack中的timestamp指向所回复包群中的第一个确认包 “When an incoming segment belongs to the current window, but arrives out of order (which implies that an earlier segment was lost), the timestamp of the earlier segment is returned as soon as it arrives, rather than the timestamp of the segment that arrived out of order.”这条细节未看明白$）从包中的时间戳选项中记录这两个值</p>

<p>4.PAWS check：(s32)(tp->rx_opt.rcv_tsval - tp->rx_opt.ts_recent) &lt; 0，则转入slow path<br/>
  （PAWS:Protection Against Wrapped Sequence Numbers, SeqNo有可能会有回环交叠（因为它最大只有32bit），两个相同序号的包实际上是不同的两个包，此时判断tsval是否小于ts_recent即判断该包是否是一个过去时间的一个多余的包，然后将其作为一个重复包丢弃）</p>

<h5>Fast Path：</h5>

<p>  1.当len == tcp_header_len，即这是一个纯ack（区别于piggyback），注意这是个纯ack，所以它通过长度来进行判断而不是标识！<br/>
    tcp_store_ts_recent(tp): tp->rx_opt.ts_recent = tp->rx_opt.rcv_tsval;<br/>
    tcp_ack(sk, skb, 0) 处理ack，进一步处理，未看！<br/>
    <code>__kfree_skb(skb)</code> 释放该包<br/>
     tcp_data_snd_check(sk,tp) 检查有无更进一步的data包处理<br/>
  2.当len &lt; tcp_header_len，说明该包的首部太小，清除之；<br/>
  3.当len > tcp_header_len，它是一个data包，tcp_copy_to_iovec函数未看，它决定该payload是否可以直接拷贝给用户空间：<br/>
    可，tcp_store_ts_recent(tp);<br/>
      tcp_rcv_rtt_measure_ts(sk,skb); //计算RTT<br/>
      <code>__skb_pull(skb, tcp_header_len);</code> //剥tcp首部<br/>
       tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq; //更新rcv_next<br/>
($ 那么将data拷贝到用户空间的操作在何处体现？难道是在tcp_copy_to_iovec中？)<br/>
    不可，除了以上的操作之外，还要<br/>
      <code>__skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);</code> //将该包加入到接收sk_buff队列尾部<br/>
    tcp_event_data_recv()：management tasks处理<br/>
    若TCP_SKB_CB(skb)->ack_seq != tp->snd_una，说明这是一个有效的ack包<br/>
      tcp_ack(sk, skb, FLAG_DATA); //FLAG_DATA说明这是一个背在data上的ack<br/>
      tcp_data_snd_check(sk, tp); //该函数调用tcp_push_pending_frames函数，如果sk->sk_send_head存在则最终调用 tcp_write_xmit函数发包<br/>
      <code>__tcp_ack_snd_check(sk, 0);</code> //检查基于该收包事件，有无进一步的ack包处理（Delayed ACK，Quick ACK）</p>

<h5>Slow Path：</h5>

<p>  tcp_checksum_complete_user(sk, skb)：checksum检查<br/>
  tcp_fast_parse_options(skb, th, tp)：timestamp选项检查；tcp_paws_discard(sk, skb)：PAWS检查<br/>
  tcp_sequence(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq)：检查是否乱序，并在其中激活QuickACK模式<br/>
    上面两行中，都会再检查RST标志，若没激活则tcp_send_dupack，作用不明，貌似是针对该错包回复一个冗余的ack<br/>
  检查RST标志，tcp_reset(sk) 该函数没什么操作，填写一些错误信息后进入tcp_done函数(该函数进行一些关闭tcp连接的收尾操作)<br/>
  tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq)：更新timestamp信息<br/>
  检查SYN标志，在连接已建立的状态下，收到SYN是错误的，因此tcp_reset(sk)<br/>
  检查ACK标志，tcp_ack(sk, skb, FLAG_SLOWPATH)<br/>
  tcp_rcv_rtt_measure_ts(sk, skb)：更新RTT<br/>
  tcp_urg(sk, skb, th)：处理URG标志<br/>
  tcp_data_queue(sk, skb)：处理接收包所含数据，未看<br/>
  tcp_data_snd_check(sk, tp) &amp; tcp_ack_snd_check(sk)：检查有无进一步的data或ack发送</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_event_data_recv(struct sock *sk, struct tcp_sock *tp, struct sk_buff *skb)    linux/net/ipv4/tcp_input.c #502</span></code></pre></td></tr></table></div></figure>


<p>  //
  inet_csk_schedule_ack(sk)：将icsk_pending置为ICSK_ACK_SCHED，但具体意义不明<br/>
  （struct inet_connection_sock：/linux/include/net/inet_connection_sock，面向INET连接的 socket结构，记录着和tcp连接有关的很多变量，比如本函数要处理的ATO（Acknowledgement timeout）信息；tcp_sock是其上的拓展，它的具体意义尚待发掘）<br/>
  tcp_measure_rcv_mss(sk, skb)：更新rcv_mss，说是与delayed ACK有关，但是具体是怎么运作的？<br/>
  tcp_rcv_rtt_measure(tp)：更新RTT，为什么又更新一遍$<br/>
  接下来的一些列操作是更新inet_connection_sock中的ATO信息，具体操作代码中有注释，但这些信息的运作方式还不明</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_ack(struct sock *sk, struct sk_buff *skb, int flag)    /linux/net/ipv4/tcp_input.c #2491</span></code></pre></td></tr></table></div></figure>


<p>  //处理接受到的ack，内容非常复杂
  首先介绍一下ack可以携带的各个FLAG：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FLAG_DATA：              Incoming frame contained data.
</span><span class='line'>FLAG_WIN_UPDATE：        Incoming ACK was a window update
</span><span class='line'>FLAG_DATA_ACKED：        This ACK acknowledged new data.
</span><span class='line'>FLAG_RETRANS_DATA_ACKED：Some of which was retransmitted.
</span><span class='line'>FLAG_SYN_ACKED：         This ACK acknowledged SYN.
</span><span class='line'>FLAG_DATA_SACKED：       New SACK.
</span><span class='line'>FLAG_ECE：               ECE in this ACK.
</span><span class='line'>FLAG_DATA_LOST：         SACK detected data lossage.
</span><span class='line'>FLAG_SLOWPATH：          Do not skip RFC checks for window update.
</span><span class='line'>FLAG_ACKED：             (FLAG_DATA_ACKED|FLAG_SYN_ACKED)
</span><span class='line'>FLAG_NOT_DUP：           (FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)
</span><span class='line'>FLAG_CA_ALERT：          (FLAG_DATA_SACKED|FLAG_ECE)
</span><span class='line'>FLAG_FORWARD_PROGRESS： (FLAG_ACKED|FLAG_DATA_SACKED)</span></code></pre></td></tr></table></div></figure>


<p>  prior_snd_una = tp->snd_una;ack_seq = TCP_SKB_CB(skb)->seq; ack = TCP_SKB_CB(skb)->ack_seq;<br/>
  //1记录着上一次被确认的data序号；2记录着所收ack包的序号；3记录着所收ack包确认对象的data序号；<br/>
  首先判断若ack在tp->snd_nxt之后或者在prio_snd_una之前，则说明该ack非法或者过时（在过时的情况下，若sacked打开则还需tcp_sacktag_write_queue处理） 24</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!(flag&FLAG_SLOWPATH) && after(ack, prior_snd_una))
</span><span class='line'>    tcp_update_wl（即tp-&gt;snd_wl1 = ack_seq）; tp-&gt;snd_una=ack; //为什么此种情况下并不更新窗口？
</span><span class='line'>else
</span><span class='line'>    flag |= tcp_ack_update_window(sk, tp, skb, ack, ack_seq);
</span><span class='line'>    //nwin = ntohs(skb-&gt;h.th-&gt;window)从ack中记录通告窗口
</span><span class='line'>    如果检查需要更新发送窗口，则tp-&gt;snd_wl1 = ack_seq; tp-&gt;snd_wnd = nwin;
</span><span class='line'>    tp-&gt;snd_una = ack;
</span><span class='line'>    if (TCP_SKB_CB(skb)-&gt;sacked) flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una); //该函数未看
</span><span class='line'>
</span><span class='line'>    tp-&gt;rcv_tstamp = tcp_time_stamp; //rcv_tstamp记录着最近一次收到ack的时戳
</span><span class='line'>    prior_in_flight = tcp_packets_in_flight(tp);
</span><span class='line'>    if(!tp-&gt;packets_out) icsk-&gt;icsk_prbes_out = 0;
</span><span class='line'>    if (sk-&gt;sk_send_head) tcp_ack_probe(sk);    //若此时网络中没有data，直接进入zero-window probe的ack处理;通告窗口的数据已经得到处理，所以tcp_ack_probe中仅仅是重置probe计时器，即 icsk-&gt;icsk_retransmit_timer
</span><span class='line'>
</span><span class='line'>    flag |= tcp_clean_rtx_queue(sk, &seq_rtt);   //从重传队列中移除被确认的data包
</span><span class='line'>
</span><span class='line'>    if (tcp_ack_is_dubious(sk, flag)) { //该函数判断此ack是否可疑，判真情况下具体是flag不为FLAG_NOT_DUP，或flag是FLAG_CA_ALERT，或 icsk_ca_state不为TCP_CA_OPEN状态
</span><span class='line'>    if ((flag & FLAG_DATA_ACKED) && tcp_may_raise_cwnd(sk, flag))
</span><span class='line'>    //如果这个包是一个对新数据包的ack，那么通过tcp_may_raise_cwnd函数来判断是否要进行窗口操作，判真情况下具体是flag不是 FLAG_ECE或snd_cwnd&lt;snd_ssthresh（慢启动？）且icsk_ca_state不为TCP_CA_RECOVERY和 TCP_CA_CWR状态（所以，为什么TCP_CA_LOSS状态可以增窗呢？）
</span><span class='line'>        tcp_cong_avoid(sk, ack, seq_rtt, prior_in_flight, 0);  
</span><span class='line'>    //该函数会调用icsk-&gt;icsk_ca_ops-&gt;cong_avoid(sk, ack, rtt, in_flight, good)， 这是个函数指针；另外会更新snd_cwnd_stamp
</span><span class='line'>    tcp_fastretrans_alert(sk, prior_snd_una, prior_packets, flag); //未看，极其重要的函数
</span><span class='line'>}else{
</span><span class='line'>    if ((flag & FLAG_DATA_ACKED)) tcp_cong_avoid(sk, ack, seq_rtt, prior_in_flight, 1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>tcp_ack中有很多新的内容，都还未涉及，要注意！！！！！！</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)    /linux/net/ipv4/tcp_input.c #3139</span></code></pre></td></tr></table></div></figure>


<p>  //将数据拷贝至用户空间<br/>
若TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq 则空包丢弃<br/>
__skb_pull(skb, th->doff*4) //剥离tcp首部</p>

<h5>1.若TCP_SKB_CB(skb)->seq == tp->rcv_nxt且tcp_receive_window(tp)!=0，非乱序且处于接受窗口中，正常的情况</h5>

<p>若tp->ucopy.task == current, tp->copied_seq == tp->rcv_nxt, tp->ucopy.len等条件满足，则可以拷贝至用户空间<br/>
  //current是什么不明？ucopy.len貌似是用户最先设定的数据包的量，每次收包之后减小直至零<br/>
    skb_copy_datagram_iovec(skb, 0, tp->ucopy.iov, chunk) //向ucopy.iov拷贝数据<br/>
    tcp_rcv_space_adjust(sk) //计算TCP接受buffer空间大小，拷贝完<br/>
tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;<br/>
if(th->fin) tcp_fin(skb, sk, th); //原来fin的处理在这里！<br/>
若!skb_queue_empty(&amp;tp->out_of_order_queue)<br/>
    tcp_ofo_queue(sk); //看out_of_order_queue中有没有可以移到receive_queue中<br/>
    tcp_sack_remove(tp) //RCV.NXT advances, some SACKs should be eaten<br/>
    tcp_fast_path_check(sk,tp)   //tp->pred_flag值的更新<br/>
  清除skb并return</p>

<h5>2.若!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt) 说明这是一个重传的包</h5>

<p>  tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);   //在其中打开并填写dsack信息,在dyokucate_sack[0]中从seq到end_seq，修改dsack和eff_sacks值<br/>
  tcp_enter_quickack_mode(sk); //进入quick ack模式<br/>
  清除skb并return<br/>
若!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt + tcp_receive_window(tp))<br/>
  清除skb并return<br/>
若before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt) 说明这是一个Partial包，即seq&lt;rcv_next&lt;end_seq<br/>
  tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, tp->rcv_nxt); //填写dsack信息，从seq到rcv_nxt</p>

<h5>3. 其他情况，说明收到了一个乱序包</h5>

<p>若out_of_order_queue为空，则<br/>
（注：out_of_order_queue是一个sk_buff_head结构，它的prev/next指针分别指向最后一个和第一个sk_buff结构，块的排放顺序对应其序号的大小顺序）<br/>
  初始化sack相关域，num_sacks/eff_sacks为1，dsack为0，selective_acks[0]从seq到end_seq；<br/>
  <code>__skb_queue_head(&amp;tp-&gt;out_of_order_queue,skb);</code> //将收包加入out_of_order_queue的头部</p>

<p>若out_of_order_queue不为空，则首先获取skb1 = tp->out_of_order_queue.prev即最新的一个乱序块<br/>
  若seq == TCP_SKB_CB(skb1)->end_seq，说明收包能够接在最新乱序块的右边<br/>
    <code>__skb_append(skb1, skb, &amp;tp-&gt;out_of_order_queue);</code><br/>
    tp->selective_acks[0].end_seq = end_seq; //将新收包接在skb1的右边，看来第一个selective_acks块对应的是最新的乱序序列<br/>
  循环执行skb1=skb1->prev，直到找到!after(TCP_SKB_CB(skb1)->seq, seq)表明需要将收包插在此块之后，或skb1=(struct sk_buff<em>)&amp;tp->out_of_order_queue表明收包比队列中的所与块的序列都要小<br/>
    循环内需要找到收包与队列已有包中的重复部分，然后tcp_dsack_set设置该部分为dsack内容<br/>
  <code>__skb_insert(skb, skb1, skb1-&gt;next, &amp;tp-&gt;out_of_order_queue);</code> //将收包对应的块插入到队列中<br/>
  再次循环执行skb1=skb1->next，直到找到!after(end_seq, TCP_SKB_CB(skb1)->seq)表明需要将从收包到该包之间的所有包全部从队列中移除，或者skb1=(struct sk_buff</em>)&amp;tp->out_of_order_queue表明需要将收包之后的所有包都移出<br/>
    循环内需要将当前的队列包与收包的交叠部分设置为dsack值（当然随着循环的推进，dsack处于不断更新的状况），还要通过 <code>__skb_unlink(skb1, &amp;tp-&gt;out_of_order_queue)，__kfree_skb(skb1);</code>将当前的队列包移除<br/>
  （该处的两部循环，旨在通过比较队列中块的序号和所收包的序号范围，将队列中的包连续化，即消除孔洞）</p>

<hr />
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/06/kernel-net-sack/">内核tcp协议栈SACK的处理tcp_sacktag_write_queue</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-06T15:41:00+08:00'><span class='date'>2013-09-06</span> <span class='time'>15:41:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://simohayha.iteye.com/blog/578744">http://simohayha.iteye.com/blog/578744</a></p>

<p>  上一篇处理ack的blog中我们知道当我们接收到ack的时候，我们会判断sack段，如果包含sack段的话，我们就要进行处理。这篇blog就主要来介绍内核如何处理sack段。</p>

<p>  SACK是包含在tcp的option中的，由于tcp的头的长度的限制，因此SACK也就是最多包含4个段，也就是32个字节。我们先来看tcp中的SACK段的表示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_sack_block {
</span><span class='line'>    u32   start_seq; //起始序列号
</span><span class='line'>    u32   end_seq;   //结束序列号
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>可以看到很简单，就是一个段的起始序列号和一个结束序列号。</p>

<p>前一篇blog我们知道tcp_skb_cb的sacked域也就是sack option的偏移值，而在tcp的option它的组成是由3部分组成的，第一部分为option类型，第二部分为当前option的长度，第三部分才是数据段，因此我们如果要取得SACK的段，就必须这样计算。</p>

<p>这里ack_skb也就是我们要处理的skbuffer。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//首先得到sack option的起始指针。
</span><span class='line'>unsigned char *ptr = (skb_transport_header(ack_skb) +
</span><span class='line'>              TCP_SKB_CB(ack_skb)-&gt;sacked);
</span><span class='line'>//加2的意思也就是加上类型和长度，这里刚好是2个字节。最终结果也就是sack option的数据段。
</span><span class='line'>struct tcp_sack_block_wire *sp_wire = (struct tcp_sack_block_wire *)(ptr+2);</span></code></pre></td></tr></table></div></figure>


<p>这里很奇怪，内核还有一个tcp_sack_block_wire类型的结构，它和tcp_sack_block是完全一样的。</p>

<p>而我们如果要得到当前的SACK段的个数我们要这样做:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define TCPOLEN_SACK_BASE        2
</span><span class='line'>int num_sacks = min(TCP_NUM_SACKS, (ptr[1] - TCPOLEN_SACK_BASE) &gt;&gt; 3);</span></code></pre></td></tr></table></div></figure>


<p>这里ptr1也就是sack option的长度(字节数),而TCPOLEN_SACK_BASE为类型和长度字段的长度，因此这两个值的差也就是sack段的总长度，而这里每个段都是8个字节，因此我们右移3位就得到了它的个数，最后sack的段的长度不能大于4,因此我们要取一个最小值。</p>

<p>上面的结构下面这张图非常清晰的展示了，这几个域的关系：</p>

<p><img src="/images/kernel/2013-09-06.jpeg" alt="" /></p>

<p>然后我们来看SACK的处理，在内核中SACK的处理是通过tcp_sacktag_write_queue来实现的，这个函数比较长，因此这里我们分段来看。</p>

<p>先来看函数的原型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int
</span><span class='line'>tcp_sacktag_write_queue(struct sock *sk, struct sk_buff *ack_skb,
</span><span class='line'>            u32 prior_snd_una)</span></code></pre></td></tr></table></div></figure>


<p>第一个参数是当前的sock，第二个参数是要处理的skb，第三个参数是接受ack的时候的snd_una.</p>

<p>在看之前这里有几个重要的域要再要说明下。<br/>
1 tcp socket的sacked_out域，这个域保存了所有被sack的段的个数。<br/>
2 还有一个就是tcp_sacktag_state结构，这个结构保存了当前skb的一些信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_sacktag_state {
</span><span class='line'>    int reord;
</span><span class='line'>    int fack_count;
</span><span class='line'>    int flag;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>3 tcp socket的highest_sack域，这个域也就是被sack确认的最大序列号的skb。</p>

<p>先来看第一部分，这部分的代码主要功能是初始化一些用到的值，比如sack的指针，当前有多少sack段等等，以及一些合法性校验。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//sack段的最大个数
</span><span class='line'>#define TCP_NUM_SACKS 4
</span><span class='line'>......
</span><span class='line'>......
</span><span class='line'>    const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    //下面两句代码，前面已经分析过了，也就是取得sack的指针以及sack 数据段的指针。
</span><span class='line'>    unsigned char *ptr = (skb_transport_header(ack_skb) +
</span><span class='line'>                  TCP_SKB_CB(ack_skb)-&gt;sacked);
</span><span class='line'>    struct tcp_sack_block_wire *sp_wire = (struct tcp_sack_block_wire *)(ptr+2);
</span><span class='line'>    //这个数组最终会用来保存所有的SACK段。
</span><span class='line'>    struct tcp_sack_block sp[TCP_NUM_SACKS];
</span><span class='line'>    struct tcp_sack_block *cache;
</span><span class='line'>    struct tcp_sacktag_state state;
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>    //这里得到当前的sack段的个数，这段代码前面也介绍过了。
</span><span class='line'>    int num_sacks = min(TCP_NUM_SACKS, (ptr[1] - TCPOLEN_SACK_BASE) &gt;&gt; 3);
</span><span class='line'>    int used_sacks;
</span><span class='line'>    //重复的sack的个数。
</span><span class='line'>    int found_dup_sack = 0;
</span><span class='line'>    int i, j;
</span><span class='line'>    int first_sack_index;
</span><span class='line'>
</span><span class='line'>    state.flag = 0;
</span><span class='line'>    state.reord = tp-&gt;packets_out;
</span><span class='line'>    //如果sack的个数为0,则我们要更新相关的域。
</span><span class='line'>    if (!tp-&gt;sacked_out) {
</span><span class='line'>        if (WARN_ON(tp-&gt;fackets_out))
</span><span class='line'>            tp-&gt;fackets_out = 0;
</span><span class='line'>    //这个函数主要更新highest_sack域。
</span><span class='line'>        tcp_highest_sack_reset(sk);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //开始检测是否有重复的sack。这个函数紧接着会详细分析。
</span><span class='line'>    found_dup_sack = tcp_check_dsack(sk, ack_skb, sp_wire,
</span><span class='line'>                     num_sacks, prior_snd_una);
</span><span class='line'>    //如果有发现，则设置flag。
</span><span class='line'>    if (found_dup_sack)
</span><span class='line'>        state.flag |= FLAG_DSACKING_ACK;
</span><span class='line'>
</span><span class='line'>    //再次判断ack的序列号是否太老。
</span><span class='line'>    if (before(TCP_SKB_CB(ack_skb)-&gt;ack_seq, prior_snd_una - tp-&gt;max_window))
</span><span class='line'>        return 0;
</span><span class='line'>    //如果packets_out为0,则说明我们没有发送还没有确认的段，此时进入out，也就是错误处理。
</span><span class='line'>    if (!tp-&gt;packets_out)
</span><span class='line'>        goto out;</span></code></pre></td></tr></table></div></figure>


<p>在看接下来的部分之前我们先来看tcp_highest_sack_reset和tcp_check_dsack函数，先是tcp_highest_sack_reset函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void tcp_highest_sack_reset(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    //设置highest_sack为写队列的头。
</span><span class='line'>    tcp_sk(sk)-&gt;highest_sack = tcp_write_queue_head(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里原因很简单，因为当sacked_out为0,则说明没有通过sack确认的段，此时highest_sack自然就指向写队列的头。<br/>
第二个是tcp_check_dsack函数，这个函数比较复杂，他主要是为了检测D-SACK,也就是重复的sack。<br/>
有关dsack的概念可以去看RFC 2883和3708.<br/>
我这里简要的提一下dsack的功能，D-SACK的功能主要是使接受者能够通过sack的块来报道接收到的重复的段，从而使发送者更好的进行拥塞控制。<br/>
这里D-SACK的判断是通过RFC2883中所描述的进行的。如果是下面两种情况，则说明收到了一个D-SACK。<br/>
1 如果SACK的第一个段所ack的区域被当前skb的ack所确认的段覆盖了一部分，则说明我们收到了一个d-sack,而代码中也就是sack第一个段的起始序列号小于snd_una。下面的图描述了这种情况：</p>

<p><img src="/images/kernel/2013-09-06-2.jpeg" alt="" /></p>

<p>2 如果sack的第二个段完全包含了第二个段，则说明我们收到了重复的sack，下面这张图描述了这种关系。</p>

<p><img src="/images/kernel/2013-09-06-3.jpeg" alt="" /></p>

<p>最后要注意的是，这里收到D-SACK后，我们需要打开当前sock d-sack的option。并设置dsack的flag。</p>

<p>然后我们还需要判断dsack的数据是否已经被ack完全确认过了，如果确认过了，我们就需要更新undo_retrans域，这个域表示重传的数据段的个数。</p>

<p>来看代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_check_dsack(struct sock *sk, struct sk_buff *ack_skb,
</span><span class='line'>               struct tcp_sack_block_wire *sp, int num_sacks,
</span><span class='line'>               u32 prior_snd_una)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    //首先取得sack的第一个段的起始和结束序列号
</span><span class='line'>    u32 start_seq_0 = get_unaligned_be32(&sp[0].start_seq);
</span><span class='line'>    u32 end_seq_0 = get_unaligned_be32(&sp[0].end_seq);
</span><span class='line'>    int dup_sack = 0;
</span><span class='line'>
</span><span class='line'>    //判断D-sack,首先判断第一个条件，也就是起始序列号小于ack的序列号
</span><span class='line'>    if (before(start_seq_0, TCP_SKB_CB(ack_skb)-&gt;ack_seq)) {
</span><span class='line'>        //设置dsack标记。
</span><span class='line'>        dup_sack = 1;
</span><span class='line'>        //这里更新tcp的option的sack_ok域。
</span><span class='line'>        tcp_dsack_seen(tp);
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKRECV);
</span><span class='line'>    } else if (num_sacks &gt; 1) {
</span><span class='line'>        //然后执行第二个判断，取得第二个段的起始和结束序列号。
</span><span class='line'>        u32 end_seq_1 = get_unaligned_be32(&sp[1].end_seq);
</span><span class='line'>        u32 start_seq_1 = get_unaligned_be32(&sp[1].start_seq);
</span><span class='line'>        //执行第二个判断，也就是第二个段完全包含第一个段。
</span><span class='line'>        if (!after(end_seq_0, end_seq_1) &&
</span><span class='line'>            !before(start_seq_0, start_seq_1)) {
</span><span class='line'>            dup_sack = 1;
</span><span class='line'>            tcp_dsack_seen(tp);
</span><span class='line'>            NET_INC_STATS_BH(sock_net(sk),
</span><span class='line'>                    LINUX_MIB_TCPDSACKOFORECV);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //判断是否dsack的数据段完全被ack所确认。
</span><span class='line'>    if (dup_sack &&
</span><span class='line'>        !after(end_seq_0, prior_snd_una) &&
</span><span class='line'>        after(end_seq_0, tp-&gt;undo_marker))
</span><span class='line'>        //更新重传段的个数。
</span><span class='line'>        tp-&gt;undo_retrans--;
</span><span class='line'>
</span><span class='line'>    return dup_sack;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后回到tcp_sacktag_write_queue，接下来这部分很简单，主要是提取sack的段到sp中，并校验每个段的合法性，然后统计一些信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//开始遍历，这里num_sacks也就是我们前面计算的sack段的个数
</span><span class='line'>for (i = 0; i &lt; num_sacks; i++) {
</span><span class='line'>    int dup_sack = !i && found_dup_sack;
</span><span class='line'>
</span><span class='line'>    //赋值。
</span><span class='line'>    sp[used_sacks].start_seq = get_unaligned_be32(&sp_wire[i].start_seq);
</span><span class='line'>    sp[used_sacks].end_seq = get_unaligned_be32(&sp_wire[i].end_seq);
</span><span class='line'>
</span><span class='line'>    //检测段的合法性。
</span><span class='line'>    if (!tcp_is_sackblock_valid(tp, dup_sack,
</span><span class='line'>                    sp[used_sacks].start_seq,
</span><span class='line'>                    sp[used_sacks].end_seq)) {
</span><span class='line'>        int mib_idx;
</span><span class='line'>
</span><span class='line'>        if (dup_sack) {
</span><span class='line'>            if (!tp-&gt;undo_marker)
</span><span class='line'>                mib_idx = LINUX_MIB_TCPDSACKIGNOREDNOUNDO;
</span><span class='line'>            else
</span><span class='line'>                mib_idx = LINUX_MIB_TCPDSACKIGNOREDOLD;
</span><span class='line'>        } else {
</span><span class='line'>            /* Don't count olds caused by ACK reordering */
</span><span class='line'>            if ((TCP_SKB_CB(ack_skb)-&gt;ack_seq != tp-&gt;snd_una) &&
</span><span class='line'>                !after(sp[used_sacks].end_seq, tp-&gt;snd_una))
</span><span class='line'>                continue;
</span><span class='line'>            mib_idx = LINUX_MIB_TCPSACKDISCARD;
</span><span class='line'>        }
</span><span class='line'>        //更新统计信息。
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), mib_idx);
</span><span class='line'>        if (i == 0)
</span><span class='line'>            first_sack_index = -1;
</span><span class='line'>        continue;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //忽略已经确认过的段。
</span><span class='line'>    if (!after(sp[used_sacks].end_seq, prior_snd_una))
</span><span class='line'>        continue;
</span><span class='line'>    //这个值表示我们要使用的sack的段的个数。
</span><span class='line'>    used_sacks++;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后接下来的代码就是排序sack的段，也就是按照序列号的大小来排序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (i = used_sacks - 1; i &gt; 0; i--) {
</span><span class='line'>    for (j = 0; j &lt; i; j++) {
</span><span class='line'>        //可以看到这里通过比较起始序列号来排序。
</span><span class='line'>        if (after(sp[j].start_seq, sp[j + 1].start_seq)) {
</span><span class='line'>            //交换对应的值。
</span><span class='line'>            swap(sp[j], sp[j + 1]);
</span><span class='line'>
</span><span class='line'>            /* Track where the first SACK block goes to */
</span><span class='line'>            if (j == first_sack_index)
</span><span class='line'>                first_sack_index = j + 1;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后就是cache的初始化，这里的tcp socket的recv_sack_cache域要注意，这个域保存了上一次处理的sack的段的序列号。可以看到这个域类型也是tcp_sack_block，而且大小也是4,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//如果sack的数据段的个数为0,则说明我们要忽略调cache，此时可以看到cache指向recv_sack_cache的末尾。
</span><span class='line'>if (!tp-&gt;sacked_out) {
</span><span class='line'>    /* It's already past, so skip checking against it */
</span><span class='line'>    cache = tp-&gt;recv_sack_cache + ARRAY_SIZE(tp-&gt;recv_sack_cache);
</span><span class='line'>} else {
</span><span class='line'>    //否则取出cache，然后跳过空的块。
</span><span class='line'>    cache = tp-&gt;recv_sack_cache;
</span><span class='line'>    /* Skip empty blocks in at head of the cache */
</span><span class='line'>    while (tcp_sack_cache_ok(tp, cache) && !cache-&gt;start_seq &&
</span><span class='line'>           !cache-&gt;end_seq)
</span><span class='line'>        //跳过空的块。
</span><span class='line'>        cache++;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后就是开始真正处理重传队列中的skb了。</p>

<p>我们要知道重传队列中的skb有三种类型，分别是SACKED(S), RETRANS&reg; 和LOST(L)，而每种类型所处理的数据包的个数分别保存在sacked_out, retrans_out 和lost_out中。</p>

<p>而处于重传队列的skb也就是会处于下面6中状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> * Tag  InFlight    Description
</span><span class='line'> * 0       1        - orig segment is in flight.
</span><span class='line'> * S       0        - nothing flies, orig reached receiver.
</span><span class='line'> * L       0        - nothing flies, orig lost by net.
</span><span class='line'> * R       2        - both orig and retransmit are in flight.
</span><span class='line'> * L|R     1        - orig is lost, retransmit is in flight.
</span><span class='line'> * S|R     1        - orig reached receiver, retrans is still in flight.</span></code></pre></td></tr></table></div></figure>


<p>这里Tag也就是上面所说的三种类型，而InFlight也就是表示还在网络中的段的个数。</p>

<p>然后重传队列中的skb的状态变迁是通过下面这几种事件来触发的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 1. New ACK (+SACK) arrives. (tcp_sacktag_write_queue())
</span><span class='line'> * 2. Retransmission. (tcp_retransmit_skb(), tcp_xmit_retransmit_queue())
</span><span class='line'> * 3. Loss detection event of one of three flavors:
</span><span class='line'> *    A. Scoreboard estimator decided the packet is lost.
</span><span class='line'> *       A'. Reno "three dupacks" marks head of queue lost.
</span><span class='line'> *       A''. Its FACK modfication, head until snd.fack is lost.
</span><span class='line'> *    B. SACK arrives sacking data transmitted after never retransmitted
</span><span class='line'> *       hole was sent out.
</span><span class='line'> *    C. SACK arrives sacking SND.NXT at the moment, when the
</span><span class='line'> *       segment was retransmitted.
</span><span class='line'> * 4. D-SACK added new rule: D-SACK changes any tag to S.</span></code></pre></td></tr></table></div></figure>


<p>在进入这段代码分析之前，我们先来看几个重要的域。</p>

<p>tcp socket的high_seq域，这个域是我们进入拥塞控制的时候最大的发送序列号，也就是snd_nxt.</p>

<p>然后这里还有FACK的概念，FACK算法也就是收到的不同的SACK块之间的hole，他就认为是这些段丢失掉了。因此这里tcp socket有一个fackets_out域，这个域表示了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    //首先取得写队列的头，以便与下面的遍历。
</span><span class='line'>    skb = tcp_write_queue_head(sk);
</span><span class='line'>    state.fack_count = 0;
</span><span class='line'>    i = 0;
</span><span class='line'>
</span><span class='line'>    //这里used_sacks表示我们需要处理的sack段的个数。
</span><span class='line'>    while (i &lt; used_sacks) {
</span><span class='line'>        u32 start_seq = sp[i].start_seq;
</span><span class='line'>        u32 end_seq = sp[i].end_seq;
</span><span class='line'>        //得到是否是重复的sack
</span><span class='line'>        int dup_sack = (found_dup_sack && (i == first_sack_index));
</span><span class='line'>        struct tcp_sack_block *next_dup = NULL;
</span><span class='line'>
</span><span class='line'>        if (found_dup_sack && ((i + 1) == first_sack_index))
</span><span class='line'>            next_dup = &sp[i + 1];
</span><span class='line'>
</span><span class='line'>        //如果sack段的结束序列号大于将要发送的最大序列号，这个情况说明我们可能有数据丢失。因此设置丢失标记。这里可以看到也就是上面所说的事件B到达。
</span><span class='line'>        if (after(end_seq, tp-&gt;high_seq))
</span><span class='line'>            state.flag |= FLAG_DATA_LOST;
</span><span class='line'>
</span><span class='line'>        //跳过一些太老的cache
</span><span class='line'>        while (tcp_sack_cache_ok(tp, cache) &&
</span><span class='line'>               !before(start_seq, cache-&gt;end_seq))
</span><span class='line'>            cache++;
</span><span class='line'>
</span><span class='line'>        //如果有cache，就先处理cache的sack块。
</span><span class='line'>        if (tcp_sack_cache_ok(tp, cache) && !dup_sack &&
</span><span class='line'>            after(end_seq, cache-&gt;start_seq)) {
</span><span class='line'>
</span><span class='line'>            //如果当前的段的起始序列号小于cache的起始序列号(这个说明他们之间有交叉)，则我们处理他们之间的段。
</span><span class='line'>            if (before(start_seq, cache-&gt;start_seq)) {
</span><span class='line'>                skb = tcp_sacktag_skip(skb, sk, &state,
</span><span class='line'>                               start_seq);
</span><span class='line'>                skb = tcp_sacktag_walk(skb, sk, next_dup,
</span><span class='line'>                               &state,
</span><span class='line'>                               start_seq,
</span><span class='line'>                               cache-&gt;start_seq,
</span><span class='line'>                               dup_sack);
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            //处理剩下的块，也就是cache-&gt;end_seq和ned_seq之间的段。
</span><span class='line'>            if (!after(end_seq, cache-&gt;end_seq))
</span><span class='line'>                goto advance_sp;
</span><span class='line'>            //是否有需要跳过处理的skb
</span><span class='line'>            skb = tcp_maybe_skipping_dsack(skb, sk, next_dup,
</span><span class='line'>                               &state,
</span><span class='line'>                               cache-&gt;end_seq);
</span><span class='line'>
</span><span class='line'>            /* ...tail remains todo... */
</span><span class='line'>            //如果刚好等于sack处理的最大序列号，则我们需要处理这个段。
</span><span class='line'>            if (tcp_highest_sack_seq(tp) == cache-&gt;end_seq) {
</span><span class='line'>                /* ...but better entrypoint exists! */
</span><span class='line'>                skb = tcp_highest_sack(sk);
</span><span class='line'>                if (skb == NULL)
</span><span class='line'>                    break;
</span><span class='line'>                state.fack_count = tp-&gt;fackets_out;
</span><span class='line'>                cache++;
</span><span class='line'>                goto walk;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            //再次检测是否有需要skip的段。
</span><span class='line'>            skb = tcp_sacktag_skip(skb, sk, &state, cache-&gt;end_seq);
</span><span class='line'>
</span><span class='line'>            //紧接着处理下一个cache。
</span><span class='line'>            cache++;
</span><span class='line'>            continue;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        //然后处理这次新的sack段。
</span><span class='line'>        if (!before(start_seq, tcp_highest_sack_seq(tp))) {
</span><span class='line'>            skb = tcp_highest_sack(sk);
</span><span class='line'>            if (skb == NULL)
</span><span class='line'>                break;
</span><span class='line'>            state.fack_count = tp-&gt;fackets_out;
</span><span class='line'>        }
</span><span class='line'>        skb = tcp_sacktag_skip(skb, sk, &state, start_seq);
</span><span class='line'>
</span><span class='line'>walk:
</span><span class='line'>        //处理sack的段，主要是tag赋值。
</span><span class='line'>        skb = tcp_sacktag_walk(skb, sk, next_dup, &state,
</span><span class='line'>                       start_seq, end_seq, dup_sack);
</span><span class='line'>
</span><span class='line'>advance_sp:
</span><span class='line'>        /* SACK enhanced FRTO (RFC4138, Appendix B): Clearing correct
</span><span class='line'>         * due to in-order walk
</span><span class='line'>         */
</span><span class='line'>        if (after(end_seq, tp-&gt;frto_highmark))
</span><span class='line'>            state.flag &= ~FLAG_ONLY_ORIG_SACKED;
</span><span class='line'>
</span><span class='line'>        i++;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>上面的代码并不复杂，这里主要有两个函数，我们需要详细的来分析，一个是tcp_sacktag_skip，一个是tcp_sacktag_walk。</p>

<p>先来看tcp_sacktag_skip，我们给重传队列的skb的tag赋值时，我们需要遍历整个队列，可是由于我们有序列号，因此我们可以先确认起始的skb，然后从这个skb开始遍历，这里这个函数就是用来确认起始skb的，这里确认的步骤主要是通过start_seq来确认的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct sk_buff *tcp_sacktag_skip(struct sk_buff *skb, struct sock *sk,
</span><span class='line'>                    struct tcp_sacktag_state *state,
</span><span class='line'>                    u32 skip_to_seq)
</span><span class='line'>{
</span><span class='line'>    //开始遍历重传队列。
</span><span class='line'>    tcp_for_write_queue_from(skb, sk) {
</span><span class='line'>        //如果当前的skb刚好等于发送队列的头，则说明我们这个是第一个数据包，则我们直接跳出循环。
</span><span class='line'>        if (skb == tcp_send_head(sk))
</span><span class='line'>            break;
</span><span class='line'>
</span><span class='line'>        //如果skb的结束序列号大于我们传递进来的序列号，则说明这个skb包含了我们sack确认的段，因此我们退出循环。
</span><span class='line'>        if (after(TCP_SKB_CB(skb)-&gt;end_seq, skip_to_seq))
</span><span class='line'>            break;
</span><span class='line'>        //更新fack的计数。
</span><span class='line'>        state-&gt;fack_count += tcp_skb_pcount(skb);
</span><span class='line'>    }
</span><span class='line'>    //返回skb
</span><span class='line'>    return skb;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是最关键的一个函数tcp_sacktag_walk，这个函数主要是遍历重传队列，找到对应需要设置的段，然后设置tcp_cb的sacked域为TCPCB_SACKED_ACKED，这里要注意，还有一种情况就是sack确认了多个skb，这个时候我们就需要合并这些skb，然后再处理。</p>

<p>然后来看代码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct sk_buff *tcp_sacktag_walk(struct sk_buff *skb, struct sock *sk,
</span><span class='line'>                    struct tcp_sack_block *next_dup,
</span><span class='line'>                    struct tcp_sacktag_state *state,
</span><span class='line'>                    u32 start_seq, u32 end_seq,
</span><span class='line'>                    int dup_sack_in)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct sk_buff *tmp;
</span><span class='line'>
</span><span class='line'>    //开始遍历skb队列。
</span><span class='line'>    tcp_for_write_queue_from(skb, sk) {
</span><span class='line'>        //in_sack不为0的话表示当前的skb就是我们要设置标记的skb。
</span><span class='line'>        int in_sack = 0;
</span><span class='line'>        int dup_sack = dup_sack_in;
</span><span class='line'>
</span><span class='line'>        if (skb == tcp_send_head(sk))
</span><span class='line'>            break;
</span><span class='line'>
</span><span class='line'>        //由于skb是有序的，因此如果某个skb的序列号大于sack段的结束序列号，我们就退出循环。
</span><span class='line'>        if (!before(TCP_SKB_CB(skb)-&gt;seq, end_seq))
</span><span class='line'>            break;
</span><span class='line'>        //如果存在next_dup,则判断是否需要进入处理。这里就是skb的序列号小于dup的结束序列号
</span><span class='line'>        if ((next_dup != NULL) &&
</span><span class='line'>            before(TCP_SKB_CB(skb)-&gt;seq, next_dup-&gt;end_seq)) {
</span><span class='line'>            //返回值付给in_sack,也就是这个函数会返回当前skb是否能够被sack的段确认。
</span><span class='line'>            in_sack = tcp_match_skb_to_sack(sk, skb,
</span><span class='line'>                            next_dup-&gt;start_seq,
</span><span class='line'>                            next_dup-&gt;end_seq);
</span><span class='line'>            if (in_sack &gt; 0)
</span><span class='line'>                dup_sack = 1;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        //如果小于等于0,则尝试着合并多个skb段(主要是由于可能一个sack段确认了多个skb，这样我们尝试着合并他们)
</span><span class='line'>        if (in_sack &lt;= 0) {
</span><span class='line'>            tmp = tcp_shift_skb_data(sk, skb, state,
</span><span class='line'>                         start_seq, end_seq, dup_sack);
</span><span class='line'>            //这里tmp就为我们合并成功的skb。
</span><span class='line'>            if (tmp != NULL) {
</span><span class='line'>                //如果不等，则我们从合并成功的skb重新开始处理。
</span><span class='line'>                if (tmp != skb) {
</span><span class='line'>                    skb = tmp;
</span><span class='line'>                    continue;
</span><span class='line'>                }
</span><span class='line'>
</span><span class='line'>                in_sack = 0;
</span><span class='line'>            } else {
</span><span class='line'>                //否则我们单独处理这个skb
</span><span class='line'>                in_sack = tcp_match_skb_to_sack(sk, skb,
</span><span class='line'>                                start_seq,
</span><span class='line'>                                end_seq);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        if (unlikely(in_sack &lt; 0))
</span><span class='line'>            break;
</span><span class='line'>        //如果in_sack大于0,则说明我们需要处理这个skb了。
</span><span class='line'>        if (in_sack) {
</span><span class='line'>            //开始处理skb，紧接着我们会分析这个函数。
</span><span class='line'>            TCP_SKB_CB(skb)-&gt;sacked = tcp_sacktag_one(skb, sk,
</span><span class='line'>                                  state,
</span><span class='line'>                                  dup_sack,
</span><span class='line'>                                  tcp_skb_pcount(skb));
</span><span class='line'>            //是否需要更新sack处理的那个最大的skb。
</span><span class='line'>            if (!before(TCP_SKB_CB(skb)-&gt;seq,
</span><span class='line'>                    tcp_highest_sack_seq(tp)))
</span><span class='line'>                tcp_advance_highest_sack(sk, skb);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        state-&gt;fack_count += tcp_skb_pcount(skb);
</span><span class='line'>    }
</span><span class='line'>    return skb;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后我们来看tcp_sacktag_one函数，这个函数用来设置对应的tag，这里所要设置的也就是tcp_cb的sacked域。我们再来回顾一下它的值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define TCPCB_SACKED_ACKED      0x01 /* SKB ACK'd by a SACK block    */
</span><span class='line'>#define TCPCB_SACKED_RETRANS    0x02  /* SKB retransmitted        */
</span><span class='line'>#define TCPCB_LOST              0x04  /* SKB is lost          */
</span><span class='line'>#define TCPCB_TAGBITS           0x07  /* All tag bits         */
</span><span class='line'>#define TCPCB_EVER_RETRANS      0x80  /* Ever retransmitted frame */
</span><span class='line'>#define TCPCB_RETRANS     (TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS)</span></code></pre></td></tr></table></div></figure>


<p>如果一切都正常的话，我们最终就会设置skb的这个域为TCPCB_SACKED_ACKED，也就是已经被sack过了。</p>

<p>这个函数处理比较简单，主要就是通过序列号以及sacked本身的值最终来确认sacked要被设置的值。</p>

<p>这里我们还记得，一开始sacked是被初始化为sack option的偏移(如果是正确的sack)的.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static u8 tcp_sacktag_one(struct sk_buff *skb, struct sock *sk,
</span><span class='line'>              struct tcp_sacktag_state *state,
</span><span class='line'>              int dup_sack, int pcount)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    u8 sacked = TCP_SKB_CB(skb)-&gt;sacked;
</span><span class='line'>    int fack_count = state-&gt;fack_count;
</span><span class='line'>
</span><span class='line'>    ......
</span><span class='line'>
</span><span class='line'>    //如果skb的结束序列号小于发送未确认的，则说明这个帧应当被丢弃。
</span><span class='line'>    if (!after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una))
</span><span class='line'>        return sacked;
</span><span class='line'>    //如果当前的skb还未被sack确认过，则我们才会进入处理。
</span><span class='line'>    if (!(sacked & TCPCB_SACKED_ACKED)) {
</span><span class='line'>        //如果是重传被sack确认的。
</span><span class='line'>        if (sacked & TCPCB_SACKED_RETRANS) {
</span><span class='line'>            //如果设置了lost，则我们需要修改它的tag。
</span><span class='line'>            if (sacked & TCPCB_LOST) {
</span><span class='line'>                sacked &= ~(TCPCB_LOST|TCPCB_SACKED_RETRANS);
</span><span class='line'>                //更新lost的数据包
</span><span class='line'>                tp-&gt;lost_out -= pcount;
</span><span class='line'>                tp-&gt;retrans_out -= pcount;
</span><span class='line'>            }
</span><span class='line'>        } else {
</span><span class='line'>            .......
</span><span class='line'>        }
</span><span class='line'>        //开始修改sacked，设置flag。
</span><span class='line'>        sacked |= TCPCB_SACKED_ACKED;
</span><span class='line'>        state-&gt;flag |= FLAG_DATA_SACKED;
</span><span class='line'>        //增加sack确认的包的个数/
</span><span class='line'>        tp-&gt;sacked_out += pcount;
</span><span class='line'>
</span><span class='line'>        fack_count += pcount;
</span><span class='line'>
</span><span class='line'>        //处理fack
</span><span class='line'>        if (!tcp_is_fack(tp) && (tp-&gt;lost_skb_hint != NULL) &&
</span><span class='line'>            before(TCP_SKB_CB(skb)-&gt;seq,
</span><span class='line'>               TCP_SKB_CB(tp-&gt;lost_skb_hint)-&gt;seq))
</span><span class='line'>            tp-&gt;lost_cnt_hint += pcount;
</span><span class='line'>
</span><span class='line'>        if (fack_count &gt; tp-&gt;fackets_out)
</span><span class='line'>            tp-&gt;fackets_out = fack_count;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* D-SACK. We can detect redundant retransmission in S|R and plain R
</span><span class='line'>     * frames and clear it. undo_retrans is decreased above, L|R frames
</span><span class='line'>     * are accounted above as well.
</span><span class='line'>     */
</span><span class='line'>    if (dup_sack && (sacked & TCPCB_SACKED_RETRANS)) {
</span><span class='line'>        sacked &= ~TCPCB_SACKED_RETRANS;
</span><span class='line'>        tp-&gt;retrans_out -= pcount;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return sacked;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后我们来看tcp_sacktag_write_queue的最后一部分，也就是更新cache的部分。</p>

<p>它也就是将处理过的sack清0,没处理过的保存到cache中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//开始遍历，可以看到这里将将我们未处理的sack段的序列号清0.
</span><span class='line'>for (i = 0; i &lt; ARRAY_SIZE(tp-&gt;recv_sack_cache) - used_sacks; i++) {
</span><span class='line'>        tp-&gt;recv_sack_cache[i].start_seq = 0;
</span><span class='line'>        tp-&gt;recv_sack_cache[i].end_seq = 0;
</span><span class='line'>    }
</span><span class='line'>    //然后保存这次处理了的段。
</span><span class='line'>    for (j = 0; j &lt; used_sacks; j++)
</span><span class='line'>        tp-&gt;recv_sack_cache[i++] = sp[j];
</span><span class='line'>
</span><span class='line'>    //标记丢失的段。
</span><span class='line'>    tcp_mark_lost_retrans(sk);
</span><span class='line'>
</span><span class='line'>    tcp_verify_left_out(tp);
</span><span class='line'>
</span><span class='line'>    if ((state.reord &lt; tp-&gt;fackets_out) &&
</span><span class='line'>        ((icsk-&gt;icsk_ca_state != TCP_CA_Loss) || tp-&gt;undo_marker) &&
</span><span class='line'>        (!tp-&gt;frto_highmark || after(tp-&gt;snd_una, tp-&gt;frto_highmark)))
</span><span class='line'>        tcp_update_reordering(sk, tp-&gt;fackets_out - state.reord, 0);</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/53">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/51">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>12</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(31)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(123)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>57</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>18</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(19)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(26)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(123)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/07/07/ubuntu-kvm/">ubuntu安装kvm虚拟机</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/07/centos-kvm/">centos安装kvm虚拟机</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/06/centos-vnc/">vnc远程连接，远程登录服务器或者虚拟机</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/02/debug-crash-kmem/">crash kmem</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/02/kernel-net-info/">查看所有tcp连接</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
