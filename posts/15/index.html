
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>学习中......</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/03/23/kernel-net-rmem/">TCP接收缓存大小的动态调整</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-23T13:53:00+08:00'><span class='date'>2015-03-23</span> <span class='time'>13:53:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/zhangskd/article/details/8200048">http://blog.csdn.net/zhangskd/article/details/8200048</a></p>

<h4>引言</h4>

<p>TCP中有拥塞控制，也有流控制，它们各自有什么作用呢？</p>

<p>拥塞控制(Congestion Control) — A mechanism to prevent a TCP sender from overwhelming the network.<br/>
流控制(Flow Control) — A mechanism to prevent a TCP sender from overwhelming a TCP receiver.</p>

<p>下面是一段关于流控制原理的简要描述。<br/>
“The basic flow control algorithm works as follows: The receiver communicates to the sender the maximum amount of data it can accept using the rwnd protocol field. This is called the receive window. The TCP sender then sends no more than this amount of data across the network. The TCP sender then stops and waits for acknowledgements back from the receiver. When acknowledgement of the previously sent data is returned to the sender, the sender then resumes sending new data. It&rsquo;s essentially the old maxim hurry up and wait. ”</p>

<p>由于发送速度可能大于接收速度、接收端的应用程序未能及时从接收缓冲区读取数据、接收缓冲区不够大不能缓存所有接收到的报文等原因，TCP接收端的接收缓冲区很快就会被塞满，从而导致不能接收后续的数据，发送端此后发送数据是无效的，因此需要流控制。TCP流控制主要用于匹配发送端和接收端的速度，即根据接收端当前的接收能力来调整发送端的发送速度。</p>

<p>TCP流控制中一个很重要的地方就是，TCP接收缓存大小是如何动态调整的，即TCP确认窗口上限是如何动态调整的？</p>

<p>本文主要分析TCP接收缓存大小动态调整的原理和实现。</p>

<h4>原理</h4>

<p>早期的TCP实现中，TCP接收缓存的大小是固定的。随着网络的发展，固定的TCP接收缓存值就不适应了，成为TCP性能的瓶颈之一。这时候就需要手动去调整，因为不同的网络需要不同大小的TCP接收缓存，手动调整不仅费时费力，还会引起一些问题。TCP接收缓存设置小了，就不能充分利用网络。而TCP缓存设置大了，又浪费了内存。</p>

<p>如果把TCP接收缓存设置为无穷大，那就更糟糕了，因为某些应用可能会耗尽内存，使其它应用的连接陷入饥饿。所以TCP接收缓存的大小需要动态调整，才能达到最佳的效果。</p>

<p>动态调整TCP接收缓存大小，就是使TCP接收缓存按需分配，同时要确保TCP接收缓存大小不会成为传输的限制。</p>

<p>linux采用Dynamic Right-Sizing方法来动态调整TCP的接收缓存大小，其基本思想就是：通过估算发送方的拥塞窗口的大小，来动态设置TCP接收缓存的大小。</p>

<p>It has been demomstrated that this method can successfully grow the receiver&rsquo;s advertised window at a pace sufficient to avoid constraining the sender&rsquo;s throughput. As a result, systems can avoid the network performance problems that result from either the under-utilization or over-utilization of buffer space.</p>

<h4>实现</h4>

<p>下文代码基于3.2.12内核，主要源文件为：net/ipv4/tcp_input.c。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_sock {  
</span><span class='line'>    ...  
</span><span class='line'>    u32 rcv_nxt; /* What we want to receive next，希望接收的下一个序列号 */  
</span><span class='line'>    u32 rcv_wnd; /* Current receiver window，当前接收窗口的大小*/  
</span><span class='line'>    u32 copied_seq; /* Head of yet unread data，应用程序下次从这里复制数据 */  
</span><span class='line'>    u16 advmss; /* Advertised MSS，接收端通告的MSS */  
</span><span class='line'>    u32 window_clamp; /* Maximal window to advertise，通告窗口的上限*/  
</span><span class='line'>  
</span><span class='line'>    /* Receiver side RTT estimation */  
</span><span class='line'>    struct {  
</span><span class='line'>        u32 rtt;  
</span><span class='line'>        u32 seq;  
</span><span class='line'>        u32 time;  
</span><span class='line'>    } rcv_rtt_est; /* 用于接收端的RTT测量*/  
</span><span class='line'>  
</span><span class='line'>    /* Receiver queue space */  
</span><span class='line'>    struct {  
</span><span class='line'>        int space;  
</span><span class='line'>        u32 seq;  
</span><span class='line'>        u32 time;  
</span><span class='line'>    } rcvq_space; /* 用于调整接收缓冲区和接收窗口*/  
</span><span class='line'>  
</span><span class='line'>    /* Options received (usually on last packet, some only on SYN packets). */  
</span><span class='line'>    struct tcp_options_received rx_opt; /* TCP选项*/  
</span><span class='line'>    ...  
</span><span class='line'>};  
</span><span class='line'>  
</span><span class='line'>struct sock {  
</span><span class='line'>    ...  
</span><span class='line'>    int sk_rcvbuf; /* TCP接收缓冲区的大小*/  
</span><span class='line'>    int sk_sndbuf; /* TCP发送缓冲区大小*/  
</span><span class='line'>    unsigned int ...  
</span><span class='line'>        sk_userlocks : 4, /*TCP接收缓冲区的锁标志*/  
</span><span class='line'>    ...  
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h4>RTT测量</h4>

<p>在发送端有两种RTT的测量方法(具体可见前面blog)，但是因为TCP流控制是在接收端进行的，所以接收端也需要有测量RTT的方法。</p>

<h5>（1）没有时间戳时的测量方法</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void tcp_rcv_rtt_measure(struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>    /* 第一次接收到数据时，需要对相关变量初始化*/  
</span><span class='line'>    if (tp-&gt;rcv_rtt_est.time == 0)  
</span><span class='line'>        goto new_measure;  
</span><span class='line'>  
</span><span class='line'>    /* 收到指定的序列号后，才能获取一个RTT测量样本*/  
</span><span class='line'>    if (before(tp-&gt;rcv_nxt, tp-&gt;rcv_rtt_est.seq))  
</span><span class='line'>        return;  
</span><span class='line'>  
</span><span class='line'>    /* RTT的样本：jiffies - tp-&gt;rcv_rtt_est.time */  
</span><span class='line'>    tcp_rcv_rtt_update(tp, jiffies - tp-&gt;rcv_rtt_est.time, 1);  
</span><span class='line'>  
</span><span class='line'>new_measure:  
</span><span class='line'>    tp-&gt;rcv_rtt_est.seq = tp-&gt;rcv_nxt + tp-&gt;rcv_wnd; /* 收到此序列号的ack时，一个RTT样本的计时结束*/  
</span><span class='line'>    tp-&gt;rcv_rtt_est.time = tcp_time_stamp; /* 一个RTT样本开始计时*/  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>此函数在接收到带有负载的数据段时被调用。</p>

<p>此函数的原理：我们知道发送端不可能在一个RTT期间发送大于一个通告窗口的数据量。那么接收端可以把接收一个确认窗口的数据量(rcv_wnd)所用的时间作为RTT。接收端收到一个数据段，然后发送确认(确认号为rcv_nxt，通告窗口为rcv_wnd)，开始计时，RTT就是收到序号为rcv_nxt + rcv_wnd的数据段所用的时间。很显然，这种假设并不准确，测量所得的RTT会偏大一些。所以这种方法只有当没有采用时间戳选项时才使用，而内核默认是采用时间戳选项的(tcp_timestamps为1)。</p>

<p>下面是一段对此方法的评价：<br/>
If the sender is being throttled by the network, this estimate will be valid. However, if the sending application did not have any data to send, the measured time could be much larger than the actual round-trip time. Thus this measurement acts only as an upper-bound on the round-trip time.</p>

<h5>（2）采用时间戳选项时的测量方法</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void tcp_rcv_rtt_measure_ts(struct sock *sk, const struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    /* 启用了Timestamps选项，并且流量稳定*/  
</span><span class='line'>    if (tp-&gt;rx_opt.rcv_tsecr && (TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq &gt;=  
</span><span class='line'>        inet_csk(sk)-&gt;icsk_ack.rcv_mss))  
</span><span class='line'>        /* RTT = 当前时间 - 回显时间*/  
</span><span class='line'>        tcp_rcv_rtt_update(tp, tcp_time_stamp - tp-&gt;rx_opt.rcv_tsecr, 0);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>虽然此种方法是默认方法，但是在流量小的时候，通过时间戳采样得到的RTT的值会偏大，此时就会采用没有时间戳时的RTT测量方法。</p>

<h5>（3）采样处理</h5>

<p>不管是没有使用时间戳选项的RTT采样，还是使用时间戳选项的RTT采样，都是获得一个RTT样本。之后还需要对获得的RTT样本进行处理，以得到最终的RTT。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* win_dep表示是否对RTT采样进行微调，1为不进行微调，0为进行微调。*/  
</span><span class='line'>static void tcp_rcv_rtt_update(struct tcp_sock *tp, u32 sample, int win_dep)  
</span><span class='line'>{  
</span><span class='line'>    u32 new_sample = tp-&gt;rcv_rtt_est.rtt;  
</span><span class='line'>    long m = sample;  
</span><span class='line'>  
</span><span class='line'>    if (m == 0)  
</span><span class='line'>        m = 1; /* 时延最小为1ms*/  
</span><span class='line'>  
</span><span class='line'>    if (new_sample != 0) { /* 不是第一次获得样本*/  
</span><span class='line'>        /* If we sample in larger samples in the non-timestamp case, we could grossly 
</span><span class='line'>         * overestimate the RTT especially with chatty applications or bulk transfer apps 
</span><span class='line'>         * which are stalled on filesystem I/O. 
</span><span class='line'>         * 
</span><span class='line'>         * Also, since we are only going for a minimum in the non-timestamp case, we do 
</span><span class='line'>         * not smooth things out else with timestamps disabled convergence takes too long. 
</span><span class='line'>         */  
</span><span class='line'>        /* 对RTT采样进行微调，新的RTT样本只占最终RTT的1/8 */  
</span><span class='line'>        if (! win_dep) {   
</span><span class='line'>            m -= (new_sample &gt;&gt; 3);  
</span><span class='line'>            new_sample += m;  
</span><span class='line'>  
</span><span class='line'>        } else if (m &lt; new_sample)  
</span><span class='line'>            /* 不对RTT采样进行微调，直接取最小值，原因可见上面那段注释*/  
</span><span class='line'>            new_sample = m &lt;&lt; 3;   
</span><span class='line'>  
</span><span class='line'>    } else {   
</span><span class='line'>        /* No previous measure. 第一次获得样本*/  
</span><span class='line'>        new_sample = m &lt;&lt; 3;  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    if (tp-&gt;rcv_rtt_est.rtt != new_sample)  
</span><span class='line'>        tp-&gt;rcv_rtt_est.rtt = new_sample; /* 更新RTT*/  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对于没有使用时间戳选项的RTT测量方法，不进行微调。因为用此种方法获得的RTT采样值已经偏高而且收敛很慢。直接选择最小RTT样本作为最终的RTT测量值。<br/>
对于使用时间戳选项的RTT测量方法，进行微调，新样本占最终RTT的1/8，即rtt = 7/8 old + 1/8 new。</p>

<h4>调整接收缓存</h4>

<p>当数据从TCP接收缓存复制到用户空间之后，会调用tcp_rcv_space_adjust()来调整TCP接收缓存和接收窗口上限的大小。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*  
</span><span class='line'> * This function should be called every time data is copied to user space. 
</span><span class='line'> * It calculates the appropriate TCP receive buffer space. 
</span><span class='line'> */  
</span><span class='line'>void tcp_rcv_space_adjust(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    int time;  
</span><span class='line'>    int space;  
</span><span class='line'>  
</span><span class='line'>    /* 第一次调整*/  
</span><span class='line'>    if (tp-&gt;rcvq_space.time == 0)  
</span><span class='line'>        goto new_measure;  
</span><span class='line'>  
</span><span class='line'>    time = tcp_time_stamp - tp-&gt;rcvq_space.time; /*计算上次调整到现在的时间*/  
</span><span class='line'>  
</span><span class='line'>    /* 调整至少每隔一个RTT才进行一次，RTT的作用在这里！*/  
</span><span class='line'>    if (time &lt; (tp-&gt;rcv_rtt_est.rtt &gt;&gt; 3) || tp-&gt;rcv_rtt_est.rtt == 0)  
</span><span class='line'>        return;  
</span><span class='line'>  
</span><span class='line'>    /* 一个RTT内接收方应用程序接收并复制到用户空间的数据量的2倍*/  
</span><span class='line'>    space = 2 * (tp-&gt;copied_seq - tp-&gt;rcvq_space.seq);  
</span><span class='line'>    space = max(tp-&gt;rcvq_space.space, space);  
</span><span class='line'>  
</span><span class='line'>    /* 如果这次的space比上次的大*/  
</span><span class='line'>    if (tp-&gt;rcvq_space.space != space) {  
</span><span class='line'>        int rcvmem;  
</span><span class='line'>        tp-&gt;rcvq_space.space = space; /*更新rcvq_space.space*/  
</span><span class='line'>  
</span><span class='line'>        /* 启用自动调节接收缓冲区大小，并且接收缓冲区没有上锁*/  
</span><span class='line'>        if (sysctl_tcp_moderate_rcvbuf && ! (sk-&gt;sk_userlocks & SOCK_RCVBUF_LOCK)) {  
</span><span class='line'>            int new_clamp = space;  
</span><span class='line'>            /* Receive space grows, normalize in order to take into account packet headers and 
</span><span class='line'>             * sk_buff structure overhead. 
</span><span class='line'>             */  
</span><span class='line'>             space /= tp-&gt;advmss; /* 接收缓冲区可以缓存数据包的个数*/  
</span><span class='line'>  
</span><span class='line'>             if (!space)  
</span><span class='line'>                space = 1;  
</span><span class='line'>  
</span><span class='line'>            /* 一个数据包耗费的总内存包括： 
</span><span class='line'>               * 应用层数据：tp-&gt;advmss， 
</span><span class='line'>               * 协议头：MAX_TCP_HEADER， 
</span><span class='line'>               * sk_buff结构， 
</span><span class='line'>               * skb_shared_info结构。 
</span><span class='line'>               */  
</span><span class='line'>             rcvmem = SKB_TRUESIZE(tp-&gt;advmss + MAX_TCP_HEADER);  
</span><span class='line'>  
</span><span class='line'>             /* 对rcvmem进行微调*/  
</span><span class='line'>             while(tcp_win_from_space(rcvmem) &lt; tp-&gt;advmss)  
</span><span class='line'>                 rcvmem += 128;  
</span><span class='line'>  
</span><span class='line'>             space *= rcvmem;  
</span><span class='line'>             space = min(space, sysctl_tcp_rmem[2]); /*不能超过允许的最大接收缓冲区大小*/  
</span><span class='line'>  
</span><span class='line'>             if (space &gt; sk-&gt;sk_rcvbuf) {  
</span><span class='line'>                 sk-&gt;sk_rcvbuf = space; /* 调整接收缓冲区的大小*/  
</span><span class='line'>                 /* Make the window clamp follow along. */  
</span><span class='line'>                 tp-&gt;window_clamp = new_clamp; /*调整接收窗口的上限*/  
</span><span class='line'>             }  
</span><span class='line'>        }  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>new_measure:  
</span><span class='line'>     /*此序号之前的数据已复制到用户空间，下次复制将从这里开始*/  
</span><span class='line'>    tp-&gt;rcvq_space.seq = tp-&gt;copied_seq;  
</span><span class='line'>    tp-&gt;rcvq_space.time = tcp_time_stamp; /*记录这次调整的时间*/  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>/* return minimum truesize of the skb containing X bytes of data */  
</span><span class='line'>#define SKB_TRUESIZE(X) ((X) +              \  
</span><span class='line'>                            SKB_DATA_ALIGN(sizeof(struct sk_buff)) +        \  
</span><span class='line'>                            SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))  
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>static inline int tcp_win_from_space(int space)  
</span><span class='line'>{  
</span><span class='line'>    return sysctl_tcp_adv_win_scale &lt;= 0 ?  
</span><span class='line'>              (space &gt;&gt; (-sysctl_tcp_adv_win_scale)) :  
</span><span class='line'>               space - (space &gt;&gt; sysctl_tcp_adv_win_scale);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>tp->rcvq_space.space表示当前接收缓存的大小（只包括应用层数据，单位为字节）。<br/>
sk->sk_rcvbuf表示当前接收缓存的大小（包括应用层数据、TCP协议头、sk_buff和skb_shared_info结构，tcp_adv_win_scale微调，单位为字节）。</p>

<h4>系统参数</h4>

<h5>(1) tcp_moderate_rcvbuf</h5>

<p>是否自动调节TCP接收缓冲区的大小，默认值为1。</p>

<h5>(2) tcp_adv_win_scale</h5>

<p>在tcp_moderate_rcvbuf启用的情况下，用来对计算接收缓冲区和接收窗口的参数进行微调，默认值为2。<br/>
This means that the application buffer is &frac14;th of the total buffer space specified in the tcp_rmem variable.</p>

<h5>(3) tcp_rmem</h5>

<p>包括三个参数：min default max。<br/>
tcp_rmem[1] — default ：接收缓冲区长度的初始值，用来初始化sock的sk_rcvbuf，默认为87380字节。<br/>
tcp_rmem[2] — max：接收缓冲区长度的最大值，用来调整sock的sk_rcvbuf，默认为4194304，一般是2000多个数据包。</p>

<h5>小结</h5>

<p>接收端的接收窗口上限和接收缓冲区大小，是接收方应用程序在上个RTT内接收并复制到用户空间的数据量的2倍，并且接收窗口上限和接收缓冲区大小是递增的。</p>

<h6>（1）为什么是2倍呢？</h6>

<p>In order to keep pace with the growth of the sender&rsquo;s congestion window during slow-start, the receiver should use the same doubling factor. Thus the receiver should advertise a window that is twice the size of the last measured window size.</p>

<p>这样就能保证接收窗口上限的增长速度不小于拥塞窗口的增长速度，避免接收窗口成为传输瓶颈。</p>

<h6>（2）收到乱序包时有什么影响？</h6>

<p>Packets that are received out of order may have lowered the goodput during this measurement, but will increase the goodput of the following measurement which, if larger, will supercede this measurement.</p>

<p>乱序包会使本次的吞吐量测量值偏小，使下次的吞吐量测量值偏大。</p>

<h4>Reference</h4>

<p>[1] Mike Fisk, Wu-chun Feng, &ldquo;Dynamic Right-Sizing in TCP&rdquo;.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/03/19/kernel-net-tso2/">TCP的TSO处理（一）</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-19T18:27:00+08:00'><span class='date'>2015-03-19</span> <span class='time'>18:27:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/zhangskd/article/details/7699081">http://blog.csdn.net/zhangskd/article/details/7699081</a></p>

<h4>概述</h4>

<p>In computer networking, large segment offload (LSO) is a technique for increasing outbound
throughput of high-bandwidth network connections by reducing CPU overhead. It works by queuing
up large buffers and letting the network interface card (NIC) split them into separate packets.
The technique is also called TCP segmentation offload (TSO) when applied to TCP, or generic
segmentation offload (GSO).</p>

<p>The inbound counterpart of large segment offload is large recive offload (LRO).</p>

<p>When large chunks of data are to be sent over a computer network, they need to be first broken
down to smaller segments that can pass through all the network elements like routers and
switches between the source and destination computers. This process it referred to as
segmentation. Segmentation is often done by the TCP protocol in the host computer. Offloading
this work to the NIC is called TCP segmentation offload (TSO).</p>

<p>For example, a unit of 64KB (65,536 bytes) of data is usually segmented to 46 segments of 1448
bytes each before it is sent over the network through the NIC. With some intelligence in the NIC,
the host CPU can hand over the 64KB of data to the NIC in a single transmit request, the NIC can
break that data down into smaller segments of 1448 bytes, add the TCP, IP, and data link layer
protocol headers——according to a template provided by the host&rsquo;s TCP/IP stack——to each
segment, and send the resulting frames over the network. This significantly reduces the work
done by the CPU. Many new NICs on the market today support TSO. [1]</p>

<h4>具体</h4>

<p>It is a method to reduce CPU workload of packet cutting in 1500byte and asking hardware to
perform the same functionality.</p>

<p>1.TSO feature is implemented using the hardware support. This means hardware should be
able to segment the packets in max size of 1500 byte and reattach the header with every
packets.</p>

<p>2.Every network hardware is represented by netdevice structure in kernel. If hardware supports
TSO, it enables the Segmentation offload features in netdevice, mainly represented by
&ldquo; NETIF_F_TSO&rdquo; and other fields. [2]</p>

<p>TCP Segmentation Offload is supported in Linux by the network device layer. A driver that wants
to offer TSO needs to set the NETIF_F_TSO bit in the network device structure. In order for a
device to support TSO, it needs to also support Net : TCP Checksum Offloading and
Net : Scatter Gather.</p>

<p>The driver will then receive super-sized skb&rsquo;s. These are indicated to the driver by
skb_shinfo(skb)->gso_size being non-zero. The gso_size is the size the hardware should
fragment the TCP data. TSO may change how and when TCP decides to send data. [3]</p>

<h4>实现</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* This data is invariant across clones and lives at the end of the 
</span><span class='line'> * header data, ie. at skb-&gt;end. 
</span><span class='line'> */  
</span><span class='line'>struct skb_share_info {  
</span><span class='line'>    ...  
</span><span class='line'>   unsigned short gso_size; // 每个数据段的大小  
</span><span class='line'>   unsigned short gso_segs; // skb被分割成多少个数据段  
</span><span class='line'>   unsigned short gso_type;  
</span><span class='line'>   struct sk_buff *frag_list; // 分割后的数据包列表  
</span><span class='line'>   ...  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Initialize TSO state of skb. 
</span><span class='line'> * This must be invoked the first time we consider transmitting 
</span><span class='line'> * SKB onto the wire. 
</span><span class='line'> */  
</span><span class='line'>static int tcp_init_tso_segs(struct sock *sk, struct sk_buff *skb,  
</span><span class='line'>                                            unsigned int mss_now)  
</span><span class='line'>{  
</span><span class='line'>    int tso_segs = tcp_skb_pcount(skb);  
</span><span class='line'>  
</span><span class='line'>    /* 如果还没有分段，或者有多个分段但是分段长度不等于当前MSS，则需处理*/  
</span><span class='line'>    if (! tso_segs || (tso_segs &gt; 1 && tcp_skb_mss(skb) != mss_now)) {  
</span><span class='line'>        tcp_set_skb_tso_segs(sk, skb, mss_now);  
</span><span class='line'>  
</span><span class='line'>        tso_segs = tcp_skb_pcount(skb);/* 重新获取分段数量 */  
</span><span class='line'>    }  
</span><span class='line'>    return tso_segs;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>/* Initialize TSO segments for a packet. */  
</span><span class='line'>static void tcp_set_skb_tso_segs(struct sock *sk, struct sk_buff *skb,  
</span><span class='line'>                                        unsigned int mss_now)  
</span><span class='line'>{  
</span><span class='line'>    /* 有以下情况则不需要分片： 
</span><span class='line'>      * 1. 数据的长度不超过允许的最大长度MSS 
</span><span class='line'>     * 2. 网卡不支持GSO 
</span><span class='line'>     * 3. 网卡不支持重新计算校验和 
</span><span class='line'>     */  
</span><span class='line'>    if (skb-&gt;len &lt;= mss_now || ! sk_can_gso(sk) ||  
</span><span class='line'>        skb-&gt;ip_summed == CHECKSUM_NONE) {  
</span><span class='line'>  
</span><span class='line'>        /* Avoid the costly divide in the normal non-TSO case.*/  
</span><span class='line'>        skb_shinfo(skb)-&gt;gso_segs = 1;  
</span><span class='line'>        skb_shinfo(skb)-&gt;gso_size = 0;  
</span><span class='line'>        skb_shinfo(skb)-&gt;gso_type = 0;  
</span><span class='line'>    } else {  
</span><span class='line'>  
</span><span class='line'>        /* 计算需要分成几个数据段*/  
</span><span class='line'>        skb_shinfo(skb)-&gt;gso_segs = DIV_ROUND_UP(skb-&gt;len, mss_now);/*向上取整*/  
</span><span class='line'>        skb_shinfo(skb)-&gt;gso_size = mss_now; /* 每个数据段的大小*/  
</span><span class='line'>        skb_shinfo(skb)-&gt;gso_type = sk-&gt;sk_gso_type;  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>/* Due to TSO, an SKB can be composed of multiple actual packets.  
</span><span class='line'> * To keep these tracked properly, we use this. 
</span><span class='line'> */  
</span><span class='line'>static inline int tcp_skb_pcount (const struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>    return skb_shinfo(skb)-&gt;gso_segs;  
</span><span class='line'>}  
</span><span class='line'>   
</span><span class='line'>/* This is valid if tcp_skb_pcount() &gt; 1 */  
</span><span class='line'>static inline int tcp_skb_mss(const struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>    return skb_shinfo(skb)-&gt;gso_size;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>static inline int sk_can_gso(const struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    /* sk_route_caps标志网卡驱动的特征, sk_gso_type表示GSO的类型， 
</span><span class='line'>     * 设置为SKB_GSO_TCPV4 
</span><span class='line'>     */  
</span><span class='line'>    return net_gso_ok(sk-&gt;sk_route_caps, sk-&gt;sk_gso_type);  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>static inline int net_gso_ok(int features, int gso_type)  
</span><span class='line'>{  
</span><span class='line'>    int feature = gso_type &lt;&lt; NETIF_F_GSO_SHIFT;  
</span><span class='line'>    return (features & feature) == feature;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>sk_gso_max_size</h5>

<p>NIC also specify the maximum segment size which it can handle, in sk_gso_max_size field.
Mostly it will be set to 64k. This 64k values means if the data at TCP is more than 64k,
then again TCP has to segment it in 64k and then push to interface.</p>

<p>相关变量，sock中：unsigned int sk_gso_max_size.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* RFC2861 Check whether we are limited by application or congestion window 
</span><span class='line'> * This is the inverse of cwnd check in tcp_tso_should_defer 
</span><span class='line'> * 函数返回1，受拥塞控制窗口的限制，需要增加拥塞控制窗口； 
</span><span class='line'> * 函数返回0，受应用程序的限制，不需要增加拥塞控制窗口。 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>int tcp_is_cwnd_limited(const struct sock *sk, u32 in_flight)  
</span><span class='line'>{  
</span><span class='line'>    const struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    u32 left;  
</span><span class='line'>   
</span><span class='line'>    if (in_flight &gt;= tp-&gt;snd_cwnd)  
</span><span class='line'>        return 1;  
</span><span class='line'>   
</span><span class='line'>    /* left表示还可以发送的数据量 */  
</span><span class='line'>    left = tp-&gt;snd_cwnd - in_flight;  
</span><span class='line'>   
</span><span class='line'>  
</span><span class='line'>    /* 如果使用gso，符合以下条件，认为是拥塞窗口受到了限制， 
</span><span class='line'>     * 可以增加拥塞窗口。 
</span><span class='line'>     */  
</span><span class='line'>    if (sk_can_gso(sk) &&   
</span><span class='line'>        left * sysctl_tcp_tso_win_divisor &lt; tp-&gt;snd_cwnd &&  
</span><span class='line'>        left * tp-&gt;mss_cache &lt; sk-&gt;sk_gso_max_size)  
</span><span class='line'>        return 1;  
</span><span class='line'>  
</span><span class='line'>    /* 如果left大于允许的突发流量，那么拥塞窗口的增长已经很快了， 
</span><span class='line'>     * 不能再增加了。 
</span><span class='line'>     */  
</span><span class='line'>    return left &lt;= tcp_max_burst(tp);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>TSO Nagle</h4>

<p>GSO, Generic Segmentation Offload，是协议栈提高效率的一个策略。</p>

<p>它尽可能晚的推迟分段(segmentation)，最理想的是在网卡驱动里分段，在网卡驱动里把
大包(super-packet)拆开，组成SG list，或在一块预先分配好的内存中重组各段，然后交给
网卡。</p>

<p>The idea behind GSO seems to be that many of the performance benefits of LSO (TSO/UFO)
can be obtained in a hardware-independent way, by passing large &ldquo;superpackets&rdquo; around for
as long as possible, and deferring segmentation to the last possible moment - for devices
without hardware segmentation/fragmentation support, this would be when data is actually
handled to the device driver; for devices with hardware support, it could even be done in hardware.</p>

<p>Try to defer sending, if possible, in order to minimize the amount of TSO splitting we do.
View it as a kind of TSO Nagle test.</p>

<p>通过延迟数据包的发送，来减少TSO分段的次数，达到减小CPU负载的目的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_sock {  
</span><span class='line'>    ...  
</span><span class='line'>    u32 tso_deferred; /* 上次TSO延迟的时间戳 */  
</span><span class='line'>    ...  
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** This algorithm is from John Heffner. 
</span><span class='line'> * 0: send now ; 1: deferred 
</span><span class='line'> */  
</span><span class='line'>static int tcp_tso_should_defer (struct sock *sk, struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    const struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>    u32 in_flight, send_win, cong_win, limit;  
</span><span class='line'>    int win_divisor;  
</span><span class='line'>      
</span><span class='line'>    /* 如果此skb包含结束标志，则马上发送*/  
</span><span class='line'>    if (TCP_SKB_CB(skb)-&gt;flags & TCPHDR_FIN)  
</span><span class='line'>        goto send_now;  
</span><span class='line'>  
</span><span class='line'>    /* 如果此时不处于Open态，则马上发送*/  
</span><span class='line'>    if (icsk-&gt;icsk_ca_state != TCP_CA_Open)  
</span><span class='line'>        goto send_now;  
</span><span class='line'>  
</span><span class='line'>    /* Defer for less than two clock ticks. 
</span><span class='line'>     * 上个skb被延迟了，且超过现在1ms以上，则不再延迟。 
</span><span class='line'>     * 也就是说，TSO延迟不能超过2ms！ 
</span><span class='line'>     */  
</span><span class='line'>    if (tp-&gt;tso_deferred && (((u32)jiffies &lt;&lt;1) &gt;&gt; 1) - (tp-&gt;tso_deferred &gt;&gt; 1) &gt; 1)  
</span><span class='line'>        goto send_now;  
</span><span class='line'>    
</span><span class='line'>    in_flight = tcp_packets_in_flight(tp);  
</span><span class='line'>    /* 如果此数据段不用分片，或者受到拥塞窗口的限制不能发包，则报错*/  
</span><span class='line'>    BUG_ON(tcp_skb_pcount(skb) &lt;= 1 || (tp-&gt;snd_cwnd &lt;= in_flight));  
</span><span class='line'>    /* 通告窗口的剩余大小*/  
</span><span class='line'>    send_win = tcp_wnd_end(tp) - TCP_SKB_CB(skb)-&gt;seq;  
</span><span class='line'>    /* 拥塞窗口的剩余大小*/  
</span><span class='line'>    cong_win = (tp-&gt;snd_cwnd - in_flight) * tp-&gt;mss_cache;  
</span><span class='line'>    /* 取其小者作为最终的发送限制*/  
</span><span class='line'>    limit = min(send_win, cong_win);  
</span><span class='line'>  
</span><span class='line'>    /*If a full-sized TSO skb can be sent, do it. 
</span><span class='line'>     * 一般来说是64KB 
</span><span class='line'>     */  
</span><span class='line'>    if (limit &gt;= sk-&gt;sk_gso_max_size)  
</span><span class='line'>        goto send_now;  
</span><span class='line'>  
</span><span class='line'>    /* Middle in queue won't get any more data, full sendable already ? */  
</span><span class='line'>    if ((skb != tcp_write_queue_tail(sk)) && (limit &gt;= skb-&gt;len))  
</span><span class='line'>        goto send_now;  
</span><span class='line'>  
</span><span class='line'>    win_divisor = ACCESS_ONCE(sysctl_tcp_tso_win_divisor);  
</span><span class='line'>    if (win_divisor) {  
</span><span class='line'>        /* 一个RTT内允许发送的最大字节数*/  
</span><span class='line'>        u32 chunk = min(tp-&gt;snd_wnd, tp-&gt;snd_cwnd * tp-&gt;mss_cache);  
</span><span class='line'>        chunk /= win_divisor; /* 单个TSO段可消耗的发送量*/  
</span><span class='line'>  
</span><span class='line'>        /* If at least some fraction of a window is available, just use it. */  
</span><span class='line'>        if (limit &gt;= chunk)  
</span><span class='line'>            goto send_now;  
</span><span class='line'>    } else {  
</span><span class='line'>        /* Different approach, try not to defer past a single ACK. 
</span><span class='line'>         * Receiver should ACK every other full sized frame, so if we have space for 
</span><span class='line'>         * more than 3 frames then send now. 
</span><span class='line'>         */  
</span><span class='line'>        if (limit &gt; tcp_max_burst(tp) * tp-&gt;mss_cache)  
</span><span class='line'>            goto send_now;  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    /* OK, it looks like it is advisable to defer. */  
</span><span class='line'>    tp-&gt;tso_deferred = 1 | (jiffies &lt;&lt; 1); /* 记录此次defer的时间戳*/  
</span><span class='line'>  
</span><span class='line'>    return 1;  
</span><span class='line'>  
</span><span class='line'>send_now:  
</span><span class='line'>    tp-&gt;tso_deferred = 0;  
</span><span class='line'>    return 0;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>/* Returns end sequence number of the receiver's advertised window */  
</span><span class='line'>static inline u32 tcp_wnd_end (const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>    /* snd_wnd的单位为字节*/  
</span><span class='line'>    return tp-&gt;snd_una + tp-&gt;snd_wnd;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>tcp_tso_win_divisor：单个TSO段可消耗拥塞窗口的比例，默认值为3。</p>

<h5>符合以下任意条件，不会TSO延迟，可马上发送：</h5>

<p>(1) 数据包带有FIN标志。传输快结束了，不宜延迟。<br/>
(2) 发送方不处于Open拥塞状态。处于异常状态时，不宜延迟。<br/>
(3) 上一次skb被延迟了，且距离现在大于等于2ms。延迟不能超过2ms。<br/>
(4) min(send_win, cong_win) > full-sized TSO skb。允许发送的数据量超过TSO一次能处理的最大值，没必要再defer。<br/>
(5) skb处于发送队列中间，且允许整个skb一起发送。处于发送队列中间的skb不能再获得新的数据，没必要再defer。<br/>
(6) tcp_tso_win_divisor有设置时，limit > 单个TSO段可消耗的数据量，即min(snd_wnd, snd_cwnd * mss_cache) / tcp_tso_win_divisor。<br/>
(7) tcp_tso_win_divisor没有设置时，limit > tcp_max_burst(tp) * mss_cache，一般是3个数据包。</p>

<p>条件4、5、6/7，都是limit > 某个阈值，就可以马上发送。这个因为通过这几个条件，可以确定此时发送是受到应用程序的限制，而不是通告窗口或者拥塞窗口。在应用程序发送的数据量很少的情况下，不宜采用TSO Nagle，因为这会影响此类应用。</p>

<p>我们注意到tcp_is_cwnd_limited()中的注释说：<br/>
&ldquo; This is the inverse of cwnd check in tcp_tso_should_defer"，所以可以认为在tcp_tso_should_defer()中包含判断
tcp_is_not_cwnd_limited (或者tcp_is_application_limited) 的条件。</p>

<h5>符合以下所有条件，才会进行TSO延迟：</h5>

<p>(1) 数据包不带有FIN标志。<br/>
(2) 发送方处于Open拥塞状态。<br/>
(3) 距离上一次延迟的时间在2ms以内。<br/>
(4) 允许发送的数据量小于sk_gso_max_size。<br/>
(5) skb处于发送队列末尾，或者skb不能整个发送出去。<br/>
(6) tcp_tso_win_divisor有设置时，允许发送的数据量不大于单个TSO段可消耗的。<br/>
(7) tcp_tso_win_divisor没有设置时，允许发送的数据量不大于3个包。</p>

<p>可以看到TSO的触发条件并不苛刻，所以被调用时并没有加unlikely。</p>

<h4>应用</h4>

<h5>(1) 禁用TSO</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ethtool -K ethX tso off</span></code></pre></td></tr></table></div></figure>


<h5>(2) 启用TSO</h5>

<p>TSO是默认启用的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ethtool -K ethX tso on</span></code></pre></td></tr></table></div></figure>


<h4>Reference</h4>

<p>[1] <a href="http://en.wikipedia.org/wiki/Large_segment_offload">http://en.wikipedia.org/wiki/Large_segment_offload</a></p>

<p>[2] <a href="http://tejparkash.wordpress.com/2010/03/06/tso-explained/">http://tejparkash.wordpress.com/2010/03/06/tso-explained/</a></p>

<p>[3] <a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/tso">http://www.linuxfoundation.org/collaborate/workgroups/networking/tso</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/03/19/kernel-net-tso1/">TSO/GSO</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-19T18:24:00+08:00'><span class='date'>2015-03-19</span> <span class='time'>18:24:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://book.51cto.com/art/201206/344985.htm">http://book.51cto.com/art/201206/344985.htm</a></p>

<p>TSO是通过网络设备进行TCP段的分割，从而来提高网络性能的一种技术。较大的数据包（超过标准1518B的帧）可以使用该技术，使操作系统减少必须处理的数据数量以提高性能。通常，当请求大量数据时，TCP发送方必须将数据拆分为MSS大小的数据块，然后进一步将其封装为数据包形式，以便最终可以在网络中进行传输。而当启用了TSO技术之后，TCP发送方可以将数据拆分为MSS整数倍大小的数据块，然后将大块数据的分段直接交给网络设备处理，操作系统需要创建并传输的数据包数量更少，因此性能会有较大的提高。图1-3所示为标准帧和TSO技术特性比较。</p>

<p><img src="/images/kernel/2015-03-19-3.jpg" alt="" /></p>

<p> 图是标准帧和TSO的处理过程<br/>
a) 不支持TSO  b) 启用TSO后</p>

<p>从前面有关TSO的论述可以看出，TSO只是针对TCP协议的，使TCP协议在硬件上得到了有力的支持。事实上，这种概念也可以应用于其他的传输层协议，如TCPv6，UDP，甚至DCCP等，这就是GSO(Generic Segmentation Offload)。</p>

<p>性能提高的关键在于尽可能地推迟分段的时机，这样才能有效地降低成本。最理想的是在网络设备驱动里进行分段，在网络设备驱动里把大包进行拆分，组成分段列表，或在一块预先分配好的内存中重组各段，然后交给网络设备。这样，就要在网络设备的驱动里边来实现它，那么就需要修改每一个网络设备的驱动程序。事实上，这样做不大现实。</p>

<p>然而似乎有另一种更容易的解决办法来支持GSO，那就是在把数据报文提交给网络设备驱动之前进行聚合/分散操作。Linux目前支持GSO框架已经支持的传输层的其他协议。有关GSO方面的代码，参见后续章节。</p>

<p>应用层可以使用ethtool -K eth0 tso off|on命令对支持TSO特性的网络设备进行TSO功能的关闭和启用。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/03/19/kernel-net-cwnd/">拥塞窗口cwnd的理解</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-19T18:15:00+08:00'><span class='date'>2015-03-19</span> <span class='time'>18:15:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/linweixuan/article/details/4353015">http://blog.csdn.net/linweixuan/article/details/4353015</a></p>

<p>开始的时候拥塞窗口是1，发一个数据包等ACK回来 cwnd++即2,这个时候可以发送两个包,发送间隔几乎没有, 对方回的ACK到达发送方几乎是同时到达的.一个RTT来回,cwnd就翻倍,cwnd++,cwnd++即4了.如此下去,cwnd是指数增加.</p>

<p><img src="/images/kernel/2015-03-19-2.jpg" alt="" /></p>

<p>snd_cwnd_clamp这个变量我们可以不管,假定是一个大值.窗口到了我们设置的门限,snd_cwnd不在增加 而通过snd_cwnd_cnt变量来计数增加,一直增加到大过cwnd值,cwnd才加1,然后snd_cwnd_cnt重新计数, 通过snd_cwnd_cnt延缓cwnd计数,由于TCP是固定大小报文,每一个snd_cwnd代表了一个报文段的增加,snd_cwnd_cnt则看成byte的增加</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_cong_avoid(struct send_queue* sq)
</span><span class='line'>{
</span><span class='line'>    /* In saft area, increase*/
</span><span class='line'>    if (sq-&gt;snd_cwnd &lt;= sq-&gt;snd_ssthresh){
</span><span class='line'>        if (sq-&gt;snd_cwnd &lt; sq-&gt;snd_cwnd_clamp)
</span><span class='line'>            sq-&gt;snd_cwnd++;
</span><span class='line'>    }
</span><span class='line'>    else{ 
</span><span class='line'>        /* In theory this is tp-&gt;snd_cwnd += 1 / tp-&gt;snd_cwnd */
</span><span class='line'>        if (sq-&gt;snd_cwnd_cnt &gt;= sq-&gt;snd_cwnd) {
</span><span class='line'>            if (sq-&gt;snd_cwnd &lt; sq-&gt;snd_cwnd_clamp)
</span><span class='line'>                sq-&gt;snd_cwnd++;
</span><span class='line'>            sq-&gt;snd_cwnd_cnt = 0;
</span><span class='line'>        } else
</span><span class='line'>            sq-&gt;snd_cwnd_cnt++;
</span><span class='line'>    } 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>snd_cwnd 还没到达门限不断增加snd_cwnd++<br/>
snd_cwnd++                      | &lt;&ndash;snd_ssthresh
                                ^</p>

<p>到达了snd_ssthresh转入拥塞避免，这个阶段由变量snd_cwnd_cnt来控制</p>

<p>转入拥塞,由于snd_cwnd_cnt从0开始小于snd_ssthresh，即从snd_ssthresh那个点开始计数, 一旦计数达到snd_cwnd拥塞窗口的值，但是还小过牵制snd_cwnd_clamp值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>                          snd_cwnd_clamp
</span><span class='line'>                                 ^
</span><span class='line'>    snd_cwnd++                   |            | &lt;--snd_ssthresh
</span><span class='line'>                                              ^
</span><span class='line'>                                    snd_cwnd++        
</span><span class='line'>                                                          snd_cwnd_clamp
</span><span class='line'>                                                                 ^
</span><span class='line'>                                snd_cwnd_cnt++                   |            | &lt;--snd_ssthresh
</span><span class='line'>                                                                              ^
</span><span class='line'>                                               0      ---&gt;       snd_cwnd_cnt++
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>               &lt;------                       时间                      -------&gt;</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/03/19/kernel-net-rcv_wnd/">TCP接收窗口的调整算法</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-19T17:42:00+08:00'><span class='date'>2015-03-19</span> <span class='time'>17:42:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/zhangskd/article/details/8588202">TCP接收窗口的调整算法（上）</a><br/>
<a href="http://blog.csdn.net/zhangskd/article/details/8602493">TCP接收窗口的调整算法（中）</a><br/>
<a href="http://blog.csdn.net/zhangskd/article/details/8603099">TCP接收窗口的调整算法（下）</a></p>

<hr />

<h3>TCP接收窗口的调整算法（上）</h3>

<p>我们知道TCP首部中有一个16位的接收窗口字段，它可以告诉对端：我现在能接收多少数据。TCP的流控制主要就是通过调整接收窗口的大小来进行的。</p>

<p>本文内容：分析TCP接收窗口的调整算法，包括一些相关知识和初始接收窗口的取值。</p>

<p>内核版本：3.2.12</p>

<h4>数据结构</h4>

<p>以下是涉及到的数据结构。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_sock {  
</span><span class='line'>    ...  
</span><span class='line'>    /* 最早接收但未确认的段的序号，即当前接收窗口的左端*/  
</span><span class='line'>    u32 rcv_wup; /* rcv_nxt on last window update sent */  
</span><span class='line'>    u16 advmss; /* Advertised MSS. 本端能接收的MSS上限，建立连接时用来通告对端*/  
</span><span class='line'>    u32 rcv_ssthresh; /* Current window clamp. 当前接收窗口大小的阈值*/  
</span><span class='line'>    u32 rcv_wnd; /* Current receiver window，当前的接收窗口大小*/  
</span><span class='line'>    u32 window_clamp; /* 接收窗口的最大值，这个值也会动态调整*/  
</span><span class='line'>    ...  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_options_received {  
</span><span class='line'>    ...  
</span><span class='line'>        snd_wscale : 4, /* Window scaling received from sender, 对端接收窗口扩大因子 */  
</span><span class='line'>        rcv_wscale : 4; /* Window scaling to send to receiver, 本端接收窗口扩大因子 */  
</span><span class='line'>    u16 user_mss; /* mss requested by user in ioctl */  
</span><span class='line'>    u16 mss_clamp; /* Maximal mss, negotiated at connection setup，对端的最大mss */  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** 
</span><span class='line'> * struct sock - network layer representation of sockets 
</span><span class='line'> * @sk_rcvbuf: size of receive buffer in bytes 
</span><span class='line'> * @sk_receive_queue: incoming packets 
</span><span class='line'> * @sk_write_queue: packet sending queue 
</span><span class='line'> * @sk_sndbuf: size of send buffer in bytes 
</span><span class='line'> */  
</span><span class='line'>struct sock {  
</span><span class='line'>    ...  
</span><span class='line'>    struct sk_buff_head sk_receive_queue;  
</span><span class='line'>    /* 表示接收队列sk_receive_queue中所有段的数据总长度*/  
</span><span class='line'>#define sk_rmem_alloc sk_backlog.rmem_alloc  
</span><span class='line'>  
</span><span class='line'>    int sk_rcvbuf; /* 接收缓冲区长度的上限*/  
</span><span class='line'>    int sk_sndbuf; /* 发送缓冲区长度的上限*/  
</span><span class='line'>  
</span><span class='line'>    struct sk_buff_head sk_write_queue;  
</span><span class='line'>    ...  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>struct sk_buff_head {  
</span><span class='line'>    /* These two members must be first. */  
</span><span class='line'>    struct sk_buff *next;  
</span><span class='line'>    struct sk_buff *prev;  
</span><span class='line'>    __u32 qlen;  
</span><span class='line'>    spinlock_t lock;  
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>




</div>
  
  
    <footer>
      <a rel="full-article" target="_blank" href="/blog/2015/03/19/kernel-net-rcv_wnd/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/16">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/14">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>12</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(28)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>8</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(120)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>54</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>18</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(18)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(59)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(26)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(115)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/06/12/kernel-net-tcp-close/">linux内核中tcp连接的断开处理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/12/kernel-net-socket-io/">Socket层实现系列 — I/O事件及其处理函数</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/12/kernel-net-socket-wakeup/">Socket层实现系列 — 睡眠驱动的同步等待</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/12/kernel-net-socket-signal/">Socket层实现系列 — 信号驱动的异步等待</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/12/kernel-net-sock-socket/">socket和sock的一些分析</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
