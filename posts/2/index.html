
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>学习中......</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/01/14/kernel-sched-idle/">Idle进程的切换过程</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-14T23:39:00+08:00'><span class='date'>2015-01-14</span> <span class='time'>23:39:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.chinaunix.net/uid-27767798-id-3577069.html">http://blog.chinaunix.net/uid-27767798-id-3577069.html</a></p>

<p>  每个cpu都有自己的运行队列，如果当前cpu上运行的任务都已经dequeue出运行队列，而且idle_balance也没有移动到当前运行队列的任务，那么schedule函数中，按照rt ，cfs，idle这三种调度方式顺序，寻找各自的运行任务，那么如果rt和cfs都未找到运行任务，那么最后会调用idle schedule的idle进程，作为schedule函数调度的下一个任务。</p>

<p>kernel/sched.c 中的schedule()函数中的片段</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (prev-&gt;state && !(preempt_count() & PREEMPT_ACTIVE)) {   
</span><span class='line'>    //state大于0代表prev也就是当前运行的任务不是running状态，并且没有标记 PREEMPT_ACTIVE，就表示当前的运行的任务没有必要停留在运行队列中了
</span><span class='line'>    if (unlikely(signal_pending_state(prev-&gt;state, prev)))  //如果当前进程标记了状态是TASK_INTERRUPTIBLE，并且还有信号未处理，那么没有必要从运行队列中移除这个进程
</span><span class='line'>        prev-&gt;state = TASK_RUNNING;
</span><span class='line'>    else
</span><span class='line'>        deactivate_task(rq, prev, DEQUEUE_SLEEP);        //从运行队列中移除这个进程
</span><span class='line'>    switch_count = &prev-&gt;nvcsw;
</span><span class='line'>}
</span><span class='line'>        
</span><span class='line'>pre_schedule(rq, prev);
</span><span class='line'>
</span><span class='line'>if (unlikely(!rq-&gt;nr_running)) //如果当前运行队列没有进程可以运行了，就balance其他运行队列的任务到当前运行队列，这里balance的具体过程暂时不说
</span><span class='line'>    idle_balance(cpu, rq);
</span><span class='line'>
</span><span class='line'>put_prev_task(rq, prev);
</span><span class='line'>next = pick_next_task(rq);     //按照rt，cfs，idle优先级的顺序挑选进程，如果在rt和cfs中都没有找到能够运行的任务，那么当前cpu会切换到idle进程。</span></code></pre></td></tr></table></div></figure>


<p>  这里 PREEMPT_ACTIVE是个标志位，由于进程由于系统调用或者中断异常返回到用户态之前，都要判断是否可以被抢占，会首先判断preempt_count,等于0的时候表示没有禁止抢占，然后再去判断是否标记了need_resched,如果标记了，在去调用schedule函数，如果在某些时候禁止了抢占，禁止了一次就要preempt_count加1。可以肯定的一点是进程的state和是否在运行队列的因果关系并不是十分同步的，修改了进程的状态后，可能还需要做一些其他的工作才去调用schedule函数。引用一下其他人的例子。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (;;) {
</span><span class='line'>   prepare_to_wait(&wq, &__wait,TASK_UNINTERRUPTIBLE);
</span><span class='line'>   if (condition)
</span><span class='line'>     break;
</span><span class='line'>   schedule();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  可以看出在修改了进程的state之后，并不会立刻调用schedule函数，即使立刻调用了schedule函数，也不能保证在schedule函数之前的禁止抢占开启之前有其他的抢占动作。毕竟修改进程的state和从运行队列中移除任务不是一行代码（机器码）就能搞定的事情。所以如果在修改了进程的状态之后和schedule函数禁止抢占之前有抢占动作（可能是中断异常返回），如果这个时候进程被其他进程抢占，这个时候把当前进程移除运行队列，那么这个进程将永远没有机会运行后面的代码。所以这个时候在抢占的过程之前将preempt_count标记PREEMPT_ACTIVE，这样抢占中调用schedule函数将不会从当前运行队列中移除当前进程，这样才有前面分析schedule函数代码，有判断进程state同时判断preempt_count未标记PREEMPT_ACTIVE的情况。</p>

<p>  在当前进程被移除出运行队列之前还需要判断是否有挂起的信号需要处理，如果当前进程的状态是TASK_INTERRUPTIBLE或者TASK_WAKEKILL的时候，如果还有信号未处理，那么当前进程就不需要被移除运行队列，并且将state置为running。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int signal_pending_state(long state, struct task_struct *p)
</span><span class='line'>{
</span><span class='line'>    if (!(state & (TASK_INTERRUPTIBLE | TASK_WAKEKILL))) //首先判断状态不是这两个可以处理信号的状态就直接返回0，后面的逻辑不考虑了
</span><span class='line'>        return 0;
</span><span class='line'>    if (!signal_pending(p))             //如果没有信号挂起就不继续了
</span><span class='line'>        return 0;
</span><span class='line'>
</span><span class='line'>    return (state & TASK_INTERRUPTIBLE) || __fatal_signal_pending(p); //如果有信号
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<pre><code>说下 put_prev_task的逻辑，按照道理说应该是rt，cfs，idle的顺序寻找待运行态的任务。
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pick_next_task(struct rq *rq)
</span><span class='line'>{
</span><span class='line'>    const struct sched_class *class;
</span><span class='line'>    struct task_struct *p;
</span><span class='line'>
</span><span class='line'>    /*
</span><span class='line'>     * Optimization: we know that if all tasks are in
</span><span class='line'>     * the fair class we can call that function directly:
</span><span class='line'>     */
</span><span class='line'>    //这里注释的意思都能看懂，如果rq中的cfs队列的运行个数和rq中的运行个数相同，直接调用cfs中 的pick函数，因为默认的调度策略是cfs。
</span><span class='line'>    if (likely(rq-&gt;nr_running == rq-&gt;cfs.nr_running)) {
</span><span class='line'>        p = fair_sched_class.pick_next_task(rq);
</span><span class='line'>        if (likely(p))
</span><span class='line'>        return p;
</span><span class='line'>    }
</span><span class='line'>        
</span><span class='line'>    //这里 sched_class_highest就是rt_sched_class，所以前面没有选择出任务，那么从rt开始挑选任务，直到idle
</span><span class='line'>    class = sched_class_highest;
</span><span class='line'>         for ( ; ; ) {
</span><span class='line'>        p = class-&gt;pick_next_task(rq);
</span><span class='line'>        if (p)
</span><span class='line'>            return p;
</span><span class='line'>        /*
</span><span class='line'>         * Will never be NULL as the idle class always
</span><span class='line'>         * returns a non-NULL p:
</span><span class='line'>         */
</span><span class='line'>        class = class-&gt;next;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  从每个调度类的代码的最后可以看出这个next关系</p>

<p>sched_rt.c中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const struct sched_class rt_sched_class = {
</span><span class='line'>.next = &fair_sched_class,</span></code></pre></td></tr></table></div></figure>


<p>sched_fair.c中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const struct sched_class fair_sched_class = {
</span><span class='line'>.next = &idle_sched_class,</span></code></pre></td></tr></table></div></figure>


<p>  那么可以试想如果rt和cfs都没有可以运行的任务，那么最后就是调用idle的pick_next_task函数</p>

<p>sched_idletask.c:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct task_struct *pick_next_task_idle(struct rq *rq)
</span><span class='line'>{
</span><span class='line'>    schedstat_inc(rq, sched_goidle);
</span><span class='line'>    calc_load_account_idle(rq);
</span><span class='line'>    return rq-&gt;idle;    //可以看到就是返回rq中idle进程。
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  这idle进程在启动start_kernel函数的时候调用init_idle函数的时候，把当前进程（0号进程）置为每个rq的idle上。</p>

<p>kernel/sched.c:5415</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rq-&gt;curr = rq-&gt;idle = idle;</span></code></pre></td></tr></table></div></figure>


<p>  这里idle就是调用start_kernel函数的进程，就是0号进程。</p>

<p>  0号进程在fork完init进程等之后，进入cpu_idle函数，大概的逻辑是for循环调用hlt指令，每次hlt返回后，调用schedule函数，具体的流程现在还没太看懂，可以看到的是在具体的逻辑在default_idle函数中，调用了safe_halt函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void native_safe_halt(void)
</span><span class='line'>{
</span><span class='line'>        asm volatile("sti; hlt": : :"memory");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  关于hlt指令的作用是：引用wiki百科</p>

<blockquote><p>  In the x86 computer architecture, HLT (halt) is an assembly language instruction which halts the CPU until the next external interrupt is fired.[1] Interrupts are signals sent by hardware devices to the CPU alerting it that an event occurred to which it should react. For example, hardware timers send interrupts to the CPU at regular intervals.</p>

<p>  The HLT instruction is executed by the operating system when there is no immediate work to be done, and the system enters its idle state. In Windows NT, for example, this instruction is run in the &ldquo;System Idle Process&rdquo;.</p></blockquote>

<p>  可以看到注释的意思是，hlt指令使得cpu挂起，直到有中断产生这个时候cpu重新开始运行。所以时钟中断会唤醒正在hlt中的cpu，让它调用schedule函数，检测是否有新的任务在rq中，如果有的话切换到新的任务，否则继续执行hlt，cpu继续挂起。</p>

<p>参考文章<br/>
1.<a href="http://blog.csdn.net/dog250/article/details/5303547">http://blog.csdn.net/dog250/article/details/5303547</a></p>

<p>2.<a href="http://en.wikipedia.org/wiki/HLT">http://en.wikipedia.org/wiki/HLT</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/01/14/kernel-nmi-irq/">NMI 看门狗</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-14T23:34:00+08:00'><span class='date'>2015-01-14</span> <span class='time'>23:34:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/arethe/article/details/6153143">http://blog.csdn.net/arethe/article/details/6153143</a></p>

<h4>[X86和X86-64体系结构均支持NMI看门狗]</h4>

<p>  你的系统是不是会经常被锁住（Lock up）？直至解锁，系统不再响应键盘？你希望帮助我们解决类似的问题吗？如果你对所有的问题都回答“yes”，那么此文档正是为你而写。</p>

<p>  在很多X86/X86-64结构的硬件上，我们都可以使用一种被称为“看门狗NMI中断”的机制。（NMI：Non Maskable Interrupt. 这种中断即使在系统被锁住时，也能被响应）。这种机制可以被用来调试内核锁住现象。通过周期性地执行NMI中断，内核能够监测到是否有CPU被锁住。当有处理器被锁住时，打印调试信息。</p>

<p>  为了使用NMI看门狗，首先需要在内核中支持APIC。对于SMP内核，APIC的相关支持已自动地被编译进内核。对于UP内核，需要在内核配置中使能CONFIG_X86_UP_APIC (Processor type and features -> Local APIC support on uniprocessors) 或 CONFIG_X86_UP_IOAPIC (Processor type and features -> IO-APIC support on uniprocessors)。在没有IO-APIC的单处理器系统中，配置CONFIG_X86_UP_APIC。在有IO-APIC的单处理器系统中，则需配置CONFIG_X86_UP_IOAPIC。[注意：某些与内核调试相关选项可能会禁用NMI看门狗。如：Kernel Stack Meter或Kernel Tracer]。</p>

<p>  对于X86-64系统，APIC已被编进内核。</p>

<p>  使用本地APIC（nmi_watchdog=2）时，需要占用第一个性能寄存器，因而此寄存器不能再被另作它用（如高精度的性能分析）。Oprofile与perfctr的驱动已自动地禁用了本地APIC的NMI看门狗。</p>

<p>  可以通过启动参数“nmi_watchdog=N”使能NMI看门狗。即在lilo.conf的相关项中添加如下语句：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  append=”nmi_watchdog=1”</span></code></pre></td></tr></table></div></figure>


<p>  对于具有IO-APIC的SMP与UP机器，设置nmi_watchdog=1。对于没有IO-APIC的UP机器，设置nmi_watchdog=2，但仅在某些处理器上可以起作用。如果有疑问，在用nmi_watchdog=1启动后，再查看/proc/interrupts文件中的NMI项，如果该项为0，那么便用nmi_watchdog=2重新启动，并再次检查NMI项。如果还是0，问题就比较严重了，你的处理器很可能不支持NMI。</p>

<p>  “锁住（Lockup）”是指如下的情况：如果系统中的任何一个CPU不能处理周期性的本地时钟中断，并持续5秒钟以上，那么NMI的处理函数将产生一个oops并杀死当前进程。这是一种“可控崩溃”（Controlled Crash，所谓可控，是指发生崩溃时，能够输出内核信息），可以用此机制来调试“锁住”现象。那么，无论什么时候发生“锁住”，5秒钟之后都会自动地输出oops。如果内核没有输出信息，说明此时发生的崩溃过于严重（如：hardware-wise），以至于NMI中断都无法被响应，或者此次崩溃使得内核无法打印信息。</p>

<p>  在使用本地APIC时要注意，NMI中断被触发的频率依赖于系统的当前负载。由于缺乏更好的时钟源，本地APIC中的NMI看门狗使用的是“有效周期（Cycle unhalted，这个词的翻译似乎不太确切，如果某位朋友有更佳的建议，请告知在下。）”事件。也许你已经猜到了，当CPU处于halted（空等）状态时，该时钟是不计数的。处理器处于空闲状态的时候，常出现这样的情况。如果你的系统在被锁住时，执行的不是hlt指令，看门狗中断很快就会被触发，因为每个时钟周期都会发生“有效周期”事件。如果不幸，处理器在被锁住时，执行的恰是“hlt”指令，那么“有效周期”事件永远都不会发生，看门狗自然也不会被触发。这是本地APIC看门狗的缺陷，在倒霉的时候，永远不会进行时钟计数。而I/O APIC中的看门狗由于采用外部时钟进行驱动，便不存在这个缺陷。但是，它的NMI频率非常高，会显著地影响系统的性能。</p>

<p>  X86的nmi_watchdog在默认情况下是禁用的，因此你需要在系统启动的时候使能它。</p>

<p>  在系统运行期间，可以禁用NMI看门狗，只要向文件“/proc/sys/kernel/nmi_watchdog”中写“0”即可。向该文件写“1”，将重新使能看门狗。即使如此，你仍然需要在启动时使用参数“nmi_watchdog=”。</p>

<p>  注意：在2.4.2-ac18之前的内核中，X86 SMP平台会无条件地使能NMI-oopser。</p>

<hr />

<p>www.2cto.com/kf/201311/260704.html</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//  使能hard lockup探测
</span><span class='line'>//  调用路径：watchdog_enable-&gt;watchdog_nmi_enable
</span><span class='line'>//  函数任务：
</span><span class='line'>//      1.初始化hard lockup检测事件
</span><span class='line'>//          2.hard lockup阈值为10s
</span><span class='line'>//      2.向performance monitoring子系统注册hard lockup检测事件
</span><span class='line'>//      3.使能hard lockup检测事件
</span><span class='line'>//  注：
</span><span class='line'>//      performance monitoring，x86中的硬件设备，当cpu clock经过了指定个周期后发出一个NMI中断。
</span><span class='line'>1.1 static int watchdog_nmi_enable(unsigned int cpu)
</span><span class='line'>{
</span><span class='line'>    //hard lockup事件
</span><span class='line'>    struct perf_event_attr *wd_attr;
</span><span class='line'>    struct perf_event *event = per_cpu(watchdog_ev, cpu);
</span><span class='line'>    ....
</span><span class='line'>    wd_attr = &wd_hw_attr;
</span><span class='line'>    //hard lockup检测周期，10s
</span><span class='line'>    wd_attr-&gt;sample_period = hw_nmi_get_sample_period(watchdog_thresh);
</span><span class='line'>    //向performance monitoring注册hard lockup检测事件
</span><span class='line'>    event = perf_event_create_kernel_counter(wd_attr, cpu, NULL, watchdog_overflow_callback, NULL);
</span><span class='line'>    ....
</span><span class='line'>    //使能hard lockup的检测
</span><span class='line'>    per_cpu(watchdog_ev, cpu) = event;
</span><span class='line'>    perf_event_enable(per_cpu(watchdog_ev, cpu));
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>//  换算hard lockup检测周期到cpu频率
</span><span class='line'>1.2 u64 hw_nmi_get_sample_period(int watchdog_thresh)
</span><span class='line'>{
</span><span class='line'>    return (u64)(cpu_khz) * 1000 * watchdog_thresh;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>//  hard lockup检测事件发生时的nmi回调函数
</span><span class='line'>//  函数任务：
</span><span class='line'>//      1.判断是否发生了hard lockup
</span><span class='line'>//          1.1 dump hard lockup信息
</span><span class='line'>1.3 static void watchdog_overflow_callback(struct perf_event *event,
</span><span class='line'>     struct perf_sample_data *data,
</span><span class='line'>     struct pt_regs *regs)
</span><span class='line'>{
</span><span class='line'>    //判断是否发生hard lockup
</span><span class='line'>    if (is_hardlockup()) {
</span><span class='line'>        int this_cpu = smp_processor_id();
</span><span class='line'> 
</span><span class='line'>        //打印hard lockup信息
</span><span class='line'>        if (hardlockup_panic)
</span><span class='line'>            panic("Watchdog detected hard LOCKUP on cpu %d", this_cpu);
</span><span class='line'>        else
</span><span class='line'>            WARN(1, "Watchdog detected hard LOCKUP on cpu %d", this_cpu);
</span><span class='line'> 
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>//  判断是否发生hard lockup
</span><span class='line'>//  注：
</span><span class='line'>//      如果时钟中断在指定阈值范围内为运行，核心认为可屏蔽中断被屏蔽时间过长
</span><span class='line'>1.4 static int is_hardlockup(void)
</span><span class='line'>{
</span><span class='line'>    //获取watchdog timer的运行次数
</span><span class='line'>    unsigned long hrint = __this_cpu_read(hrtimer_interrupts);
</span><span class='line'>    //在一个hard lockup检测时间阈值内，如果watchdog timer未运行，说明cpu中断被屏蔽时间超过阈值
</span><span class='line'>    if (__this_cpu_read(hrtimer_interrupts_saved) == hrint)
</span><span class='line'>        return 1;
</span><span class='line'>    //记录watchdog timer运行的次数
</span><span class='line'>    __this_cpu_write(hrtimer_interrupts_saved, hrint);
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>//  关闭hard lockup检测机制
</span><span class='line'>//  函数任务：
</span><span class='line'>//      1.向performance monitoring子系统注销hard lockup检测控制块
</span><span class='line'>//      2.清空per-cpu hard lockup检测控制块
</span><span class='line'>//      3.释放hard lock检测控制块
</span><span class='line'>2.1 static void watchdog_nmi_disable(unsigned int cpu)
</span><span class='line'>{
</span><span class='line'>    struct perf_event *event = per_cpu(watchdog_ev, cpu);
</span><span class='line'>    if (event) {
</span><span class='line'>        //向performance monitoring子系统注销hard lockup检测控制块
</span><span class='line'>        perf_event_disable(event);
</span><span class='line'>        //清空per-cpu hard lockup检测控制块
</span><span class='line'>        per_cpu(watchdog_ev, cpu) = NULL;
</span><span class='line'>        //释放hard lock检测控制块
</span><span class='line'>        perf_event_release_kernel(event);
</span><span class='line'>    }
</span><span class='line'>    return;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/01/03/kernel-sched-irq-mark/">中断，进程</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-03T15:45:00+08:00'><span class='date'>2015-01-03</span> <span class='time'>15:45:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>blog.chinaunix.net/uid-20806345-id-3203602.html</p>

<p>  中断不是进程，不受内核调度器的管辖。在系统处理进程的过程中，对于某个cpu来说，如果有内部中断或外部中断到来，则切换到中断处理程序，切换首先要将进程由用户态要切到进程的内核态，然后再将cpu切换到中断态，待处理完中断返回进程的内核态，再返回进程的用户态，如果中断时进程刚好处于内核态中不用由用户态切到内核态了。<br/>
  中断处理时是不分优先级的，处理中断的过程中如果有任意中断到来，都会抢占当前的中断处理过程。所以对于要及时响应的中断，需要通过关中断来屏蔽其他中断。通常所说的中断优先级是指中断控制器端的优先级，当有多个中断触发时，首先选择优先级高的中断发出请求给处理器。中断优先级只是对中断控制器而言的，所有的中断对cpu来说都是一样的，没有优先级高低之分。<br/>
  关中断是关闭所有的外部可屏蔽中断，和优先级没有关系，如果在某中断处理程序中关中断，则不会被任何可屏蔽中断抢占，但是会被任意的不可屏蔽中断抢占。关中断是中断处理程序可选的。</p>

<p>bbs.chinaunix.net/thread-2306027-1-8.html</p>

<p>软中断做的是一些可延迟的费时间的事，当然不能在中断里执行了。<br/>
  <code>__do_softirq</code>代码，可以看到在执行可延迟函数第一件事就是开中断。但在开始之前，禁用了下半部中断（<code>__local_bh_disable</code>）。这样就算被中断了，返回内核时也不会被抢占，还是执行这里的代码。也不会被调度。<br/>
  那么这样的后果就是软中断上下文里的会一直执行下去，直到到达了限定次数，然后唤醒守护进程。<br/>
  因为软中断切换了栈，不再使用进程上下文，那么如果在软中断上下文直接或简洁调用了shedule，那么只有死翘翘了！！因为schedule调度回来的时候是依赖进程内核栈的thread_info。</p>

<p>  内核抢占点之一就是中断返回的时候检查是否可以抢占，检查的内容之一就是preempt_count是否等于0，因为禁用了下半部中断，那么肯定就不会等于0的，所以不会被抢占。也就是说返回的时候不会发生调度。</p>

<p>  个人理解 中断上下文 最大的特征 禁掉了某种中断（硬中断和软中断），所以导致 不能阻塞。<br/>
  softirq 有可能在两种方式下被调用，一是中断处理程序退出时，开放硬件中断之后，会去调用do_softirq()。
  do_softirq()会禁掉后半部抢占，并且现在执行流使用的是被中断的进程的栈，所以无法阻塞。<br/>
  softirq的另一种调用方式是ksoftirq内核线程，同样do_softirq()被调用，后半部中断被禁掉，同样禁止阻塞。<br/>
  工作队列，可以被任何中断或者软中断中断，运行在进程上下文，有自己的栈，可以阻塞。</p>

<p>看一下__do_softirq()的代码,新的硬中断确实可能触发更高优先级的软中断，但是这个软中断并不会在被中断的软中断之前得到执行，软中断始终是顺序执行的。从代码看来，新一批的软中断，无论优先级多高，也得等到前一批的软中断被处理完成之后才能得到处理。而优先级只能帮助软中断在对应的批次中优先得到处理。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/01/03/kernel-sched-irq/">硬中断和软中断</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-03T15:15:00+08:00'><span class='date'>2015-01-03</span> <span class='time'>15:15:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>关闭硬中断： spin_lock_irq和spin_unlock_irq以及spin_lock_irqsave和spin_unlock_irqrestore<br/>
关闭软中断： spin_lock_bh和spin_unlock_bh</p>

<hr />

<p>netfilter：<br/>
有些netfilter hooks可以从系统调用的context到达， 比如socket的send_msg()是可以到达LOCAL_OUT/POST_ROUTING的， <br/>
这样，也就是说，在这些情况下操作conntrack链表的时候，是进程上下文，而不是软中断上下文， 因此，是需要关闭bh的。</p>

<p>PRE_ROUTING上的按道理说，它只能从软中断到达，因此只需要spin_lock()就可以了。</p>

<hr />

<p><a href="http://blog.csdn.net/zhangskd/article/details/21992933">http://blog.csdn.net/zhangskd/article/details/21992933</a></p>

<h4>概述</h4>

<p>从本质上来讲，中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。
如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，
跳到中断处理程序的入口点，进行中断处理。</p>

<h5>(1) 硬中断</h5>

<p>由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断(hardirq)。</p>

<h5>(2) 软中断</h5>

<p>为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。</p>

<h5>(3) 中断嵌套</h5>

<p>Linux下硬中断是可以嵌套的，但是没有优先级的概念，也就是说任何一个新的中断都可以打断正在执行的中断，但同种中断除外。软中断不能嵌套，但相同类型的软中断可以在不同CPU上并行执行。</p>

<h5>(4) 软中断指令</h5>

<p>int是软中断指令。<br/>
中断向量表是中断号和中断处理函数地址的对应表。<br/>
int n - 触发软中断n。相应的中断处理函数的地址为：中断向量表地址 + 4 * n。</p>

<h5>(5)硬中断和软中断的区别</h5>

<p>软中断是执行中断指令产生的，而硬中断是由外设引发的。<br/>
硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。<br/>
硬中断是可屏蔽的，软中断不可屏蔽。<br/>
硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。<br/>
软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。</p>

<h4>开关</h4>

<h5>(1) 硬中断的开关</h5>

<p>简单禁止和激活当前处理器上的本地中断：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>local_irq_disable();
</span><span class='line'>local_irq_enable();</span></code></pre></td></tr></table></div></figure>


<p>保存本地中断系统状态下的禁止和激活：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned long flags;
</span><span class='line'>local_irq_save(flags);
</span><span class='line'>local_irq_restore(flags);</span></code></pre></td></tr></table></div></figure>


<h5>(2) 软中断的开关</h5>

<p>禁止下半部，如softirq、tasklet和workqueue等：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>local_bh_disable();
</span><span class='line'>local_bh_enable();</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，禁止下半部时仍然可以被硬中断抢占。</p>

<h5>(3) 判断中断状态</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define in_interrupt() (irq_count()) // 是否处于中断状态(硬中断或软中断)
</span><span class='line'>#define in_irq() (hardirq_count()) // 是否处于硬中断
</span><span class='line'>#define in_softirq() (softirq_count()) // 是否处于软中断</span></code></pre></td></tr></table></div></figure>


<h4>硬中断</h4>

<h5>(1) 注册中断处理函数</h5>

<p>注册中断处理函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** 
</span><span class='line'> * irq: 要分配的中断号 
</span><span class='line'> * handler: 要注册的中断处理函数 
</span><span class='line'> * flags: 标志(一般为0) 
</span><span class='line'> * name: 设备名(dev-&gt;name) 
</span><span class='line'> * dev: 设备(struct net_device *dev)，作为中断处理函数的参数 
</span><span class='line'> * 成功返回0 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,   
</span><span class='line'>    const char *name, void *dev);  </span></code></pre></td></tr></table></div></figure>


<p>中断处理函数本身：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef irqreturn_t (*irq_handler_t) (int, void *);  
</span><span class='line'>  
</span><span class='line'>/** 
</span><span class='line'> * enum irqreturn 
</span><span class='line'> * @IRQ_NONE: interrupt was not from this device 
</span><span class='line'> * @IRQ_HANDLED: interrupt was handled by this device 
</span><span class='line'> * @IRQ_WAKE_THREAD: handler requests to wake the handler thread 
</span><span class='line'> */  
</span><span class='line'>enum irqreturn {  
</span><span class='line'>    IRQ_NONE,  
</span><span class='line'>    IRQ_HANDLED,  
</span><span class='line'>    IRQ_WAKE_THREAD,  
</span><span class='line'>};  
</span><span class='line'>typedef enum irqreturn irqreturn_t;  
</span><span class='line'>#define IRQ_RETVAL(x) ((x) != IRQ_NONE)  </span></code></pre></td></tr></table></div></figure>


<h5>(2) 注销中断处理函数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** 
</span><span class='line'> * free_irq - free an interrupt allocated with request_irq 
</span><span class='line'> * @irq: Interrupt line to free 
</span><span class='line'> * @dev_id: Device identity to free 
</span><span class='line'> * 
</span><span class='line'> * Remove an interrupt handler. The handler is removed and if the 
</span><span class='line'> * interrupt line is no longer in use by any driver it is disabled. 
</span><span class='line'> * On a shared IRQ the caller must ensure the interrupt is disabled 
</span><span class='line'> * on the card it drives before calling this function. The function does 
</span><span class='line'> * not return until any executing interrupts for this IRQ have completed. 
</span><span class='line'> * This function must not be called from interrupt context. 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>void free_irq(unsigned int irq, void *dev_id);  </span></code></pre></td></tr></table></div></figure>


<h4>软中断</h4>

<h5>(1) 定义</h5>

<p>软中断是一组静态定义的下半部接口，可以在所有处理器上同时执行，即使两个类型相同也可以。<br/>
但一个软中断不会抢占另一个软中断，唯一可以抢占软中断的是硬中断。</p>

<p>软中断由softirq_action结构体表示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct softirq_action {  
</span><span class='line'>    void (*action) (struct softirq_action *); /* 软中断的处理函数 */  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>目前已注册的软中断有10种，定义为一个全局数组：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct softirq_action softirq_vec[NR_SOFTIRQS];  
</span><span class='line'>  
</span><span class='line'>enum {  
</span><span class='line'>    HI_SOFTIRQ = 0, /* 优先级高的tasklets */  
</span><span class='line'>    TIMER_SOFTIRQ, /* 定时器的下半部 */  
</span><span class='line'>    NET_TX_SOFTIRQ, /* 发送网络数据包 */  
</span><span class='line'>    NET_RX_SOFTIRQ, /* 接收网络数据包 */  
</span><span class='line'>    BLOCK_SOFTIRQ, /* BLOCK装置 */  
</span><span class='line'>    BLOCK_IOPOLL_SOFTIRQ,  
</span><span class='line'>    TASKLET_SOFTIRQ, /* 正常优先级的tasklets */  
</span><span class='line'>    SCHED_SOFTIRQ, /* 调度程序 */  
</span><span class='line'>    HRTIMER_SOFTIRQ, /* 高分辨率定时器 */  
</span><span class='line'>    RCU_SOFTIRQ, /* RCU锁定 */  
</span><span class='line'>    NR_SOFTIRQS /* 10 */  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<h5>(2) 注册软中断处理函数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** 
</span><span class='line'> * @nr: 软中断的索引号 
</span><span class='line'> * @action: 软中断的处理函数 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>void open_softirq(int nr, void (*action) (struct softirq_action *))  
</span><span class='line'>{  
</span><span class='line'>    softirq_vec[nr].action = action;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>open_softirq(NET_TX_SOFTIRQ, net_tx_action);
</span><span class='line'>open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span></code></pre></td></tr></table></div></figure>


<h5>(3) 触发软中断</h5>

<p>调用raise_softirq()来触发软中断。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void raise_softirq(unsigned int nr)  
</span><span class='line'>{  
</span><span class='line'>    unsigned long flags;  
</span><span class='line'>    local_irq_save(flags);  
</span><span class='line'>    raise_softirq_irqoff(nr);  
</span><span class='line'>    local_irq_restore(flags);  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>/* This function must run with irqs disabled */  
</span><span class='line'>inline void rasie_softirq_irqsoff(unsigned int nr)  
</span><span class='line'>{  
</span><span class='line'>    __raise_softirq_irqoff(nr);  
</span><span class='line'>  
</span><span class='line'>    /* If we're in an interrupt or softirq, we're done 
</span><span class='line'>     * (this also catches softirq-disabled code). We will 
</span><span class='line'>     * actually run the softirq once we return from the irq 
</span><span class='line'>     * or softirq. 
</span><span class='line'>     * Otherwise we wake up ksoftirqd to make sure we 
</span><span class='line'>     * schedule the softirq soon. 
</span><span class='line'>     */  
</span><span class='line'>    if (! in_interrupt()) /* 如果不处于硬中断或软中断 */  
</span><span class='line'>        wakeup_softirqd(void); /* 唤醒ksoftirqd/n进程 */  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>Percpu变量irq_cpustat_t中的__softirq_pending是等待处理的软中断的位图，通过设置此变量</p>

<p>即可告诉内核该执行哪些软中断。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void __rasie_softirq_irqoff(unsigned int nr)  
</span><span class='line'>{  
</span><span class='line'>    trace_softirq_raise(nr);  
</span><span class='line'>    or_softirq_pending(1UL &lt;&lt; nr);  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>typedef struct {  
</span><span class='line'>    unsigned int __softirq_pending;  
</span><span class='line'>    unsigned int __nmi_count; /* arch dependent */  
</span><span class='line'>} irq_cpustat_t;  
</span><span class='line'>  
</span><span class='line'>irq_cpustat_t irq_stat[];  
</span><span class='line'>#define __IRQ_STAT(cpu, member) (irq_stat[cpu].member)  
</span><span class='line'>#define or_softirq_pending(x) percpu_or(irq_stat.__softirq_pending, (x))  
</span><span class='line'>#define local_softirq_pending() percpu_read(irq_stat.__softirq_pending)  </span></code></pre></td></tr></table></div></figure>


<p>唤醒ksoftirqd内核线程处理软中断。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void wakeup_softirqd(void)  
</span><span class='line'>{  
</span><span class='line'>    /* Interrupts are disabled: no need to stop preemption */  
</span><span class='line'>    struct task_struct *tsk = __get_cpu_var(ksoftirqd);  
</span><span class='line'>  
</span><span class='line'>    if (tsk && tsk-&gt;state != TASK_RUNNING)  
</span><span class='line'>        wake_up_process(tsk);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>在下列地方，待处理的软中断会被检查和执行：<br/>
1. 从一个硬件中断代码处返回时<br/>
2. 在ksoftirqd内核线程中<br/>
3. 在那些显示检查和执行待处理的软中断的代码中，如网络子系统中</p>

<p>而不管是用什么方法唤起，软中断都要在do_softirq()中执行。如果有待处理的软中断，do_softirq()会循环遍历每一个，调用它们的相应的处理程序。在中断处理程序中触发软中断是最常见的形式。中断处理程序执行硬件设备的相关操作，然后触发相应的软中断，最后退出。内核在执行完中断处理程序以后，马上就会调用do_softirq()，于是软中断开始执行中断处理程序完成剩余的任务。</p>

<p>下面来看下do_softirq()的具体实现。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>asmlinkage void do_softirq(void)  
</span><span class='line'>{  
</span><span class='line'>    __u32 pending;  
</span><span class='line'>    unsigned long flags;  
</span><span class='line'>  
</span><span class='line'>    /* 如果当前已处于硬中断或软中断中，直接返回 */  
</span><span class='line'>    if (in_interrupt())   
</span><span class='line'>        return;  
</span><span class='line'>  
</span><span class='line'>    local_irq_save(flags);  
</span><span class='line'>    pending = local_softirq_pending();  
</span><span class='line'>    if (pending) /* 如果有激活的软中断 */  
</span><span class='line'>        __do_softirq(); /* 处理函数 */  
</span><span class='line'>    local_irq_restore(flags);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* We restart softirq processing MAX_SOFTIRQ_RESTART times, 
</span><span class='line'> * and we fall back to softirqd after that. 
</span><span class='line'> * This number has been established via experimentation. 
</span><span class='line'> * The two things to balance is latency against fairness - we want 
</span><span class='line'> * to handle softirqs as soon as possible, but they should not be 
</span><span class='line'> * able to lock up the box. 
</span><span class='line'> */  
</span><span class='line'>asmlinkage void __do_softirq(void)  
</span><span class='line'>{  
</span><span class='line'>    struct softirq_action *h;  
</span><span class='line'>    __u32 pending;  
</span><span class='line'>    /* 本函数能重复触发执行的次数，防止占用过多的cpu时间 */  
</span><span class='line'>    int max_restart = MAX_SOFTIRQ_RESTART;  
</span><span class='line'>    int cpu;  
</span><span class='line'>  
</span><span class='line'>    pending = local_softirq_pending(); /* 激活的软中断位图 */  
</span><span class='line'>    account_system_vtime(current);  
</span><span class='line'>    /* 本地禁止当前的软中断 */  
</span><span class='line'>    __local_bh_disable((unsigned long)__builtin_return_address(0), SOFTIRQ_OFFSET);  
</span><span class='line'>    lockdep_softirq_enter(); /* current-&gt;softirq_context++ */  
</span><span class='line'>    cpu = smp_processor_id(); /* 当前cpu编号 */  
</span><span class='line'>  
</span><span class='line'>restart:  
</span><span class='line'>    /* Reset the pending bitmask before enabling irqs */  
</span><span class='line'>    set_softirq_pending(0); /* 重置位图 */  
</span><span class='line'>    local_irq_enable();  
</span><span class='line'>    h = softirq_vec;  
</span><span class='line'>    do {  
</span><span class='line'>        if (pending & 1) {  
</span><span class='line'>            unsigned int vec_nr = h - softirq_vec; /* 软中断索引 */  
</span><span class='line'>            int prev_count = preempt_count();  
</span><span class='line'>            kstat_incr_softirqs_this_cpu(vec_nr);  
</span><span class='line'>  
</span><span class='line'>            trace_softirq_entry(vec_nr);  
</span><span class='line'>            h-&gt;action(h); /* 调用软中断的处理函数 */  
</span><span class='line'>            trace_softirq_exit(vec_nr);  
</span><span class='line'>  
</span><span class='line'>            if (unlikely(prev_count != preempt_count())) {  
</span><span class='line'>                printk(KERN_ERR "huh, entered softirq %u %s %p" "with preempt_count %08x,"  
</span><span class='line'>                    "exited with %08x?\n", vec_nr, softirq_to_name[vec_nr], h-&gt;action, prev_count,  
</span><span class='line'>                    preempt_count());  
</span><span class='line'>            }  
</span><span class='line'>            rcu_bh_qs(cpu);  
</span><span class='line'>        }  
</span><span class='line'>        h++;  
</span><span class='line'>        pending &gt;&gt;= 1;  
</span><span class='line'>    } while(pending);  
</span><span class='line'>  
</span><span class='line'>    local_irq_disable();  
</span><span class='line'>    pending = local_softirq_pending();  
</span><span class='line'>    if (pending & --max_restart) /* 重复触发 */  
</span><span class='line'>        goto restart;  
</span><span class='line'>  
</span><span class='line'>    /* 如果重复触发了10次了，接下来唤醒ksoftirqd/n内核线程来处理 */  
</span><span class='line'>    if (pending)  
</span><span class='line'>        wakeup_softirqd();   
</span><span class='line'>  
</span><span class='line'>    lockdep_softirq_exit();  
</span><span class='line'>    account_system_vtime(current);  
</span><span class='line'>    __local_bh_enable(SOFTIRQ_OFFSET);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h5>(4) ksoftirqd内核线程</h5>

<p>内核不会立即处理重新触发的软中断。<br/>
当大量软中断出现的时候，内核会唤醒一组内核线程来处理。<br/>
这些线程的优先级最低(nice值为19)，这能避免它们跟其它重要的任务抢夺资源。<br/>
但它们最终肯定会被执行，所以这个折中的方案能够保证在软中断很多时用户程序不会因为得不到处理时间而处于饥饿状态，同时也保证过量的软中断最终会得到处理。</p>

<p>每个处理器都有一个这样的线程，名字为ksoftirqd/n，n为处理器的编号。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int run_ksoftirqd(void *__bind_cpu)  
</span><span class='line'>{  
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>    current-&gt;flags |= PF_KSOFTIRQD; /* I am ksoftirqd */  
</span><span class='line'>  
</span><span class='line'>    while(! kthread_should_stop()) {  
</span><span class='line'>        preempt_disable();  
</span><span class='line'>  
</span><span class='line'>        if (! local_softirq_pending()) { /* 如果没有要处理的软中断 */  
</span><span class='line'>            preempt_enable_no_resched();  
</span><span class='line'>            schedule();  
</span><span class='line'>            preempt_disable():  
</span><span class='line'>        }  
</span><span class='line'>  
</span><span class='line'>        __set_current_state(TASK_RUNNING);  
</span><span class='line'>  
</span><span class='line'>        while(local_softirq_pending()) {  
</span><span class='line'>            /* Preempt disable stops cpu going offline. 
</span><span class='line'>             * If already offline, we'll be on wrong CPU: don't process. 
</span><span class='line'>             */  
</span><span class='line'>             if (cpu_is_offline(long)__bind_cpu))/* 被要求释放cpu */  
</span><span class='line'>                 goto wait_to_die;  
</span><span class='line'>  
</span><span class='line'>            do_softirq(); /* 软中断的统一处理函数 */  
</span><span class='line'>  
</span><span class='line'>            preempt_enable_no_resched();  
</span><span class='line'>            cond_resched();  
</span><span class='line'>            preempt_disable();  
</span><span class='line'>            rcu_note_context_switch((long)__bind_cpu);  
</span><span class='line'>        }  
</span><span class='line'>  
</span><span class='line'>        preempt_enable();  
</span><span class='line'>        set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    __set_current_state(TASK_RUNNING);  
</span><span class='line'>    return 0;  
</span><span class='line'>  
</span><span class='line'>wait_to_die:  
</span><span class='line'>    preempt_enable();  
</span><span class='line'>    /* Wait for kthread_stop */  
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>    while(! kthread_should_stop()) {  
</span><span class='line'>        schedule();  
</span><span class='line'>        set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    __set_current_state(TASK_RUNNING);  
</span><span class='line'>    return 0;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/01/03/kernel-sched-ksoftirqd/">关于ksoftirqd进程</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-03T15:01:00+08:00'><span class='date'>2015-01-03</span> <span class='time'>15:01:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>blog.chinaunix.net/uid-20737871-id-1881243.html</p>

<p>每个处理器都有一组辅助处理器软中断(和tasklet)的内核线程。当内核中出现大量软中断的时候，这些内核进程就会辅助处理它们。</p>

<h4>引入ksoftirq内核线程的原因：</h4>

<p>对于软中断，内核会选择在几个特殊时机进行处理。而在中断处理程序返回时处理是最常见的。软中断被触发的频率有时可能很高，更不利的是，处理函数有时还会 字形重复触发，那么就会导致用户空间进程无法获得足够的处理时间，因而处于饥饿状态。单纯的对重新触发的软中断采取不立即处理的策略，也无法让人接受。</p>

<h4>最初的解决方案：</h4>

<p>1）只要还有被触发并等待处理的软中断，本次执行就要负责处理，重新触发的软中断也在本次执行返回前被处理。这样做可以保证对内核的软中断采取即时处理的 方式，关键在于，对重新触发的软中断也会立即处理。当负载很高的时候，此时若有大量被触发的软中断，而它们本身又会重复触发。系统可能会一直处理软中断根 本不能完成其他任务。</p>

<p>2）不处理重新触发的软中断。在从中断返回的时候，内核和平常一样，也会检查所有挂起的软中断并处理他们。但是，任何自行重新触发的软中断不会马上处理， 它们被放到下一个软中断执行时机去处理。而这个时机通常也就是下一次中断返回的时候。可是，在比较空闲的系统中，立即处理软中断才是比较好的做法。尽管它 能保证用户空间不处于饥饿状态，但它却让软中断忍受饥饿的痛苦，而根本没有好好利用闲置的系统资源。</p>

<h4>改进：</h4>

<p>最终在内核中实现的方案是不会立即处理处理重新触发的软中断。而作为改进，当大量软中断出现的时候，内核会唤醒一组内核线程来处理这些负载。这些线程在最 低的优先级上运行（nice值是19），这能避免它们跟其他重要的任务抢夺资源。但它们最终肯定会被执行，所以这个折中方案能够保证在软中断负担很中的时 候用户程序不会因为得不到处理时间处于饥饿状态。相应的，也能保证”过量“的软中断终究会得到处理。</p>

<p>每个处理器都有一个这样的线程。所有线程的名字都叫做ksoftirq/n，区别在于n，它对应的是处理器的编号。在一个双CPU的机器上就有两个这样的 线程，分别叫做ksoftirqd/0和ksoftirqd/1。为了保证只要有空闲的处理器，它们就会处理软中断，所以给每个处理器都分配一个这样的线 程。一旦该线程被初始化，它就会执行类似下面这样的死循环：</p>

<p>在kernel/softirq.c中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int ksoftirqd(void * __bind_cpu)
</span><span class='line'>{
</span><span class='line'>    set_user_nice(current, 19);
</span><span class='line'>    current-&gt;flags |= PF_NOFREEZE;
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    while (!kthread_should_stop()) {
</span><span class='line'>        preempt_disable();
</span><span class='line'>        if (!local_softirq_pending()) {
</span><span class='line'>            preempt_enable_no_resched();
</span><span class='line'>            schedule();
</span><span class='line'>            preempt_disable();
</span><span class='line'>        }
</span><span class='line'>        __set_current_state(TASK_RUNNING);
</span><span class='line'>        while (local_softirq_pending()) {
</span><span class='line'>            /* Preempt disable stops cpu going offline.
</span><span class='line'>                If already offline, we'll be on wrong CPU:
</span><span class='line'>                don't process */
</span><span class='line'>            if (cpu_is_offline((long)__bind_cpu))
</span><span class='line'>                goto wait_to_die;
</span><span class='line'>            do_softirq();
</span><span class='line'>            preempt_enable_no_resched();
</span><span class='line'>            cond_resched();
</span><span class='line'>            preempt_disable();
</span><span class='line'>        }
</span><span class='line'>        preempt_enable();
</span><span class='line'>        set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    }
</span><span class='line'>    __set_current_state(TASK_RUNNING);
</span><span class='line'>    return 0;
</span><span class='line'>wait_to_die:
</span><span class='line'>    preempt_enable();
</span><span class='line'>    /* Wait for kthread_stop */
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    while (!kthread_should_stop()) {
</span><span class='line'>        schedule();
</span><span class='line'>        set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    }
</span><span class='line'>    __set_current_state(TASK_RUNNING);
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>只要有待处理的软中断(由softirq_pending()函数负责发现)，ksoftirq就会调用do_softirq去处理它们。通过重复执行这 样的操作，重新触发的软中断也会被执行。如果有必要，每次迭代后都会调用schedule()以便让更重要的进程得到处理机会。当所有需要执行的操作都完 成以后，该内核线程将自己设置为TASK_INTERRUPTIBLE状态，唤起调度程序选择其他可执行进程投入运行。</p>

<p>只要do_softirq()函数发现已经执行过的内核线程重新触发了它自己，软中断内核线程就会被唤醒.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(12)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>12</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(37)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(22)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>8</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(36)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>12</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>11</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(17)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(48)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(12)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>12</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(111)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(59)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(33)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(26)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/01/15/tools-squid/">squid--代理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/15/tools-cscope/">vim+cscope</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/14/debug-mod-timer/">mod_timer会切换cpu</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/14/debug-softirq-time-count/">中断时间统计</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/14/kernel-sched-alg1/">linux内核分析之调度算法（一）</a>
      </li>
    
  </ul>
</section>
<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>
