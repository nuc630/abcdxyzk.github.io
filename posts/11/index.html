
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/12/kernel-cpufreq/">Linux动态频率调节系统CPUFreq</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-12T14:46:00+08:00'><span class='date'>2015-08-12</span> <span class='time'>14:46:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/droidphone/article/details/9346981">Linux动态频率调节系统CPUFreq之一：概述</a><br/>
<a href="http://blog.csdn.net/droidphone/article/details/9385745">Linux动态频率调节系统CPUFreq之二：核心（core）架构与API</a><br/>
<a href="http://blog.csdn.net/droidphone/article/details/9532999">Linux动态频率调节系统CPUFreq之三：governor</a></p>

<hr />

<h3>Linux动态频率调节系统CPUFreq之一：概述</h3>

<p>随着技术的发展，我们对CPU的处理能力提出了越来越高的需求，芯片厂家也对制造工艺不断地提升。现在的主流PC处理器的主频已经在3GHz左右，就算是智能手机的处理器也已经可以工作在1.5GHz以上，可是我们并不是时时刻刻都需要让CPU工作在最高的主频上，尤其是移动设备和笔记本电脑，大部分时间里，CPU其实工作在轻负载状态下，我们知道：主频越高，功耗也越高。为了节省CPU的功耗和减少发热，我们有必要根据当前CPU的负载状态，动态地提供刚好足够的主频给CPU。在Linux中，内核的开发者定义了一套框架模型来完成这一目的，它就是CPUFreq系统。</p>

<h4>1. sysfs接口</h4>

<p>我们先从CPUFreq提供的sysfs接口入手，直观地看看它提供了那些功能。以下是我的电脑输出的结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>droidphone@990:~$ cd /sys/devices/system/cpu  
</span><span class='line'>droidphone@990:/sys/devices/system/cpu$ ls  
</span><span class='line'>cpu0  cpu3  cpu6     cpuidle     offline   power    release  
</span><span class='line'>cpu1  cpu4  cpu7     kernel_max  online    present  uevent  
</span><span class='line'>cpu2  cpu5  cpufreq  modalias    possible  probe  </span></code></pre></td></tr></table></div></figure>


<p>所有与CPUFreq相关的sysfs接口都位于：/sys/devices/system/cpu下面，我们可以看到，8个cpu分别建立了一个自己的目录，从cpu0到cpu7，我们再看看offline和online以及present的内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>droidphone@990:/sys/devices/system/cpu$ cat online  
</span><span class='line'>0-7  
</span><span class='line'>droidphone@990:/sys/devices/system/cpu$ cat offline  
</span><span class='line'>8-15  
</span><span class='line'>droidphone@990:/sys/devices/system/cpu$ cat present  
</span><span class='line'>0-7  
</span><span class='line'>droidphone@990:/sys/devices/system/cpu$  </span></code></pre></td></tr></table></div></figure>


<p>online代表目前正在工作的cpu，输出显示编号为0-7这8个cpu在工作，offline代表目前被关掉的cpu，present则表示主板上已经安装的cpu，由输出可以看到，我的主板可以安装16个cpu（因为intel的超线程技术，其实物理上只是8个），第8-15号cpu处于关闭状态（实际上不存在，因为present只有0-7）。</p>

<p>接着往下看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>droidphone@990:/sys/devices/system/cpu/cpu0$ ls  
</span><span class='line'>cache    cpuidle      microcode  power      thermal_throttle  uevent  
</span><span class='line'>cpufreq  crash_notes  node0      subsystem  topology  
</span><span class='line'>droidphone@990:/sys/devices/system/cpu/cpu0$ cd cpufreq/  
</span><span class='line'>droidphone@990:/sys/devices/system/cpu/cpu0/cpufreq$ ls  
</span><span class='line'>affected_cpus               related_cpus                   scaling_max_freq  
</span><span class='line'>bios_limit                  scaling_available_frequencies  scaling_min_freq  
</span><span class='line'>cpuinfo_cur_freq            scaling_available_governors    scaling_setspeed  
</span><span class='line'>cpuinfo_max_freq            scaling_cur_freq               stats  
</span><span class='line'>cpuinfo_min_freq            scaling_driver  
</span><span class='line'>cpuinfo_transition_latency  scaling_governor  
</span><span class='line'>droidphone@990:/sys/devices/system/cpu/cpu0/cpufreq$   </span></code></pre></td></tr></table></div></figure>


<p>在我的电脑上，部分的值如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cpuinfo_cur_freq:   1600000
</span><span class='line'>cpuinfo_max_freq:  3401000
</span><span class='line'>cpuinfo_min_freq:   1600000
</span><span class='line'>scaling_cur_freq:    1600000
</span><span class='line'>scaling_max_freq:  3401000
</span><span class='line'>scaling_min_freq:   1600000</span></code></pre></td></tr></table></div></figure>


<p>所以，我的cpu0的最低运行频率是1.6GHz，最高是3.4GHz，目前正在运行的频率是1.6GHz，前缀cpuinfo代表的是cpu硬件上支持的频率，而scaling前缀代表的是可以通过CPUFreq系统用软件进行调节时所支持的频率。cpuinfo_cur_freq代表通过硬件实际上读到的频率值，而scaling_cur_freq则是软件当前的设置值，多数情况下这两个值是一致的，但是也有可能因为硬件的原因，有微小的差异。scaling_available_frequencies会输出当前软件支持的频率值，看看我的cpu支持那些频率：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>droidphone@990:/sys/devices/system/cpu/cpu0/cpufreq$ cat scaling_available_frequencies   
</span><span class='line'>3401000 3400000 3000000 2800000 2600000 2400000 2200000 2000000 1800000 1600000   
</span><span class='line'>droidphone@990:/sys/devices/system/cpu/cpu0/cpufreq$   </span></code></pre></td></tr></table></div></figure>


<p>Oh，从1.6GHz到3.4GHz，一共支持10挡的频率可供选择。scaling_available_governors则会输出当前可供选择的频率调节策略：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>conservative ondemand userspace powersave performance  </span></code></pre></td></tr></table></div></figure>


<p>一共有5中策略供我们选择，那么当前系统选用那种策略？让我们看看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dong@dong-990:/sys/devices/system/cpu/cpu0/cpufreq$ cat scaling_governor  
</span><span class='line'>ondemand  </span></code></pre></td></tr></table></div></figure>


<p>OK，我的系统当前选择ondemand这种策略，这种策略的主要思想是：只要cpu的负载超过某一个阀值，cpu的频率会立刻提升至最高，然后再根据实际情况降到合适的水平。详细的情况我们留在后面的章节中讨论。scaling_driver则会输出当前使用哪一个驱动来设置cpu的工作频率。</p>

<p>当我们选择userspace作为我们的调频governor时，我们可以通过scaling_setspeed手工设置需要的频率。powersave则简单地使用最低的工作频率进行运行，而performance则一直选择最高的频率进行运行。</p>

<h4>2. 软件架构</h4>

<p>通过上一节的介绍，我们可以大致梳理出CPUFreq系统的构成和工作方式。首先，CPU的硬件特性决定了这个CPU的最高和最低工作频率，所有的频率调整数值都必须在这个范围内，它们用cpuinfo_xxx_freq来表示。然后，我们可以在这个范围内再次定义出一个软件的调节范围，它们用scaling_xxx_freq来表示，同时，根据具体的硬件平台的不同，我们还需要提供一个频率表，这个频率表规定了cpu可以工作的频率值，当然这些频率值必须要在cpuinfo_xxx_freq的范围内。有了这些频率信息，CPUFreq系统就可以根据当前cpu的负载轻重状况，合理地从频率表中选择一个合适的频率供cpu使用，已达到节能的目的。至于如何选择频率表中的频率，这个要由不同的governor来实现，目前的内核版本提供了5种governor供我们选择。选择好适当的频率以后，具体的频率调节工作就交由scaling_driver来完成。CPUFreq系统把一些公共的逻辑和接口代码抽象出来，这些代码与平台无关，也与具体的调频策略无关，内核的文档把它称为CPUFreq Core（/Documents/cpufreq/core.txt）。另外一部分，与实际的调频策略相关的部分被称作cpufreq_policy，cpufreq_policy又是由频率信息和具体的governor组成，governor才是具体策略的实现者，当然governor需要我们提供必要的频率信息，governor的实现最好能做到平台无关，与平台相关的代码用cpufreq_driver表述，它完成实际的频率调节工作。最后，如果其他内核模块需要在频率调节的过程中得到通知消息，则可以通过cpufreq notifiers来完成。由此，我们可以总结出CPUFreq系统的软件结构如下：</p>

<h4>3. cpufreq_policy</h4>

<p>一种调频策略的各种限制条件的组合称之为policy，代码中用cpufreq_policy这一数据结构来表示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct cpufreq_policy {  
</span><span class='line'>&#9;  
</span><span class='line'>&#9;cpumask_var_t           cpus;     
</span><span class='line'>&#9;cpumask_var_t           related_cpus;   
</span><span class='line'>  
</span><span class='line'>&#9;unsigned int            shared_type;   
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;  
</span><span class='line'>&#9;unsigned int            cpu;      
</span><span class='line'>&#9;unsigned int            last_cpu;   
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;    
</span><span class='line'>&#9;struct cpufreq_cpuinfo  cpuinfo;  
</span><span class='line'>  
</span><span class='line'>&#9;unsigned int            min;    /* in kHz */  
</span><span class='line'>&#9;unsigned int            max;    /* in kHz */  
</span><span class='line'>&#9;unsigned int            cur;      
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;   
</span><span class='line'>&#9;unsigned int            policy;   
</span><span class='line'>&#9;struct cpufreq_governor *governor;   
</span><span class='line'>&#9;void                    *governor_data;  
</span><span class='line'>  
</span><span class='line'>&#9;struct work_struct      update;   
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;   
</span><span class='line'>  
</span><span class='line'>&#9;struct cpufreq_real_policy      user_policy;  
</span><span class='line'>  
</span><span class='line'>&#9;struct kobject          kobj;  
</span><span class='line'>&#9;struct completion       kobj_unregister;  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>其中的各个字段的解释如下：</p>

<p>cpus和related_cpus    这两个都是cpumask_var_t变量，cpus表示的是这一policy控制之下的所有还出于online状态的cpu，而related_cpus则是online和offline两者的合集。主要是用于多个cpu使用同一种policy的情况，实际上，我们平常见到的大多数系统中都是这种情况：所有的cpu同时使用同一种policy。我们需要related_cpus变量指出这个policy所管理的所有cpu编号。</p>

<p>cpu和last_cpu    虽然一种policy可以同时用于多个cpu，但是通常一种policy只会由其中的一个cpu进行管理，cpu变量用于记录用于管理该policy的cpu编号，而last_cpu则是上一次管理该policy的cpu编号（因为管理policy的cpu可能会被plug out，这时候就要把管理工作迁移到另一个cpu上）。</p>

<p>cpuinfo    保存cpu硬件所能支持的最大和最小的频率以及切换延迟信息。</p>

<p>min/max/cur  该policy下的可使用的最小频率，最大频率和当前频率。</p>

<p>policy    该变量可以取以下两个值：CPUFREQ_POLICY_POWERSAVE和CPUFREQ_POLICY_PERFORMANCE，该变量只有当调频驱动支持setpolicy回调函数的时候有效，这时候由驱动根据policy变量的值来决定系统的工作频率或状态。如果调频驱动（cpufreq_driver）支持target回调，则频率由相应的governor来决定。</p>

<p>governor和governor_data    指向该policy当前使用的cpufreq_governor结构和它的上下文数据。governor是实现该policy的关键所在，调频策略的逻辑由governor实现。</p>

<p>update    有时在中断上下文中需要更新policy，需要利用该工作队列把实际的工作移到稍后的进程上下文中执行。</p>

<p>user_policy    有时候因为特殊的原因需要修改policy的参数，比如溫度过高时，最大可允许的运行频率可能会被降低，为了在适当的时候恢复原有的运行参数，需要使用user_policy保存原始的参数（min，max，policy，governor）。</p>

<p>kobj    该policy在sysfs中对应的kobj的对象。</p>

<h4>4. cpufreq_governor</h4>

<p>所谓的governor，我把它翻译成：调节器。governor负责检测cpu的使用状况，从而在可用的范围中选择一个合适的频率，代码中它用cpufreq_governor结构来表示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct cpufreq_governor {  
</span><span class='line'>&#9;char    name[CPUFREQ_NAME_LEN];  
</span><span class='line'>&#9;int     initialized;  
</span><span class='line'>&#9;int     (*governor)     (struct cpufreq_policy *policy,  
</span><span class='line'>&#9;&#9;&#9;&#9; unsigned int event);  
</span><span class='line'>&#9;ssize_t (*show_setspeed)        (struct cpufreq_policy *policy,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; char *buf);  
</span><span class='line'>&#9;int     (*store_setspeed)       (struct cpufreq_policy *policy,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; unsigned int freq);  
</span><span class='line'>&#9;unsigned int max_transition_latency; /* HW must be able to switch to 
</span><span class='line'>&#9;&#9;&#9;next freq faster than this value in nano secs or we 
</span><span class='line'>&#9;&#9;&#9;will fallback to performance governor */  
</span><span class='line'>&#9;struct list_head        governor_list;  
</span><span class='line'>&#9;struct module           *owner;  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>其中的各个字段的解释如下：</p>

<p>name    该governor的名字。</p>

<p>initialized    初始化标志。</p>

<p>governor    指向一个回调函数，CPUFreq Core会在不同的阶段调用该回调函数，用于该governor的启动、停止、初始化、退出动作。</p>

<p>list_head    所有注册的governor都会利用该字段链接在一个全局链表中，以供系统查询和使用。</p>

<h4>5. cpufreq_driver</h4>

<p>上一节提到的gonvernor只是负责计算并提出合适的频率，但是频率的设定工作是平台相关的，这需要cpufreq_driver驱动来完成，cpufreq_driver的结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct cpufreq_driver {  
</span><span class='line'>&#9;struct module           *owner;  
</span><span class='line'>&#9;char                    name[CPUFREQ_NAME_LEN];  
</span><span class='line'>&#9;u8                      flags;  
</span><span class='line'>       
</span><span class='line'>&#9;bool                    have_governor_per_policy;  
</span><span class='line'>  
</span><span class='line'>&#9;/* needed by all drivers */  
</span><span class='line'>&#9;int     (*init)         (struct cpufreq_policy *policy);  
</span><span class='line'>&#9;int     (*verify)       (struct cpufreq_policy *policy);  
</span><span class='line'>  
</span><span class='line'>&#9;/* define one out of two */  
</span><span class='line'>&#9;int     (*setpolicy)    (struct cpufreq_policy *policy);  
</span><span class='line'>&#9;int     (*target)       (struct cpufreq_policy *policy,  
</span><span class='line'>&#9;&#9;&#9;&#9; unsigned int target_freq,  
</span><span class='line'>&#9;&#9;&#9;&#9; unsigned int relation);  
</span><span class='line'>  
</span><span class='line'>&#9;/* should be defined, if possible */  
</span><span class='line'>&#9;unsigned int    (*get)  (unsigned int cpu);  
</span><span class='line'>  
</span><span class='line'>&#9;/* optional */  
</span><span class='line'>&#9;unsigned int (*getavg)  (struct cpufreq_policy *policy,  
</span><span class='line'>&#9;&#9;&#9;&#9; unsigned int cpu);  
</span><span class='line'>&#9;int     (*bios_limit)   (int cpu, unsigned int *limit);  
</span><span class='line'>  
</span><span class='line'>&#9;int     (*exit)         (struct cpufreq_policy *policy);  
</span><span class='line'>&#9;int     (*suspend)      (struct cpufreq_policy *policy);  
</span><span class='line'>&#9;int     (*resume)       (struct cpufreq_policy *policy);  
</span><span class='line'>&#9;struct freq_attr        **attr;  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>相关的字段的意义解释如下：</p>

<p>name    该频率驱动的名字。</p>

<p>init    回调函数，该回调函数必须实现，CPUFreq Core会通过该回调函数对该驱动进行必要的初始化工作。</p>

<p>verify    回调函数，该回调函数必须实现，CPUFreq Core会通过该回调函数检查policy的参数是否被驱动支持。</p>

<p>setpolicy/target    回调函数，驱动必须实现这两个函数中的其中一个，如果不支持通过governor选择合适的运行频率，则实现setpolicy回调函数，这样系统只能支持CPUFREQ_POLICY_POWERSAVE和CPUFREQ_POLICY_PERFORMANCE这两种工作策略。反之，实现target回调函数，通过target回调设定governor所需要的频率。</p>

<p>get    回调函数，用于获取cpu当前的工作频率。</p>

<p>getavg    回调函数，用于获取cpu当前的平均工作频率。</p>

<h4>6. cpufreq notifiers</h4>

<p>CPUFreq的通知系统使用了内核的标准通知接口。它对外提供了两个通知事件：policy通知和transition通知。</p>

<p>policy通知用于通知其它模块cpu的policy需要改变，每次policy改变时，该通知链上的回调将会用不同的事件参数被调用3次，分别是：</p>

<p>CPUFREQ_ADJUST    只要有需要，所有的被通知者可以在此时修改policy的限制信息，比如温控系统可能会修改在大允许运行的频率。<br/>
CPUFREQ_INCOMPATIBLE    只是为了避免硬件错误的情况下，可以在该通知中修改policy的限制信息。<br/>
CPUFREQ_NOTIFY    真正切换policy前，该通知会发往所有的被通知者。</p>

<p>transition通知链用于在驱动实施调整cpu的频率时，用于通知相关的注册者。每次调整频率时，该通知会发出两次通知事件：</p>

<p>CPUFREQ_PRECHANGE    调整前的通知。<br/>
CPUFREQ_POSTCHANGE    完成调整后的通知。</p>

<p>当检测到因系统进入suspend而造成频率被改变时，以下通知消息会被发出：</p>

<p>CPUFREQ_RESUMECHANGE</p>

<hr />

<h3>Linux动态频率调节系统CPUFreq之二：核心（core）架构与API</h3>

<p>上一节中，我们大致地讲解了一下CPUFreq在用户空间的sysfs接口和它的几个重要的数据结构，同时也提到，CPUFreq子系统把一些公共的代码逻辑组织在一起，构成了CPUFreq的核心部分，这些公共逻辑向CPUFreq和其它内核模块提供了必要的API，像cpufreq_governor、cpufreq_driver等模块通过这些API来完成一个完整的CPUFreq体系。这一节我们就来讨论一下核心架构的代码架构以及如何使用这些公共的API接口。</p>

<p>核心部分的代码都在：/drivers/cpufreq/cpufreq.c中，本系列文章我使用的内核版本是3.10.0.</p>

<h4>1. CPUFreq子系统的初始化</h4>

<p>先看看具体的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int __init cpufreq_core_init(void)  
</span><span class='line'>{  
</span><span class='line'>&#9;int cpu;  
</span><span class='line'>  
</span><span class='line'>&#9;if (cpufreq_disabled())  
</span><span class='line'>&#9;&#9;return -ENODEV;  
</span><span class='line'>  
</span><span class='line'>&#9;for_each_possible_cpu(cpu) {  
</span><span class='line'>&#9;&#9;per_cpu(cpufreq_policy_cpu, cpu) = -1;  
</span><span class='line'>&#9;&#9;init_rwsem(&per_cpu(cpu_policy_rwsem, cpu));  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;cpufreq_global_kobject = kobject_create_and_add("cpufreq", &cpu_subsys.dev_root-&gt;kobj);  
</span><span class='line'>&#9;BUG_ON(!cpufreq_global_kobject);  
</span><span class='line'>&#9;register_syscore_ops(&cpufreq_syscore_ops);  
</span><span class='line'>  
</span><span class='line'>&#9;return 0;  
</span><span class='line'>}  
</span><span class='line'>core_initcall(cpufreq_core_init);  </span></code></pre></td></tr></table></div></figure>


<p>可见，在系统的启动阶段，经由initcall机制，cpufreq_core_init被调用，由它来完成核心部分的初始化工作，其中：</p>

<p>cpufreq_policy_cpu    是一个per_cpu变量，在smp的系统下，每个cpu可以有自己独立的调频policy，也可以所有的cpu都是用一种policy，这时候就有可能出现其中一个cpu管理着某个policy，而其它cpu因为也使用同一个policy，这些cpu的policy的就交由那个管理cpu代管，这个per_cpu变量就是用来记录各个cpu的policy实际上是由那个cpu进行管理的。初始化时都被初始化为-1了，代表现在还没有开始进行policy的管理。</p>

<p>接下来的kobject_create_and_add函数在/sys/devices/system/cpu这个节点下建立了一个cpufreq节点，该节点的下面以后会用来放置当前governor的一些配置参数。参数cpu_subsys是内核的一个全局变量，是由更早期的初始化时初始化的，代码在drivers/base/cpu.c中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct bus_type cpu_subsys = {  
</span><span class='line'>&#9;.name = "cpu",  
</span><span class='line'>&#9;.dev_name = "cpu",  
</span><span class='line'>};  
</span><span class='line'>EXPORT_SYMBOL_GPL(cpu_subsys);  
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>void __init cpu_dev_init(void)  
</span><span class='line'>{  
</span><span class='line'>&#9;if (subsys_system_register(&cpu_subsys, cpu_root_attr_groups))  
</span><span class='line'>&#9;&#9;panic("Failed to register CPU subsystem");  
</span><span class='line'>  
</span><span class='line'>&#9;cpu_dev_register_generic();  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>这将会建立一根cpu总线，总线下挂着系统中所有的cpu，cpu总线设备的根目录就位于：/sys/devices/system/cpu，同时，/sys/bus下也会出现一个cpu的总线节点。cpu总线设备的根目录下会依次出现cpu0，cpu1，&hellip;&hellip; cpux节点，每个cpu对应其中的一个设备节点。CPUFreq子系统利用这个cpu_subsys来获取系统中的cpu设备，并在这些cpu设备下面建立相应的cpufreq对象，这个我们在后面再讨论。</p>

<p>这样看来，cpufreq子系统的初始化其实没有做什么重要的事情，只是初始化了几个per_cpu变量和建立了一个cpufreq文件节点。下图是初始化过程的序列图：</p>

<p><img src="/images/kernel/2015-08-12-1.png" alt="" /></p>

<p>图 1.1  核心层初始化</p>

<h4>2. 注册cpufreq_governor</h4>

<p>系统中可以同时存在多个governor策略，一个policy通过cpufreq_policy结构中的governor指针和某个governor相关联。要想一个governor被policy使用，首先要把该governor注册到cpufreq的核心中，我们可以通过核心层提供的API来完成注册：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int cpufreq_register_governor(struct cpufreq_governor *governor)  
</span><span class='line'>{  
</span><span class='line'>&#9;int err;  
</span><span class='line'>&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;governor-&gt;initialized = 0;  
</span><span class='line'>&#9;err = -EBUSY;  
</span><span class='line'>&#9;if (__find_governor(governor-&gt;name) == NULL) {  
</span><span class='line'>&#9;&#9;err = 0;  
</span><span class='line'>&#9;&#9;list_add(&governor-&gt;governor_list, &cpufreq_governor_list);  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;......  
</span><span class='line'>&#9;return err;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>核心层定义了一个全局链表变量：cpufreq_governor_list，注册函数首先根据governor的名称，通过<code>__find_governor()</code>函数查找该governor是否已經被注册过，如果没有被注册过，则把代表该governor的结构体添加到cpufreq_governor_list链表中。在上一篇中我们提到，目前的内核版本提供了5种governor供我们使用，我们可以通过内核的配置項来选择需要编译的governor，同时需要指定一个默认的governor。在cpufreq.h中，将会根据配置項的选择，把CPUFREQ_DEFAULT_GOVERNOR宏指向默认governor结构体变量的地址，在注册cpufreq_driver的阶段需要使用这个宏来设定系统默认使用的governor。</p>

<h4>3. 注册一个cpufreq_driver驱动</h4>

<p>与governor不同，系统中只会存在一个cpufreq_driver驱动，根据上一篇Linux动态频率调节系统CPUFreq之一：概述的介绍，cpufreq_driver是平台相关的，负责最终实施频率的调整动作，而选择工作频率的策略是由governor完成的。所以，系统中只需要注册一个cpufreq_driver即可，它只负责知道如何控制该平台的时钟系统，从而设定由governor确定的工作频率。注册cpufreq_driver驱动会触发cpufreq核心的一系列额外的初始化动作，第一节所说的核心初始化工作非常简单，实际上，更多的初始化动作在注册cpufreq_driver阶段完成。核心提供了一个API：cpufreq_register_driver来完成注册工作。下面我们分析一下这个函数的工作过程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int cpufreq_register_driver(struct cpufreq_driver *driver_data)  
</span><span class='line'>{  
</span><span class='line'>&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;if (cpufreq_disabled())  
</span><span class='line'>&#9;&#9;return -ENODEV;  
</span><span class='line'>  
</span><span class='line'>&#9;if (!driver_data || !driver_data-&gt;verify || !driver_data-&gt;init ||  
</span><span class='line'>&#9;    ((!driver_data-&gt;setpolicy) && (!driver_data-&gt;target)))  
</span><span class='line'>&#9;&#9;return -EINVAL;  </span></code></pre></td></tr></table></div></figure>


<p>该API只有一个参数：一个cpufreq_driver指针，driver_data，该结构事先在驱动的代码中定义，调用该API时作为参数传入。函数先判断系统目前是否禁止了调频功能，然后检查cpufreq_driver的几个回调函数是否被实现，由代码可以看出，verify和init回调函数必须要实现，而setpolicy和target回调则至少要被实现其中的一个。这几个回调的作用请参考本系列的第一篇文章。接下来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>write_lock_irqsave(&cpufreq_driver_lock, flags);  
</span><span class='line'>       if (cpufreq_driver) {  
</span><span class='line'>&#9;       write_unlock_irqrestore(&cpufreq_driver_lock, flags);  
</span><span class='line'>&#9;       return -EBUSY;  
</span><span class='line'>       }  
</span><span class='line'>       cpufreq_driver = driver_data;  
</span><span class='line'>       write_unlock_irqrestore(&cpufreq_driver_lock, flags);  </span></code></pre></td></tr></table></div></figure>


<p>检查全局变量cpufreq_driver是否已经被赋值，如果没有，则传入的参数被赋值给全局变量cpufreq_driver，从而保证了系统中只会注册一个cpufreq_driver驱动。然后：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ret = subsys_interface_register(&cpufreq_interface);  
</span><span class='line'>  
</span><span class='line'>......  
</span><span class='line'>......   
</span><span class='line'>  
</span><span class='line'>register_hotcpu_notifier(&cpufreq_cpu_notifier);  </span></code></pre></td></tr></table></div></figure>


<p>通过subsys_interface_register给每一个cpu建立一个cpufreq_policy，最后注册cpu hot plug通知，以便在cpu hot plug的时候，能够动态地处理各个cpu policy之间的关系（比如迁移负责管理的cpu等等）。这里要重点讨论一下subsys_interface_register的过程，回到第一节的内容，我们知道初始化阶段，cpu_subsys被建立，从而每个cpu都会在cpu总线设备下建立一个属于自己的设备：sys/devices/system/cpu/cpux。subsys_interface_register负责在cpu_subsys子系统的子设备下面注册公共的接口。我们看看参数cpufreq_interface的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct subsys_interface cpufreq_interface = {  
</span><span class='line'>&#9;.name           = "cpufreq",  
</span><span class='line'>&#9;.subsys         = &cpu_subsys,  
</span><span class='line'>&#9;.add_dev        = cpufreq_add_dev,  
</span><span class='line'>&#9;.remove_dev     = cpufreq_remove_dev,  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>subsys_interface_register函数的代码我就不再展开了，它的大致作用就是：遍历子系统下面的每一个子设备，然后用这个子设备作为参数，调用cpufrq_interface结构的add_dev回调函数，这里的回调函数被指向了cpufreq_add_dev，它的具体工作方式我们在下一节中讨论。</p>

<p>driver注册完成后，驱动被保存在全局变量cpufreq_driver中，供核心层使用，同时，每个cpu也会建立自己的policy策略，governor也开始工作，实时地监控着cpu的负载并计算合适的工作频率，然后通过driver调整真正的工作频率。下图是cpufreq_driver注册过程的序列图：</p>

<p><img src="/images/kernel/2015-08-12-2.png" alt="" /></p>

<p>图 3.1   cpufreq_driver的注册过程</p>

<h4>4.  为每个cpu建立频率调整策略（policy）</h4>

<p>为每个cpu建立频率调整策略实在注册cpufreq_driver阶段的subsys_interface_registe函数中完成的，上一节已经提到，该函数最终会调用cpufreq_add_dev回调函数，现在展开这个函数分析一下：</p>

<p>因为subsys_interface_registe会枚举各个cpu设备，不管该cpu处于offline还是online状态，cpufreq_add_dev都会被调用，所以函数的一开始，判断如果cpu处于offline状态，直接返回。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)  
</span><span class='line'>{  
</span><span class='line'>&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;if (cpu_is_offline(cpu))  
</span><span class='line'>&#9;&#9;return 0;  </span></code></pre></td></tr></table></div></figure>


<p>如果是smp系统，本cpu的policy可能和其他cpu共同使用同一个policy，并委托另一个叫做管理cpu的cpu进行管理，下面的代码判断这种情况，如果已经委托别的cpu管理，则直接返回，核心层定义了另一个per_cpu变量：cpufreq_cpu_data，用来保存各个cpu所使用的cpufreq_policy结构的指针，cpufreq_cpu_get函数实际上就是通过这个per_cpu变量，获取该指针，如果该指针非0，代表该cpu已经建立好了它自身的policy（可能是在他之前的管理cpu建立policy期间一并建立的）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>policy = cpufreq_cpu_get(cpu);  
</span><span class='line'>if (unlikely(policy)) {  
</span><span class='line'>&#9;cpufreq_cpu_put(policy);  
</span><span class='line'>&#9;return 0;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>因为cpu hot plug期间，cpufreq_add_dev也会被调用，下面的代码片段检测该cpu之前是否被hot-unpluged过，如果是，找到其中一个相关的cpu（这些相关的cpu都委托给同一个托管它cpu进行管理，调用cpufreq_add_policy_cpu函数，该函数只是简单地建立一个cpufreq链接，链接到管理cpu的cpufreq节点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for_each_online_cpu(sibling) {  
</span><span class='line'>&#9; struct cpufreq_policy *cp = per_cpu(cpufreq_cpu_data, sibling);  
</span><span class='line'>&#9; if (cp && cpumask_test_cpu(cpu, cp-&gt;related_cpus)) {  
</span><span class='line'>&#9;&#9; read_unlock_irqrestore(&cpufreq_driver_lock, flags);  
</span><span class='line'>&#9;&#9; return cpufreq_add_policy_cpu(cpu, sibling, dev);  
</span><span class='line'>&#9; }  
</span><span class='line'> }  </span></code></pre></td></tr></table></div></figure>


<p>当这是系统初始化阶段第一次调用cpufreq_add_dev时（subsys_interface_register枚举到的第一个cpu，通常就是cpu0），cpufreq_cpu_data应该为NULL，所以我们要为这样的cpu分配一个cpufreq_policy结构，并初始化该policy所管理的cpu，包括online的cpus字段和online+offline的cpu_related字段，并把自己设置为这个policy的管理cpu，使用默认governor初始化policy->governor字段，同时吧自己加入到online的cpus字段中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>policy = kzalloc(sizeof(struct cpufreq_policy), GFP_KERNEL);  
</span><span class='line'>if (!policy)  
</span><span class='line'>&#9;goto nomem_out;  
</span><span class='line'>  
</span><span class='line'>if (!alloc_cpumask_var(&policy-&gt;cpus, GFP_KERNEL))  
</span><span class='line'>&#9;goto err_free_policy;  
</span><span class='line'>  
</span><span class='line'>if (!zalloc_cpumask_var(&policy-&gt;related_cpus, GFP_KERNEL))  
</span><span class='line'>&#9;goto err_free_cpumask;  
</span><span class='line'>  
</span><span class='line'>policy-&gt;cpu = cpu;  
</span><span class='line'>policy-&gt;governor = CPUFREQ_DEFAULT_GOVERNOR;  
</span><span class='line'>cpumask_copy(policy-&gt;cpus, cpumask_of(cpu));  
</span><span class='line'>  
</span><span class='line'>/* Initially set CPU itself as the policy_cpu */  
</span><span class='line'>per_cpu(cpufreq_policy_cpu, cpu) = cpu;  </span></code></pre></td></tr></table></div></figure>


<p>接下来初始化一个供kobject系统注销时使用的同步变量，初始化一个workqueue，某些时候不能马上执行对该policy的更新操作，可以使用该workqueue来延迟执行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>init_completion(&policy-&gt;kobj_unregister);  
</span><span class='line'>INIT_WORK(&policy-&gt;update, handle_update);  </span></code></pre></td></tr></table></div></figure>


<p>接着，调用cpufreq_driver的init回调，进一步初始化该policy：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ret = cpufreq_driver-&gt;init(policy);  
</span><span class='line'> if (ret) {  
</span><span class='line'>&#9; pr_debug("initialization failed\n");  
</span><span class='line'>&#9; goto err_set_policy_cpu;  
</span><span class='line'> }  </span></code></pre></td></tr></table></div></figure>


<p>在上述驱动的初始化内部，应该完成以下工作：</p>

<p>设定该cpu的最大和最小工作频率<br/>
设定该policy的最大和最小工作频率<br/>
设定该policy可供调节的频率档位<br/>
设定cpu调节频率时的延迟时间特性<br/>
该policy可以管理的cpu个数（policy->cpus）</p>

<p>继续：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* related cpus should atleast have policy-&gt;cpus */  
</span><span class='line'>cpumask_or(policy-&gt;related_cpus, policy-&gt;related_cpus, policy-&gt;cpus);  </span></code></pre></td></tr></table></div></figure>


<p>注释已经写的很清楚了，把online的cpu加到代表online+offline的related字段中。接着，剔除offline的cpu：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cpumask_and(policy-&gt;cpus, policy-&gt;cpus, cpu_online_mask);  </span></code></pre></td></tr></table></div></figure>


<p>然后，发出CPUFREQ_START通知：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>blocking_notifier_call_chain(&cpufreq_policy_notifier_list,  
</span><span class='line'>&#9;&#9;&#9;     CPUFREQ_START, policy);  </span></code></pre></td></tr></table></div></figure>


<p>如果是hot-plug加入的cpu，找出它上次使用的governor：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#ifdef CONFIG_HOTPLUG_CPU  
</span><span class='line'>&#9;gov = __find_governor(per_cpu(cpufreq_cpu_governor, cpu));  
</span><span class='line'>&#9;if (gov) {  
</span><span class='line'>&#9;&#9;policy-&gt;governor = gov;  
</span><span class='line'>&#9;&#9;pr_debug("Restoring governor %s for cpu %d\n",  
</span><span class='line'>&#9;&#9;       policy-&gt;governor-&gt;name, cpu);  
</span><span class='line'>&#9;}  
</span><span class='line'>#endif  </span></code></pre></td></tr></table></div></figure>


<p>最后，建立cpu设备下的sysfs文件节点：cpufreq，它的完整路径是：/sys/devices/system/cpu/cpux/cpufreq，同时，在他的下面，相应的sysfs节点也同时被建立，节点的内容请参考本系列的第一篇文章：Linux动态频率调节系统CPUFreq之一：概述：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ret = cpufreq_add_dev_interface(cpu, policy, dev);  </span></code></pre></td></tr></table></div></figure>


<p>至此，一个cpu的policy建立完成，它的频率限制条件、使用的governor策略，sysfs文件节点都已经建立完成。需要注意点是，系统中有多少个cpu，cpufreq_add_dev函数就会被调用多少次，最后，每个cpu都会建立自己的policy，当然，也有可能只有部分cpu建立了真正的policy，而其它cpu则委托这些cpu进行policy的管理，关于这一点，一开始读代码的时候可能有点困扰，为了搞清楚他们之间的关系，我们再跟入cpufreq_add_dev_interface函数看看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int cpufreq_add_dev_interface(unsigned int cpu,  
</span><span class='line'>&#9;&#9;&#9;&#9;     struct cpufreq_policy *policy,  
</span><span class='line'>&#9;&#9;&#9;&#9;     struct device *dev)  
</span><span class='line'>{  
</span><span class='line'>&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;/* prepare interface data */  
</span><span class='line'>&#9;ret = kobject_init_and_add(&policy-&gt;kobj, &ktype_cpufreq,  
</span><span class='line'>&#9;&#9;&#9;&#9;   &dev-&gt;kobj, "cpufreq");  
</span><span class='line'>&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;/* set up files for this cpu device */  
</span><span class='line'>&#9;drv_attr = cpufreq_driver-&gt;attr;  
</span><span class='line'>&#9;while ((drv_attr) && (*drv_attr)) {  
</span><span class='line'>&#9;&#9;ret = sysfs_create_file(&policy-&gt;kobj, &((*drv_attr)-&gt;attr));  
</span><span class='line'>&#9;&#9;if (ret)  
</span><span class='line'>&#9;&#9;&#9;goto err_out_kobj_put;  
</span><span class='line'>&#9;&#9;drv_attr++;  
</span><span class='line'>&#9;}  </span></code></pre></td></tr></table></div></figure>


<p>函数的一开始，建立cpufreq文件节点，然后在它的下面再建立一系列节点，用户可以通过这些文件节点控制该policy的一些参数。这不是我们的重点，我们看下面这一段代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for_each_cpu(j, policy-&gt;cpus) {  
</span><span class='line'>&#9;per_cpu(cpufreq_cpu_data, j) = policy;  
</span><span class='line'>&#9;per_cpu(cpufreq_policy_cpu, j) = policy-&gt;cpu;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>前面的代码已经设定了该policy所管理的online cpu：policy->cpus，通过两个per_cpu变量，这里把每个online cpu的policy都设置为了本cpu（管理cpu）的policy，并且把所有online的cpu的管理cpu也指定为了本cpu。接下来，cpufreq_add_dev_symlink被调用，所有policy->cpus指定的cpu会建立一个cpufreq链接，指向本cpu（管理cpu）的真实cpufreq节点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ret = cpufreq_add_dev_symlink(cpu, policy);  </span></code></pre></td></tr></table></div></figure>


<p>注意，假如这时的cpu是cpu0，也就是说，其它cpu的cpufreq_add_dev还没有被调用，但是在cpufreq_cpu_data中，与之对应的policy指针已经被赋值为cpu0所对应的policy，这样，回到cpufreq_add_dev函数的开头部分，当接下其它被认为使用cpu0托管他们的policy的cpu也会进入cpufreq_add_dev函数，但是，因为cpufreq_cpu_data中对应的policy已经在cpu0的建立阶段被赋值，所以这些cpu他们不会走完所有的流程，在函数的开头的判断部分，判断cpufreq_cpu_data中cpu对应的policy已经被赋值，就直接返回了。
接着往下看cpufreq_add_dev_interface的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>memcpy(&new_policy, policy, sizeof(struct cpufreq_policy));  
</span><span class='line'>/* assure that the starting sequence is run in __cpufreq_set_policy */  
</span><span class='line'>policy-&gt;governor = NULL;  
</span><span class='line'>  
</span><span class='line'>/* set default policy */  
</span><span class='line'>ret = __cpufreq_set_policy(policy, &new_policy);  
</span><span class='line'>policy-&gt;user_policy.policy = policy-&gt;policy;  
</span><span class='line'>policy-&gt;user_policy.governor = policy-&gt;governor;  </span></code></pre></td></tr></table></div></figure>


<p>通过<code>__cpufreq_set_policy</code>函数，最终使得该policy正式生效。到这里，每个cpu的policy已经建立完毕，并正式开始工作。关于<code>__cpufreq_set_policy</code>的代码这里就不展开了，我只给出它的序列图：</p>

<p><img src="/images/kernel/2015-08-12-3.png" alt="" /></p>

<p>图 4.1  设置一个cpufreq_policy</p>

<h4>5. 其它API</h4>

<p>cpufreq的核心层除了提供上面几节讨论的注册governor，注册cpufreq_driver等API外，还提供了其他一些辅助的API，以方便其它模块的使用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
</span><span class='line'>int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);</span></code></pre></td></tr></table></div></figure>


<p>以上两个API用于注册和注销cpufreq系统的通知消息，第二个参数可以选择通知的类型，可以有以下两种类型：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CPUFREQ_TRANSITION_NOTIFIER      收到频率变更通知
</span><span class='line'>CPUFREQ_POLICY_NOTIFIER               收到policy更新通知
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>int cpufreq_driver_target(struct cpufreq_policy *policy,
</span><span class='line'>&#9;&#9;&#9;&#9; unsigned int target_freq,
</span><span class='line'>&#9;&#9;&#9;&#9; unsigned int relation);
</span><span class='line'>int __cpufreq_driver_target(struct cpufreq_policy *policy,
</span><span class='line'>&#9;&#9;&#9;&#9;   unsigned int target_freq,
</span><span class='line'>&#9;&#9;&#9;&#9;   unsigned int relation);</span></code></pre></td></tr></table></div></figure>


<p>以上两个API用来设置cpu的工作频率，区别在于cpufreq_driver_target是带锁的版本，而<code>__cpufreq_driver_target</code>是不带锁的版本，如果确定是在governor的上下文中，使用不带锁的版本，否则需要使用带锁的版本。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned int min, unsigned int max)；</span></code></pre></td></tr></table></div></figure>


<p>这个API用来检查并重新设定policy的最大和最小频率。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int cpufreq_update_policy(unsigned int cpu);</span></code></pre></td></tr></table></div></figure>


<p>这个API用来触发cpufreq核心进行policy的更新操作。</p>

<hr />

<h3>Linux动态频率调节系统CPUFreq之三：governor</h3>

<p>在上一篇文章中，介绍了cpufreq的core层，core提供了cpufreq系统的初始化，公共数据结构的建立以及对cpufreq中其它子部件提供注册功能。core的最核心功能是对policy的管理，一个policy通过cpufreq_policy结构中的governor字段，和某个governor相关联，本章的内容正是要对governor进行讨论。</p>

<p>通过前面两篇文章的介绍，我们知道，governor的作用是：检测系统的负载状况，然后根据当前的负载，选择出某个可供使用的工作频率，然后把该工作频率传递给cpufreq_driver，完成频率的动态调节。内核默认提供了5种governor供我们使用，在之前的内核版本中，每种governor几乎是独立的代码，它们各自用自己的方式实现对系统的负载进行监测，很多时候，检测的逻辑其实是很相似的，各个governor最大的不同之处其实是根据检测的结果，选择合适频率的策略。所以，为了减少代码的重复，在我现在分析的内核版本中（3.10.0），一些公共的逻辑代码被单独抽象出来，单独用一个文件来实现：/drivers/cpufreq/cpufreq_governor.c，而各个具体的governor则分别有自己的代码文件，如：cpufreq_ondemand.c，cpufreq_performance.c。下面我们先从公共部分讨论。</p>

<h4>1. 数据结构</h4>

<p>cpu_dbs_common_info  该结构把对计算cpu负载需要使用到的一些辅助变量整合在了一起，通常，每个cpu都需要一个cpu_dbs_common_info结构体，该结构体中的成员会在governor的生命周期期间进行传递，以用于统计当前cpu的负载，它的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Per cpu structures */  
</span><span class='line'>struct cpu_dbs_common_info {  
</span><span class='line'>&#9;int cpu;  
</span><span class='line'>&#9;u64 prev_cpu_idle;  
</span><span class='line'>&#9;u64 prev_cpu_wall;  
</span><span class='line'>&#9;u64 prev_cpu_nice;  
</span><span class='line'>&#9;struct cpufreq_policy *cur_policy;  
</span><span class='line'>&#9;struct delayed_work work;  
</span><span class='line'>  
</span><span class='line'>&#9;struct mutex timer_mutex;  
</span><span class='line'>&#9;ktime_t time_stamp;  
</span><span class='line'>};  
</span><span class='line'>
</span><span class='line'>cpu  与该结构体相关联的cpu编号。
</span><span class='line'>prev_cpu_idle  上一次统计时刻该cpu停留在idle状态的总时间。
</span><span class='line'>prev_cpu_wall  上一次统计时刻对应的总工作时间。
</span><span class='line'>cur_policy  指向该cpu所使用的cpufreq_policy结构。
</span><span class='line'>work  工作队列，该工作队列会被定期地触发，然后定期地进行负载的更新和统计工作。</span></code></pre></td></tr></table></div></figure>


<p>dbs缩写，实际是：demand based switching，通常，因为cpu_dbs_common_info只包含了经过抽象后的公共部分，所以，各个governor会自己定义的一个包含cpu_dbs_common_info的自定义结构，例如对于ondemand，他会定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct od_cpu_dbs_info_s {  
</span><span class='line'>&#9;struct cpu_dbs_common_info cdbs;  
</span><span class='line'>&#9;struct cpufreq_frequency_table *freq_table;  
</span><span class='line'>&#9;unsigned int freq_lo;  
</span><span class='line'>&#9;unsigned int freq_lo_jiffies;  
</span><span class='line'>&#9;unsigned int freq_hi_jiffies;  
</span><span class='line'>&#9;unsigned int rate_mult;  
</span><span class='line'>&#9;unsigned int sample_type:1;  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>而对于Conservative，他的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct cs_cpu_dbs_info_s {  
</span><span class='line'>&#9;struct cpu_dbs_common_info cdbs;  
</span><span class='line'>&#9;unsigned int down_skip;  
</span><span class='line'>&#9;unsigned int requested_freq;  
</span><span class='line'>&#9;unsigned int enable:1;  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>把它理解为类似于C++语言的基类和子类的概念就是了。</p>

<p>common_dbs_data    各个独立的governor，需要和governor的公共层交互，需要实现一套公共的接口，这个接口由common_dbs_data结构来提供：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct common_dbs_data {  
</span><span class='line'>&#9;/* Common across governors */  
</span><span class='line'>&#9;#define GOV_ONDEMAND            0  
</span><span class='line'>&#9;#define GOV_CONSERVATIVE        1  
</span><span class='line'>&#9;int governor;  
</span><span class='line'>&#9;struct attribute_group *attr_group_gov_sys; /* one governor - system */  
</span><span class='line'>&#9;struct attribute_group *attr_group_gov_pol; /* one governor - policy */  
</span><span class='line'>  
</span><span class='line'>&#9;/* Common data for platforms that don't set have_governor_per_policy */  
</span><span class='line'>&#9;struct dbs_data *gdbs_data;  
</span><span class='line'>  
</span><span class='line'>&#9;struct cpu_dbs_common_info *(*get_cpu_cdbs)(int cpu);  
</span><span class='line'>&#9;void *(*get_cpu_dbs_info_s)(int cpu);  
</span><span class='line'>&#9;void (*gov_dbs_timer)(struct work_struct *work);  
</span><span class='line'>&#9;void (*gov_check_cpu)(int cpu, unsigned int load);  
</span><span class='line'>&#9;int (*init)(struct dbs_data *dbs_data);  
</span><span class='line'>&#9;void (*exit)(struct dbs_data *dbs_data);  
</span><span class='line'>  
</span><span class='line'>&#9;/* Governor specific ops, see below */  
</span><span class='line'>&#9;void *gov_ops;  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>主要的字段意义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>governor  因为ondemand和conservative的实现部分有很多相似的地方，用该字段做一区分，可以设置为GOV_ONDEMAND或GOV_CONSERVATIVE的其中之一。
</span><span class='line'>attr_group_gov_sys  该公共的sysfs属性组。
</span><span class='line'>attr_group_gov_pol  各policy使用的属性组，有时候多个policy会使用同一个governor算法。
</span><span class='line'>gdbs_data  通常，当没有设置have_governor_per_policy时，表示所有的policy使用了同一种governor，该字段指向该governor的dbs_data结构。
</span><span class='line'>get_cpu_cdbs  回调函数，公共层用它取得对应cpu的cpu_dbs_common_info结构指针。
</span><span class='line'>get_cpu_dbs_info_s  回调函数，公共层用它取得对应cpu的cpu_dbs_common_info_s的派生结构指针，例如：od_cpu_dbs_info_s，cs_cpu_dbs_info_s。
</span><span class='line'>gov_dbs_timer  前面说过，cpu_dbs_common_info_s结构中有一个工作队列，该回调通常用作工作队列的工作函数。
</span><span class='line'>gov_check_cpu  计算cpu负载的回调函数，通常会直接调用公共层提供的dbs_check_cpu函数完成实际的计算工作。
</span><span class='line'>init   初始化回调，用于完成该governor的一些额外的初始化工作。
</span><span class='line'>exit  回调函数，governor被移除时调用。
</span><span class='line'>gov_ops  各个governor可以用该指针定义各自特有的一些操作接口。</span></code></pre></td></tr></table></div></figure>


<p>dbs_data    该结构体通常由governor的公共层代码在governor的初始化阶段动态创建，该结构的一个最重要的字段就是cdata：一个common_dbs_data结构指针，另外，该结构还包含一些定义governor工作方式的一些调节参数。该结构的详细定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct dbs_data {  
</span><span class='line'>&#9;struct common_dbs_data *cdata;  
</span><span class='line'>&#9;unsigned int min_sampling_rate;  
</span><span class='line'>&#9;int usage_count;  
</span><span class='line'>&#9;void *tuners;  
</span><span class='line'>  
</span><span class='line'>&#9;/* dbs_mutex protects dbs_enable in governor start/stop */  
</span><span class='line'>&#9;struct mutex mutex;  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>几个主要的字段：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cdata  一个common_dbs_data结构指针，通常由具体governor的实现部分定义好，然后作为参数，通过公共层的API：cpufreq_governor_dbs，传递到公共层，cpufreq_governor_dbs函数在创建好dbs_data结构后，把该指针赋值给该字段。
</span><span class='line'>min_sampling_rate  用于记录统计cpu负载的采样周期。
</span><span class='line'>usage_count  当没有设置have_governor_per_policy时，意味着所有的policy采用同一个governor，该字段就是用来统计目前该governor被多少个policy引用。
</span><span class='line'>tuners  指向governor的调节参数结构，不同的governor可以定义自己的tuner结构，公共层代码会在governor的初始化阶段调用common_dbs_data结构的init回调函数，governor的实现可以在init回调中初始化tuners字段。</span></code></pre></td></tr></table></div></figure>


<p>如果设置了have_governor_per_policy，每个policy拥有各自独立的governor，也就是说，拥有独立的dbs_data结构，它会记录在cpufreq_policy结构的governor_data字段中，否则，如果没有设置have_governor_per_policy，多个policy共享一个governor，和同一个dbs_data结构关联，此时，dbs_data被赋值在common_dbs_data结构的gdbs_data字段中。</p>

<p>cpufreq_governor  这个结构在本系列文章的第一篇已经介绍过了，请参看Linux动态频率调节系统CPUFreq之一：概述。几个数据结构的关系如下图所示：</p>

<p><img src="/images/kernel/2015-08-12-4.png" alt="" /></p>

<p>图 1.1  governor的数据结构关系</p>

<p>下面我们以ondemand这个系统已经实现的governor为例，说明一下如何实现一个governor。具体的代码请参看：/drivers/cpufreq/cpufreq_ondemand.c。</p>

<h4>2. 定义一个governor</h4>

<p>要实现一个governor，首先要定义一个cpufreq_governor结构，对于ondeman来说，它的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct cpufreq_governor cpufreq_gov_ondemand = {  
</span><span class='line'>&#9;.name                   = "ondemand",  
</span><span class='line'>&#9;.governor               = od_cpufreq_governor_dbs,  
</span><span class='line'>&#9;.max_transition_latency = TRANSITION_LATENCY_LIMIT,  
</span><span class='line'>&#9;.owner                  = THIS_MODULE,  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>其中，governor是这个结构的核心字段，cpufreq_governor注册后，cpufreq的核心层通过该字段操纵这个governor的行为，包括：初始化、启动、退出等工作。现在，该字段被设置为od_cpufreq_governor_dbs，我们看看它的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int od_cpufreq_governor_dbs(struct cpufreq_policy *policy,  
</span><span class='line'>&#9;&#9;unsigned int event)  
</span><span class='line'>{  
</span><span class='line'>&#9;return cpufreq_governor_dbs(policy, &od_dbs_cdata, event);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>只是简单地调用了governor的公共层提供的API：cpufreq_governor_dbs，关于这个API，我们在后面会逐一进行展开，这里我们注意到参数：&amp;od_dbs_cdata，正是我们前面讨论过得common_dbs_data结构，作为和governor公共层的接口，在这里它的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct common_dbs_data od_dbs_cdata = {  
</span><span class='line'>&#9;.governor = GOV_ONDEMAND,  
</span><span class='line'>&#9;.attr_group_gov_sys = &od_attr_group_gov_sys,  
</span><span class='line'>&#9;.attr_group_gov_pol = &od_attr_group_gov_pol,  
</span><span class='line'>&#9;.get_cpu_cdbs = get_cpu_cdbs,  
</span><span class='line'>&#9;.get_cpu_dbs_info_s = get_cpu_dbs_info_s,  
</span><span class='line'>&#9;.gov_dbs_timer = od_dbs_timer,  
</span><span class='line'>&#9;.gov_check_cpu = od_check_cpu,  
</span><span class='line'>&#9;.gov_ops = &od_ops,  
</span><span class='line'>&#9;.init = od_init,  
</span><span class='line'>&#9;.exit = od_exit,  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>这里先介绍一下get_cpu_cdbs和get_cpu_dbs_info_s这两个回调，前面介绍cpu_dbs_common_info_s结构的时候已经说过，各个governor需要定义一个cpu_dbs_common_info_s结构的派生结构，对于ondemand来说，这个派生结构是：od_cpu_dbs_info_s。两个回调函数分别用来获得基类和派生类这两个结构的指针。我们先看看od_cpu_dbs_info_s是如何定义的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static DEFINE_PER_CPU(struct od_cpu_dbs_info_s, od_cpu_dbs_info);  </span></code></pre></td></tr></table></div></figure>


<p>没错，它被定义为了一个per_cpu变量，也就是说，每个cpu拥有各自独立的od_cpu_dbs_info_s，这很正常，因为每个cpu需要的实时负载是不一样的，需要独立的上下文变量来进行负载的统计。前面也已经列出了od_cpu_dbs_info_s的声明，他的第一个字段cdbs就是一个cpu_dbs_common_info_s结构。内核为我们提供了一个辅助宏来帮助我们定义get_cpu_cdbs和get_cpu_dbs_info_s这两个回调函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define define_get_cpu_dbs_routines(_dbs_info)                          \  
</span><span class='line'>static struct cpu_dbs_common_info *get_cpu_cdbs(int cpu)                \  
</span><span class='line'>{                                                                       \  
</span><span class='line'>&#9;return &per_cpu(_dbs_info, cpu).cdbs;                           \  
</span><span class='line'>}                                                                       \  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;                \  
</span><span class='line'>static void *get_cpu_dbs_info_s(int cpu)                                \  
</span><span class='line'>{                                                                       \  
</span><span class='line'>&#9;return &per_cpu(_dbs_info, cpu);                                \  
</span><span class='line'>}        </span></code></pre></td></tr></table></div></figure>


<p>所以，在cpufreq_ondemand.c中，我们只要简单地使用上述的宏即可定义这两个回调：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>define_get_cpu_dbs_routines(od_cpu_dbs_info);  </span></code></pre></td></tr></table></div></figure>


<p>经过上述这一系列的定义以后，governor的公共层即可通过这两个回调获取各个cpu所对应的cpu_dbs_common_info_s和od_cpu_dbs_info_s的结构指针，用来记录本次统计周期的一些上下文参数（idle时间和运行时间等等）。</p>

<h4>3. 初始化一个governor</h4>

<p>当一个governor被policy选定后，核心层会通过<code>__cpufreq_set_policy</code>函数对该cpu的policy进行设定，参看 Linux动态频率调节系统CPUFreq之二：核心（core）架构与API中的第4节和图4.1。如果policy认为这是一个新的governor（和原来使用的旧的governor不相同），policy会通过<code>__cpufreq_governor</code>函数，并传递CPUFREQ_GOV_POLICY_INIT参数，而<code>__cpufreq_governor</code>函数实际上是调用cpufreq_governor结构中的governor回调函数，在第2节中我们已经知道，这个回调最后会进入governor公共API：cpufreq_governor_dbs，下面是它收到CPUFREQ_GOV_POLICY_INIT参数时，经过简化后的代码片段：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>case CPUFREQ_GOV_POLICY_INIT:  
</span><span class='line'>&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;dbs_data = kzalloc(sizeof(*dbs_data), GFP_KERNEL);  
</span><span class='line'>&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;dbs_data-&gt;cdata = cdata;  
</span><span class='line'>&#9;dbs_data-&gt;usage_count = 1;  
</span><span class='line'>&#9;rc = cdata-&gt;init(dbs_data);  
</span><span class='line'>&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;rc = sysfs_create_group(get_governor_parent_kobj(policy),  
</span><span class='line'>&#9;&#9;&#9;get_sysfs_attr(dbs_data));  
</span><span class='line'>&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;policy-&gt;governor_data = dbs_data;  
</span><span class='line'>  
</span><span class='line'>&#9;......  
</span><span class='line'>&#9;/* Bring kernel and HW constraints together */  
</span><span class='line'>&#9;dbs_data-&gt;min_sampling_rate = max(dbs_data-&gt;min_sampling_rate,  
</span><span class='line'>&#9;&#9;&#9;MIN_LATENCY_MULTIPLIER * latency);  
</span><span class='line'>&#9;set_sampling_rate(dbs_data, max(dbs_data-&gt;min_sampling_rate,  
</span><span class='line'>&#9;&#9;&#9;&#9;latency * LATENCY_MULTIPLIER));  
</span><span class='line'>&#9;if ((cdata-&gt;governor == GOV_CONSERVATIVE) &&  
</span><span class='line'>&#9;&#9;&#9;(!policy-&gt;governor-&gt;initialized)) {  
</span><span class='line'>&#9;&#9;struct cs_ops *cs_ops = dbs_data-&gt;cdata-&gt;gov_ops;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;cpufreq_register_notifier(cs_ops-&gt;notifier_block,  
</span><span class='line'>&#9;&#9;&#9;&#9;CPUFREQ_TRANSITION_NOTIFIER);  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;if (!have_governor_per_policy())  
</span><span class='line'>&#9;&#9;cdata-&gt;gdbs_data = dbs_data;  
</span><span class='line'>  
</span><span class='line'>&#9;return 0;  </span></code></pre></td></tr></table></div></figure>


<p>首先，它会给这个policy分配一个dbs_data实例，然后把通过参数cdata传入的common_dbs_data指针，赋值给它的cdata字段，这样，policy就可以通过该字段获得governor的操作接口（通过cdata的一系列回调函数）。然后，调用cdata的init回调函数，对这个governor做进一步的初始化工作，对于ondemand来说，init回调的实际执行函数是：od_init，主要是完成和governor相关的一些调节参数的初始化，然后把初始化好的od_dbs_tuners结构指针赋值到dbs_data的tuners字段中，它的详细代码这里就不贴出了。接着，通过sysfs_create_group函数，建立该governor在sysfs中的节点，以后我们就可以通过这些节点对该governor的算法逻辑进行微调，ondemand在我的电脑中，建立了以下这些节点（sys/devices/system/cpu/cpufreq/ondemand）：</p>

<p>sampling_rate;
io_is_busy;
up_threshold;
sampling_down_factor;
ignore_nice;
powersave_bias;
sampling_rate_min;</p>

<p>继续，把初始化好的dbs_data结构赋值给policy的governor_data字段，以方便以后的访问。最后是通过set_sampling_rate设置governor的采样周期，如果还有设置have_governor_per_policy，把dbs_data结构指针赋值给cdata结构的gdbs_data字段，至此，governor的初始化工作完成，下面是整个过程的序列图：</p>

<p><img src="/images/kernel/2015-08-12-5.png" alt="" /></p>

<p>图 3.1  governor的初始化</p>

<h4>4. 启动一个governor</h4>

<p>核心层会通过<code>__cpufreq_set_policy</code>函数，通过CPUFREQ_GOV_POLICY_INIT参数，在公共层的API：cpufreq_governor_dbs中，完成了对governor的初始化工作，紧接着，<code>__cpufreq_set_policy</code>会通过CPUFREQ_GOV_START参数，和初始化governor的流程一样，最终会到达cpufreq_governor_dbs函数中，我们看看它是如何启动一个governor的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>case CPUFREQ_GOV_START:  
</span><span class='line'>&#9;if (!policy-&gt;cur)  
</span><span class='line'>&#9;&#9;return -EINVAL;  
</span><span class='line'>  
</span><span class='line'>&#9;mutex_lock(&dbs_data-&gt;mutex);  
</span><span class='line'>  
</span><span class='line'>&#9;for_each_cpu(j, policy-&gt;cpus) {  
</span><span class='line'>&#9;&#9;struct cpu_dbs_common_info *j_cdbs =  
</span><span class='line'>&#9;&#9;&#9;dbs_data-&gt;cdata-&gt;get_cpu_cdbs(j);  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;j_cdbs-&gt;cpu = j;  
</span><span class='line'>&#9;&#9;j_cdbs-&gt;cur_policy = policy;  
</span><span class='line'>&#9;&#9;j_cdbs-&gt;prev_cpu_idle = get_cpu_idle_time(j,  
</span><span class='line'>&#9;&#9;&#9;&#9;       &j_cdbs-&gt;prev_cpu_wall, io_busy);  
</span><span class='line'>&#9;&#9;if (ignore_nice)  
</span><span class='line'>&#9;&#9;&#9;j_cdbs-&gt;prev_cpu_nice =  
</span><span class='line'>&#9;&#9;&#9;&#9;kcpustat_cpu(j).cpustat[CPUTIME_NICE];  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;mutex_init(&j_cdbs-&gt;timer_mutex);  
</span><span class='line'>&#9;&#9;INIT_DEFERRABLE_WORK(&j_cdbs-&gt;work,  
</span><span class='line'>&#9;&#9;&#9;&#9;     dbs_data-&gt;cdata-&gt;gov_dbs_timer);  
</span><span class='line'>&#9;}  </span></code></pre></td></tr></table></div></figure>


<p>首先，遍历使用该policy的所有的处于online状态的cpu，针对每一个cpu，做以下动作：</p>

<p>取出该cpu相关联的cpu_dbs_common_info结构指针，之前已经讨论过，governor定义了一个per_cpu变量来定义各个cpu所对应的cpu_dbs_common_info结构，通过common_dbs_data结构的回调函数可以获取该结构的指针。</p>

<p>初始化cpu_dbs_common_info结构的cpu，cur_policy，prev_cpu_idle，prev_cpu_wall，prev_cpu_nice字段，其中，prev_cpu_idle，prev_cpu_wall这两个字段会被以后的负载计算所使用。</p>

<p>为每个cpu初始化一个工作队列，工作队列的执行函数是common_dbs_data结构中的gov_dbs_timer字段所指向的回调函数，对于ondemand来说，该函数是：od_dbs_timer。这个工作队列会被按照设定好的采样率定期地被唤醒，进行cpu负载的统计工作。</p>

<p>然后，记录目前的时间戳，调度初始化好的工作队列在稍后某个时间点运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Initiate timer time stamp */  
</span><span class='line'> cpu_cdbs-&gt;time_stamp = ktime_get();  
</span><span class='line'>  
</span><span class='line'> gov_queue_work(dbs_data, policy,  
</span><span class='line'>&#9;&#9; delay_for_sampling_rate(sampling_rate), true);  </span></code></pre></td></tr></table></div></figure>


<p>下图表达了启动一个governor的过程：</p>

<p><img src="/images/kernel/2015-08-12-6.png" alt="" /></p>

<p>图 4.1  启动一个governor</p>

<p>工作队列被调度执行后，会在工作队列的执行函数中进行cpu负载的统计工作，这个我们在下一节中讨论。</p>

<h4>5. 系统负载的检测</h4>

<p>上一节我们提到，核心层启动一个governor后，会在每个使用该governor的cpu上建立一个工作队列，工作队列的执行函数是在common_dbs_data中gov_dbs_timer字段所指向的函数，理所当然，该函数由各个governor的具体代码来实现，对于ondemand governor，它的实现函数是od_dbs_timer。governor的公共层代码为我们提供了一个API：dbs_check_cpu，该API用来计算两个统计周期期间某个cpu的负载情况，我们先分析一下dbs_check_cpu：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void dbs_check_cpu(struct dbs_data *dbs_data, int cpu)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct cpu_dbs_common_info *cdbs = dbs_data-&gt;cdata-&gt;get_cpu_cdbs(cpu);  
</span><span class='line'>&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;policy = cdbs-&gt;cur_policy;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Get Absolute Load (in terms of freq for ondemand gov) */  
</span><span class='line'>&#9;for_each_cpu(j, policy-&gt;cpus) {  
</span><span class='line'>&#9;&#9;struct cpu_dbs_common_info *j_cdbs;  
</span><span class='line'>&#9;&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;j_cdbs = dbs_data-&gt;cdata-&gt;get_cpu_cdbs(j);  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;......  
</span><span class='line'>&#9;&#9;cur_idle_time = get_cpu_idle_time(j, &cur_wall_time, io_busy);  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;wall_time = (unsigned int)  
</span><span class='line'>&#9;&#9;&#9;(cur_wall_time - j_cdbs-&gt;prev_cpu_wall);  
</span><span class='line'>&#9;&#9;j_cdbs-&gt;prev_cpu_wall = cur_wall_time;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;idle_time = (unsigned int)  
</span><span class='line'>&#9;&#9;&#9;(cur_idle_time - j_cdbs-&gt;prev_cpu_idle);  
</span><span class='line'>&#9;&#9;j_cdbs-&gt;prev_cpu_idle = cur_idle_time;  
</span><span class='line'>&#9;&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;load = 100 * (wall_time - idle_time) / wall_time;  
</span><span class='line'>&#9;&#9;......  
</span><span class='line'>&#9;&#9;load *= cur_freq；    /* 实际的代码不是这样，为了简化讨论，精简为实际的计算逻辑*/  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;if (load &gt; max_load)  
</span><span class='line'>&#9;&#9;&#9;max_load = load;  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;dbs_data-&gt;cdata-&gt;gov_check_cpu(cpu, max_load);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>由代码可以看出，遍历该policy下每个online的cpu，取出该cpu对应的cpu_dbs_common_info结构，该结构中的prev_cpu_idle和prev_cpu_wall保存有上一次采样周期时记录的idle时间和运行时间，负载的计算其实很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>idle_time = 本次idle时间 - 上次idle时间；
</span><span class='line'>wall_time = 本次总运行时间 - 上次总运行时间；
</span><span class='line'>负载load = 100 * （wall_time - idle_time）/ wall_time；
</span><span class='line'>把所有cpu中，负载最大值记入max_load中，作为选择频率的依据；</span></code></pre></td></tr></table></div></figure>


<p>计算出最大负载max_load后，调用具体governor实现的gov_check_cpu回调函数，对于ondemand来说，该回调函数是：od_check_cpu，我们跟进去看看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void od_check_cpu(int cpu, unsigned int load_freq)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct od_cpu_dbs_info_s *dbs_info = &per_cpu(od_cpu_dbs_info, cpu);  
</span><span class='line'>&#9;struct cpufreq_policy *policy = dbs_info-&gt;cdbs.cur_policy;  
</span><span class='line'>&#9;struct dbs_data *dbs_data = policy-&gt;governor_data;  
</span><span class='line'>&#9;struct od_dbs_tuners *od_tuners = dbs_data-&gt;tuners;  
</span><span class='line'>  
</span><span class='line'>&#9;dbs_info-&gt;freq_lo = 0;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Check for frequency increase */  
</span><span class='line'>&#9;if (load_freq &gt; od_tuners-&gt;up_threshold * policy-&gt;cur) {  
</span><span class='line'>&#9;&#9;/* If switching to max speed, apply sampling_down_factor */  
</span><span class='line'>&#9;&#9;if (policy-&gt;cur &lt; policy-&gt;max)  
</span><span class='line'>&#9;&#9;&#9;dbs_info-&gt;rate_mult =  
</span><span class='line'>&#9;&#9;&#9;&#9;od_tuners-&gt;sampling_down_factor;  
</span><span class='line'>&#9;&#9;dbs_freq_increase(policy, policy-&gt;max);  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>&#9;}  </span></code></pre></td></tr></table></div></figure>


<p>当负载比预设的阀值高时（od_tuners->up_threshold，默认值是95%），立刻选择该policy最大的工作频率作为接下来的工作频率。如果负载没有达到预设的阀值，但是当前频率已经是最低频率了，则什么都不做，直接返回：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (policy-&gt;cur == policy-&gt;min)  
</span><span class='line'>&#9;return;  </span></code></pre></td></tr></table></div></figure>


<p>运行到这里，cpu的频率可能已经在上面的过程中被设置为最大频率，实际上我们可能并不需要这么高的频率，所以接着判断，当负载低于另一个预设值时，这时需要计算一个合适于该负载的新频率：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (load_freq &lt; od_tuners-&gt;adj_up_threshold  
</span><span class='line'>&#9;&#9;* policy-&gt;cur) {  
</span><span class='line'>&#9;unsigned int freq_next;  
</span><span class='line'>&#9;freq_next = load_freq / od_tuners-&gt;adj_up_threshold;  
</span><span class='line'>  
</span><span class='line'>&#9;/* No longer fully busy, reset rate_mult */  
</span><span class='line'>&#9;dbs_info-&gt;rate_mult = 1;  
</span><span class='line'>  
</span><span class='line'>&#9;if (freq_next &lt; policy-&gt;min)  
</span><span class='line'>&#9;&#9;freq_next = policy-&gt;min;  
</span><span class='line'>  
</span><span class='line'>&#9;if (!od_tuners-&gt;powersave_bias) {  
</span><span class='line'>&#9;&#9;__cpufreq_driver_target(policy, freq_next,  
</span><span class='line'>&#9;&#9;&#9;&#9;CPUFREQ_RELATION_L);  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;freq_next = od_ops.powersave_bias_target(policy, freq_next,  
</span><span class='line'>&#9;&#9;&#9;&#9;CPUFREQ_RELATION_L);  
</span><span class='line'>&#9;__cpufreq_driver_target(policy, freq_next, CPUFREQ_RELATION_L);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>对于ondemand来说，因为传入的负载是乘上了当前频率后的归一化值，所以计算新频率时，直接用load_freq除以想要的负载即可。本来计算出来的频率直接通过<code>__cpufreq_driver_target</code>函数，交给cpufreq_driver调节频率即可，但是这里的处理考虑了powersave_bias的设置情况，当设置了powersave_bias时，表明我们为了进一步节省电力，我们希望在计算出来的新频率的基础上，再乘以一个powersave_bias设定的百分比，作为真正的运行频率，powersave_bias的值从0-1000，每一步代表0.1%。实际的情况比想象中稍微复杂一点，考虑到乘以一个powersave_bias后的新频率可能不在cpu所支持的频率表中，ondemand算法会在频率表中查找，分别找出最接近新频率的一个区间，由高低两个频率组成，低的频率记入od_cpu_dbs_info_s结构的freq_lo字段中，高的频率通过od_ops.powersave_bias_target回调返回。同时，od_ops.powersave_bias_target回调函数还计算出高低两个频率应该运行的时间，分别记入od_cpu_dbs_info_s结构的freq_hi_jiffies和freq_low_jiffies字段中。原则是，通过两个不同频率的运行时间的组合，使得综合结果接近我们想要的目标频率。详细的计算逻辑请参考函数：generic_powersave_bias_target。
讨论完上面两个函数，让我们回到本节的开头，负载的计算工作是在一个工作队列中发起的，前面说过，ondemand对应的工作队列的工作函数是od_dbs_timer，我们看看他的实现代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void od_dbs_timer(struct work_struct *work)  
</span><span class='line'>{  
</span><span class='line'>&#9;......  
</span><span class='line'>  
</span><span class='line'>&#9;/* Common NORMAL_SAMPLE setup */  
</span><span class='line'>&#9;core_dbs_info-&gt;sample_type = OD_NORMAL_SAMPLE;  
</span><span class='line'>&#9;if (sample_type == OD_SUB_SAMPLE) {  
</span><span class='line'>&#9;&#9;delay = core_dbs_info-&gt;freq_lo_jiffies;  
</span><span class='line'>&#9;&#9;__cpufreq_driver_target(core_dbs_info-&gt;cdbs.cur_policy,  
</span><span class='line'>&#9;&#9;&#9;&#9;core_dbs_info-&gt;freq_lo, CPUFREQ_RELATION_H);  
</span><span class='line'>&#9;} else {  
</span><span class='line'>&#9;&#9;dbs_check_cpu(dbs_data, cpu);  
</span><span class='line'>&#9;&#9;if (core_dbs_info-&gt;freq_lo) {  
</span><span class='line'>&#9;&#9;&#9;/* Setup timer for SUB_SAMPLE */  
</span><span class='line'>&#9;&#9;&#9;core_dbs_info-&gt;sample_type = OD_SUB_SAMPLE;  
</span><span class='line'>&#9;&#9;&#9;delay = core_dbs_info-&gt;freq_hi_jiffies;  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>max_delay:  
</span><span class='line'>&#9;if (!delay)  
</span><span class='line'>&#9;&#9;delay = delay_for_sampling_rate(od_tuners-&gt;sampling_rate  
</span><span class='line'>&#9;&#9;&#9;&#9;* core_dbs_info-&gt;rate_mult);  
</span><span class='line'>  
</span><span class='line'>&#9;gov_queue_work(dbs_data, dbs_info-&gt;cdbs.cur_policy, delay, modify_all);  
</span><span class='line'>&#9;mutex_unlock(&core_dbs_info-&gt;cdbs.timer_mutex);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>如果sample_type是OD_SUB_SAMPLE时，表明上一次采样时，需要用高低两个频率来模拟实际的目标频率中的第二步：需要运行freq_lo，并且持续时间为freq_lo_jiffies。否则，调用公共层计算负载的API：dbs_check_cpu，开始一次新的采样，当powersave_bias没有设置时，该函数返回前，所需要的新的目标频率会被设置，考虑到powersave_bias的设置情况，判断一下如果freq_lo被设置，说明需要用高低两个频率来模拟实际的目标频率，高频率已经在dbs_check_cpu返回前被设置（实际的设置工作是在od_check_cpu中），所以把sample_type设置为OD_SUB_SAMPLE，以便下一次运行工作函数进行采样时可以设置低频率运行。最后，调度工作队列在下一个采样时刻再次运行，这样，cpu的工作频率实现了在每个采样周期，根据实际的负载情况，动态地设定合适的工作频率进行运行，既满足了性能的需求，也降低了系统的功耗，达到了cpufreq系统的最终目的，整个流程可以参考下图：</p>

<p><img src="/images/kernel/2015-08-12-7.png" alt="" /></p>

<p>图 5.1  负载计算和频率选择</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/10/kernel-net-skb-probe/">监控skb释放</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-10T15:53:00+08:00'><span class='date'>2015-08-10</span> <span class='time'>15:53:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>skb_probe.c</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;linux/kernel.h&gt;
</span><span class='line'>#include &lt;linux/module.h&gt;
</span><span class='line'>#include &lt;linux/kprobes.h&gt;
</span><span class='line'>
</span><span class='line'>#include &lt;linux/net.h&gt;
</span><span class='line'>#include &lt;linux/socket.h&gt;
</span><span class='line'>#include &lt;linux/sockios.h&gt;
</span><span class='line'>#include &lt;linux/in.h&gt;
</span><span class='line'>#include &lt;linux/inet.h&gt;
</span><span class='line'>#include &lt;linux/inetdevice.h&gt;
</span><span class='line'>#include &lt;linux/netdevice.h&gt;
</span><span class='line'>#include &lt;linux/etherdevice.h&gt;
</span><span class='line'>
</span><span class='line'>#include &lt;net/snmp.h&gt;
</span><span class='line'>#include &lt;net/ip.h&gt;
</span><span class='line'>#include &lt;net/protocol.h&gt;
</span><span class='line'>#include &lt;net/route.h&gt;
</span><span class='line'>#include &lt;linux/skbuff.h&gt;
</span><span class='line'>#include &lt;net/sock.h&gt;
</span><span class='line'>#include &lt;net/arp.h&gt;
</span><span class='line'>#include &lt;net/icmp.h&gt;
</span><span class='line'>#include &lt;net/raw.h&gt;
</span><span class='line'>#include &lt;net/checksum.h&gt;
</span><span class='line'>#include &lt;linux/netfilter_ipv4.h&gt;
</span><span class='line'>#include &lt;net/xfrm.h&gt;
</span><span class='line'>#include &lt;linux/mroute.h&gt;
</span><span class='line'>#include &lt;linux/netlink.h&gt;
</span><span class='line'>
</span><span class='line'>int count = 0;
</span><span class='line'>
</span><span class='line'>struct ctl_table_header *ctl_header = NULL;
</span><span class='line'>static struct ctl_table debug_table[] = { 
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;.procname       = "pr_count",
</span><span class='line'>&#9;&#9;.data           = &count,
</span><span class='line'>&#9;&#9;.maxlen         = sizeof(count),
</span><span class='line'>&#9;&#9;.mode           = 0644,
</span><span class='line'>&#9;&#9;.proc_handler   = &proc_dointvec, },
</span><span class='line'>&#9;{ },
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static struct ctl_table ipv4_dir_table[] = {
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;.procname    = "ipv4",
</span><span class='line'>&#9;&#9;.mode        = 0555,
</span><span class='line'>&#9;&#9;.child       = debug_table, },
</span><span class='line'>&#9;{ },
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static ctl_table net_dir_table[] = {
</span><span class='line'>&#9;{ 
</span><span class='line'>&#9;&#9;.procname    = "net",
</span><span class='line'>&#9;&#9;.mode        = 0555,
</span><span class='line'>&#9;&#9;.child        = ipv4_dir_table, },
</span><span class='line'>&#9;{ },
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>int dump_stack_skb(void)
</span><span class='line'>{
</span><span class='line'>&#9;if (count &gt; 0) {
</span><span class='line'>&#9;&#9;dump_stack();
</span><span class='line'>&#9;&#9;count--;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/*
</span><span class='line'>// ip_rcv call skb_orphan, skb_orphan will reset skb-&gt;destructor
</span><span class='line'>int j_ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
</span><span class='line'>{
</span><span class='line'>&#9;skb-&gt;destructor = (void*)dump_stack_skb;
</span><span class='line'>&#9;jprobe_return();
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static struct jprobe jp_ip_rcv = {
</span><span class='line'>&#9;.entry = j_ip_rcv,
</span><span class='line'>&#9;.kp = {
</span><span class='line'>&#9;&#9;.symbol_name  = "ip_rcv",
</span><span class='line'>&#9;}
</span><span class='line'>};
</span><span class='line'>*/
</span><span class='line'>
</span><span class='line'>int j_ip_rcv_finish(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;skb-&gt;destructor = (void*)dump_stack_skb;
</span><span class='line'>&#9;jprobe_return();
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static struct jprobe jp_ip_rcv_finish = {
</span><span class='line'>&#9;.entry = j_ip_rcv_finish,
</span><span class='line'>&#9;.kp = {
</span><span class='line'>&#9;&#9;.symbol_name  = "ip_rcv_finish",
</span><span class='line'>&#9;}
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>static int __init kprobe_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;int ret;
</span><span class='line'>&#9;ctl_header = register_sysctl_table(net_dir_table);
</span><span class='line'>&#9;if(!ctl_header){
</span><span class='line'>&#9;&#9;printk(KERN_ERR"SYNPROXY: sp_sysctl_init() calls failed.");
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>//    ret = register_jprobe(&jp_ip_rcv);
</span><span class='line'>&#9;ret = register_jprobe(&jp_ip_rcv_finish);
</span><span class='line'>&#9;if (ret &lt; 0) {
</span><span class='line'>&#9;&#9;unregister_sysctl_table(ctl_header);
</span><span class='line'>&#9;&#9;printk(KERN_INFO "register_jprobe failed, returned %d\n", ret);
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>//    printk(KERN_INFO "Planted jprobe at %p, handler addr %p\n", jp_ip_rcv.kp.addr, jp_ip_rcv.entry);
</span><span class='line'>&#9;printk(KERN_INFO "Planted jprobe at %p, handler addr %p\n", jp_ip_rcv_finish.kp.addr, jp_ip_rcv_finish.entry);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static void __exit kprobe_exit(void)
</span><span class='line'>{
</span><span class='line'>&#9;if (ctl_header)
</span><span class='line'>&#9;&#9;unregister_sysctl_table(ctl_header);
</span><span class='line'>
</span><span class='line'>//    unregister_jprobe(&jp_ip_rcv);
</span><span class='line'>//    printk(KERN_INFO "kprobe at %p unregistered\n", jp_ip_rcv.kp.addr);
</span><span class='line'>&#9;unregister_jprobe(&jp_ip_rcv_finish);
</span><span class='line'>&#9;printk(KERN_INFO "kprobe at %p unregistered\n", jp_ip_rcv_finish.kp.addr);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>module_init(kprobe_init)
</span><span class='line'>module_exit(kprobe_exit)
</span><span class='line'>MODULE_LICENSE("GPL");</span></code></pre></td></tr></table></div></figure>


<h4>Makefile</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>obj-m := skb_probe.o
</span><span class='line'>
</span><span class='line'>KDIR:=/lib/modules/`uname -r`/build
</span><span class='line'>PWD=$(shell pwd)
</span><span class='line'>
</span><span class='line'>KBUILD_FLAGS += -w
</span><span class='line'>
</span><span class='line'>all:
</span><span class='line'>&#9;make -C $(KDIR) M=$(PWD) modules
</span><span class='line'>clean:
</span><span class='line'>&#9;make -C $(KDIR) M=$(PWD) clean</span></code></pre></td></tr></table></div></figure>


<h4>运行</h4>

<p>打印10次释放</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo 10 &gt; /proc/sys/net/ipv4/pr_count</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/10/arm-gcc-warning/">error, forbidden warning</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-10T14:18:00+08:00'><span class='date'>2015-08-10</span> <span class='time'>14:18:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>编译时出现类似的情况：把Warning当做Error，当没有加-Werror选项</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  CC [M]  /home/kk/udp_probe/udp_probe.o
</span><span class='line'>/home/kk/udp_probe/udp_probe.c: In function 'kp_init':
</span><span class='line'>/home/kk/udp_probe/udp_probe.c:36:18: warning: assignment makes pointer from integer without a cast [enabled by default]
</span><span class='line'>error, forbidden warning: udp_probe.c:36
</span><span class='line'>make[2]: *** [/home/kk/udp_probe/udp_probe.o] 错误 1
</span><span class='line'>make[1]: *** [_module_/home/kk/udp_probe] 错误 2
</span><span class='line'>make[1]:正在离开目录 `/media/000617990000DB90/403a/source/kernel'
</span><span class='line'>make: *** [all] 错误 2</span></code></pre></td></tr></table></div></figure>


<p>修改 scripts/gcc-wrapper.py 去掉 interpret_warning 函数中的如下部分</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;# If there is a warning, remove any object if it exists.
</span><span class='line'>&#9;if ofile:
</span><span class='line'>&#9;&#9;try:
</span><span class='line'>&#9;&#9;&#9;os.remove(ofile)
</span><span class='line'>&#9;&#9;except OSError:
</span><span class='line'>&#9;&#9;&#9;pass
</span><span class='line'>&#9;sys.exit(1)</span></code></pre></td></tr></table></div></figure>


<hr />

<p>若直接加 -w gcc选项，则会直接不显示Warning</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/07/cgroup-9/">cpuset子系统</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-07T17:26:00+08:00'><span class='date'>2015-08-07</span> <span class='time'>17:26:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.cnblogs.com/lisperl/archive/2012/05/02/2478817.html">http://www.cnblogs.com/lisperl/archive/2012/05/02/2478817.html</a></p>

<p>cpuset子系统为cgroup 中的任务分配独立 CPU（在多核系统）和内存节点。Cpuset子系统为定义了一个叫cpuset的数据结构来管理cgroup中的任务能够使用的cpu和内存节点。Cpuset定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct cpuset {
</span><span class='line'>&#9;struct cgroup_subsys_state css;
</span><span class='line'> 
</span><span class='line'>&#9;unsigned long flags; /* "unsigned long" so bitops work */
</span><span class='line'>&#9;cpumask_var_t cpus_allowed; /* CPUs allowed to tasks in cpuset */
</span><span class='line'>&#9;nodemask_t mems_allowed; /* Memory Nodes allowed to tasks */
</span><span class='line'> 
</span><span class='line'>&#9;struct cpuset *parent; /* my parent */
</span><span class='line'> 
</span><span class='line'>&#9;struct fmeter fmeter; /* memory_pressure filter */
</span><span class='line'> 
</span><span class='line'>&#9;/* partition number for rebuild_sched_domains() */
</span><span class='line'>&#9;int pn;
</span><span class='line'> 
</span><span class='line'>&#9;/* for custom sched domain */
</span><span class='line'>&#9;int relax_domain_level;
</span><span class='line'> 
</span><span class='line'>&#9;/* used for walking a cpuset heirarchy */
</span><span class='line'>&#9;struct list_head stack_list;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>其中css字段用于task或cgroup获取cpuset结构。</p>

<p>cpus_allowed和mems_allowed定义了该cpuset包含的cpu和内存节点。</p>

<p>Parent字段用于维持cpuset的树状结构，stack_list则用于遍历cpuset的层次结构。</p>

<p>Pn和relax_domain_level是跟Linux 调度域相关的字段，pn指定了cpuset的调度域的分区号，而relax_domain_level表示进行cpu负载均衡寻找空闲cpu的策略。</p>

<p>除此之外，进程的task_struct结构体里面还有一个cpumask_t cpus_allowed成员，用以存储进程的cpus_allowed信息;一个nodemask_t mems_allowed成员，用于存储进程的mems_allowed信息。</p>

<p>Cpuset子系统的实现是通过在内核代码加入一些hook代码。由于代码比较散，我们逐条分析。</p>

<p>在内核初始化代码（即start_kernel函数）中插入了对cpuset_init调用的代码，这个函数用于cpuset的初始化。</p>

<p>下面我们来看这个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int __init cpuset_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;int err = 0;
</span><span class='line'> 
</span><span class='line'>&#9;if (!alloc_cpumask_var(&top_cpuset.cpus_allowed, GFP_KERNEL))
</span><span class='line'>&#9;&#9;BUG();
</span><span class='line'> 
</span><span class='line'>&#9;cpumask_setall(top_cpuset.cpus_allowed);
</span><span class='line'>&#9;nodes_setall(top_cpuset.mems_allowed);
</span><span class='line'> 
</span><span class='line'>&#9;fmeter_init(&top_cpuset.fmeter);
</span><span class='line'>&#9;set_bit(CS_SCHED_LOAD_BALANCE, &top_cpuset.flags);
</span><span class='line'>&#9;top_cpuset.relax_domain_level = -1;
</span><span class='line'> 
</span><span class='line'>&#9;err = register_filesystem(&cpuset_fs_type);
</span><span class='line'>&#9;if (err &lt; 0)
</span><span class='line'>&#9;&#9;return err;
</span><span class='line'> 
</span><span class='line'>&#9;if (!alloc_cpumask_var(&cpus_attach, GFP_KERNEL))
</span><span class='line'>&#9;&#9;BUG();
</span><span class='line'> 
</span><span class='line'>&#9;number_of_cpusets = 1;
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>cpumask_setall和nodes_setall将top_cpuset能使用的cpu和内存节点设置成所有节点。紧接着，初始化fmeter，设置top_cpuset的load balance标志。最后注册cpuset文件系统，这个是为了兼容性，因为在cgroups之前就有cpuset了，不过在具体实现时，对cpuset文件系统的操作都被重定向了cgroup文件系统。</p>

<p>除了这些初始化工作，cpuset子系统还在do_basic_setup函数（此函数在kernel_init中被调用）中插入了对cpuset_init_smp的调用代码，用于smp相关的初始化工作。</p>

<p>下面我们看这个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __init cpuset_init_smp(void)
</span><span class='line'>{
</span><span class='line'>&#9;cpumask_copy(top_cpuset.cpus_allowed, cpu_active_mask);
</span><span class='line'>&#9;top_cpuset.mems_allowed = node_states[N_HIGH_MEMORY];
</span><span class='line'> 
</span><span class='line'>&#9;hotcpu_notifier(cpuset_track_online_cpus, 0);
</span><span class='line'>&#9;hotplug_memory_notifier(cpuset_track_online_nodes, 10);
</span><span class='line'> 
</span><span class='line'>&#9;cpuset_wq = create_singlethread_workqueue("cpuset");
</span><span class='line'>&#9;BUG_ON(!cpuset_wq);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>首先，将top_cpuset的cpu和memory节点设置成所有online的节点，之前初始化时还不知道有哪些online节点所以只是简单设成所有，在smp初始化后就可以将其设成所有online节点了。然后加入了两个hook函数，cpuset_track_online_cpus和cpuset_track_online_nodes，这个两个函数将在cpu和memory热插拔时被调用。</p>

<p>cpuset_track_online_cpus函数中调用scan_for_empty_cpusets函数扫描空的cpuset，并将其下的进程移到其非空的parent下，同时更新cpuset的cpus_allowed信息。cpuset_track_online_nodes的处理类似。</p>

<p>那cpuset又是怎么对进程的调度起作用的呢？</p>

<p>这个就跟task_struct中cpu_allowed字段有关了。首先，这个cpu_allowed和进程所属的cpuset的cpus_allowed保持一致；其次，在进程被fork出来的时候，进程继承了父进程的cpuset和cpus_allowed字段；最后，进程被fork出来后，除非指定CLONE_STOPPED标记，都会被调用wake_up_new_task唤醒，在wake_up_new_task中有：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cpu = select_task_rq(rq, p, SD_BALANCE_FORK, 0);
</span><span class='line'>set_task_cpu(p, cpu);</span></code></pre></td></tr></table></div></figure>


<p>即为新fork出来的进程选择运行的cpu，而select_task_rq会调用进程所属的调度器的函数，对于普通进程，其调度器是CFS，CFS对应的函数是select_task_rq_fair。在select_task_rq_fair返回选到的cpu后，select_task_rq会对结果和cpu_allowed比较：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (unlikely(!cpumask_test_cpu(cpu, &p-&gt;cpus_allowed) ||
</span><span class='line'>     !cpu_online(cpu)))
</span><span class='line'>cpu = select_fallback_rq(task_cpu(p), p);</span></code></pre></td></tr></table></div></figure>


<p>这就保证了新fork出来的进程只能在cpu_allowed中的cpu上运行。</p>

<p>对于被wake up的进程来说，在被调度之前，也会调用select_task_rq选择可运行的cpu。</p>

<p>这就保证了进程任何时候都只会在cpu_allowed中的cpu上运行。</p>

<p>最后说一下，如何保证task_struct中的cpus_allowd和进程所属的cpuset中的cpus_allowed一致。首先，在cpu热插拔时，scan_for_empty_cpusets会更新task_struct中的cpus_allowed信息，其次对cpuset下的控制文件写入操作时也会更新task_struct中的cpus_allowed信息,最后当一个进程被attach到其他cpuset时，同样会更新task_struct中的cpus_allowed信息。</p>

<p>在cpuset之前，Linux内核就提供了指定进程可以运行的cpu的方法。通过调用sched_setaffinity可以指定进程可以运行的cpu。Cpuset对其进行了扩展，保证此调用设定的cpu仍然在cpu_allowed的范围内。在sched_setaffinity中，插入了这样两行代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cpuset_cpus_allowed(p, cpus_allowed);
</span><span class='line'>cpumask_and(new_mask, in_mask, cpus_allowed);</span></code></pre></td></tr></table></div></figure>


<p>其中cpuset_cpus_allowed返回进程对应的cpuset中的cpus_allowed，cpumask_and则将cpus_allowed和调用sched_setaffinity时的参数in_mask相与得出进程新的cpus_allowed。</p>

<p>通过以上代码的嵌入，Linux内核实现了对进程可调度的cpu的控制。下面我们来分析一下cpuset对memory节点的控制。</p>

<p>Linux中内核分配物理页框的函数有6个:alloc_pages,alloc_page,<strong>get_free_pages,</strong>get_free_page,get_zeroed_page,<strong>get_dma_pages,这些函数最终都通过alloc_pages实现，而alloc_pages又通过</strong>alloc_pages_nodemask实现，在__alloc_pages_nodemask中，调用get_page_from_freelist从zone list中分配一个page，在get_page_from_freelist中调用cpuset_zone_allowed_softwall判断当前节点是否属于mems_allowed。通过附加这样一个判断，保证进程从mems_allowed中的节点分配内存。</p>

<p>Linux在cpuset出现之前，也提供了mbind, set_mempolicy来限定进程可用的内存节点。Cpuset子系统对其做了扩展，扩展的方法跟扩展sched_setaffinity类似，通过导出cpuset_mems_allowed，返回进程所属的cupset允许的内存节点，对mbind，set_mempolicy的参数进行过滤。</p>

<p>最后让我们来看一下，cpuset子系统最重要的两个控制文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>&#9;.name = "cpus",
</span><span class='line'>&#9;.read = cpuset_common_file_read,
</span><span class='line'>&#9;.write_string = cpuset_write_resmask,
</span><span class='line'>&#9;.max_write_len = (100U + 6 * NR_CPUS),
</span><span class='line'>&#9;.private = FILE_CPULIST,
</span><span class='line'>},
</span><span class='line'> 
</span><span class='line'>{
</span><span class='line'>&#9;.name = "mems",
</span><span class='line'>&#9;.read = cpuset_common_file_read,
</span><span class='line'>&#9;.write_string = cpuset_write_resmask,
</span><span class='line'>&#9;.max_write_len = (100U + 6 * MAX_NUMNODES),
</span><span class='line'>&#9;.private = FILE_MEMLIST,
</span><span class='line'>},</span></code></pre></td></tr></table></div></figure>


<p>通过cpus文件，我们可以指定进程可以使用的cpu节点，通过mems文件，我们可以指定进程可以使用的memory节点。</p>

<p>这两个文件的读写都是通过cpuset_common_file_read和cpuset_write_resmask实现的，通过private属性区分。</p>

<p>在cpuset_common_file_read中读出可用的cpu或memory节点；在cpuset_write_resmask中则根据文件类型分别调用update_cpumask和update_nodemask更新cpu或memory节点信息。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/07/cgroup-8/">memory子系统</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-07T17:22:00+08:00'><span class='date'>2015-08-07</span> <span class='time'>17:22:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.cnblogs.com/lisperl/archive/2012/04/28/2474872.html">http://www.cnblogs.com/lisperl/archive/2012/04/28/2474872.html</a></p>

<p>memory 子系统可以设定 cgroup 中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告。memory子系统是通过linux的resource counter机制实现的。下面我们就先来看一下resource counter机制。</p>

<p>resource counter是内核为子系统提供的一种资源管理机制。这个机制的实现包括了用于记录资源的数据结构和相关函数。Resource counter定义了一个res_counter的结构体来管理特定资源，定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct res_counter {
</span><span class='line'>&#9;unsigned long long usage;
</span><span class='line'>&#9;unsigned long long max_usage;
</span><span class='line'>&#9;unsigned long long limit;
</span><span class='line'>&#9;unsigned long long soft_limit;
</span><span class='line'>&#9;unsigned long long failcnt; /*
</span><span class='line'>&#9;spinlock_t lock;
</span><span class='line'>&#9;struct res_counter *parent;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>Usage用于记录当前已使用的资源，max_usage用于记录使用过的最大资源量，limit用于设置资源的使用上限，进程组不能使用超过这个限制的资源，soft_limit用于设定一个软上限，进程组使用的资源可以超过这个限制，failcnt用于记录资源分配失败的次数，管理可以根据这个记录，调整上限值。Parent指向父节点，这个变量用于处理层次性的资源管理。</p>

<p>除了这个关键的数据结构，resource counter还定义了一系列相关的函数。下面我们来看几个关键的函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void res_counter_init(struct res_counter *counter, struct res_counter *parent)
</span><span class='line'>{
</span><span class='line'>&#9;spin_lock_init(&counter-&gt;lock);
</span><span class='line'>&#9;counter-&gt;limit = RESOURCE_MAX;
</span><span class='line'>&#9;counter-&gt;soft_limit = RESOURCE_MAX;
</span><span class='line'>&#9;counter-&gt;parent = parent;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个函数用于初始化一个res_counter。</p>

<p>第二个关键的函数是int res_counter_charge(struct res_counter *counter, unsigned long val, struct res_counter **limit_fail_at)。当资源将要被分配的时候，资源就要被记录到相应的res_counter里。这个函数作用就是记录进程组使用的资源。在这个函数中有：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (c = counter; c != NULL; c = c-&gt;parent) {
</span><span class='line'>&#9;spin_lock(&c-&gt;lock);
</span><span class='line'>&#9;ret = res_counter_charge_locked(c, val);
</span><span class='line'>&#9;spin_unlock(&c-&gt;lock);
</span><span class='line'>&#9;if (ret &lt; 0) {
</span><span class='line'>&#9;&#9;*limit_fail_at = c;
</span><span class='line'>&#9;&#9;goto undo;
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在这个循环里，从当前res_counter开始，从下往上逐层增加资源的使用量。我们来看一下res_counter_charge_locked这个函数，这个函数顾名思义就是在加锁的情况下增加使用量。实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>&#9;if (counter-&gt;usage + val &gt; counter-&gt;limit) {
</span><span class='line'>&#9;&#9;counter-&gt;failcnt++;
</span><span class='line'>&#9;&#9;return -ENOMEM;
</span><span class='line'>&#9;}
</span><span class='line'> 
</span><span class='line'>&#9;counter-&gt;usage += val;
</span><span class='line'>&#9;if (counter-&gt;usage &gt; counter-&gt;max_usage)
</span><span class='line'>&#9;&#9;counter-&gt;max_usage = counter-&gt;usage;
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>首先判断是否已经超过使用上限，如果是的话就增加失败次数，返回相关代码；否则就增加使用量的值，如果这个值已经超过历史最大值，则更新最大值。</p>

<p>第三个关键的函数是void res_counter_uncharge(struct res_counter *counter, unsigned long val)。当资源被归还到系统的时候，要在相应的res_counter减轻相应的使用量。这个函数作用就在于在于此。实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (c = counter; c != NULL; c = c-&gt;parent) {
</span><span class='line'>&#9;spin_lock(&c-&gt;lock);
</span><span class='line'>&#9;res_counter_uncharge_locked(c, val);
</span><span class='line'>&#9;spin_unlock(&c-&gt;lock);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从当前counter开始，从下往上逐层减少使用量，其中调用了res_counter_uncharge_locked，这个函数的作用就是在加锁的情况下减少相应的counter的使用量。</p>

<p>有这些数据结构和函数，只需要在内核分配资源的时候，植入相应的charge函数，释放资源时，植入相应的uncharge函数，就能实现对资源的控制了。</p>

<p>介绍完resource counter，我们再来看memory子系统是利用resource counter实现对内存资源的管理的。</p>

<p>memory子系统定义了一个叫mem_cgroup的结构体来管理cgroup相关的内存使用信息，定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct mem_cgroup {
</span><span class='line'>&#9;struct cgroup_subsys_state css;
</span><span class='line'>&#9;struct res_counter res;
</span><span class='line'>&#9;struct res_counter memsw;
</span><span class='line'>&#9;struct mem_cgroup_lru_info info;
</span><span class='line'>&#9;spinlock_t reclaim_param_lock;
</span><span class='line'>&#9;int prev_priority;
</span><span class='line'>&#9;int last_scanned_child;
</span><span class='line'>&#9;bool use_hierarchy;
</span><span class='line'>&#9;atomic_t oom_lock;
</span><span class='line'>&#9;atomic_t refcnt;
</span><span class='line'>&#9;unsigned int swappiness;
</span><span class='line'>&#9;int oom_kill_disable;
</span><span class='line'>&#9;bool memsw_is_minimum;
</span><span class='line'>&#9;struct mutex thresholds_lock;
</span><span class='line'>&#9;struct mem_cgroup_thresholds thresholds;
</span><span class='line'>&#9;struct mem_cgroup_thresholds memsw_thresholds;
</span><span class='line'>&#9;struct list_head oom_notify;
</span><span class='line'>&#9;unsigned long  move_charge_at_immigrate;
</span><span class='line'>&#9;struct mem_cgroup_stat_cpu *stat;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>跟其他子系统一样，mem_cgroup也包含了一个cgroup_subsys_state成员，便于task或cgroup获取mem_cgroup。</p>

<p>mem_cgroup中包含了两个res_counter成员，分别用于管理memory资源和memory+swap资源，如果memsw_is_minimum为true，则res.limit=memsw.limit，即当进程组使用的内存超过memory的限制时，不能通过swap来缓解。</p>

<p>use_hierarchy则用来标记资源控制和记录时是否是层次性的。</p>

<p>oom_kill_disable则表示是否使用oom-killer。</p>

<p>oom_notify指向一个oom notifier event fd链表。</p>

<p>另外memory子系统还定义了一个叫page_cgroup的结构体：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct page_cgroup {
</span><span class='line'>&#9;unsigned long flags;
</span><span class='line'>&#9;struct mem_cgroup *mem_cgroup;
</span><span class='line'>&#9;struct page *page;
</span><span class='line'>&#9;struct list_head lru; /* per cgroup LRU list */
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>此结构体可以看作是mem_map的一个扩展，每个page_cgroup都和所有的page关联，而其中的mem_cgroup成员，则将page与特定的mem_cgroup关联起来。</p>

<p>我们知道在linux系统中，page结构体是用来管理物理页框的，一个物理页框对应一个page结构体，而每个进程中的task_struct中都有一个mm_struct来管理进程的内存信息。每个mm_struct知道它属于的进程，进而知道所属的mem_cgroup，而每个page都知道它属于的page_cgroup，进而也知道所属的mem_cgroup，而内存使用量的计算是按cgroup为单位的，这样以来，内存资源的管理就可以实现了。</p>

<p>memory子系统既然是通过resource counter实现的，那肯定会在内存分配给进程时进行charge操作的。下面我们就来看一下这些charge操作：</p>

<p>1.page fault发生时，有两种情况内核需要给进程分配新的页框。一种是进程请求调页（demand paging），另一种是copy on write。内核在handle_pte_fault中进行处理。其中，do_linear_fault处理pte不存在且页面线性映射了文件的情况，do_anonymous_page处理pte不存在且页面没有映射文件的情况，do_nonlinear_fault处理pte存在且页面非线性映射文件的情况，do_wp_page则处理copy on write的情况。其中do_linear_fault和do_nonlinear_fault都会调用<strong>do_fault来处理。Memory子系统则</strong>do_fault、do_anonymous_page、do_wp_page植入mem_cgroup_newpage_charge来进行charge操作。</p>

<p>2.内核在handle_pte_fault中进行处理时，还有一种情况是pte存在且页又没有映射文件。这种情况说明页面之前在内存中，但是后面被换出到swap空间了。内核用do_swap_page函数处理这种情况，memory子系统在do_swap_page加入了mem_cgroup_try_charge_swapin函数进行charge。mem_cgroup_try_charge_swapin是处理页面换入时的charge的，当执行swapoff系统调用（关掉swap空间），内核也会执行页面换入操作，因此mem_cgroup_try_charge_swapin也被植入到了相应的函数中。</p>

<p>3.当内核将page加入到page cache中时，也需要进行charge操作，mem_cgroup_cache_charge函数正是处理这种情况，它被植入到系统处理page cache的add_to_page_cache_locked函数中。</p>

<p>4.最后mem_cgroup_prepare_migration是用于处理内存迁移中的charge操作。</p>

<p>除了charge操作，memory子系统还需要处理相应的uncharge操作。下面我们来看一下uncharge操作：</p>

<p>1.mem_cgroup_uncharge_page用于当匿名页完全unmaped的时候。但是如果该page是swap cache的话，uncharge操作延迟到mem_cgroup_uncharge_swapcache被调用时执行。</p>

<p>2.mem_cgroup_uncharge_cache_page用于page cache从radix-tree删除的时候。但是如果该page是swap cache的话，uncharge操作延迟到mem_cgroup_uncharge_swapcache被调用时执行。</p>

<p>3.mem_cgroup_uncharge_swapcache用于swap cache从radix-tree删除的时候。Charge的资源会被算到swap_cgroup，如果mem+swap controller被禁用了，就不需要这样做了。</p>

<p>4.mem_cgroup_uncharge_swap用于swap_entry的引用数减到0的时候。这个函数主要在mem+swap controller可用的情况下使用的。</p>

<p>5.mem_cgroup_end_migration用于内存迁移结束时相关的uncharge操作。</p>

<p>Charge函数最终都是通过调用<strong>mem_cgroup_try_charge来实现的。在</strong>mem_cgroup_try_charge函数中，调用res_counter_charge(&amp;mem->res, csize, &amp;fail_res)对memory进行charge，调用res_counter_charge(&amp;mem->memsw, csize, &amp;fail_res)对memory+swap进行charge。</p>

<p>Uncharge函数最终都是通过调用<strong>do_uncharge来实现的。在</strong>do_uncharge中，分别调用res_counter_uncharge(&amp;mem->res,PAGE_SIZE)和res_counter_uncharge(&amp;mem->memsw, PAGE_SIZE)来uncharge memory和memory+swap。</p>

<p>跟其他子系统一样，memory子系统也实现了一个cgroup_subsys。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct cgroup_subsys mem_cgroup_subsys = {
</span><span class='line'>&#9;.name = "memory",
</span><span class='line'>&#9;.subsys_id = mem_cgroup_subsys_id,
</span><span class='line'>&#9;.create = mem_cgroup_create,
</span><span class='line'>&#9;.pre_destroy = mem_cgroup_pre_destroy,
</span><span class='line'>&#9;.destroy = mem_cgroup_destroy,
</span><span class='line'>&#9;.populate = mem_cgroup_populate,
</span><span class='line'>&#9;.can_attach = mem_cgroup_can_attach,
</span><span class='line'>&#9;.cancel_attach = mem_cgroup_cancel_attach,
</span><span class='line'>&#9;.attach = mem_cgroup_move_task,
</span><span class='line'>&#9;.early_init = 0,
</span><span class='line'>&#9;.use_id = 1,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>Memory子系统中重要的文件有</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>memsw.limit_in_bytes
</span><span class='line'>{
</span><span class='line'>&#9;.name = "memsw.limit_in_bytes",
</span><span class='line'>&#9;.private = MEMFILE_PRIVATE(_MEMSWAP, RES_LIMIT),
</span><span class='line'>&#9;.write_string = mem_cgroup_write,
</span><span class='line'>&#9;.read_u64 = mem_cgroup_read,
</span><span class='line'>},</span></code></pre></td></tr></table></div></figure>


<p>这个文件用于设定memory+swap上限值。</p>

<p>Limit_in_bytes</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>&#9;.name = "limit_in_bytes",
</span><span class='line'>&#9;.private = MEMFILE_PRIVATE(_MEM, RES_LIMIT),
</span><span class='line'>&#9;.write_string = mem_cgroup_write,
</span><span class='line'>&#9;.read_u64 = mem_cgroup_read,
</span><span class='line'>},</span></code></pre></td></tr></table></div></figure>


<p>这个文件用于设定memory上限值。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/12">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/10">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(40)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>23</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>13</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(51)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~haproxy/?opendiv=tools'>haproxy</a><a href='##' onmousedown=showDiv('tools~haproxy') id='aexp_tools~haproxy'><span class='exp_style' id='exp_tools~haproxy'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~haproxy')) document.getElementById('aexp_tools~haproxy').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(54)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>17</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~cgroup/?opendiv=system'>cgroup</a><a href='##' onmousedown=showDiv('system~cgroup') id='aexp_system~cgroup'><span class='exp_style' id='exp_system~cgroup'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~cgroup')) document.getElementById('aexp_system~cgroup').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~kvm/?opendiv=system'>kvm</a><a href='##' onmousedown=showDiv('system~kvm') id='aexp_system~kvm'><span class='exp_style' id='exp_system~kvm'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~kvm')) document.getElementById('aexp_system~kvm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~namespace/?opendiv=system'>namespace</a><a href='##' onmousedown=showDiv('system~namespace') id='aexp_system~namespace'><span class='exp_style' id='exp_system~namespace'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~namespace')) document.getElementById('aexp_system~namespace').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(163)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~fs/?opendiv=kernel'>fs</a><a href='##' onmousedown=showDiv('kernel~fs') id='aexp_kernel~fs'><span class='exp_style' id='exp_kernel~fs'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~fs')) document.getElementById('aexp_kernel~fs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>33</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>80</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>19</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(22)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(70)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>17</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~perf/?opendiv=debug'>perf</a><a href='##' onmousedown=showDiv('debug~perf') id='aexp_debug~perf'><span class='exp_style' id='exp_debug~perf'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~perf')) document.getElementById('aexp_debug~perf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(27)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>20</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2016/'>2016</a><a href='##' onmousedown=showDiv('2016')><span class='exp_style' id='exp_2016'>[+]</span></a><span class='right_span'>(9)</span></li>
<div id='2016' class='catsub'><li><a href='/blog/cats/2016~03/?opendiv=2016'>2016-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2016~02/?opendiv=2016'>2016-02</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2016~01/?opendiv=2016'>2016-01</a><span class='right_span'>6</span></li>
</div><li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(207)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~12/?opendiv=2015'>2015-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2015~11/?opendiv=2015'>2015-11</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2015~10/?opendiv=2015'>2015-10</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2015~09/?opendiv=2015'>2015-09</a><span class='right_span'>18</span></li>
<li><a href='/blog/cats/2015~08/?opendiv=2015'>2015-08</a><span class='right_span'>25</span></li>
<li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>31</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/03/09/kernel-net-bonding-source/">bonding的源代码分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/09/kernel-net-bonding/">七种网卡绑定模式详解</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/29/kernel-net-connect/">socket建立连接 sys_connect</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/21/kernel-net-udp-sum/">udp checksum</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/21/system-base-init/">Linux系统启动过程分析</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
	<li>
		<a href=http://smilejay.com/ target=_blank>smilejay</a>
	</li>
	<li>
		<a href=http://blog.chinaunix.net/uid/10167808.html target=_blank>godbach</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
