
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>学习中......</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/04/01/centos-base/">CentOS各种设置</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-01T23:39:00+08:00'><span class='date'>2015-04-01</span> <span class='time'>23:39:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>vmware虚拟机mkinitrd提示no module ehci-hcd 错误的话，加：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> --builtin=ehci-hcd --builtin=ohci-hcd --builtin=uhci-hcd </span></code></pre></td></tr></table></div></figure>


<hr />

<p>CentOS6.0 下默认开selinux时出现httpd 报“SELinux policy enabled; httpd running as context unconfined_u:system”的解决方案</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>yum install policycoreutils-python
</span><span class='line'>
</span><span class='line'># To allow httpd to use nfs dirs in CentOS-6
</span><span class='line'>setsebool -P httpd_use_nfs 1
</span><span class='line'>setsebool -P httpd_enable_homedirs 1</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>CentOS 关闭防火墙</h4>

<p>1） 永久性生效，重启后不会复原<br/>
开启： chkconfig iptables on<br/>
关闭： chkconfig iptables off</p>

<p>2） 即时生效，重启后复原<br/>
开启： service iptables start<br/>
关闭： service iptables stop</p>

<hr />

<h4>CentOS安装软件：/lib/ld-linux.so.2: bad ELF interpreter 解决</h4>

<p>是因为64位系统中安装了32位程序, 解决方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>yum install glibc.i686</span></code></pre></td></tr></table></div></figure>


<p>其他包</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>yum install libstdc++.i686</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>gcc, c++</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>yum install glibc
</span><span class='line'>yum install glibc-devel
</span><span class='line'>yum install gcc-c++
</span><span class='line'>yum install libstdc++</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/04/01/kernel-net-tc/">tc模拟丢包率时延</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-01T23:25:00+08:00'><span class='date'>2015-04-01</span> <span class='time'>23:25:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>tc 的最最基本的使用</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tc qdisc show    # 显示
</span><span class='line'>tc qdisc add dev eth0 root ...... # 加入
</span><span class='line'>tc qdisc change dev eth0 root ...... # 修改存在的 qdisc ，记的，加入同一条后只能用 change 来修改
</span><span class='line'>tc qdisc del dev eth0 root  # 删除</span></code></pre></td></tr></table></div></figure>


<h4>Linux 中延时模拟</h4>

<p>设置延时 3s :</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tc qdisc add dev eth0 root netem delay 3000ms</span></code></pre></td></tr></table></div></figure>


<p>可以在 3000ms 后面在加上一个延时，比如 3000ms 200ms 表示 3000ms ± 200ms ，延时范围 2800 – 3200 之间.</p>

<h4>Linux 中丢包模拟</h4>

<p>设置丢包 50% ,iptables 也可以模拟这个，但一下不记的命令了，下次放上来:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tc qdisc change dev eth0 root netem loss 50%</span></code></pre></td></tr></table></div></figure>


<p>上面的设丢包，如果给后面的 50% 的丢包比率修改成 50% 80% 时，这时和上面的延时不一样，这是指丢包比率为 50-80% 之间。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/04/01/kernel-net-write-xmit/">Linux TCP发送数据tcp_write_xmit</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-01T23:20:00+08:00'><span class='date'>2015-04-01</span> <span class='time'>23:20:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/youxin2012/article/details/27175253">http://blog.csdn.net/youxin2012/article/details/27175253</a></p>

<p><code>__tcp_push_pending_frames</code> 该函数将所有pending的数据，全部发送出去。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __tcp_push_pending_frames(struct sock *sk, unsigned int cur_mss,
</span><span class='line'>             int nonagle)
</span><span class='line'>{
</span><span class='line'>    /* If we are closed, the bytes will have to remain here.
</span><span class='line'>     * In time closedown will finish, we empty the write queue and
</span><span class='line'>     * all will be happy.
</span><span class='line'>     */
</span><span class='line'>    /* 该socket已经关闭，那么直接返回 */
</span><span class='line'>    if (unlikely(sk-&gt;sk_state == TCP_CLOSE))
</span><span class='line'>        return;
</span><span class='line'>
</span><span class='line'>    /* 发送数据 */
</span><span class='line'>    if (tcp_write_xmit(sk, cur_mss, nonagle, 0, GFP_ATOMIC))
</span><span class='line'>        tcp_check_probe_timer(sk); //发送数据失败，使用probe timer进行检查。
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>发送端 tcp_write_xmit 函数</h4>

<p>版本：2.6.33.4</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* This routine writes packets to the network.  It advances the
</span><span class='line'> * send_head.  This happens as incoming acks open up the remote
</span><span class='line'> * window for us.
</span><span class='line'> *
</span><span class='line'> * LARGESEND note: !tcp_urg_mode is overkill, only frames between
</span><span class='line'> * snd_up-64k-mss .. snd_up cannot be large. However, taking into
</span><span class='line'> * account rare use of URG, this is not a big flaw.
</span><span class='line'> *
</span><span class='line'> * Returns 1, if no segments are in flight and we have queued segments, but
</span><span class='line'> * cannot send anything now because of SWS or another problem.
</span><span class='line'> */
</span><span class='line'>static int tcp_write_xmit(struct sock *sk, unsigned int mss_now, int nonagle,
</span><span class='line'>              int push_one, gfp_t gfp)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>    unsigned int tso_segs, sent_pkts;
</span><span class='line'>    int cwnd_quota;
</span><span class='line'>    int result;
</span><span class='line'>
</span><span class='line'>    /* sent_pkts用来统计函数中已发送报文总数。*/
</span><span class='line'>    sent_pkts = 0;
</span><span class='line'>
</span><span class='line'>    /* 检查是不是只发送一个skb buffer，即push one */
</span><span class='line'>    if (!push_one) {
</span><span class='line'>        /* 如果要发送多个skb，则需要检测MTU。
</span><span class='line'>         * 这时会检测MTU，希望MTU可以比之前的大，提高发送效率。
</span><span class='line'>         */
</span><span class='line'>        /* Do MTU probing. */
</span><span class='line'>        result = tcp_mtu_probe(sk);
</span><span class='line'>        if (!result) {
</span><span class='line'>            return 0;
</span><span class='line'>        } else if (result &gt; 0) {
</span><span class='line'>            sent_pkts = 1;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    while ((skb = tcp_send_head(sk))) {
</span><span class='line'>        unsigned int limit;
</span><span class='line'>
</span><span class='line'>        /* 设置有关TSO的信息，包括GSO类型，GSO分段的大小等等。
</span><span class='line'>         * 这些信息是准备给软件TSO分段使用的。
</span><span class='line'>         * 如果网络设备不支持TSO，但又使用了TSO功能，
</span><span class='line'>         * 则报文在提交给网络设备之前，需进行软分段，即由代码实现TSO分段。
</span><span class='line'>         */
</span><span class='line'>        tso_segs = tcp_init_tso_segs(sk, skb, mss_now);
</span><span class='line'>        BUG_ON(!tso_segs);
</span><span class='line'>
</span><span class='line'>        /* 检查congestion windows， 可以发送几个segment */
</span><span class='line'>        /* 检测拥塞窗口的大小，如果为0，则说明拥塞窗口已满，目前不能发送。
</span><span class='line'>         * 拿拥塞窗口和正在网络上传输的包数目相比，如果拥塞窗口还大，
</span><span class='line'>         * 则返回拥塞窗口减掉正在网络上传输的包数目剩下的大小。
</span><span class='line'>         * 该函数目的是判断正在网络上传输的包数目是否超过拥塞窗口，
</span><span class='line'>         * 如果超过了，则不发送。
</span><span class='line'>         */
</span><span class='line'>        cwnd_quota = tcp_cwnd_test(tp, skb);
</span><span class='line'>        if (!cwnd_quota)
</span><span class='line'>            break;
</span><span class='line'>
</span><span class='line'>        /* 检测当前报文是否完全处于发送窗口内，如果是则可以发送，否则不能发送 */
</span><span class='line'>        if (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now)))
</span><span class='line'>            break;
</span><span class='line'>
</span><span class='line'>        /* tso_segs=1表示无需tso分段 */
</span><span class='line'>        if (tso_segs == 1) {
</span><span class='line'>            /* 根据nagle算法，计算是否需要发送数据 */
</span><span class='line'>            if (unlikely(!tcp_nagle_test(tp, skb, mss_now,
</span><span class='line'>                             (tcp_skb_is_last(sk, skb) ?
</span><span class='line'>                              nonagle : TCP_NAGLE_PUSH))))
</span><span class='line'>                break;
</span><span class='line'>        } else {
</span><span class='line'>            /* 当不止一个skb时，通过TSO计算是否需要延时发送 */
</span><span class='line'>            /* 如果需要TSO分段，则检测该报文是否应该延时发送。
</span><span class='line'>              * tcp_tso_should_defer()用来检测GSO段是否需要延时发送。
</span><span class='line'>             * 在段中有FIN标志，或者不处于open拥塞状态，或者TSO段延时超过2个时钟滴答，
</span><span class='line'>             * 或者拥塞窗口和发送窗口的最小值大于64K或三倍的当前有效MSS，在这些情况下会立即发送，
</span><span class='line'>             * 而其他情况下会延时发送，这样主要是为了减少软GSO分段的次数，以提高性能。
</span><span class='line'>             */
</span><span class='line'>            if (!push_one && tcp_tso_should_defer(sk, skb))
</span><span class='line'>                break;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        limit = mss_now;
</span><span class='line'>        /* 在TSO分片大于1的情况下，且TCP不是URG模式。通过MSS计算发送数据的limit
</span><span class='line'>         * 以发送窗口和拥塞窗口的最小值作为分段段长*/
</span><span class='line'>         */
</span><span class='line'>        if (tso_segs &gt; 1 && !tcp_urg_mode(tp))
</span><span class='line'>            limit = tcp_mss_split_point(sk, skb, mss_now,
</span><span class='line'>                            cwnd_quota);
</span><span class='line'>        /* 当skb的长度大于限制时，需要调用tso_fragment分片,如果分段失败则暂不发送 */
</span><span class='line'>        if (skb-&gt;len &gt; limit &&
</span><span class='line'>            unlikely(tso_fragment(sk, skb, limit, mss_now)))
</span><span class='line'>            break;
</span><span class='line'>
</span><span class='line'>        /* 以上6行：根据条件，可能需要对SKB中的报文进行分段处理，分段的报文包括两种：
</span><span class='line'>         * 一种是普通的用MSS分段的报文，另一种则是TSO分段的报文。
</span><span class='line'>         * 能否发送报文主要取决于两个条件：一是报文需完全在发送窗口中，而是拥塞窗口未满。
</span><span class='line'>         * 第一种报文，应该不会再分段了，因为在tcp_sendmsg()中创建报文的SKB时已经根据MSS处理了，
</span><span class='line'>         * 而第二种报文，则一般情况下都会大于MSS，因为通过TSO分段的段有可能大于拥塞窗口的剩余空间，
</span><span class='line'>         * 如果是这样，就需要以发送窗口和拥塞窗口的最小值作为段长对报文再次分段。
</span><span class='line'>         */
</span><span class='line'>
</span><span class='line'>        /* 更新tcp的时间戳，记录此报文发送的时间 */
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
</span><span class='line'>
</span><span class='line'>        if (unlikely(tcp_transmit_skb(sk, skb, 1, gfp)))
</span><span class='line'>            break;
</span><span class='line'>
</span><span class='line'>        /* Advance the send_head.  This one is sent out.
</span><span class='line'>         * This call will increment packets_out.
</span><span class='line'>         */
</span><span class='line'>        /* 更新统计，并启动重传计时器 */
</span><span class='line'>        /* 调用tcp_event_new_data_sent()--&gt;tcp_advance_send_head()更新sk_send_head，
</span><span class='line'>         * 即取发送队列中的下一个SKB。同时更新snd_nxt，即等待发送的下一个TCP段的序号，
</span><span class='line'>         * 然后统计发出但未得到确认的数据报个数。最后如果发送该报文前没有需要确认的报文，
</span><span class='line'>         * 则复位重传定时器，对本次发送的报文做重传超时计时。
</span><span class='line'>         */
</span><span class='line'>        tcp_event_new_data_sent(sk, skb);
</span><span class='line'>
</span><span class='line'>        /* 更新struct tcp_sock中的snd_sml字段。snd_sml表示最近发送的小包(小于MSS的段)的最后一个字节序号，
</span><span class='line'>         * 在发送成功后，如果报文小于MSS，即更新该字段，主要用来判断是否启动nagle算法
</span><span class='line'>         */
</span><span class='line'>        tcp_minshall_update(tp, mss_now, skb);
</span><span class='line'>        sent_pkts++;
</span><span class='line'>
</span><span class='line'>        if (push_one)
</span><span class='line'>            break;
</span><span class='line'>    }
</span><span class='line'>    /* 如果本次有数据发送，则对TCP拥塞窗口进行检查确认。*/
</span><span class='line'>    if (likely(sent_pkts)) {
</span><span class='line'>        tcp_cwnd_validate(sk);
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>    /*
</span><span class='line'>     * 如果本次没有数据发送，则根据已发送但未确认的报文数packets_out和sk_send_head返回，
</span><span class='line'>     * packets_out不为零或sk_send_head为空都视为有数据发出，因此返回成功。
</span><span class='line'>     */
</span><span class='line'>    return !tp-&gt;packets_out && tcp_send_head(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/04/01/kernel-net-data-queue/">Linux TCP数据包接收处理tcp_data_queue</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-01T18:20:00+08:00'><span class='date'>2015-04-01</span> <span class='time'>18:20:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.cppblog.com/fwxjj/archive/2013/02/18/197906.aspx">http://www.cppblog.com/fwxjj/archive/2013/02/18/197906.aspx</a></p>

<h4>tcp_data_queue函数</h4>

<p>这里就是对数据包的处理了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    struct tcphdr *th = tcp_hdr(skb);
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    int eaten = -1;
</span><span class='line'>    /* 没有数据处理*/
</span><span class='line'>    if (TCP_SKB_CB(skb)-&gt;seq == TCP_SKB_CB(skb)-&gt;end_seq)
</span><span class='line'>        goto drop;
</span><span class='line'>    /* 跳过tcp头部*/
</span><span class='line'>    __skb_pull(skb, th-&gt;doff * 4);
</span><span class='line'>    /* 如果收到对方发来的CWR，则本地TCP发送时不在设置ECE*/
</span><span class='line'>    TCP_ECN_accept_cwr(tp, skb);
</span><span class='line'>    /* 初始化Duplicate SACK*/
</span><span class='line'>    if (tp-&gt;rx_opt.dsack) {
</span><span class='line'>        tp-&gt;rx_opt.dsack = 0;
</span><span class='line'>        tp-&gt;rx_opt.eff_sacks = tp-&gt;rx_opt.num_sacks;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>如果该数据包刚好是下一个要接收的数据，则可以直接copy到用户空间（如果存在且可用），否则排队到receive queue</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*  Queue data for delivery to the user.
</span><span class='line'> *  Packets in sequence go to the receive queue.
</span><span class='line'> *  Out of sequence packets to the out_of_order_queue.
</span><span class='line'> */
</span><span class='line'>if (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) {
</span><span class='line'>    if (tcp_receive_window(tp) == 0)
</span><span class='line'>        goto out_of_window;
</span><span class='line'>
</span><span class='line'>    /* Ok. In sequence. In window. */
</span><span class='line'>    if (tp-&gt;ucopy.task == current &&
</span><span class='line'>        tp-&gt;copied_seq == tp-&gt;rcv_nxt && tp-&gt;ucopy.len &&
</span><span class='line'>        sock_owned_by_user(sk) && !tp-&gt;urg_data) {
</span><span class='line'>        int chunk = min_t(unsigned int, skb-&gt;len,
</span><span class='line'>                  tp-&gt;ucopy.len);
</span><span class='line'>
</span><span class='line'>        // tcp_v4_rcv_do是有可能在tcp_recvmsg的进程上下文中调用的，tcp_recvmsg会先local_bh_disable，在调用
</span><span class='line'>        // 如过到这里，说明就是这种情况，那么复制数据到用户空间，这里可以先开启软中断，保证系统能及时相应一些其他中断
</span><span class='line'>        __set_current_state(TASK_RUNNING);
</span><span class='line'>        local_bh_enable();
</span><span class='line'>        if (!skb_copy_datagram_iovec(skb, 0, tp-&gt;ucopy.iov, chunk)) {
</span><span class='line'>            tp-&gt;ucopy.len -= chunk;
</span><span class='line'>            tp-&gt;copied_seq += chunk;
</span><span class='line'>            eaten = (chunk == skb-&gt;len && !th-&gt;fin);
</span><span class='line'>            tcp_rcv_space_adjust(sk);
</span><span class='line'>        }
</span><span class='line'>        local_bh_disable();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if (eaten &lt;= 0) {
</span><span class='line'>ueue_and_out:
</span><span class='line'>        if (eaten &lt; 0 &&
</span><span class='line'>            /* 该函数用于判断是否有接收缓存，在tcp内存管理中将分析*/
</span><span class='line'>            tcp_try_rmem_schedule(sk, skb-&gt;truesize))
</span><span class='line'>            goto drop;
</span><span class='line'>
</span><span class='line'>        skb_set_owner_r(skb, sk);
</span><span class='line'>        __skb_queue_tail(&sk-&gt;sk_receive_queue, skb);
</span><span class='line'>    }
</span><span class='line'>    tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>    if (skb-&gt;len)
</span><span class='line'>        tcp_event_data_recv(sk, skb);
</span><span class='line'>    if (th-&gt;fin)
</span><span class='line'>        tcp_fin(skb, sk, th);
</span><span class='line'>    /* 到达的数据包哟可能填充了乱序队列中的hole */
</span><span class='line'>    if (!skb_queue_empty(&tp-&gt;out_of_order_queue)) {
</span><span class='line'>        tcp_ofo_queue(sk);
</span><span class='line'>
</span><span class='line'>        /* RFC2581. 4.2. SHOULD send immediate ACK, when
</span><span class='line'>         * gap in queue is filled.
</span><span class='line'>         */
</span><span class='line'>        /*关闭乒乓模式，在quick计数没消耗完时则可立即发送ACK，见tcp_in_quickack_mode*/
</span><span class='line'>        if (skb_queue_empty(&tp-&gt;out_of_order_queue))
</span><span class='line'>            inet_csk(sk)-&gt;icsk_ack.pingpong = 0;
</span><span class='line'>    }
</span><span class='line'>    /* 新数据到达导致返回给对方的SACK Block 调整*/
</span><span class='line'>    if (tp-&gt;rx_opt.num_sacks)
</span><span class='line'>        tcp_sack_remove(tp);
</span><span class='line'>    /* 在当前slow path，检测是否可以进入fast path*/
</span><span class='line'>    tcp_fast_path_check(sk);
</span><span class='line'>
</span><span class='line'>    if (eaten &gt; 0)
</span><span class='line'>        __kfree_skb(skb);
</span><span class='line'>    else if (!sock_flag(sk, SOCK_DEAD))
</span><span class='line'>        sk-&gt;sk_data_ready(sk, 0);
</span><span class='line'>    return;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面看看函数tcp_ofo_queue，也即out-of-order queue的处理</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* This one checks to see if we can put data from the
</span><span class='line'> * out_of_order queue into the receive_queue.
</span><span class='line'> */
</span><span class='line'>static void tcp_ofo_queue(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    __u32 dsack_high = tp-&gt;rcv_nxt;
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>    while ((skb = skb_peek(&tp-&gt;out_of_order_queue)) != NULL) {
</span><span class='line'>        /* 当前hole未覆盖，则处理结束*/
</span><span class='line'>        if (after(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt))
</span><span class='line'>            break;
</span><span class='line'>        /* DSACK处理*/
</span><span class='line'>        if (before(TCP_SKB_CB(skb)-&gt;seq, dsack_high)) {
</span><span class='line'>            __u32 dsack = dsack_high;
</span><span class='line'>            if (before(TCP_SKB_CB(skb)-&gt;end_seq, dsack_high))
</span><span class='line'>                dsack_high = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>            tcp_dsack_extend(sk, TCP_SKB_CB(skb)-&gt;seq, dsack);
</span><span class='line'>        }
</span><span class='line'>        /* 该乱序数据包完全被到达的数据包覆盖，则从乱序队列中删除之，并释放该数据包*/
</span><span class='line'>        if (!after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;rcv_nxt)) {
</span><span class='line'>            SOCK_DEBUG(sk, "ofo packet was already received /n");
</span><span class='line'>            __skb_unlink(skb, &tp-&gt;out_of_order_queue);
</span><span class='line'>            __kfree_skb(skb);
</span><span class='line'>            continue;
</span><span class='line'>        }
</span><span class='line'>        SOCK_DEBUG(sk, "ofo requeuing : rcv_next %X seq %X - %X/n",
</span><span class='line'>               tp-&gt;rcv_nxt, TCP_SKB_CB(skb)-&gt;seq,
</span><span class='line'>               TCP_SKB_CB(skb)-&gt;end_seq);
</span><span class='line'>        /* hole被填充，取出该乱序数据包到receive queue中排队，并更新rcv_nxt */
</span><span class='line'>        __skb_unlink(skb, &tp-&gt;out_of_order_queue);
</span><span class='line'>        __skb_queue_tail(&sk-&gt;sk_receive_queue, skb);
</span><span class='line'>        tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>        if (tcp_hdr(skb)-&gt;fin)
</span><span class='line'>            tcp_fin(skb, sk, tcp_hdr(skb));
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 该数据包的数据已经完全存在，则发送DSACK，并进入快速ACK模式，调度ACK发送*/
</span><span class='line'>if (!after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;rcv_nxt)) {
</span><span class='line'>        /* A retransmit, 2nd most common case.  Force an immediate ack. */
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);
</span><span class='line'>        tcp_dsack_set(sk, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq);
</span><span class='line'>
</span><span class='line'>out_of_window:
</span><span class='line'>        tcp_enter_quickack_mode(sk);
</span><span class='line'>        inet_csk_schedule_ack(sk);
</span><span class='line'>drop:
</span><span class='line'>        __kfree_skb(skb);
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Out of window. F.e. zero window probe. */
</span><span class='line'>    if (!before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt + tcp_receive_window(tp)))
</span><span class='line'>        goto out_of_window;
</span><span class='line'>
</span><span class='line'>    tcp_enter_quickack_mode(sk);
</span><span class='line'>    /* 部分数据已存在，则设置正确的DSACK，然后排队到receive queue*/
</span><span class='line'>    if (before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt)) {
</span><span class='line'>        /* Partial packet, seq &lt; rcv_next &lt; end_seq */
</span><span class='line'>        SOCK_DEBUG(sk, "partial packet: rcv_next %X seq %X - %X/n",
</span><span class='line'>               tp-&gt;rcv_nxt, TCP_SKB_CB(skb)-&gt;seq,
</span><span class='line'>               TCP_SKB_CB(skb)-&gt;end_seq);
</span><span class='line'>
</span><span class='line'>        tcp_dsack_set(sk, TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt);
</span><span class='line'>
</span><span class='line'>        /* If window is closed, drop tail of packet. But after
</span><span class='line'>         * remembering D-SACK for its head made in previous line.
</span><span class='line'>         */
</span><span class='line'>        if (!tcp_receive_window(tp))
</span><span class='line'>            goto out_of_window;
</span><span class='line'>        goto queue_and_out;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    TCP_ECN_check_ce(tp, skb); /* 检查ECE是否设置 */
</span><span class='line'>    /* 以下则把数据包排队到乱序队列 */
</span><span class='line'>    /* 同样先判断内存是否满足 */
</span><span class='line'>    if (tcp_try_rmem_schedule(sk, skb-&gt;truesize))
</span><span class='line'>        goto drop;
</span><span class='line'>
</span><span class='line'>    /* Disable header prediction. */
</span><span class='line'>    tp-&gt;pred_flags = 0;
</span><span class='line'>    inet_csk_schedule_ack(sk);
</span><span class='line'>
</span><span class='line'>    SOCK_DEBUG(sk, "out of order segment: rcv_next %X seq %X - %X/n",
</span><span class='line'>           tp-&gt;rcv_nxt, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq);
</span><span class='line'>
</span><span class='line'>    skb_set_owner_r(skb, sk);
</span><span class='line'>    /* 该数据包是乱序队列的第一个数据包*/
</span><span class='line'>    if (!skb_peek(&tp-&gt;out_of_order_queue)) {
</span><span class='line'>        /* Initial out of order segment, build 1 SACK. */
</span><span class='line'>        if (tcp_is_sack(tp)) {
</span><span class='line'>            tp-&gt;rx_opt.num_sacks = 1;
</span><span class='line'>            tp-&gt;rx_opt.dsack     = 0;
</span><span class='line'>            tp-&gt;rx_opt.eff_sacks = 1;
</span><span class='line'>            tp-&gt;selective_acks[0].start_seq = TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>            tp-&gt;selective_acks[0].end_seq =
</span><span class='line'>                        TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>        }
</span><span class='line'>        __skb_queue_head(&tp-&gt;out_of_order_queue, skb);
</span><span class='line'>    } else {
</span><span class='line'>        struct sk_buff *skb1 = tp-&gt;out_of_order_queue.prev;
</span><span class='line'>        u32 seq = TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>        u32 end_seq = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>        /*刚好与乱序队列最后一个数据包数据衔接*/
</span><span class='line'>        if (seq == TCP_SKB_CB(skb1)-&gt;end_seq) {
</span><span class='line'>            __skb_queue_after(&tp-&gt;out_of_order_queue, skb1, skb);
</span><span class='line'>            /*如果没有sack block或者当前数据包开始序号不等于第一个block右边界*/
</span><span class='line'>            if (!tp-&gt;rx_opt.num_sacks ||
</span><span class='line'>                tp-&gt;selective_acks[0].end_seq != seq)
</span><span class='line'>                goto add_sack;
</span><span class='line'>            /*该数据包在某个hole后是按序到达的，所以可以直接扩展第一个sack*/
</span><span class='line'>            /* Common case: data arrive in order after hole. */
</span><span class='line'>            tp-&gt;selective_acks[0].end_seq = end_seq;
</span><span class='line'>            return;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        /* Find place to insert this segment. */
</span><span class='line'>        /* 该循环找到一个开始序号不大于该数据包开始序号的乱序队列中的数据包*/
</span><span class='line'>        do {
</span><span class='line'>            if (!after(TCP_SKB_CB(skb1)-&gt;seq, seq))
</span><span class='line'>                break;
</span><span class='line'>        } while ((skb1 = skb1-&gt;prev) !=
</span><span class='line'>             (struct sk_buff *)&tp-&gt;out_of_order_queue);
</span><span class='line'>
</span><span class='line'>        /* Do skb overlap to previous one? 检查与前个数据包是否有重叠*/
</span><span class='line'>        if (skb1 != (struct sk_buff *)&tp-&gt;out_of_order_queue &&
</span><span class='line'>            before(seq, TCP_SKB_CB(skb1)-&gt;end_seq)) {
</span><span class='line'>            if (!after(end_seq, TCP_SKB_CB(skb1)-&gt;end_seq)) {
</span><span class='line'>                /* All the bits are present. Drop. */
</span><span class='line'>                __kfree_skb(skb);
</span><span class='line'>                tcp_dsack_set(sk, seq, end_seq);
</span><span class='line'>                goto add_sack;
</span><span class='line'>            }
</span><span class='line'>            if (after(seq, TCP_SKB_CB(skb1)-&gt;seq)) {
</span><span class='line'>                /* Partial overlap. */
</span><span class='line'>                tcp_dsack_set(sk, seq,
</span><span class='line'>                          TCP_SKB_CB(skb1)-&gt;end_seq);
</span><span class='line'>            } else {
</span><span class='line'>                skb1 = skb1-&gt;prev;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        /* 排队到乱序队列*/
</span><span class='line'>        __skb_queue_after(&tp-&gt;out_of_order_queue, skb1, skb);
</span><span class='line'>
</span><span class='line'>        /* And clean segments covered by new one as whole. 检测与后面的数据包重叠*/
</span><span class='line'>        while ((skb1 = skb-&gt;next) !=
</span><span class='line'>               (struct sk_buff *)&tp-&gt;out_of_order_queue &&
</span><span class='line'>               after(end_seq, TCP_SKB_CB(skb1)-&gt;seq)) {
</span><span class='line'>            if (before(end_seq, TCP_SKB_CB(skb1)-&gt;end_seq)) {
</span><span class='line'>                tcp_dsack_extend(sk, TCP_SKB_CB(skb1)-&gt;seq,
</span><span class='line'>                         end_seq);
</span><span class='line'>                break;
</span><span class='line'>            }
</span><span class='line'>            __skb_unlink(skb1, &tp-&gt;out_of_order_queue);
</span><span class='line'>            tcp_dsack_extend(sk, TCP_SKB_CB(skb1)-&gt;seq,
</span><span class='line'>                     TCP_SKB_CB(skb1)-&gt;end_seq);
</span><span class='line'>            __kfree_skb(skb1);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>add_sack:
</span><span class='line'>        if (tcp_is_sack(tp))
</span><span class='line'>            /* 根据乱序队列的现状更新SACK的blocks */
</span><span class='line'>            tcp_sack_new_ofo_skb(sk, seq, end_seq);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/04/01/kernel-net-estab/">Linux TCP数据包接收处理tcp_rcv_established</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-01T17:50:00+08:00'><span class='date'>2015-04-01</span> <span class='time'>17:50:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.cppblog.com/fwxjj/archive/2013/02/18/197906.aspx">http://www.cppblog.com/fwxjj/archive/2013/02/18/197906.aspx</a></p>

<p>tcp_rcv_established函数的工作原理是把数据包的处理分为2类：fast path和slow path，其含义显而易见。这样分类的目的当然是加快数据包的处理，因为在正常情况下，数据包是按顺序到达的，网络状况也是稳定的，这时可以按照fast path直接把数据包存放到receive queue了。而在其他的情况下则需要走slow path流程了。</p>

<p>在协议栈中，是用头部预测来实现的，每个tcp sock有个pred_flags成员，它就是判别的依据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void __tcp_fast_path_on(struct tcp_sock *tp, u32 snd_wnd)
</span><span class='line'>{
</span><span class='line'>    tp-&gt;pred_flags = htonl((tp-&gt;tcp_header_len &lt;&lt; 26) |
</span><span class='line'>                   ntohl(TCP_FLAG_ACK) |
</span><span class='line'>                   snd_wnd);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看出头部预测依赖的是头部长度字段和通告窗口。也就是说标志位除了ACK和PSH外，如果其他的存在的话，就不能用</p>

<h5>fast path处理，其揭示的含义如下：</h5>

<p>1 Either the data transaction is taking place in only one direction (which means that we are the receiver and not transmitting any data) or in the case where we are sending out data also, the window advertised from the other end is constant. The latter means that we have not transmitted any data from our side for quite some time but are receiving data from the other end. The receive window advertised by the other end is constant.</p>

<ol>
<li><p>Other than PSH|ACK flags in the TCP header, no other flag is set (ACK is set for each TCP segment). <br/>
This means that if any other flag is set such as URG, FIN, SYN, ECN, RST, and CWR, we know that something important is there to be attended and we need to move into the SLOW path.</p></li>
<li><p>The header length has unchanged. If the TCP header length remains unchanged, we have not added/reduced any TCP option and we can safely assume that there is nothing important to be attended, if the above two conditions are TRUE.</p></li>
</ol>


<h5>fast path工作的条件</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void tcp_fast_path_check(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>    if (skb_queue_empty(&tp-&gt;out_of_order_queue) &&
</span><span class='line'>        tp-&gt;rcv_wnd &&
</span><span class='line'>        atomic_read(&sk-&gt;sk_rmem_alloc) &lt; sk-&gt;sk_rcvbuf &&
</span><span class='line'>        !tp-&gt;urg_data)
</span><span class='line'>        tcp_fast_path_on(tp);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>1 没有乱序数据包<br/>
2 接收窗口不为0<br/>
3 还有接收缓存空间<br/>
4 没有紧急数据</p>

<p>反之，则进入slow path处理；另外当连接新建立时处于slow path。</p>

<h5>从fast path进入slow path的触发条件（进入slow path 后pred_flags清除为0）：</h5>

<p>1 在tcp_data_queue中接收到乱序数据包<br/>
2 在tcp_prune_queue中用完缓存并且开始丢弃数据包<br/>
3 在tcp_urgent_check中遇到紧急指针<br/>
4 在tcp_select_window中发送的通告窗口下降到0.</p>

<h5>从slow_path进入fast_path的触发条件：</h5>

<p>1 When we have read past an urgent byte in tcp_recvmsg() . Wehave gotten an urgent byte and we remain in the slow path mode until we receive the urgent byte because it is handled in the slow path in tcp_rcv_established().<br/>
2 当在tcp_data_queue中乱序队列由于gap被填充而处理完毕时，运行tcp_fast_path_check。<br/>
3 tcp_ack_update_window()中更新了通告窗口。</p>

<h4>fast path处理流程</h4>

<p>A 判断能否进入fast path</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ((tcp_flag_word(th) & TCP_HP_BITS) == tp-&gt;pred_flags &&
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) {</span></code></pre></td></tr></table></div></figure>


<p>TCP_HP_BITS的作用就是排除flag中的PSH标志位。只有在头部预测满足并且数据包以正确的顺序（该数据包的第一个序号就是下个要接收的序号）到达时才进入fast path。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_header_len = tp-&gt;tcp_header_len;
</span><span class='line'>
</span><span class='line'>/* Timestamp header prediction: tcp_header_len
</span><span class='line'> * is automatically equal to th-&gt;doff*4 due to pred_flags
</span><span class='line'> * match.
</span><span class='line'> */
</span><span class='line'>
</span><span class='line'>/* Check timestamp */
</span><span class='line'>//相等说明tcp timestamp option被打开。
</span><span class='line'>if (tcp_header_len == sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) {
</span><span class='line'>    /* No? Slow path! */
</span><span class='line'>    //这里主要是parse timestamp选项，如果返回0则表明pase出错，此时我们进入slow_path
</span><span class='line'>    if (!tcp_parse_aligned_timestamp(tp, th))
</span><span class='line'>        goto slow_path;
</span><span class='line'>
</span><span class='line'>    /* If PAWS failed, check it more carefully in slow path */
</span><span class='line'>    //如果上面pase成功，则tp对应的rx_opt域已经被正确赋值，此时如果rcv_tsval（新的接收的数据段的时间戳)比ts_recent(对端发送过来的数据(也就是上一次)的最新的一个时间戳)小，则我们要进入slow path 处理paws。
</span><span class='line'>    if ((s32)(tp-&gt;rx_opt.rcv_tsval - tp-&gt;rx_opt.ts_recent) &lt; 0)
</span><span class='line'>        goto slow_path;
</span><span class='line'>
</span><span class='line'>    /* DO NOT update ts_recent here, if checksum fails
</span><span class='line'>     * and timestamp was corrupted part, it will result
</span><span class='line'>     * in a hung connection since we will drop all
</span><span class='line'>     * future packets due to the PAWS test.
</span><span class='line'>     */
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该代码段是依据时戳选项来检查PAWS（Protect Against Wrapped Sequence numbers）。
如果发送来的仅是一个TCP头的话（没有捎带数据或者接收端检测到有乱序数据这些情况时都会发送一个纯粹的ACK包）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Bulk data transfer: sender */
</span><span class='line'>if (len == tcp_header_len) {
</span><span class='line'>    /* Predicted packet is in window by definition.
</span><span class='line'>     * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.
</span><span class='line'>     * Hence, check seq&lt;=rcv_wup reduces to:
</span><span class='line'>     */
</span><span class='line'>    if (tcp_header_len ==
</span><span class='line'>        (sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &&
</span><span class='line'>        tp-&gt;rcv_nxt == tp-&gt;rcv_wup)
</span><span class='line'>        tcp_store_ts_recent(tp);
</span><span class='line'>
</span><span class='line'>    /* We know that such packets are checksummed
</span><span class='line'>     * on entry.
</span><span class='line'>     */
</span><span class='line'>    tcp_ack(sk, skb, 0);
</span><span class='line'>    __kfree_skb(skb);
</span><span class='line'>    tcp_data_snd_check(sk);
</span><span class='line'>    return 0;
</span><span class='line'>} else { /* Header too small */
</span><span class='line'>    TCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);
</span><span class='line'>    goto discard;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>主要的工作如下：<br/>
1 保存对方的最近时戳 tcp_store_ts_recent。通过前面的if判断可以看出tcp总是回显2次时戳回显直接最先到达的数据包的时戳，<br/>
  rcv_wup只在发送数据（这时回显时戳）时重置为rcv_nxt，所以接收到前一次回显后第一个数据包后，rcv_nxt增加了，但是<br/>
  rcv_wup没有更新，所以后面的数据包处理时不会调用该函数来保存时戳。<br/>
2 ACK处理。这个函数非常复杂，包含了拥塞控制机制，确认处理等等。<br/>
3 检查是否有数据待发送 tcp_data_snd_check。</p>

<p>如果该数据包中包含了数据的话</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>        } else {
</span><span class='line'>            int eaten = 0;
</span><span class='line'>            int copied_early = 0;
</span><span class='line'>            /* 此数据包刚好是下一个读取的数据，并且用户空间可存放下该数据包*/
</span><span class='line'>            if (tp-&gt;copied_seq == tp-&gt;rcv_nxt &&
</span><span class='line'>                len - tcp_header_len &lt;= tp-&gt;ucopy.len) {
</span><span class='line'>#ifdef CONFIG_NET_DMA
</span><span class='line'>                if (tcp_dma_try_early_copy(sk, skb, tcp_header_len)) {
</span><span class='line'>                    copied_early = 1;
</span><span class='line'>                    eaten = 1;
</span><span class='line'>                }
</span><span class='line'>#endif          /* 如果该函数在进程上下文中调用并且sock被用户占用的话*/
</span><span class='line'>                if (tp-&gt;ucopy.task == current &&
</span><span class='line'>                    sock_owned_by_user(sk) && !copied_early) {
</span><span class='line'>                    /* 进程有可能被设置为TASK_INTERRUPTIBLE */
</span><span class='line'>                    __set_current_state(TASK_RUNNING);
</span><span class='line'>                    /* 直接copy数据到用户空间*/
</span><span class='line'>                    if (!tcp_copy_to_iovec(sk, skb, tcp_header_len))
</span><span class='line'>                        eaten = 1;
</span><span class='line'>                }
</span><span class='line'>                if (eaten) {
</span><span class='line'>                    /* Predicted packet is in window by definition.
</span><span class='line'>                     * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.
</span><span class='line'>                     * Hence, check seq&lt;=rcv_wup reduces to:
</span><span class='line'>                     */
</span><span class='line'>                    if (tcp_header_len ==
</span><span class='line'>                        (sizeof(struct tcphdr) +
</span><span class='line'>                         TCPOLEN_TSTAMP_ALIGNED) &&
</span><span class='line'>                        tp-&gt;rcv_nxt == tp-&gt;rcv_wup)
</span><span class='line'>                        tcp_store_ts_recent(tp);
</span><span class='line'>                    /* 更新RCV RTT，Dynamic Right-Sizing算法*/
</span><span class='line'>                    tcp_rcv_rtt_measure_ts(sk, skb);
</span><span class='line'>
</span><span class='line'>                    __skb_pull(skb, tcp_header_len);
</span><span class='line'>                    tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>                    NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPHPHITSTOUSER);
</span><span class='line'>                }
</span><span class='line'>                if (copied_early)
</span><span class='line'>                    tcp_cleanup_rbuf(sk, skb-&gt;len);
</span><span class='line'>            }
</span><span class='line'>            if (!eaten) { /* 没有直接读到用户空间*/
</span><span class='line'>                if (tcp_checksum_complete_user(sk, skb))
</span><span class='line'>                    goto csum_error;
</span><span class='line'>
</span><span class='line'>                /* Predicted packet is in window by definition.
</span><span class='line'>                 * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.
</span><span class='line'>                 * Hence, check seq&lt;=rcv_wup reduces to:
</span><span class='line'>                 */
</span><span class='line'>                if (tcp_header_len ==
</span><span class='line'>                    (sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &&
</span><span class='line'>                    tp-&gt;rcv_nxt == tp-&gt;rcv_wup)
</span><span class='line'>                    tcp_store_ts_recent(tp);
</span><span class='line'>
</span><span class='line'>                tcp_rcv_rtt_measure_ts(sk, skb);
</span><span class='line'>
</span><span class='line'>                if ((int)skb-&gt;truesize &gt; sk-&gt;sk_forward_alloc)
</span><span class='line'>                    goto step5;
</span><span class='line'>
</span><span class='line'>                NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPHPHITS);
</span><span class='line'>
</span><span class='line'>                /* Bulk data transfer: receiver */
</span><span class='line'>                __skb_pull(skb, tcp_header_len);
</span><span class='line'>                /* 进入receive queue 排队，以待tcp_recvmsg读取*/
</span><span class='line'>                __skb_queue_tail(&sk-&gt;sk_receive_queue, skb);
</span><span class='line'>                skb_set_owner_r(skb, sk);
</span><span class='line'>                tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>            }
</span><span class='line'>            /* 数据包接收后续处理*/
</span><span class='line'>            tcp_event_data_recv(sk, skb);
</span><span class='line'>            /* ACK 处理*/
</span><span class='line'>            if (TCP_SKB_CB(skb)-&gt;ack_seq != tp-&gt;snd_una) {
</span><span class='line'>                /* Well, only one small jumplet in fast path... */
</span><span class='line'>                tcp_ack(sk, skb, FLAG_DATA);
</span><span class='line'>                tcp_data_snd_check(sk);
</span><span class='line'>                if (!inet_csk_ack_scheduled(sk))
</span><span class='line'>                    goto no_ack;
</span><span class='line'>            }
</span><span class='line'>            /* ACK发送处理*/
</span><span class='line'>            if (!copied_early || tp-&gt;rcv_nxt != tp-&gt;rcv_wup)
</span><span class='line'>                __tcp_ack_snd_check(sk, 0);
</span><span class='line'>no_ack:
</span><span class='line'>#ifdef CONFIG_NET_DMA
</span><span class='line'>            if (copied_early)
</span><span class='line'>                __skb_queue_tail(&sk-&gt;sk_async_wait_queue, skb);
</span><span class='line'>            else
</span><span class='line'>#endif
</span><span class='line'>            /* eaten为1，表示数据直接copy到了用户空间，这时无需提醒用户进程数据的到达，否则需调用sk_data_ready来通知，因为此时数据到达了receive queue*/
</span><span class='line'>            if (eaten)
</span><span class='line'>                __kfree_skb(skb);
</span><span class='line'>            else
</span><span class='line'>                sk-&gt;sk_data_ready(sk, 0);
</span><span class='line'>            return 0;
</span><span class='line'>        }</span></code></pre></td></tr></table></div></figure>


<h4>tcp_event_data_recv函数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_event_data_recv(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    u32 now;
</span><span class='line'>    /* 接收到了数据，设置ACK需调度标志*/
</span><span class='line'>    inet_csk_schedule_ack(sk);
</span><span class='line'>
</span><span class='line'>    tcp_measure_rcv_mss(sk, skb);
</span><span class='line'>
</span><span class='line'>    tcp_rcv_rtt_measure(tp);
</span><span class='line'>
</span><span class='line'>    now = tcp_time_stamp;
</span><span class='line'>    /* 以下为根据接收间隔更新icsk_ack.ato，该值主要用于判断pingpong模式见函数tcp_event_data_sent */
</span><span class='line'>    if (!icsk-&gt;icsk_ack.ato) {
</span><span class='line'>        /* The _first_ data packet received, initialize
</span><span class='line'>         * delayed ACK engine.
</span><span class='line'>         */
</span><span class='line'>        tcp_incr_quickack(sk);
</span><span class='line'>        icsk-&gt;icsk_ack.ato = TCP_ATO_MIN;
</span><span class='line'>    } else {
</span><span class='line'>        int m = now - icsk-&gt;icsk_ack.lrcvtime;
</span><span class='line'>
</span><span class='line'>        if (m &lt;= TCP_ATO_MIN / 2) {
</span><span class='line'>            /* The fastest case is the first. */
</span><span class='line'>            icsk-&gt;icsk_ack.ato = (icsk-&gt;icsk_ack.ato &gt;&gt; 1) + TCP_ATO_MIN / 2;
</span><span class='line'>        } else if (m &lt; icsk-&gt;icsk_ack.ato) {
</span><span class='line'>            icsk-&gt;icsk_ack.ato = (icsk-&gt;icsk_ack.ato &gt;&gt; 1) + m;
</span><span class='line'>            if (icsk-&gt;icsk_ack.ato &gt; icsk-&gt;icsk_rto)
</span><span class='line'>                icsk-&gt;icsk_ack.ato = icsk-&gt;icsk_rto;
</span><span class='line'>        } else if (m &gt; icsk-&gt;icsk_rto) {
</span><span class='line'>            /* Too long gap. Apparently sender failed to
</span><span class='line'>             * restart window, so that we send ACKs quickly.
</span><span class='line'>             */
</span><span class='line'>            tcp_incr_quickack(sk);
</span><span class='line'>            sk_mem_reclaim(sk);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    icsk-&gt;icsk_ack.lrcvtime = now;
</span><span class='line'>
</span><span class='line'>    TCP_ECN_check_ce(tp, skb);
</span><span class='line'>    /* 每次接收到来自对方的一个TCP数据报，且数据报长度大于128字节时，我们需要调用tcp_grow_window，增加rcv_ssthresh的值，一般每次为rcv_ssthresh增长两倍的mss，增加的条件是rcv_ssthresh小于window_clamp,并且 rcv_ssthresh小于接收缓存剩余空间的3/4，同时tcp_memory_pressure没有被置位(即接收缓存中的数据量没有太大)。 tcp_grow_window中对新收到的skb的长度还有一些限制，并不总是增长rcv_ssthresh的值*/
</span><span class='line'>    if (skb-&gt;len &gt;= 128)
</span><span class='line'>        tcp_grow_window(sk, skb);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>rcv_ssthresh是当前的接收窗口大小的一个阀值，其初始值就置为rcv_wnd。它跟rcv_wnd配合工作，当本地socket收到数据报，并满足一定条件时，增长rcv_ssthresh的值，在下一次发送数据报组建TCP首部时，需要通告对方当前的接收窗口大小，这时需要更新rcv_wnd，此时rcv_wnd的取值不能超过rcv_ssthresh的值。两者配合，达到一个滑动窗口大小缓慢增长的效果。</p>

<p><code>__tcp_ack_snd_check</code>用来判断ACK的发送方式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * Check if sending an ack is needed.
</span><span class='line'> */
</span><span class='line'>static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>    /* More than one full frame received... */
</span><span class='line'>    if (((tp-&gt;rcv_nxt - tp-&gt;rcv_wup) &gt; inet_csk(sk)-&gt;icsk_ack.rcv_mss
</span><span class='line'>         /* ... and right edge of window advances far enough.
</span><span class='line'>          * (tcp_recvmsg() will send ACK otherwise). Or...
</span><span class='line'>          */
</span><span class='line'>         && __tcp_select_window(sk) &gt;= tp-&gt;rcv_wnd) ||
</span><span class='line'>        /* We ACK each frame or... */
</span><span class='line'>        tcp_in_quickack_mode(sk) ||
</span><span class='line'>        /* We have out of order data. */
</span><span class='line'>        (ofo_possible && skb_peek(&tp-&gt;out_of_order_queue))) {
</span><span class='line'>        /* Then ack it now */
</span><span class='line'>        tcp_send_ack(sk);
</span><span class='line'>    } else {
</span><span class='line'>        /* Else, send delayed ack. */
</span><span class='line'>        tcp_send_delayed_ack(sk);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里有个疑问，就是当ucopy应用读到需要读取到的数据包后，也即在一次处理中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (tp-&gt;copied_seq == tp-&gt;rcv_nxt &&
</span><span class='line'>        len - tcp_header_len &lt;= tp-&gt;ucopy.len) {</span></code></pre></td></tr></table></div></figure>


<p>的第二个条件的等号为真 len - tcp_header_len == tp->ucopy.len，然后执行流程到后面eaten为1，所以函数以释放skb结束，没有调用sk_data_ready函数。假设这个处理调用流程如下：<br/>
tcp_recvmsg-> sk_wait_data  -> sk_wait_event -> release_sock -> __release_sock-> sk_backlog_rcv-> tcp_rcv_established那么即使此时用户得到了所需的数据，但是在tcp_rcv_established返回前没有提示数据已得到，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define sk_wait_event(__sk, __timeo, __condition)       /
</span><span class='line'>    ({  int __rc;                                       /
</span><span class='line'>        release_sock(__sk);                             /
</span><span class='line'>        __rc = __condition;                             /
</span><span class='line'>        if (!__rc) {                                    /
</span><span class='line'>            *(__timeo) = schedule_timeout(*(__timeo));  /
</span><span class='line'>        }                                               /
</span><span class='line'>        lock_sock(__sk);                                /
</span><span class='line'>        __rc = __condition;                             /
</span><span class='line'>        __rc;                                           /
</span><span class='line'>    })</span></code></pre></td></tr></table></div></figure>


<p>但是在回到sk_wait_event后，由于__condition为 !skb_queue_empty(&amp;sk->sk_receive_queue)，所以还是会调用schedule_timeout来等待。这点显然是浪费时间，所以这个condition应该考虑下这个数据已经读满的情况，而不能光靠观察receive queue来判断是否等待。</p>

<p>接下来分析slow path</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>slow_path:
</span><span class='line'>    if (len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete_user(sk, skb))
</span><span class='line'>        goto csum_error;
</span><span class='line'>
</span><span class='line'>    /*
</span><span class='line'>     *  Standard slow path.
</span><span class='line'>     */
</span><span class='line'>    /* 检查到达的数据包 */
</span><span class='line'>    res = tcp_validate_incoming(sk, skb, th, 1);
</span><span class='line'>    if (res &lt;= 0)
</span><span class='line'>        return -res;
</span><span class='line'>
</span><span class='line'>step5:  /* 如果设置了ACK，则调用tcp_ack处理，后面再分析该函数*/
</span><span class='line'>    if (th-&gt;ack)
</span><span class='line'>        tcp_ack(sk, skb, FLAG_SLOWPATH);
</span><span class='line'>
</span><span class='line'>    tcp_rcv_rtt_measure_ts(sk, skb);
</span><span class='line'>
</span><span class='line'>    /* Process urgent data. */
</span><span class='line'>    tcp_urg(sk, skb, th);
</span><span class='line'>
</span><span class='line'>    /* step 7: process the segment text */
</span><span class='line'>    tcp_data_queue(sk, skb);
</span><span class='line'>
</span><span class='line'>    tcp_data_snd_check(sk);
</span><span class='line'>    tcp_ack_snd_check(sk);
</span><span class='line'>    return 0;</span></code></pre></td></tr></table></div></figure>


<p>先看看tcp_validate_incoming函数，在slow path处理前检查输入数据包的合法性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Does PAWS and seqno based validation of an incoming segment, flags will
</span><span class='line'> * play significant role here.
</span><span class='line'> */
</span><span class='line'>static int tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
</span><span class='line'>                  struct tcphdr *th, int syn_inerr)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>    /* RFC1323: H1. Apply PAWS check first. */
</span><span class='line'>    if (tcp_fast_parse_options(skb, th, tp) && tp-&gt;rx_opt.saw_tstamp &&
</span><span class='line'>        tcp_paws_discard(sk, skb)) {
</span><span class='line'>        if (!th-&gt;rst) {
</span><span class='line'>            NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);
</span><span class='line'>            tcp_send_dupack(sk, skb);
</span><span class='line'>            goto discard;
</span><span class='line'>        }
</span><span class='line'>        /* Reset is accepted even if it did not pass PAWS. */
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Step 1: check sequence number */
</span><span class='line'>    if (!tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) {
</span><span class='line'>        /* RFC793, page 37: "In all states except SYN-SENT, all reset
</span><span class='line'>         * (RST) segments are validated by checking their SEQ-fields."
</span><span class='line'>         * And page 69: "If an incoming segment is not acceptable,
</span><span class='line'>         * an acknowledgment should be sent in reply (unless the RST
</span><span class='line'>         * bit is set, if so drop the segment and return)".
</span><span class='line'>         */
</span><span class='line'>        if (!th-&gt;rst)
</span><span class='line'>            tcp_send_dupack(sk, skb);
</span><span class='line'>        goto discard;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Step 2: check RST bit */
</span><span class='line'>    if (th-&gt;rst) {
</span><span class='line'>        tcp_reset(sk);
</span><span class='line'>        goto discard;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* ts_recent update must be made after we are sure that the packet
</span><span class='line'>     * is in window.
</span><span class='line'>     */
</span><span class='line'>    tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)-&gt;seq);
</span><span class='line'>
</span><span class='line'>    /* step 3: check security and precedence [ignored] */
</span><span class='line'>
</span><span class='line'>    /* step 4: Check for a SYN in window. */
</span><span class='line'>    if (th-&gt;syn && !before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt)) {
</span><span class='line'>        if (syn_inerr)
</span><span class='line'>            TCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONSYN);
</span><span class='line'>        tcp_reset(sk);
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return 1;
</span><span class='line'>
</span><span class='line'>discard:
</span><span class='line'>    __kfree_skb(skb);
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>第一步：检查PAWS tcp_paws_discard</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_paws_discard(const struct sock *sk,
</span><span class='line'>                   const struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    const struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    return ((s32)(tp-&gt;rx_opt.ts_recent - tp-&gt;rx_opt.rcv_tsval) &gt; TCP_PAWS_WINDOW &&
</span><span class='line'>        get_seconds() &lt; tp-&gt;rx_opt.ts_recent_stamp + TCP_PAWS_24DAYS &&
</span><span class='line'>        !tcp_disordered_ack(sk, skb));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>PAWS丢弃数据包要满足以下条件</p>

<p>1 The difference between the timestamp value obtained in the current segmentand last seen timestamp on the incoming TCP segment should be more than TCP_PAWS_WINDOW (= 1), which means that if the segment that was transmitted 1 clock tick before the segment that reached here earlier TCP seq should be acceptable.
It may be because of reordering of the segments that the latter reached earlier.
2 the 24 days have not elapsed since last time timestamp was stored,
3 tcp_disordered_ack返回0.</p>

<h2>以下转载自CU论坛<a href="http://linux.chinaunix.net/bbs/viewthread.php?tid=1130308">http://linux.chinaunix.net/bbs/viewthread.php?tid=1130308</a></h2>

<p>在实际进行PAWS预防时，Linux是通过如下代码调用来完成的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_rcv_established
</span><span class='line'>  |
</span><span class='line'>  |--&gt;tcp_paws_discard
</span><span class='line'>        |
</span><span class='line'>        |--&gt;tcp_disordered_ack</span></code></pre></td></tr></table></div></figure>


<p>其中关键是local方通过tcp_disordered_ack函数对一个刚收到的数据分段进行判断，下面我们对该函数的判断逻辑进行下总结：<br/>
大前提：该收到分段的TS值表明有回绕现象发生<br/>
a）若该分段不是一个纯ACK，则丢弃。因为显然这个分段所携带的数据是一个老数据了，不是local方目前希望接收的（参见PAWS的处理依据一节）<br/>
b）若该分段不是local所希望接收的，则丢弃。这个原因很显然<br/>
c）若该分段是一个纯ACK，但该ACK并不是一个重复ACK（由local方后续数据正确到达所引发的），则丢弃。因为显然该ACK是一个老的ACK，并不是由于为了加快local方重发而在每收到一个丢失分段后的分段而发出的ACK。<br/>
d）若该分段是一个ACK，且为重复ACK，并且该ACK的TS值超过了local方那个丢失分段后的重发rto，则丢弃。因为显然此时local方已经重发了那个导致此重复ACK产生的分段，因此再收到此重复ACK就可以直接丢弃。<br/>
e）若该分段是一个ACK，且为重复ACK，但是没有超过一个rto的时间，则不能丢弃，因为这正代表peer方收到了local方发出的丢失分段后的分段，local方要对此ACK进行处理（例如立刻重传）</p>

<p>  这里有一个重要概念需要理解，即在出现TS问题后，纯ACK和带ACK的数据分段二者是显著不同的，对于后者，可以立刻丢弃掉，因为从一个窗口的某个seq到下一个窗口的同一个seq过程中，一定有窗口变化曾经发生过，从而TS记录值ts_recent也一定更新过，此时一定可以通过PAWS进行丢弃处理。但是对于前者，一个纯ACK，就不能简单丢弃了，因为有这样一个现象是合理的，即假定local方的接收缓存很大，并且peer方在发送时很快就回绕了，于是在local方的某个分段丢失后，peer方需要在每收到的后续分段时发送重复ACK，而此时该重发ACK的ack_seq就是这个丢失分段的序号，而该重发ACK的seq已经是回绕后的重复序号了，尽管此时到底是回绕后的那个重复ACK还是之前的那个同样序号seq的重复ACK，对于local方来都需要处理（立刻启动重发动作），而不能简单丢弃掉。</p>

<hr />

<p>第2步 检查数据包的序号是否正确，该判断失败后调用tcp_send_dupack发送一个duplicate acknowledge（未设置RST标志位时）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_sequence(struct tcp_sock *tp, u32 seq, u32 end_seq)
</span><span class='line'>{
</span><span class='line'>    return  !before(end_seq, tp-&gt;rcv_wup) &&
</span><span class='line'>        !after(seq, tp-&gt;rcv_nxt + tcp_receive_window(tp));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>由rcv_wup的更新时机（发送ACK时的tcp_select_window）可知位于序号rcv_wup前面的数据都已确认，所以待检查数据包的结束序号至少要大于该值；同时开始序号要落在接收窗口内。</p>

<p>第3步 如果设置了RST，则调用tcp_reset处理</p>

<p>第4步 更新ts_recent，</p>

<p>第5步 检查SYN，因为重发的SYN和原来的SYN之间不会发送数据，所以这2个SYN的序号是相同的，如果不满足则reset连接。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/14">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/12">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>12</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(28)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>8</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(120)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>54</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>18</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(18)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(59)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(26)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(115)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/06/12/kernel-net-tcp-close/">linux内核中tcp连接的断开处理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/12/kernel-net-socket-io/">Socket层实现系列 — I/O事件及其处理函数</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/12/kernel-net-socket-wakeup/">Socket层实现系列 — 睡眠驱动的同步等待</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/12/kernel-net-socket-signal/">Socket层实现系列 — 信号驱动的异步等待</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/12/kernel-net-sock-socket/">socket和sock的一些分析</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
