
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/10/10/debug-stap-inodewatch/">如何知道文件被那个进程写</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-10-10T16:27:00+08:00'><span class='date'>2013-10-10</span> <span class='time'>16:27:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一个文件正在被进程写 我想查看这个进程 文件一直在增大 找不到谁在写 使用lsof也没找到</p>

<p>这个问题挺有普遍性的，解决方法应该很多，这里我给大家提个比较直观的方法。</p>

<p>linux下每个文件都会在某个块设备上存放，当然也都有相应的inode, 那么透过vfs.write我们就可以知道谁在不停的写入特定的设备上的inode。</p>

<p>幸运的是systemtap的安装包里带了inodewatch.stp，位于/usr/local/share/doc/systemtap/examples/io目录下，就是用来这个用途的。</p>

<p>我们来看下代码：</p>

<p>$ cat inodewatch.stp</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /usr/bin/env stap
</span><span class='line'> 
</span><span class='line'>probe vfs.write, vfs.read
</span><span class='line'>{
</span><span class='line'>    # dev and ino are defined by vfs.write and vfs.read
</span><span class='line'>    if (dev == MKDEV($1,$2) # major/minor device
</span><span class='line'>        && ino == $3)
</span><span class='line'>    printf ("%s(%d) %s 0x%x/%u\n",
</span><span class='line'>        execname(), pid(), probefunc(), dev, ino)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个脚本的使用方法如下： stap  inodewatch.stp major minor ino</p>

<p>下面我们构造个场景： dd不停的写入一个文件，查出这个文件的ino, 以及它所在设备的major, minor, 运行stap脚本就可以得到答案。</p>

<p>场景交代好了，我们来演示下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pwd
</span><span class='line'>/home/chuba
</span><span class='line'>$ df
</span><span class='line'>Filesystem           1K-blocks      Used Available Use% Mounted on
</span><span class='line'>...
</span><span class='line'>/dev/sdb1            1621245336 825209568 713681236  54% /home
</span><span class='line'>...
</span><span class='line'>$ ls -al /dev/sdb1
</span><span class='line'>brw-rw---- 1 root disk 8, 17 Oct 24 11:22 /dev/sdb1 
</span><span class='line'>$ rm -f test.dat && dd if=/dev/zero of=test.dat
</span><span class='line'>^C9912890+0 records in
</span><span class='line'>9912890+0 records out
</span><span class='line'>5075399680 bytes (5.1 GB) copied, 26.8189 s, 189 MB/s</span></code></pre></td></tr></table></div></figure>


<p>这个终端模拟文件的不停写入，同时在另外一个终端查验谁干的。这里我们已经知道设备的major/minor为8/17</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ stat -c '%i' test.dat
</span><span class='line'>25337884
</span><span class='line'>$ sudo stap /usr/local/share/doc/systemtap/examples/io/inodewatch.stp 8 17 25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>dd(740) vfs_write 0x800011/25337884
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>看到了吧，dd是罪魁祸首，pid是740</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/10/10/debug-debugfs/">通过blktrace, debugfs分析磁盘IO</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-10-10T16:25:00+08:00'><span class='date'>2013-10-10</span> <span class='time'>16:25:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>如何通过blktrace+debugfs找到发生IO的文件，然后再结合自己的应用程序，分析出这些IO到底是 谁产生的，最终目的当然是尽量减少不必要的IO干扰，提高程序的性能。</p>

<p>blktrace是Jens Axobe写的一个跟踪IO请求的工具，Linux系统发起的IO请求都可以通过blktrace捕获并分析，关于这个工具的介绍请自行google之，这里推荐我们部门的<a href="http://blog.yufeng.info/">褚霸</a>同学的blog，里面有好几篇文章分别介绍了blktrace, blkparse以及blkiomon等工具的使用。</p>

<p>debugfs是ext2, ext3, ext4文件系统提供的文件系统访问工具，通过它我们可以不通过mount文件系统而直接访问文件系统的内容，它是e2fsprogs的一部分，默认应该都是安装的，详细的说明可以通过man debugfs得到。</p>

<p>下面我来演示一下如何通过这两个工具的配合来找到磁盘IO的源头。</p>

<p>先看一个简单的例子：<br/>
在一个终端会输入如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while [ 1 ];do dd if=/dev/zero of=test_file bs=4k count=20 seek=$RANDOM oflag=sync;done</span></code></pre></td></tr></table></div></figure>


<p>随机的在test_file里面写数据造成较大的IO压力，现在看看如何通过blktrace和debugfs抓到它。</p>

<p>1、通过iostat观察到有很大的磁盘压力</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
</span><span class='line'>sdb               0.00  2759.00    0.00 3515.50     0.00 50196.00    14.28     0.90    0.26   0.24  85.70</span></code></pre></td></tr></table></div></figure>


<p>2、我们看到sdb压力很大，这时候就需要通过blktrace抓取对应盘的数据<br/>
  blktrace /dev/sdb   有IO压力的时候一会儿就可以了，通过ctrl+c停止抓取。<br/>
  blktrace是需要debugfs支持的，如果系统提示debugfs没有mount，需要先mount上<br/>
  mount -t debugfs none /sys/kernel/debug 再执行blktrace命令</p>

<p>3、将blktrace抓出来的二进制文件转成文本格式。<br/>
  blkparse sdb.blktrace.* > 1.log<br/>
或blktrace  -d /dev/sda -o - |blkparse -i - > 1.log</p>

<p>4、开始分析日志</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  grep ‘ A ‘ 1.log|head -n 5
</span><span class='line'>
</span><span class='line'>8,16   0       39     0.001242727  2872  A  WS 420143 + 8 &lt;- (8,17) 420080
</span><span class='line'>8,16   0       52     0.001361766  2872  A  WS 420151 + 8 &lt;- (8,17) 420088
</span><span class='line'>8,16   0       65     0.001440210  2872  A  WS 420159 + 8 &lt;- (8,17) 420096
</span><span class='line'>8,16   0       78     0.001518207  2872  A  WS 420167 + 8 &lt;- (8,17) 420104
</span><span class='line'>8,16   0       91     0.001596083  2872  A  WS 420175 + 8 &lt;- (8,17) 420112</span></code></pre></td></tr></table></div></figure>


<p>为啥要grep ‘ A ‘呢？因为这条信息是上层一个读写请求进入到Linux IO协议栈的第一步，只有在这里我们可以看到清晰的请求原始信息。比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>8,16   0       39     0.001242727  2872  A  WS 420143 + 8 &lt;- (8,17) 420080</span></code></pre></td></tr></table></div></figure>


<p>这条说明是设备（8，17）也就是sdb1上产生的扇区为420080的写请求（读请求的话会在WS对应的位置出现‘R’），长度是8，它被映射到（8，16）上位置为420143。这个IO请求的完整生命周期是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 8,16   0       39     0.001242727  2872  A  WS 420143 + 8 &lt;- (8,17) 420080
</span><span class='line'> 8,16   0       41     0.001244984  2872  G  WS 420143 + 8 [dd]
</span><span class='line'> 8,16   0       43     0.001246609  2872  I  WS 420143 + 8 [dd]
</span><span class='line'> 8,16   0       45     0.001255064  2872  D  WS 420143 + 8 [dd]
</span><span class='line'> 8,16   0       46     0.001325168     0  C  WS 420143 + 8 [0]</span></code></pre></td></tr></table></div></figure>


<p>可以看到从’ A ‘的下一条开始都是以整个设备的扇区号为标识的，不方便我们找到对应的分区。</p>

<p>5、下面就开始通过debugfs来分析这条读写请求的来源了。
(8, 17)是sdb1, 420080是扇区号(IO层的基本单位是扇区sector，大小是512bytes)，而文件系统层是通过块block来管理的，一般的 ext3,ext4的块block大小是4096[1]，由此可得这个请求对应到文件系统的块block号是420080/8=52510, debugfs提供了命令icheck可以通过block号找到它对应的文件的inode。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#debugfs -R ‘icheck 52510′ /dev/sdb1
</span><span class='line'>debugfs 1.43-WIP (1-Aug-2012)
</span><span class='line'>Block Inode number
</span><span class='line'>52510 12</span></code></pre></td></tr></table></div></figure>


<p>6、通过inode number找到对应的文件名，很幸运，debugfs又提供了另外一条命令ncheck可以找到inode对应的文件名[2]。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#debugfs -R ‘ncheck 12′ /dev/sdb1
</span><span class='line'>debugfs 1.43-WIP (1-Aug-2012)
</span><span class='line'>Inode Pathname
</span><span class='line'>12 //test_file</span></code></pre></td></tr></table></div></figure>


<p>大家可以看到，我们现在已经成功找到了test_file这个文件啦，至此块设备层和文件系统层的分析工作已经结束了，下面就可以结合应用看看为啥会对这个文件有如此频繁的读写操作了！</p>

<p>[1] 块大小实际上也能够通过debugfs来得到。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>debugfs -R ‘stats’ /dev/sdb1|grep “Block size”</span></code></pre></td></tr></table></div></figure>


<p>[2] 有的同学找到的inode number是8，然后却无法找到对应的文件名。这是因为8是ext3/4文件系统中的日志文件的inode，它是隐藏文件，所以无法找到，可以再试试其他的block号哦！</p>

<p>根据inode你就可以找到对应的文件是什么了<br/>
find / -inum your_inode</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/27/kernel-net-tcp-timer/">内核tcp的定时器管理</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-27T16:11:00+08:00'><span class='date'>2013-09-27</span> <span class='time'>16:11:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h5>在内核中tcp协议栈有6种类型的定时器：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 重传定时器。
</span><span class='line'>2 delayed ack定时器
</span><span class='line'>3 零窗口探测定时器
</span><span class='line'>上面三种定时器都是作为tcp状态机的一部分来实现的。
</span><span class='line'>4 keep-alive 定时器 主要是管理established状态的连接。
</span><span class='line'>5 time_wait定时器 主要是用来客户端关闭时的time_wait状态用到。
</span><span class='line'>6 syn-ack定时器(主要是用在listening socket) 管理新的连接请求时所用到。</span></code></pre></td></tr></table></div></figure>


<h5>而在内核中，tcp协议栈管理定时器主要有下面4个函数：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inet_csk_reset_xmit_timer    这个函数是用来重启定时器
</span><span class='line'>inet_csk_clear_xmit_timer 这个函数用来删除定时器。
</span><span class='line'>上面两个函数都是针对状态机里面的定时器。
</span><span class='line'>tcp_set_keepalive 这个函数是用来管理keepalive 定时器的接口。
</span><span class='line'>tcp_synack_timer  这个函数是用来管理syn_ack定时器的接口。</span></code></pre></td></tr></table></div></figure>


<h5>先来看定时器的初始化。</h5>

<p>首先是在tcp_v4_init_sock中对定时器的初始化，它会调用tcp_init_xmit_timers，我们就先来看这个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_init_xmit_timers(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    inet_csk_init_xmit_timers(sk, &tcp_write_timer, &tcp_delack_timer, &tcp_keepalive_timer);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到这个函数很简单，就是调用inet_csk_init_xmit_timers,然后把3个定时器的回掉函数传递进去，下面我们来看inet_csk_init_xmit_timers。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void inet_csk_init_xmit_timers(struct sock *sk,
</span><span class='line'>                    void (*retransmit_handler)(unsigned long),
</span><span class='line'>                    void (*delack_handler)(unsigned long),
</span><span class='line'>                    void (*keepalive_handler)(unsigned long))
</span><span class='line'>{
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>    //安装定时器，设置定时器的回掉函数。
</span><span class='line'>    setup_timer(&icsk-&gt;icsk_retransmit_timer, retransmit_handler, (unsigned long)sk);
</span><span class='line'>    setup_timer(&icsk-&gt;icsk_delack_timer, delack_handler, (unsigned long)sk);
</span><span class='line'>    setup_timer(&sk-&gt;sk_timer, keepalive_handler, (unsigned long)sk);
</span><span class='line'>    icsk-&gt;icsk_pending = icsk-&gt;icsk_ack.pending = 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我 们可以看到icsk->icsk_retransmit_timer定时器，也就是重传定时器的回调函数是tcp_write_timer,而 icsk->icsk_delack_timer定时器也就是delayed-ack 定时器的回调函数是tcp_delack_timer,最后sk->sk_timer也就是keepalive定时器的回掉函数是 tcp_keepalive_timer.<br/>
这里还有一个要注意的，tcp_write_timer还会处理0窗口定时器。<br/>
这里有关内核定时器的一些基础的东西我就不介绍了，想了解的可以去看下ldd第三版。<br/>
接下来我们就来一个个的分析这6个定时器，首先是重传定时器。<br/>
我们知道4层最终调用tcp_xmit_write来讲数据发送到3层，并且tcp是字节流的，因此每次他总是发送一段数据到3层，而每次当它发送完毕(返回正确),则它就会启动重传定时器，我们来看代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_write_xmit(struct sock *sk, unsigned int mss_now, int nonagle,
</span><span class='line'>              int push_one, gfp_t gfp)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>    unsigned int tso_segs, sent_pkts;
</span><span class='line'>    int cwnd_quota;
</span><span class='line'>    int result;
</span><span class='line'>
</span><span class='line'>.............................................
</span><span class='line'>
</span><span class='line'>    while ((skb = tcp_send_head(sk))) {
</span><span class='line'>..................................................
</span><span class='line'>
</span><span class='line'>        //可以看到只有当传输成功，我们才会走到下面的函数。
</span><span class='line'>        if (unlikely(tcp_transmit_skb(sk, skb, 1, gfp)))
</span><span class='line'>            break;
</span><span class='line'>
</span><span class='line'>        /* Advance the send_head.  This one is sent out.
</span><span class='line'>         * This call will increment packets_out.
</span><span class='line'>         */
</span><span class='line'>        //最终在这个函数中启动重传定时器。
</span><span class='line'>        tcp_event_new_data_sent(sk, skb);
</span><span class='line'>
</span><span class='line'>        tcp_minshall_update(tp, mss_now, skb);
</span><span class='line'>        sent_pkts++;
</span><span class='line'>
</span><span class='line'>        if (push_one)
</span><span class='line'>            break;
</span><span class='line'>    }
</span><span class='line'>...........................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在我们来看tcp_event_new_data_sent,如何启动定时器的.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_event_new_data_sent(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    unsigned int prior_packets = tp-&gt;packets_out;
</span><span class='line'>
</span><span class='line'>    tcp_advance_send_head(sk, skb);
</span><span class='line'>    tp-&gt;snd_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>
</span><span class='line'>    /* Don't override Nagle indefinately with F-RTO */
</span><span class='line'>    if (tp-&gt;frto_counter == 2)
</span><span class='line'>        tp-&gt;frto_counter = 3;
</span><span class='line'>    //关键在这里.
</span><span class='line'>    tp-&gt;packets_out += tcp_skb_pcount(skb);
</span><span class='line'>    if (!prior_packets)
</span><span class='line'>        inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到只有当prior_packets为0时才会重启定时器,而prior_packets则是发送未确认的段的个数,也就是说如果发送了很多段,如果前面的段没有确认,那么后面发送的时候不会重启这个定时器.<br/>
我们要知道，定时器的间隔是通过rtt来得到的，具体的算法，可以看下tcp/ip详解。<br/>
当 启动了重传定时器，我们就会等待ack的到来，如果超时还没到来，那么就调用重传定时器的回调函数，否则最终会调用tcp_rearm_rto来删除或者 重启定时器，这个函数是在tcp_ack()->tcp_clean_rtx_queue()中被调用的。tcp_ack是专门用来处理ack。<br/>
这个函数很简单，就是通过判断packets_out，这个值表示当前还未确认的段的个数。然后来进行相关操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_rearm_rto(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>    //为0说明所有的传输的段都已经acked。此时remove定时器。否则重启定时器。
</span><span class='line'>    if (!tp-&gt;packets_out) {
</span><span class='line'>        inet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);
</span><span class='line'>    } else {
</span><span class='line'>        inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
</span><span class='line'>                      inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  接下来来看tcp_write_timer的实现。这个函数主要是通过icsk->icsk_pending来判断是那个定时器导致超时，这里只有两 种，一种是ICSK_TIME_RETRANS，也就是重传定时器，另一种是ICSK_TIME_PROBE0也就是0窗口定时器。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define ICSK_TIME_RETRANS   1   /* Retransmit timer */
</span><span class='line'>#define ICSK_TIME_PROBE0    3   /* Zero window probe timer */
</span><span class='line'>static void tcp_write_timer(unsigned long data)
</span><span class='line'>{
</span><span class='line'>    struct sock *sk = (struct sock *)data;
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    int event;
</span><span class='line'>
</span><span class='line'>    //首先加锁。
</span><span class='line'>    bh_lock_sock(sk);
</span><span class='line'>    //如果是进程空间则什么也不做。
</span><span class='line'>    if (sock_owned_by_user(sk)) {
</span><span class='line'>        /* Try again later */
</span><span class='line'>        sk_reset_timer(sk, &icsk-&gt;icsk_retransmit_timer, jiffies + (HZ / 20));
</span><span class='line'>        goto out_unlock;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //如果状态为close或者icsk_pending为空，则什么也不做。
</span><span class='line'>    if (sk-&gt;sk_state == TCP_CLOSE || !icsk-&gt;icsk_pending)
</span><span class='line'>        goto out;
</span><span class='line'>    //如果超时时间已经过了，则重启定时器。
</span><span class='line'>
</span><span class='line'>    if (time_after(icsk-&gt;icsk_timeout, jiffies)) {
</span><span class='line'>        sk_reset_timer(sk, &icsk-&gt;icsk_retransmit_timer, icsk-&gt;icsk_timeout);
</span><span class='line'>        goto out;
</span><span class='line'>    }
</span><span class='line'>    //取出定时器类型。
</span><span class='line'>    event = icsk-&gt;icsk_pending;
</span><span class='line'>    icsk-&gt;icsk_pending = 0;
</span><span class='line'>
</span><span class='line'>    //通过判断event来确定进入那个函数进行处理。
</span><span class='line'>    switch (event) {
</span><span class='line'>    case ICSK_TIME_RETRANS:
</span><span class='line'>        tcp_retransmit_timer(sk);
</span><span class='line'>        break;
</span><span class='line'>    case ICSK_TIME_PROBE0:
</span><span class='line'>        tcp_probe_timer(sk);
</span><span class='line'>        break;
</span><span class='line'>    }
</span><span class='line'>    TCP_CHECK_TIMER(sk);
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>    sk_mem_reclaim(sk);
</span><span class='line'>out_unlock:
</span><span class='line'>    bh_unlock_sock(sk);
</span><span class='line'>    sock_put(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们这里只看重传定时器，0窗口定时器后面紧接着会介绍。<br/>
tcp_retransmit_timer,这个函数用来处理数据段的重传。<br/>
这里要注意，重传的时候为了防止确认二义性，使用karn算法，也就是定时器退避策略。下面的代码最后部分会修改定时器的值，这里是增加一倍。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_retransmit_timer(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>    //如果没有需要确认的段，则什么也不做。
</span><span class='line'>    if (!tp-&gt;packets_out)
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    WARN_ON(tcp_write_queue_empty(sk));
</span><span class='line'>
</span><span class='line'>    /**首先进行一些合法性判断，其中:
</span><span class='line'>     * snd_wnd为窗口大小。
</span><span class='line'>     * sock_flag用来判断sock的状态。
</span><span class='line'>     * 最后一个判断是当前的连接状态不能处于syn_sent和syn_recv状态,也就是连接还未建
</span><span class='line'>     * 立状态.
</span><span class='line'>    if (!tp-&gt;snd_wnd && !sock_flag(sk, SOCK_DEAD) &&
</span><span class='line'>        !((1 &lt;&lt; sk-&gt;sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV))) {
</span><span class='line'>        //tcp_time_stamp也就是jifes，而rcv_tstamp表示最后一个ack接收的时间，也就是最后一次对端确认的时间。因此这两个时间之差不能大于tcp_rto_max,因为tcp_rto_max为我们重传定时器的间隔时间的最大值。
</span><span class='line'>        if (tcp_time_stamp - tp-&gt;rcv_tstamp &gt; TCP_RTO_MAX) {
</span><span class='line'>            tcp_write_err(sk);
</span><span class='line'>            goto out;
</span><span class='line'>        }
</span><span class='line'>        //这个函数用来进入loss状态，也就是进行一些拥塞以及流量的控制。
</span><span class='line'>        tcp_enter_loss(sk, 0);
</span><span class='line'>        //现在开始重传skb。
</span><span class='line'>        tcp_retransmit_skb(sk, tcp_write_queue_head(sk));
</span><span class='line'>        __sk_dst_reset(sk);
</span><span class='line'>        //然后重启定时器，继续等待ack的到来。
</span><span class='line'>        goto out_reset_timer;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //程序到达这里说明上面的校验失败，因此下面这个函数用来判断我们重传需要的次数。如果超过了重传次数，直接跳转到out。
</span><span class='line'>    if (tcp_write_timeout(sk))
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    //到达这里说明我们重传的次数还没到。icsk-&gt;icsk_retransmits表示重传的次数。
</span><span class='line'>    if (icsk-&gt;icsk_retransmits == 0) {
</span><span class='line'>        //这里其实也就是收集一些统计信息。
</span><span class='line'>        int mib_idx;
</span><span class='line'>
</span><span class='line'>        if (icsk-&gt;icsk_ca_state == TCP_CA_Disorder) {
</span><span class='line'>            if (tcp_is_sack(tp))
</span><span class='line'>                mib_idx = LINUX_MIB_TCPSACKFAILURES;
</span><span class='line'>            else
</span><span class='line'>                mib_idx = LINUX_MIB_TCPRENOFAILURES;
</span><span class='line'>        } else if (icsk-&gt;icsk_ca_state == TCP_CA_Recovery) {
</span><span class='line'>            if (tcp_is_sack(tp))
</span><span class='line'>                mib_idx = LINUX_MIB_TCPSACKRECOVERYFAIL;
</span><span class='line'>            else
</span><span class='line'>                mib_idx = LINUX_MIB_TCPRENORECOVERYFAIL;
</span><span class='line'>        } else if (icsk-&gt;icsk_ca_state == TCP_CA_Loss) {
</span><span class='line'>            mib_idx = LINUX_MIB_TCPLOSSFAILURES;
</span><span class='line'>        } else {
</span><span class='line'>            mib_idx = LINUX_MIB_TCPTIMEOUTS;
</span><span class='line'>        }
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), mib_idx);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //是否使用f-rto算法。
</span><span class='line'>    if (tcp_use_frto(sk)) {
</span><span class='line'>        tcp_enter_frto(sk);
</span><span class='line'>    } else {
</span><span class='line'>        //否则处理sack.
</span><span class='line'>        tcp_enter_loss(sk, 0);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 再次尝试重传队列的第一个段。
</span><span class='line'>    if (tcp_retransmit_skb(sk, tcp_write_queue_head(sk)) &gt; 0) {
</span><span class='line'>        //重传失败。
</span><span class='line'>        if (!icsk-&gt;icsk_retransmits)
</span><span class='line'>            icsk-&gt;icsk_retransmits = 1;
</span><span class='line'>        inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
</span><span class='line'>                      min(icsk-&gt;icsk_rto, TCP_RESOURCE_PROBE_INTERVAL),
</span><span class='line'>                      TCP_RTO_MAX);
</span><span class='line'>        goto out;
</span><span class='line'>    }
</span><span class='line'>    //icsk-&gt;icsk_backoff主要用在零窗口定时器。
</span><span class='line'>    icsk-&gt;icsk_backoff++;
</span><span class='line'>    //icsk_retransmits也就是重试次数。
</span><span class='line'>    icsk-&gt;icsk_retransmits++;
</span><span class='line'>
</span><span class='line'>out_reset_timer:
</span><span class='line'>    //计算rto，并重启定时器，这里使用karn算法，也就是下次超时时间增加一倍/
</span><span class='line'>    icsk-&gt;icsk_rto = min(icsk-&gt;icsk_rto &lt;&lt; 1, TCP_RTO_MAX);
</span><span class='line'>    //重启定时器，可以看到超时时间就是我们上面的icsk_rto.
</span><span class='line'>    inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, icsk-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>    if (icsk-&gt;icsk_retransmits &gt; sysctl_tcp_retries1)
</span><span class='line'>        __sk_dst_reset(sk);
</span><span class='line'>
</span><span class='line'>out:;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面我们来看tcp_write_timeout，它用来判断重传次数是否已经到了。这里主要分为两个分支，一个是状态为syn_sent或者syn_recv状态，一个是另外的状态。而这里系统设置的重传次数一共有4种。<br/>
1 sysctl_tcp_syn_retries，它表示syn分节的重传次数。<br/>
2 sysctl_tcp_retries1 它表示的是最大的重试次数，当超过了这个值，我们就需要检测路由表了。<br/>
3 sysctl_tcp_retries2 这个值也是表示重试最大次数，只不过这个值一般要比上面的值大。和上面那个不同的是，当重试次数超过这个值，我们就必须放弃重试了。<br/>
4 sysctl_tcp_orphan_retries 主要是针对孤立的socket(也就是已经从进程上下文中删除了，可是还有一些清理工作没有完成).对于这种socket，我们重试的最大的次数就是它。<br/>
下面来看代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_write_timeout(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    //retry_untry表示我们需要重传的最大次数。
</span><span class='line'>    int retry_until;
</span><span class='line'>
</span><span class='line'>    //判断socket状态。
</span><span class='line'>    if ((1 &lt;&lt; sk-&gt;sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
</span><span class='line'>        if (icsk-&gt;icsk_retransmits)
</span><span class='line'>            dst_negative_advice(&sk-&gt;sk_dst_cache);
</span><span class='line'>        //设置重传最大值
</span><span class='line'>        retry_until = icsk-&gt;icsk_syn_retries ? : sysctl_tcp_syn_retries;
</span><span class='line'>    } else {
</span><span class='line'>        //是否需要检测路由表。
</span><span class='line'>        if (icsk-&gt;icsk_retransmits &gt;= sysctl_tcp_retries1) {
</span><span class='line'>            /* Black hole detection */
</span><span class='line'>            tcp_mtu_probing(icsk, sk);
</span><span class='line'>
</span><span class='line'>            dst_negative_advice(&sk-&gt;sk_dst_cache);
</span><span class='line'>        }
</span><span class='line'>        //设置重传最大次数为sysctl_tcp_retries2
</span><span class='line'>        retry_until = sysctl_tcp_retries2;
</span><span class='line'>        if (sock_flag(sk, SOCK_DEAD)) {
</span><span class='line'>            //表示是一个孤立的socket。
</span><span class='line'>            const int alive = (icsk-&gt;icsk_rto &lt; TCP_RTO_MAX);
</span><span class='line'>
</span><span class='line'>            //从tcp_orphan_retries(这个函数中会通过sysctl_tcp_orphan_retries来进行计算)中取得重传最大次数。
</span><span class='line'>            retry_until = tcp_orphan_retries(sk, alive);
</span><span class='line'>
</span><span class='line'>            if (tcp_out_of_resources(sk, alive || icsk-&gt;icsk_retransmits &lt; retry_until))
</span><span class='line'>                return 1;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //最终进行判断，如果重传次数已到则返回1,否则为0.
</span><span class='line'>    if (icsk-&gt;icsk_retransmits &gt;= retry_until) {
</span><span class='line'>        /* Has it gone just too far? */
</span><span class='line'>        tcp_write_err(sk);
</span><span class='line'>        return 1;
</span><span class='line'>    }
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面来介绍下tcp_enter_loss，这个函数主要用来标记丢失的段(也就是没有acked的段),然后通过执行slow start来降低传输速率.<br/>
有关slow start以及Congestion avoidance算法描述可以看rfc2001:<br/>
<a href="http://www.faqs.org/rfcs/rfc2001.html">http://www.faqs.org/rfcs/rfc2001.html</a></p>

<p>下面4个算法主要是用来对拥塞进行控制的，这四个算法其实都是彼此相连的。slow start和Congestion avoidance使用了相同的机制，他们都涉及到了拥塞窗口的定义。其中拥塞窗口限制着传输的长度，它的大小根据拥塞程度上升或者下降。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Slow start
</span><span class='line'>Congestion avoidance
</span><span class='line'>Fast re-transmit
</span><span class='line'>Fast recovery</span></code></pre></td></tr></table></div></figure>


<p>然后下面主要是介绍了slow start和Congestion avoidance的一些实现细节。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CWND - Sender side limit
</span><span class='line'>RWND - Receiver side limit
</span><span class='line'>Slow start threshold ( SSTHRESH ) - Used to determine whether slow start is used or congestion avoidance
</span><span class='line'>When starting, probe slowly - IW &lt;= 2 * SMSS
</span><span class='line'>Initial size of SSTHRESH can be arbitrarily high, as high as the RWND
</span><span class='line'>Use slow start when SSTHRESH &gt; CWND. Else, use Congestion avoidance
</span><span class='line'>Slow start - CWND is increased by an amount less than or equal to the SMSS for every ACK
</span><span class='line'>Congestion avoidance - CWND += SMSS*SMSS/CWND
</span><span class='line'>When loss is detected - SSTHRESH = max( FlightSize/2, 2*SMSS )</span></code></pre></td></tr></table></div></figure>


<p>这里要注意在slow start中，窗口的大小是指数级的增长的。并且当cwnd(拥塞窗口)小于等于ssthresh，就是slow start模式，否则就执行Congestion avoidance。</p>

<h5>现在我们来看tcp_enter_loss的实现。</h5>

<p>首先来介绍下下面要用到的几个关键域的含义。<br/>
1 icsk->icsk_ca_state 这个域表示拥塞控制的状态。<br/>
2 tp->snd_una 这个域表示tcp滑动窗口中的发送未确认的第一个字节的序列号。<br/>
3 tp->prior_ssthresh 这个域表示前一个snd_ssthresh得大小，也就是说每次改变snd_ssthresh前都要保存老的snd_ssthresh到这个域。<br/>
4 tp->snd_ssthresh  slow start开始时的threshold大小<br/>
5 tp->snd_cwnd_cnt 这个域表示拥塞窗口的大小。<br/>
6 TCP_SKB_CB(skb)->sacked tcp数据中的sack标记。<br/>
7 tp->high_seq 拥塞开始时，snd_nxt的大小。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_enter_loss(struct sock *sk, int how)
</span><span class='line'>{
</span><span class='line'>    const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    /* 1 拥塞控制状态小于TCP_CA_Disorder
</span><span class='line'>     * 2 发送未确认的序列号等于拥塞开始时的下一个将要发送的序列号
</span><span class='line'>     * 3 状态为TCP_CA_Loss，并且还未重新传输过。
</span><span class='line'>     * 如果有一个满足说明有数据丢失,因此降低threshold。
</span><span class='line'>     */
</span><span class='line'>    if (icsk-&gt;icsk_ca_state &lt;= TCP_CA_Disorder || tp-&gt;snd_una == tp-&gt;high_seq ||
</span><span class='line'>        (icsk-&gt;icsk_ca_state == TCP_CA_Loss && !icsk-&gt;icsk_retransmits)) {
</span><span class='line'>        //保存老的snd_ssthresh。
</span><span class='line'>        tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk);
</span><span class='line'>        //减小snd_ssthresh
</span><span class='line'>        tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);
</span><span class='line'>        //设置拥塞状态。
</span><span class='line'>        tcp_ca_event(sk, CA_EVENT_LOSS);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //设置拥塞窗口大小
</span><span class='line'>    tp-&gt;snd_cwnd    = 1;
</span><span class='line'>    tp-&gt;snd_cwnd_cnt   = 0;
</span><span class='line'>    //设置时间
</span><span class='line'>    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
</span><span class='line'>
</span><span class='line'>    tp-&gt;bytes_acked = 0;
</span><span class='line'>    //清空所有相关的计数器。
</span><span class='line'>    tcp_clear_retrans_partial(tp);
</span><span class='line'>
</span><span class='line'>    if (tcp_is_reno(tp))
</span><span class='line'>        tcp_reset_reno_sack(tp);
</span><span class='line'>
</span><span class='line'>    if (!how) {
</span><span class='line'>        /* Push undo marker, if it was plain RTO and nothing
</span><span class='line'>         * was retransmitted. */
</span><span class='line'>        tp-&gt;undo_marker = tp-&gt;snd_una;
</span><span class='line'>    } else {
</span><span class='line'>        tp-&gt;sacked_out = 0;
</span><span class='line'>        tp-&gt;fackets_out = 0;
</span><span class='line'>    }
</span><span class='line'>    tcp_clear_all_retrans_hints(tp);
</span><span class='line'>
</span><span class='line'>    //遍历sock的write队列。
</span><span class='line'>    tcp_for_write_queue(skb, sk) {
</span><span class='line'>        if (skb == tcp_send_head(sk))
</span><span class='line'>            break;
</span><span class='line'>        //判断sack段。
</span><span class='line'>        if (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_RETRANS)
</span><span class='line'>            tp-&gt;undo_marker = 0;
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;sacked &= (~TCPCB_TAGBITS)|TCPCB_SACKED_ACKED;
</span><span class='line'>
</span><span class='line'>        //如果how为1,则说明不管sack段，此时标记所有的段为丢失(sack的意思去看tcp/ip详解).
</span><span class='line'>        if (!(TCP_SKB_CB(skb)-&gt;sacked&TCPCB_SACKED_ACKED) || how) {
</span><span class='line'>            //设置sack段。
</span><span class='line'>            TCP_SKB_CB(skb)-&gt;sacked &= ~TCPCB_SACKED_ACKED;
</span><span class='line'>            TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST;
</span><span class='line'>            //update 相关的域。
</span><span class='line'>            tp-&gt;lost_out += tcp_skb_pcount(skb);
</span><span class='line'>            tp-&gt;retransmit_high = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    tcp_verify_left_out(tp);
</span><span class='line'>    //设置当前的reordering的长度
</span><span class='line'>    tp-&gt;reordering = min_t(unsigned int, tp-&gt;reordering,
</span><span class='line'>                   sysctl_tcp_reordering);
</span><span class='line'>    //设置拥塞状态。
</span><span class='line'>    tcp_set_ca_state(sk, TCP_CA_Loss);
</span><span class='line'>    tp-&gt;high_seq = tp-&gt;snd_nxt;
</span><span class='line'>    //由于我们修改了拥塞窗口，因此设置ecn状态。
</span><span class='line'>    TCP_ECN_queue_cwr(tp);
</span><span class='line'>    /* Abort F-RTO algorithm if one is in progress */
</span><span class='line'>    tp-&gt;frto_counter = 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接 下来来看零窗口探测定时器。至于为什么会出现零窗口，这里就不阐述了，详细的可以去看tcp/ip详解。我们知道当0窗口之后,客户机会等待服务器端的窗 口打开报文，可是由于ip是不可靠的，有可能这个报文会丢失，因此就需要客户机发送一个探测段，用来提醒服务器及时汇报当前的窗口大小。这里我们知道当对 端接收窗口关闭后，我们这边的发送窗口也会关闭，此时不能发送任何一般的数据，除了探测段。<br/>
在内核中是通过tcp_ack_probe来控制零窗口的定时器的。也就是说接收到对端的窗口报告数据后，会进入这个函数。我们来看实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_ack_probe(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    const struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    //首先判断是否对端的接收窗口是否已经有空间。
</span><span class='line'>    if (!after(TCP_SKB_CB(tcp_send_head(sk))-&gt;end_seq, tcp_wnd_end(tp))) {
</span><span class='line'>        //如果有空间则删除零窗口探测定时器。
</span><span class='line'>        icsk-&gt;icsk_backoff = 0;
</span><span class='line'>        inet_csk_clear_xmit_timer(sk, ICSK_TIME_PROBE0);
</span><span class='line'>        /* Socket must be waked up by subsequent tcp_data_snd_check().
</span><span class='line'>         * This function is not for random using!
</span><span class='line'>         */
</span><span class='line'>    } else {
</span><span class='line'>        //否则启动定时器。
</span><span class='line'>        inet_csk_reset_xmit_timer(sk, ICSK_TIME_PROBE0,
</span><span class='line'>                      min(icsk-&gt;icsk_rto &lt;&lt; icsk-&gt;icsk_backoff, TCP_RTO_MAX),
</span><span class='line'>                      TCP_RTO_MAX);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们知道零窗口定时器和重传的定时器是一个定时器，只不过在回调函数中，进行event判断，从而进入不同的处理。而它调用的是tcp_probe_timer函数。<br/>
这个函数主要就是用来发送探测包，我们来看它的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_probe_timer(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    int max_probes;
</span><span class='line'>    /* 1 tp-&gt;packets_out不为0说明，当定时器被安装之后，对端的接收窗口已经被打开。这* 时就不需要传输探测包。
</span><span class='line'>     * 2 tcp_send_head用来检测是否有新的段被传输。
</span><span class='line'>     * 如果上面有一个满足，则不需要发送探测包，并直接返回。
</span><span class='line'>     */
</span><span class='line'>    if (tp-&gt;packets_out || !tcp_send_head(sk)) {
</span><span class='line'>        icsk-&gt;icsk_probes_out = 0;
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //设置最大的重试次数。
</span><span class='line'>    max_probes = sysctl_tcp_retries2;
</span><span class='line'>
</span><span class='line'>    //这里的处理和上面的tcp_write_timeout很类似。
</span><span class='line'>    if (sock_flag(sk, SOCK_DEAD)) {
</span><span class='line'>        const int alive = ((icsk-&gt;icsk_rto &lt;&lt; icsk-&gt;icsk_backoff) &lt; TCP_RTO_MAX);
</span><span class='line'>
</span><span class='line'>        max_probes = tcp_orphan_retries(sk, alive);
</span><span class='line'>
</span><span class='line'>        if (tcp_out_of_resources(sk, alive || icsk-&gt;icsk_probes_out &lt;= max_probes))
</span><span class='line'>            return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //如果重试次数大于最大的重试次数，则报错。
</span><span class='line'>    if (icsk-&gt;icsk_probes_out &gt; max_probes) {
</span><span class='line'>        tcp_write_err(sk);
</span><span class='line'>    } else {
</span><span class='line'>        /* Only send another probe if we didn't close things up. */
</span><span class='line'>    //否则发送探测包。这个函数里面会发送探测包，并重启定时器。
</span><span class='line'>        tcp_send_probe0(sk);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然 后来看delay ack定时器。所谓的delay ack也就是ack不会马上发送，而是等待一段时间和数据一起发送，这样就减少了一个数据包的发送。这里一般是将ack包含在tcp option中发送的。这里的定时器就是用来控制这段时间，如果定时器到期，都没有数据要发送给对端，此时单独发送这个ack。如果在定时器时间内，有数 据要发送，此时这个ack和数据一起发送给对端。<br/>
前面我们知道delay ack定时器的回调函数是tcp_delack_timer。在分析这个函数之前，我们先来看下这个定时器是什么时候被启动的。<br/>
首先我们知道内核接收数据都是在tcp_rcv_eastablished实现的，当我们接收完数据后，此时进入是否进行delay ack.<br/>
在tcp_rcv_eastablished最终会调用__tcp_ack_snd_check进行判断。<br/>
可以看到这个函数很简单，就是判断是否需要发送delay ack，如果是则tcp_send_delayed_ack，否则直接发送ack恢复给对端。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>/* 1 第一个判断表示多于一个的段在等待ack，并且我们的receive buf有足够的空间，
</span><span class='line'> *   这是因为这种情况，表明应用程序读取比较快，而对端的发送速度依赖于ack的到达时间，* 因此我们不希望对端减慢速度。
</span><span class='line'> * 2 这个sock处在quickack 模式
</span><span class='line'> * 3 我们有 out-of-order数据,此时必须马上给对端以确认。
</span><span class='line'> *   当上面的任意一个为真，则立即发送ack。
</span><span class='line'>**/
</span><span class='line'>    if (((tp-&gt;rcv_nxt - tp-&gt;rcv_wup) &gt; inet_csk(sk)-&gt;icsk_ack.rcv_mss
</span><span class='line'>         /* ... and right edge of window advances far enough.
</span><span class='line'>          * (tcp_recvmsg() will send ACK otherwise). Or...
</span><span class='line'>          */
</span><span class='line'>         && __tcp_select_window(sk) &gt;= tp-&gt;rcv_wnd) ||
</span><span class='line'>        /* We ACK each frame or... */
</span><span class='line'>        tcp_in_quickack_mode(sk) ||
</span><span class='line'>        /* We have out of order data. */
</span><span class='line'>        (ofo_possible && skb_peek(&tp-&gt;out_of_order_queue))) {
</span><span class='line'>        /* Then ack it now */
</span><span class='line'>        tcp_send_ack(sk);
</span><span class='line'>    } else {
</span><span class='line'>        /* Else, send delayed ack. */
</span><span class='line'>        //在这里启动定时器。
</span><span class='line'>        tcp_send_delayed_ack(sk);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面还有一个tcp_in_quickack_mode，这个函数我们说了，它是用来判断是否处在quickack 模式。<br/>
来看这个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_in_quickack_mode(const struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    return icsk-&gt;icsk_ack.quick && !icsk-&gt;icsk_ack.pingpong;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中icsk->icsk_ack.pingpong域被设置的情况只有当tcp连接是交互式的，比如telnet等等。icsk->icsk_ack.quick表示能够 quickack的数量。
然后我们来看tcp_delack_timer的实现。<br/>
在看之前，我们要知道icsk->icsk_ack.pending表示的是当前的ack的状态。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_delack_timer(unsigned long data)
</span><span class='line'>{
</span><span class='line'>    struct sock *sk = (struct sock *)data;
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>    bh_lock_sock(sk);
</span><span class='line'>    //用户进程正在使用，则等会再尝试。
</span><span class='line'>    if (sock_owned_by_user(sk)) {
</span><span class='line'>        /* Try again later. */
</span><span class='line'>        icsk-&gt;icsk_ack.blocked = 1;
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKLOCKED);
</span><span class='line'>        sk_reset_timer(sk, &icsk-&gt;icsk_delack_timer, jiffies + TCP_DELACK_MIN);
</span><span class='line'>        goto out_unlock;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    sk_mem_reclaim_partial(sk);
</span><span class='line'>
</span><span class='line'>    //判断sock状态 以及ack的状态。如果是close或者已经处在ICSK_ACK_TIMER，则直接跳出。
</span><span class='line'>    if (sk-&gt;sk_state == TCP_CLOSE || !(icsk-&gt;icsk_ack.pending & ICSK_ACK_TIMER))
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    //如果已经超时，则重启定时器，并退出。
</span><span class='line'>    if (time_after(icsk-&gt;icsk_ack.timeout, jiffies)) {
</span><span class='line'>        sk_reset_timer(sk, &icsk-&gt;icsk_delack_timer, icsk-&gt;icsk_ack.timeout);
</span><span class='line'>        goto out;
</span><span class='line'>    }
</span><span class='line'>    //清除ack状态。
</span><span class='line'>    icsk-&gt;icsk_ack.pending &= ~ICSK_ACK_TIMER;
</span><span class='line'>
</span><span class='line'>    //开始遍历prequeue。此时主要的目的是为了调用tcp_rcv_eastablished.这里会调用tcp_ack_snd_check来发送ack。
</span><span class='line'>    if (!skb_queue_empty(&tp-&gt;ucopy.prequeue)) {
</span><span class='line'>        struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSCHEDULERFAILED);
</span><span class='line'>
</span><span class='line'>        //遍历prequeue队列，发送未发送的ack。
</span><span class='line'>        while ((skb = __skb_dequeue(&tp-&gt;ucopy.prequeue)) != NULL)
</span><span class='line'>            sk_backlog_rcv(sk, skb);
</span><span class='line'>
</span><span class='line'>        tp-&gt;ucopy.memory = 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //检测是否有ack还需要被发送。也就是处于ICSK_ACK_SCHED状态的ack
</span><span class='line'>    if (inet_csk_ack_scheduled(sk)) {
</span><span class='line'>
</span><span class='line'>        if (!icsk-&gt;icsk_ack.pingpong) {
</span><span class='line'>            /* Delayed ACK missed: inflate ATO. */
</span><span class='line'>            icsk-&gt;icsk_ack.ato = min(icsk-&gt;icsk_ack.ato &lt;&lt; 1, icsk-&gt;icsk_rto);
</span><span class='line'>        } else {
</span><span class='line'>            //到这里说明已经长时间没有通信，并且处于交互模式。这个时候我们需要关闭pingpong模式。
</span><span class='line'>            icsk-&gt;icsk_ack.pingpong = 0;
</span><span class='line'>            icsk-&gt;icsk_ack.ato      = TCP_ATO_MIN;
</span><span class='line'>        }
</span><span class='line'>        //立即发送ack。
</span><span class='line'>        tcp_send_ack(sk);
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKS);
</span><span class='line'>    }
</span><span class='line'>    TCP_CHECK_TIMER(sk);
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>    if (tcp_memory_pressure)
</span><span class='line'>        sk_mem_reclaim(sk);
</span><span class='line'>out_unlock:
</span><span class='line'>    bh_unlock_sock(sk);
</span><span class='line'>    sock_put(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/21/ubuntu-dota2/">ubuntu dota2</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-21T23:51:00+08:00'><span class='date'>2013-09-21</span> <span class='time'>23:51:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ERROR- You are missing the following 32-bit libraries, and Steam may not run:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib</span></code></pre></td></tr></table></div></figure>


<p>无法输入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export LC_CTYPE="en_US.UTF-8" && steam</span></code></pre></td></tr></table></div></figure>


<h4>一、集显</h4>

<p>  ubuntu下，如果是intel的核心显卡，mesa低于9.2版本的话，会出现看不见树和看不见英雄的情况
  这时候就要更新mesa到9.2，mesa9.2支持3.6之后的内核版本，如果内核低于3.6，就要先更新内核
  ubuntu的解决办法:
  查看当前mesa版本：glxinfo |grep -i opengl
  查看当前内核版本：uname -a</p>

<p>  sudo add-apt-repository ppa:xorg-edgers/ppa
  sudo apt-get update
  sudo apt-get install linux-generic-lts-raring  (更新内核)
  sudo apt-get dist-upgrade mesa                 (更新mesa)
  然后就是重启系统</p>

<h4>二、独显</h4>

<p>ubuntu 装独显 <a href="/blog/2013/03/26/ubuntu-use-nvidia/">ubuntu 12.04 N卡双显卡</a></p>

<p>如果你想用独显玩dota2, 那么你需要用optirun steam来启动steam客户端，然后再启动游戏，这样游戏就是通过独显来渲染的。你也可以用普通的steam命令来启动steam，然后在dota2 游戏的属性中，加入启动方式optirun %command。 这样只有在启动游戏之后独显才会工作。</p>

<p>用optirun -b primus %command%(记得要装primus)，效果更好。 // 用%command%在启动时画面会显示不全，但是好像用%command好像又不会用独显了</p>

<p>primus默认是有垂直同步的，帧数当然会低，加个vblank_mode=0绝对秒杀virtualgl</p>

<p>不能用vblank_mode=0 optirun -b primus programme做桥接启动程序，这样会拉低许多显卡性能，
使用vblank_mode=0 primusrun programme，性能就上来了，我这里确实比optirun提高30%左右</p>

<hr />

<h5>1打开启动选项输入框</h5>

<h5>2 输入所选命令（使用多个命令是中间用空格隔开，例如 -novid -international -console  ）</h5>

<p>-novid （去除开始动画）<br/>
-console（命令面板）<br/>
-high （使dota2 的cpu和内存使用级为最高,也就是说让dota2 可以优先其他程序使用内存）<br/>
-windowed （窗口模式）</p>

<h5>dota 2 console 命令</h5>

<h6>1首先开启命令面板</h6>

<h6>2输入常用命令</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>net_graph 1 （ 网络状况显示）
</span><span class='line'>    再来就是改变位置，有些人不喜欢显示在左边，这个时候可以输入：
</span><span class='line'>　　net_graphpos 1
</span><span class='line'>　　这样显示的数据就会变到右边
</span><span class='line'>　　
</span><span class='line'>　　net_graphpos 2
</span><span class='line'>　　这样会变成中间
</span><span class='line'>　　
</span><span class='line'>　　net_graphpos 3
</span><span class='line'>　　这样会变成左边
</span><span class='line'>
</span><span class='line'>dota_minimap_hero_size 650 （英雄在小地图上的大小 650 为正常值，可自行更改）
</span><span class='line'>dota_force_right_click_attack 1 (英雄可以右键直接反补）
</span><span class='line'>dota_hud_healthbars 1 （去掉生命条上的分隔）
</span><span class='line'>dota_health_per_vertical_marker 250 （更改每一个分隔代表的血量 默认为250）
</span><span class='line'>dota_disable_range_finder 0  （随时显示你的施法距离）（很有用）
</span><span class='line'>dota_camera_accelerate 49 （任意调整观看视角）（没用过）
</span><span class='line'>
</span><span class='line'>dota2 一共有数百种命令，包括血的颜色，屏蔽某种声音等等，但是比较实际的就是这几种，其他的就不列举了。
</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>Dota2 录像下载失败</h4>

<p>无法打开录像文件,请确保没有其他进程已打开此文件。</p>

<p>在XXX\Steam\SteamApps\common\dota 2 beta\dota目录下新建一个名为replays的文件夹即可</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>net_graphheight "64"
</span><span class='line'>这个等于是设置高度位置 大家如果分屏率不同 可以修改数字来决定位置 数字越小 会往下移动 
</span><span class='line'>
</span><span class='line'>net_graphinsetbottom "437"
</span><span class='line'>这个等于是设置地步位置 大家如果分屏率不同 可以修改数字来决定位置 数字越小 会往上移动 
</span><span class='line'>
</span><span class='line'>net_graphinsetleft "0"
</span><span class='line'>因为已经设置右边 这个保持0就OK 但是也记得输入一次 以防万一 
</span><span class='line'>
</span><span class='line'>net_graphinsetright "-83"
</span><span class='line'>设置右边距离 记住这里是"-83" 不是83 负数越高 越往右 大家可以根据自己的需要改变数字 
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>net_graphproportionalfont "0"
</span><span class='line'>这个是关键 字体比例问题 默认是1 设定为0以后 就会变成我图中那样的小字 
</span><span class='line'>
</span><span class='line'>net_graphtext "1"
</span><span class='line'>这个没什么大问题 字体样式</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/09/kernel-net-rx/">接收包的主流程</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-09T18:10:00+08:00'><span class='date'>2013-09-09</span> <span class='time'>18:10:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_v4_rcv(struct sk_buff *skb)    linux/net/ipv4/tcp_ipv4.c #1611</span></code></pre></td></tr></table></div></figure>


<p>  //tcp刚刚收到从ipv4发上来的包<br/>
  （struct tcphdr: 定义在/include/net/tcp.h中，即包的tcp首部，不包括options部分）<br/>
  （struct sock ：定义在/include/net/sock.h中，即表示socket）<br/>
  检查skb->pkt_type != PACKET_HOST 则丢弃<br/>
  检查th->doff &lt; sizeof(struct tcphdr) / 4，即首部大小不合理，则丢弃<br/>
  检查checksum</p>

<p>  （TCP_SKB_CB(skb)：定义在tcp.h是获取一个实际指向skb->cb[0]的tcp_skb_cb类型指针；将到达的首部剥离后，从中拷贝一些信息到这个变量，供tcp控制功能使用；tcp_skb_cb是在tcp刚收到时填写在包中的）<br/>
  注意：<br/>
        1. tcp_skb_cb->end_seq = seq + th->fin + th->fin + len-doff*4<br/>
        2. when 和 sacked 没有被赋值</p>

<p>  sk = __inet_lookup(&hellip;) 从一个hash表中获取该收包对应的sock结构，根据源IP地址+端口，目的IP地址+端口，inet_iif检查sk->sk_state == TCP_TIME_WAIT，TCP在该状态下则丢弃任何接收到的包并转入后续的特殊处理（未看，和关闭连接的状态迁移有关需要后续来看$），马上准备进入CLOSED状态了；<br/>
  检查sk_filter(sk,skb)，则被过滤器阻拦，丢弃<br/>
  检查!sock_owned_by_user(sk)，不明白sock->sk_lock的意义是什么，只有检查满足才能进入接收，否则 sk_add_backlog(sk, skb)将该sk_buff记录进sk_backlog队列；（注意这部操作加锁了！）<br/>
（struct tcp_sock *tp = tcp_sk(sk)：tcp_sock定义在tcp.h中，通过tcp_sk直接将sock指针转换为tcp_sock型）</p>

<p>  ret = tcp_v4_do_rcv(sk, skb) 进入进一步接收处理！<br/>
（之后的异常操作未看）</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)    linux/net/ipv4/tcp_ipv4.c #1542</span></code></pre></td></tr></table></div></figure>


<p>  //在正常状态下由tcp_v4_rcv调用，进一步进行针对接收包的处理<br/>
  检查sk->sk_state == TCP_ESTABLISHED<br/>
    则tcp_rcv_established(sk, skb, skb->h.th, skb->len)，连接已经建立，则进入进一步接收处理！<br/>
  检查sk->sk_state == TCP_LISTEN，<br/>
    则struct sock *nsk = tcp_v4_hnd_req(sk, skb);    //该函数中判断能否找到已有的连接请求，如果有则说明接收到的是一个ack并在其中创建一个新的sock即nsk；如果没有则说明接收到的是 syn，nsk即为sk；<br/>
  if(nsk!=sk) tcp_child_process(sk,nsk,skb)    //当nsk==sk时，接收的是SYN，不进行此步直接进入tcp_rcv_state_process；否则是ack说明已经创建好了的nsk，在 tcp_child_process对nsk进行tcp_rcv_state_process状态转移处理；<br/>
  tcp_rcv_state_process(sk, skb, skb->h.th, skb->len); 非常重要函数！处理tcp的状态转移<br/>
  reset: tcp_v4_send_reset(rsk, skb);    reset，未看$<br/>
  discard: kfree_skb(skb);</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_rcv_established(struct sock *sk, struct sk_buff *skb,struct tcphdr *th, unsigned len)    linux/net/ipv4/tcp_input.c #3881</span></code></pre></td></tr></table></div></figure>


<p>Header Prediction：基于效率的考虑，将包的处理后续阶段分为fast path和slow path两种，前者用于普通的包，后者用于特殊的包；该header prediction即用于区分两种包的流向。<br/>
1.(tcp_flag_word(th) &amp; TCP_HP_BITS) == tp->pred_flags 判断标志位是不是正常情况；tcp_flag_word返回指向tcphdr的第三个32位基址（即length前面），而TCP_HP_BITS是把 PSH标志位给屏蔽掉即该位值不影响流向；所以总的来说pred_flag应该等于0xS?10 &lt;&lt; 16 + snd_wnd（那么pred_flag是在tcp_fast_path_check或tcp_fast_path_on中更新值的）<br/>
2.TCP_SKB_CB(skb)->seq == tp->rcv_nxt 判断所收包是否为我们正想要接收的，非乱序包<br/>
3.*ptr != htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16) | (TCPOPT_TIMESTAMP &lt;&lt; 8) | TCPOLEN_TIMESTAMP) 若包中没有正常的timestamp选项则转入slow path
 timestamp选项处理： 从包中的ts选项中获取数据，以此刷新tp->rx_opt的saw_tstamp,rcv_tsval,rcv_tsecr域；ts选项含三个 32bit，其中后两个分别记录着tsval和tsecr；（注意，ts_recent并不在此处更新，在后面的tcp_store_ts_recent 中更新）<br/>
  struct tcp_options_received: 定义在tcp.h中，其中saw_tstamp表明timestamp选项是否有效，ts_recent_stamp是我们最近一次更新 ts_recent的时间，ts_recent是下一次回显的时戳一般等于下次发包中的rcv_tsecr；rcv_tsval是该data从发端发出时的时戳值，rcv_tsecr是回显时间戳（即该ack对应的data或者该data对应的上次ack中的ts_tsval值），（注意两端时钟无需同步；当ack被收端推迟时，所回复的ack中的timestamp指向所回复包群中的第一个确认包 “When an incoming segment belongs to the current window, but arrives out of order (which implies that an earlier segment was lost), the timestamp of the earlier segment is returned as soon as it arrives, rather than the timestamp of the segment that arrived out of order.”这条细节未看明白$）从包中的时间戳选项中记录这两个值</p>

<p>4.PAWS check：(s32)(tp->rx_opt.rcv_tsval - tp->rx_opt.ts_recent) &lt; 0，则转入slow path<br/>
  （PAWS:Protection Against Wrapped Sequence Numbers, SeqNo有可能会有回环交叠（因为它最大只有32bit），两个相同序号的包实际上是不同的两个包，此时判断tsval是否小于ts_recent即判断该包是否是一个过去时间的一个多余的包，然后将其作为一个重复包丢弃）</p>

<h5>Fast Path：</h5>

<p>  1.当len == tcp_header_len，即这是一个纯ack（区别于piggyback），注意这是个纯ack，所以它通过长度来进行判断而不是标识！<br/>
    tcp_store_ts_recent(tp): tp->rx_opt.ts_recent = tp->rx_opt.rcv_tsval;<br/>
    tcp_ack(sk, skb, 0) 处理ack，进一步处理，未看！<br/>
    <code>__kfree_skb(skb)</code> 释放该包<br/>
     tcp_data_snd_check(sk,tp) 检查有无更进一步的data包处理<br/>
  2.当len &lt; tcp_header_len，说明该包的首部太小，清除之；<br/>
  3.当len > tcp_header_len，它是一个data包，tcp_copy_to_iovec函数未看，它决定该payload是否可以直接拷贝给用户空间：<br/>
    可，tcp_store_ts_recent(tp);<br/>
      tcp_rcv_rtt_measure_ts(sk,skb); //计算RTT<br/>
      <code>__skb_pull(skb, tcp_header_len);</code> //剥tcp首部<br/>
       tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq; //更新rcv_next<br/>
($ 那么将data拷贝到用户空间的操作在何处体现？难道是在tcp_copy_to_iovec中？)<br/>
    不可，除了以上的操作之外，还要<br/>
      <code>__skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);</code> //将该包加入到接收sk_buff队列尾部<br/>
    tcp_event_data_recv()：management tasks处理<br/>
    若TCP_SKB_CB(skb)->ack_seq != tp->snd_una，说明这是一个有效的ack包<br/>
      tcp_ack(sk, skb, FLAG_DATA); //FLAG_DATA说明这是一个背在data上的ack<br/>
      tcp_data_snd_check(sk, tp); //该函数调用tcp_push_pending_frames函数，如果sk->sk_send_head存在则最终调用 tcp_write_xmit函数发包<br/>
      <code>__tcp_ack_snd_check(sk, 0);</code> //检查基于该收包事件，有无进一步的ack包处理（Delayed ACK，Quick ACK）</p>

<h5>Slow Path：</h5>

<p>  tcp_checksum_complete_user(sk, skb)：checksum检查<br/>
  tcp_fast_parse_options(skb, th, tp)：timestamp选项检查；tcp_paws_discard(sk, skb)：PAWS检查<br/>
  tcp_sequence(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq)：检查是否乱序，并在其中激活QuickACK模式<br/>
    上面两行中，都会再检查RST标志，若没激活则tcp_send_dupack，作用不明，貌似是针对该错包回复一个冗余的ack<br/>
  检查RST标志，tcp_reset(sk) 该函数没什么操作，填写一些错误信息后进入tcp_done函数(该函数进行一些关闭tcp连接的收尾操作)<br/>
  tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq)：更新timestamp信息<br/>
  检查SYN标志，在连接已建立的状态下，收到SYN是错误的，因此tcp_reset(sk)<br/>
  检查ACK标志，tcp_ack(sk, skb, FLAG_SLOWPATH)<br/>
  tcp_rcv_rtt_measure_ts(sk, skb)：更新RTT<br/>
  tcp_urg(sk, skb, th)：处理URG标志<br/>
  tcp_data_queue(sk, skb)：处理接收包所含数据，未看<br/>
  tcp_data_snd_check(sk, tp) &amp; tcp_ack_snd_check(sk)：检查有无进一步的data或ack发送</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_event_data_recv(struct sock *sk, struct tcp_sock *tp, struct sk_buff *skb)    linux/net/ipv4/tcp_input.c #502</span></code></pre></td></tr></table></div></figure>


<p>  //
  inet_csk_schedule_ack(sk)：将icsk_pending置为ICSK_ACK_SCHED，但具体意义不明<br/>
  （struct inet_connection_sock：/linux/include/net/inet_connection_sock，面向INET连接的 socket结构，记录着和tcp连接有关的很多变量，比如本函数要处理的ATO（Acknowledgement timeout）信息；tcp_sock是其上的拓展，它的具体意义尚待发掘）<br/>
  tcp_measure_rcv_mss(sk, skb)：更新rcv_mss，说是与delayed ACK有关，但是具体是怎么运作的？<br/>
  tcp_rcv_rtt_measure(tp)：更新RTT，为什么又更新一遍$<br/>
  接下来的一些列操作是更新inet_connection_sock中的ATO信息，具体操作代码中有注释，但这些信息的运作方式还不明</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_ack(struct sock *sk, struct sk_buff *skb, int flag)    /linux/net/ipv4/tcp_input.c #2491</span></code></pre></td></tr></table></div></figure>


<p>  //处理接受到的ack，内容非常复杂
  首先介绍一下ack可以携带的各个FLAG：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FLAG_DATA：              Incoming frame contained data.
</span><span class='line'>FLAG_WIN_UPDATE：        Incoming ACK was a window update
</span><span class='line'>FLAG_DATA_ACKED：        This ACK acknowledged new data.
</span><span class='line'>FLAG_RETRANS_DATA_ACKED：Some of which was retransmitted.
</span><span class='line'>FLAG_SYN_ACKED：         This ACK acknowledged SYN.
</span><span class='line'>FLAG_DATA_SACKED：       New SACK.
</span><span class='line'>FLAG_ECE：               ECE in this ACK.
</span><span class='line'>FLAG_DATA_LOST：         SACK detected data lossage.
</span><span class='line'>FLAG_SLOWPATH：          Do not skip RFC checks for window update.
</span><span class='line'>FLAG_ACKED：             (FLAG_DATA_ACKED|FLAG_SYN_ACKED)
</span><span class='line'>FLAG_NOT_DUP：           (FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)
</span><span class='line'>FLAG_CA_ALERT：          (FLAG_DATA_SACKED|FLAG_ECE)
</span><span class='line'>FLAG_FORWARD_PROGRESS： (FLAG_ACKED|FLAG_DATA_SACKED)</span></code></pre></td></tr></table></div></figure>


<p>  prior_snd_una = tp->snd_una;ack_seq = TCP_SKB_CB(skb)->seq; ack = TCP_SKB_CB(skb)->ack_seq;<br/>
  //1记录着上一次被确认的data序号；2记录着所收ack包的序号；3记录着所收ack包确认对象的data序号；<br/>
  首先判断若ack在tp->snd_nxt之后或者在prio_snd_una之前，则说明该ack非法或者过时（在过时的情况下，若sacked打开则还需tcp_sacktag_write_queue处理） 24</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!(flag&FLAG_SLOWPATH) && after(ack, prior_snd_una))
</span><span class='line'>    tcp_update_wl（即tp-&gt;snd_wl1 = ack_seq）; tp-&gt;snd_una=ack; //为什么此种情况下并不更新窗口？
</span><span class='line'>else
</span><span class='line'>    flag |= tcp_ack_update_window(sk, tp, skb, ack, ack_seq);
</span><span class='line'>    //nwin = ntohs(skb-&gt;h.th-&gt;window)从ack中记录通告窗口
</span><span class='line'>    如果检查需要更新发送窗口，则tp-&gt;snd_wl1 = ack_seq; tp-&gt;snd_wnd = nwin;
</span><span class='line'>    tp-&gt;snd_una = ack;
</span><span class='line'>    if (TCP_SKB_CB(skb)-&gt;sacked) flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una); //该函数未看
</span><span class='line'>
</span><span class='line'>    tp-&gt;rcv_tstamp = tcp_time_stamp; //rcv_tstamp记录着最近一次收到ack的时戳
</span><span class='line'>    prior_in_flight = tcp_packets_in_flight(tp);
</span><span class='line'>    if(!tp-&gt;packets_out) icsk-&gt;icsk_prbes_out = 0;
</span><span class='line'>    if (sk-&gt;sk_send_head) tcp_ack_probe(sk);    //若此时网络中没有data，直接进入zero-window probe的ack处理;通告窗口的数据已经得到处理，所以tcp_ack_probe中仅仅是重置probe计时器，即 icsk-&gt;icsk_retransmit_timer
</span><span class='line'>
</span><span class='line'>    flag |= tcp_clean_rtx_queue(sk, &seq_rtt);   //从重传队列中移除被确认的data包
</span><span class='line'>
</span><span class='line'>    if (tcp_ack_is_dubious(sk, flag)) { //该函数判断此ack是否可疑，判真情况下具体是flag不为FLAG_NOT_DUP，或flag是FLAG_CA_ALERT，或 icsk_ca_state不为TCP_CA_OPEN状态
</span><span class='line'>    if ((flag & FLAG_DATA_ACKED) && tcp_may_raise_cwnd(sk, flag))
</span><span class='line'>    //如果这个包是一个对新数据包的ack，那么通过tcp_may_raise_cwnd函数来判断是否要进行窗口操作，判真情况下具体是flag不是 FLAG_ECE或snd_cwnd&lt;snd_ssthresh（慢启动？）且icsk_ca_state不为TCP_CA_RECOVERY和 TCP_CA_CWR状态（所以，为什么TCP_CA_LOSS状态可以增窗呢？）
</span><span class='line'>        tcp_cong_avoid(sk, ack, seq_rtt, prior_in_flight, 0);  
</span><span class='line'>    //该函数会调用icsk-&gt;icsk_ca_ops-&gt;cong_avoid(sk, ack, rtt, in_flight, good)， 这是个函数指针；另外会更新snd_cwnd_stamp
</span><span class='line'>    tcp_fastretrans_alert(sk, prior_snd_una, prior_packets, flag); //未看，极其重要的函数
</span><span class='line'>}else{
</span><span class='line'>    if ((flag & FLAG_DATA_ACKED)) tcp_cong_avoid(sk, ack, seq_rtt, prior_in_flight, 1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>tcp_ack中有很多新的内容，都还未涉及，要注意！！！！！！</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)    /linux/net/ipv4/tcp_input.c #3139</span></code></pre></td></tr></table></div></figure>


<p>  //将数据拷贝至用户空间<br/>
若TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq 则空包丢弃<br/>
__skb_pull(skb, th->doff*4) //剥离tcp首部</p>

<h5>1.若TCP_SKB_CB(skb)->seq == tp->rcv_nxt且tcp_receive_window(tp)!=0，非乱序且处于接受窗口中，正常的情况</h5>

<p>若tp->ucopy.task == current, tp->copied_seq == tp->rcv_nxt, tp->ucopy.len等条件满足，则可以拷贝至用户空间<br/>
  //current是什么不明？ucopy.len貌似是用户最先设定的数据包的量，每次收包之后减小直至零<br/>
    skb_copy_datagram_iovec(skb, 0, tp->ucopy.iov, chunk) //向ucopy.iov拷贝数据<br/>
    tcp_rcv_space_adjust(sk) //计算TCP接受buffer空间大小，拷贝完<br/>
tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;<br/>
if(th->fin) tcp_fin(skb, sk, th); //原来fin的处理在这里！<br/>
若!skb_queue_empty(&amp;tp->out_of_order_queue)<br/>
    tcp_ofo_queue(sk); //看out_of_order_queue中有没有可以移到receive_queue中<br/>
    tcp_sack_remove(tp) //RCV.NXT advances, some SACKs should be eaten<br/>
    tcp_fast_path_check(sk,tp)   //tp->pred_flag值的更新<br/>
  清除skb并return</p>

<h5>2.若!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt) 说明这是一个重传的包</h5>

<p>  tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);   //在其中打开并填写dsack信息,在dyokucate_sack[0]中从seq到end_seq，修改dsack和eff_sacks值<br/>
  tcp_enter_quickack_mode(sk); //进入quick ack模式<br/>
  清除skb并return<br/>
若!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt + tcp_receive_window(tp))<br/>
  清除skb并return<br/>
若before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt) 说明这是一个Partial包，即seq&lt;rcv_next&lt;end_seq<br/>
  tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, tp->rcv_nxt); //填写dsack信息，从seq到rcv_nxt</p>

<h5>3. 其他情况，说明收到了一个乱序包</h5>

<p>若out_of_order_queue为空，则<br/>
（注：out_of_order_queue是一个sk_buff_head结构，它的prev/next指针分别指向最后一个和第一个sk_buff结构，块的排放顺序对应其序号的大小顺序）<br/>
  初始化sack相关域，num_sacks/eff_sacks为1，dsack为0，selective_acks[0]从seq到end_seq；<br/>
  <code>__skb_queue_head(&amp;tp-&gt;out_of_order_queue,skb);</code> //将收包加入out_of_order_queue的头部</p>

<p>若out_of_order_queue不为空，则首先获取skb1 = tp->out_of_order_queue.prev即最新的一个乱序块<br/>
  若seq == TCP_SKB_CB(skb1)->end_seq，说明收包能够接在最新乱序块的右边<br/>
    <code>__skb_append(skb1, skb, &amp;tp-&gt;out_of_order_queue);</code><br/>
    tp->selective_acks[0].end_seq = end_seq; //将新收包接在skb1的右边，看来第一个selective_acks块对应的是最新的乱序序列<br/>
  循环执行skb1=skb1->prev，直到找到!after(TCP_SKB_CB(skb1)->seq, seq)表明需要将收包插在此块之后，或skb1=(struct sk_buff<em>)&amp;tp->out_of_order_queue表明收包比队列中的所与块的序列都要小<br/>
    循环内需要找到收包与队列已有包中的重复部分，然后tcp_dsack_set设置该部分为dsack内容<br/>
  <code>__skb_insert(skb, skb1, skb1-&gt;next, &amp;tp-&gt;out_of_order_queue);</code> //将收包对应的块插入到队列中<br/>
  再次循环执行skb1=skb1->next，直到找到!after(end_seq, TCP_SKB_CB(skb1)->seq)表明需要将从收包到该包之间的所有包全部从队列中移除，或者skb1=(struct sk_buff</em>)&amp;tp->out_of_order_queue表明需要将收包之后的所有包都移出<br/>
    循环内需要将当前的队列包与收包的交叠部分设置为dsack值（当然随着循环的推进，dsack处于不断更新的状况），还要通过 <code>__skb_unlink(skb1, &amp;tp-&gt;out_of_order_queue)，__kfree_skb(skb1);</code>将当前的队列包移除<br/>
  （该处的两部循环，旨在通过比较队列中块的序号和所收包的序号范围，将队列中的包连续化，即消除孔洞）</p>

<hr />
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/55">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/53">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>13</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(42)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~haproxy/?opendiv=tools'>haproxy</a><a href='##' onmousedown=showDiv('tools~haproxy') id='aexp_tools~haproxy'><span class='exp_style' id='exp_tools~haproxy'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~haproxy')) document.getElementById('aexp_tools~haproxy').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(31)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(126)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>60</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>18</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(19)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(63)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~perf/?opendiv=debug'>perf</a><a href='##' onmousedown=showDiv('debug~perf') id='aexp_debug~perf'><span class='exp_style' id='exp_debug~perf'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~perf')) document.getElementById('aexp_debug~perf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(26)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(134)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>16</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/07/27/debug-perf/">系统级性能分析工具 --- Perf</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/24/tools-haproxy-splice/">haproxy splice</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/24/tools-haproxy-log/">haproxy log</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/23/tools-haproxy/">haproxy安装配置</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/23/tools-squid-muti/">同时运行多个squid</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
