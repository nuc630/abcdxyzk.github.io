
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/25/kernel-net-dev_queue_xmit/">dev_queue_xmi函数详解</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-25T23:20:00+08:00'><span class='date'>2015-08-25</span> <span class='time'>23:20:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>blog.chinaunix.net/uid-20788636-id-3181312.html</p>

<p>前面在分析IPv6的数据流程时，当所有的信息都准备好了之后，例如，出口设备，下一跳的地址，以及链路层地址。就会调用dev.c文件中的dev_queue_xmin函数，该函数是设备驱动程序执行传输的接口。也就是所有的数据包在填充完成后，最终发送数据时，都会调用该函数。</p>

<p>dev_queue_xmit函数只接收一个skb_buff结构作为输入的值。此数据结构包含了此函数所需要的一切信息。Skb->dev是出口设备，skb->data为有效的载荷的开头，其长度为skb->len.下面是2.6.37版本内核中的dev_queue_xmit函数，该版本的内核与之前的版本有了不少的区别。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int dev_queue_xmit(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_device *dev = skb-&gt;dev;
</span><span class='line'>&#9;struct netdev_queue *txq;
</span><span class='line'>&#9;struct Qdisc *q;
</span><span class='line'>&#9;int rc = -ENOMEM;
</span><span class='line'>
</span><span class='line'>&#9;/* Disable soft irqs for various locks below. Also
</span><span class='line'>&#9; * stops preemption for RCU.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;//关闭软中断 - __rcu_read_lock_bh()---&gt;local_bh_disable();
</span><span class='line'>&#9;rcu_read_lock_bh();
</span><span class='line'>&#9;// 选择一个发送队列，如果设备提供了select_queue回调函数就使用它，否则由内核选择一个队列,这里只是Linux内核多队列的实现，但是要真正的使用都队列，需要网卡支持多队列才可以，一般的网卡都只有一个队列。在调用alloc_etherdev分配net_device是，设置队列的个数
</span><span class='line'>&#9;txq = dev_pick_tx(dev, skb);
</span><span class='line'>&#9;//从netdev_queue结构上获取设备的qdisc
</span><span class='line'>&#9;q = rcu_dereference_bh(txq-&gt;qdisc);
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_NET_CLS_ACT
</span><span class='line'>&#9;skb-&gt;tc_verd = SET_TC_AT(skb-&gt;tc_verd, AT_EGRESS);
</span><span class='line'>#endif
</span><span class='line'>&#9;//如果硬件设备有队列可以使用，该函数由dev_queue_xmit函数直接调用或由dev_queue_xmit通过qdisc_run函数调用
</span><span class='line'>&#9;trace_net_dev_queue(skb);
</span><span class='line'>&#9;if (q-&gt;enqueue) {
</span><span class='line'>&#9;&#9;rc = __dev_xmit_skb(skb, q, dev, txq); //使用流控对象发送数据包(包含入队和出队)
</span><span class='line'>&#9;&#9;//更详细的内容参考说明3
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//下面的处理是在没有发送队列的情况下
</span><span class='line'>&#9;/* The device has no queue. Common case for software devices:
</span><span class='line'>&#9; loopback, all the sorts of tunnels...
</span><span class='line'>
</span><span class='line'>&#9; Really, it is unlikely that netif_tx_lock protection is necessary
</span><span class='line'>&#9; here. (f.e. loopback and IP tunnels are clean ignoring statistics
</span><span class='line'>&#9; counters.)
</span><span class='line'>&#9; However, it is possible, that they rely on protection
</span><span class='line'>&#9; made by us here.
</span><span class='line'>
</span><span class='line'>&#9; Check this and shot the lock. It is not prone from deadlocks.
</span><span class='line'>&#9; Either shot noqueue qdisc, it is even simpler 8)
</span><span class='line'>&#9; */
</span><span class='line'>&#9;//首先，确定设备是开启的，并且还要确定队列是运行的，启动和停止队列有驱动程序决定
</span><span class='line'>&#9;//设备没有输出队列典型的是回环设备。这里需要做的就是直接调用dev_start_queue_xmit、、函数，经过驱动发送出去，如果发送失败，就直接丢弃，没有队列可以保存。
</span><span class='line'>&#9;if (dev-&gt;flags & IFF_UP) {
</span><span class='line'>&#9;&#9;int cpu = smp_processor_id(); /* ok because BHs are off */
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (txq-&gt;xmit_lock_owner != cpu) {
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (__this_cpu_read(xmit_recursion) &gt; RECURSION_LIMIT)
</span><span class='line'>&#9;&#9;&#9;&#9;goto recursion_alert;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;HARD_TX_LOCK(dev, txq, cpu);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (!netif_tx_queue_stopped(txq)) {
</span><span class='line'>&#9;&#9;&#9;&#9;__this_cpu_inc(xmit_recursion);
</span><span class='line'>&#9;&#9;&#9;&#9;rc = dev_hard_start_xmit(skb, dev, txq);//见说明4
</span><span class='line'>&#9;&#9;&#9;&#9;__this_cpu_dec(xmit_recursion);
</span><span class='line'>&#9;&#9;&#9;&#9;if (dev_xmit_complete(rc)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;HARD_TX_UNLOCK(dev, txq);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;HARD_TX_UNLOCK(dev, txq);
</span><span class='line'>&#9;&#9;&#9;if (net_ratelimit())
</span><span class='line'>&#9;&#9;&#9;&#9;printk(KERN_CRIT "Virtual device %s asks to "
</span><span class='line'>&#9;&#9;&#9;&#9; "queue packet!\n", dev-&gt;name);
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;/* Recursion is It is possible,
</span><span class='line'>&#9;&#9;&#9; * unfortunately
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>recursion_alert:
</span><span class='line'>&#9;&#9;&#9;if (net_ratelimit())
</span><span class='line'>&#9;&#9;&#9;&#9;printk(KERN_CRIT "Dead loop on virtual device "
</span><span class='line'>&#9;&#9;&#9;&#9; "%s, fix it urgently!\n", dev-&gt;name);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;rc = -ENETDOWN;
</span><span class='line'>&#9;rcu_read_unlock_bh();
</span><span class='line'>
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return rc;
</span><span class='line'>out:
</span><span class='line'>&#9;rcu_read_unlock_bh();
</span><span class='line'>&#9;return rc;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>1. 下面是dev_pick_tx函数。</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct netdev_queue *dev_pick_tx(struct net_device *dev,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int queue_index;
</span><span class='line'>&#9;const struct net_device_ops *ops = dev-&gt;netdev_ops;
</span><span class='line'>
</span><span class='line'>&#9;if (ops-&gt;ndo_select_queue) {
</span><span class='line'>&#9;&#9;//选择一个索引，这个策略可以设置，比如优先选择视频和音频队列，而哪个队列邦定哪个策略也是设定的。
</span><span class='line'>&#9;&#9;queue_index = ops-&gt;ndo_select_queue(dev, skb);
</span><span class='line'>&#9;&#9;queue_index = dev_cap_txqueue(dev, queue_index);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;struct sock *sk = skb-&gt;sk;
</span><span class='line'>&#9;&#9;queue_index = sk_tx_queue_get(sk);
</span><span class='line'>&#9;&#9;if (queue_index &lt; 0 || queue_index &gt;= dev-&gt;real_num_tx_queues) {
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;queue_index = 0;
</span><span class='line'>&#9;&#9;&#9;if (dev-&gt;real_num_tx_queues &gt; 1)
</span><span class='line'>&#9;&#9;&#9;&#9;queue_index = skb_tx_hash(dev, skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (sk) {
</span><span class='line'>&#9;&#9;&#9;&#9;struct dst_entry *dst = rcu_dereference_check(sk-&gt;sk_dst_cache, 1);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (dst && skb_dst(skb) == dst)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;sk_tx_queue_set(sk, queue_index);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;skb_set_queue_mapping(skb, queue_index);
</span><span class='line'>&#9;return netdev_get_tx_queue(dev, queue_index);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>2. 下面是其中的一种网卡类型调用函数alloc_etherdev时，</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dev = alloc_etherdev(sizeof(struct ether1_priv));</span></code></pre></td></tr></table></div></figure>


<p>其实该函数是一个宏定义：其中第二参数表示的就是队列的数量，这里在Linux2.6.37内核中找到的一种硬件网卡的实现，可用的队列是1个。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1)</span></code></pre></td></tr></table></div></figure>


<p>下面是alloc_etherdev_mq函数的定义实现。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct net_device *alloc_etherdev_mq(int sizeof_priv, unsigned int queue_count)
</span><span class='line'>{
</span><span class='line'>&#9;return alloc_netdev_mq(sizeof_priv, "eth%d", ether_setup, queue_count);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>3.</h5>

<p>几乎所有的设备都会使用队列调度出口的流量，而内核可以使用对了规则的算法安排那个帧进行发送，使其以最优效率的次序进行传输。这里检查这个队列中是否有enqueue函数，如果有则说明设备会使用这个队列，否则需另外处理。关于enqueue函数的设置，我找到dev_open->dev_activate中调用了qdisc_create_dflt来设置，需要注意的是，这里并不是将传进来的skb直接发送，而是先入队，然后调度队列，具体发送哪个数据包由enqueue和dequeue函数决定，这体现了设备的排队规则</p>

<p>Enqueue 把一个元素添加的队列</p>

<p>Dequeue 从队列中提取一个元素</p>

<p>Requeue 把一个原先已经提取的元素放回到队列，可以由于传输失败。</p>

<p>if (q->enqueue)为真的话，表明这个设备有队列，可以进行相关的流控。调用__dev_xmit_skb函数进行处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,
</span><span class='line'>&#9;&#9;&#9;&#9; struct net_device *dev,
</span><span class='line'>&#9;&#9;&#9;&#9; struct netdev_queue *txq)
</span><span class='line'>{
</span><span class='line'>&#9;spinlock_t *root_lock = qdisc_lock(q);
</span><span class='line'>&#9;bool contended = qdisc_is_running(q);
</span><span class='line'>&#9;int rc;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Heuristic to force contended enqueues to serialize on a
</span><span class='line'>&#9; * separate lock before trying to get qdisc main lock.
</span><span class='line'>&#9; * This permits __QDISC_STATE_RUNNING owner to get the lock more often
</span><span class='line'>&#9; * and dequeue packets faster.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (unlikely(contended))
</span><span class='line'>&#9;&#9;spin_lock(&q-&gt;busylock);
</span><span class='line'>
</span><span class='line'>&#9;spin_lock(root_lock);
</span><span class='line'>&#9;if (unlikely(test_bit(__QDISC_STATE_DEACTIVATED, &q-&gt;state))) {
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;rc = NET_XMIT_DROP;
</span><span class='line'>&#9;} else if ((q-&gt;flags & TCQ_F_CAN_BYPASS) && !qdisc_qlen(q) &&
</span><span class='line'>&#9;&#9; qdisc_run_begin(q)) {
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * This is a work-conserving queue; there are no old skbs
</span><span class='line'>&#9;&#9; * waiting to be sent out; and the qdisc is not running -
</span><span class='line'>&#9;&#9; * xmit the skb directly.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (!(dev-&gt;priv_flags & IFF_XMIT_DST_RELEASE))
</span><span class='line'>&#9;&#9;&#9;skb_dst_force(skb);
</span><span class='line'>&#9;&#9;__qdisc_update_bstats(q, skb-&gt;len);
</span><span class='line'>&#9;&#9;if (sch_direct_xmit(skb, q, dev, txq, root_lock)) {
</span><span class='line'>&#9;&#9;&#9;if (unlikely(contended)) {
</span><span class='line'>&#9;&#9;&#9;&#9;spin_unlock(&q-&gt;busylock);
</span><span class='line'>&#9;&#9;&#9;&#9;contended = false;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;__qdisc_run(q);
</span><span class='line'>&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;qdisc_run_end(q);
</span><span class='line'>
</span><span class='line'>&#9;&#9;rc = NET_XMIT_SUCCESS;
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;skb_dst_force(skb);
</span><span class='line'>&#9;&#9;rc = qdisc_enqueue_root(skb, q);
</span><span class='line'>&#9;&#9;if (qdisc_run_begin(q)) {
</span><span class='line'>&#9;&#9;&#9;if (unlikely(contended)) {
</span><span class='line'>&#9;&#9;&#9;&#9;spin_unlock(&q-&gt;busylock);
</span><span class='line'>&#9;&#9;&#9;&#9;contended = false;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;__qdisc_run(q);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;spin_unlock(root_lock);
</span><span class='line'>&#9;if (unlikely(contended))
</span><span class='line'>&#9;&#9;spin_unlock(&q-&gt;busylock);
</span><span class='line'>&#9;return rc;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>_dev_xmit_skb函数主要做两件事情：<br/>
 （1） 如果流控对象为空的，试图直接发送数据包。<br/>
 （2） 如果流控对象不空，将数据包加入流控对象，并运行流控对象。</p>

<p>当设备进入调度队列准备传输时，qdisc_run函数就会选出下一个要传输的帧，而该函数会间接的调用相关联的队列规则dequeue函数，从对了中取出数据进行传输。</p>

<p>有两个时机将会调用qdisc_run()：<br/>
  1.<code>__dev_xmit_skb()</code><br/>
  2.软中断服务线程NET_TX_SOFTIRQ</p>

<p>其实，真正的工作有qdisc_restart函数实现。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __qdisc_run(struct Qdisc *q)
</span><span class='line'>{
</span><span class='line'>&#9;unsigned long start_time = jiffies;
</span><span class='line'>
</span><span class='line'>&#9;while (qdisc_restart(q)) { //返回值大于0，说明流控对象非空。
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * Postpone processing if
</span><span class='line'>&#9;&#9; * 1. another process needs the CPU;
</span><span class='line'>&#9;&#9; * 2. we've been doing it for too long.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (need_resched() || jiffies != start_time) { //已经不允许继续运行本流控对象。
</span><span class='line'>&#9;&#9;&#9;__netif_schedule(q); //将本队列加入软中断的output_queue链表中。
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;qdisc_run_end(q);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果发现本队列运行的时间太长了，将会停止队列的运行，并将队列加入output_queue链表头。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int qdisc_restart(struct Qdisc *q)
</span><span class='line'>{
</span><span class='line'>&#9;struct netdev_queue *txq;
</span><span class='line'>&#9;struct net_device *dev;
</span><span class='line'>&#9;spinlock_t *root_lock;
</span><span class='line'>&#9;struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>&#9;/* Dequeue packet */
</span><span class='line'>&#9;skb = dequeue_skb(q);//一开始就调用dequeue函数。
</span><span class='line'>&#9;if (unlikely(!skb))
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;WARN_ON_ONCE(skb_dst_is_noref(skb));
</span><span class='line'>&#9;root_lock = qdisc_lock(q);
</span><span class='line'>&#9;dev = qdisc_dev(q);
</span><span class='line'>&#9;txq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));
</span><span class='line'>
</span><span class='line'>&#9;return sch_direct_xmit(skb, q, dev, txq, root_lock);//用于发送数据包
</span><span class='line'>}
</span><span class='line'>* Returns to the caller:
</span><span class='line'> *                0 - queue is empty or throttled.
</span><span class='line'> *                &gt;0 - queue is not empty.
</span><span class='line'> */
</span><span class='line'>int sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,
</span><span class='line'>&#9;&#9; struct net_device *dev, struct netdev_queue *txq,
</span><span class='line'>&#9;&#9; spinlock_t *root_lock)
</span><span class='line'>{
</span><span class='line'>&#9;int ret = NETDEV_TX_BUSY;
</span><span class='line'>
</span><span class='line'>&#9;/* And release qdisc */
</span><span class='line'>&#9;spin_unlock(root_lock);
</span><span class='line'>
</span><span class='line'>&#9;HARD_TX_LOCK(dev, txq, smp_processor_id());
</span><span class='line'>&#9;if (!netif_tx_queue_stopped(txq) && !netif_tx_queue_frozen(txq)) //设备没有被停止，且发送队列没有被冻结
</span><span class='line'>&#9;&#9;ret = dev_hard_start_xmit(skb, dev, txq); //发送数据包
</span><span class='line'>
</span><span class='line'>&#9;HARD_TX_UNLOCK(dev, txq);
</span><span class='line'>
</span><span class='line'>&#9;spin_lock(root_lock);
</span><span class='line'>
</span><span class='line'>&#9;if (dev_xmit_complete(ret)) {
</span><span class='line'>&#9;&#9;/* Driver sent out skb successfully or skb was consumed */
</span><span class='line'>&#9;&#9;//发送成功，返回新的队列的长度
</span><span class='line'>&#9;&#9;ret = qdisc_qlen(q);
</span><span class='line'>&#9;} else if (ret == NETDEV_TX_LOCKED) {
</span><span class='line'>&#9;&#9;/* Driver try lock failed */
</span><span class='line'>&#9;&#9;ret = handle_dev_cpu_collision(skb, txq, q);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;/* Driver returned NETDEV_TX_BUSY - requeue skb */
</span><span class='line'>&#9;&#9;if (unlikely (ret != NETDEV_TX_BUSY && net_ratelimit()))
</span><span class='line'>&#9;&#9;&#9;printk(KERN_WARNING "BUG %s code %d qlen %d\n",
</span><span class='line'>&#9;&#9;&#9; dev-&gt;name, ret, q-&gt;q.qlen);
</span><span class='line'>&#9;&#9; //设备繁忙，重新调度发送（利用softirq）
</span><span class='line'>&#9;&#9;ret = dev_requeue_skb(skb, q);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (ret && (netif_tx_queue_stopped(txq) ||
</span><span class='line'>&#9;&#9; netif_tx_queue_frozen(txq)))
</span><span class='line'>&#9;&#9;ret = 0;
</span><span class='line'>
</span><span class='line'>&#9;return ret;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>4. 我们看一下下面的发送函数。</h5>

<p> 从此函数可以看出，当驱动使用发送队列的时候会循环从队列中取出包发送, 而不使用队列的时候只发送一次，如果没发送成功就直接丢弃</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct netdev_queue *txq)
</span><span class='line'>{
</span><span class='line'>&#9;const struct net_device_ops *ops = dev-&gt;netdev_ops;//驱动程序的函数集
</span><span class='line'>&#9;int rc = NETDEV_TX_OK;
</span><span class='line'>
</span><span class='line'>&#9;if (likely(!skb-&gt;next)) {
</span><span class='line'>&#9;&#9;if (!list_empty(&ptype_all))
</span><span class='line'>&#9;&#9;&#9;dev_queue_xmit_nit(skb, dev);//如果dev_add_pack加入的是ETH_P_ALL，那么就会复制一份给你的回调函数。
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * If device doesnt need skb-&gt;dst, release it right now while
</span><span class='line'>&#9;&#9; * its hot in this cpu cache
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (dev-&gt;priv_flags & IFF_XMIT_DST_RELEASE)
</span><span class='line'>&#9;&#9;&#9;skb_dst_drop(skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb_orphan_try(skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (vlan_tx_tag_present(skb) &&
</span><span class='line'>&#9;&#9; !(dev-&gt;features & NETIF_F_HW_VLAN_TX)) {
</span><span class='line'>&#9;&#9;&#9;skb = __vlan_put_tag(skb, vlan_tx_tag_get(skb));
</span><span class='line'>&#9;&#9;&#9;if (unlikely(!skb))
</span><span class='line'>&#9;&#9;&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;skb-&gt;vlan_tci = 0;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (netif_needs_gso(dev, skb)) {
</span><span class='line'>&#9;&#9;&#9;if (unlikely(dev_gso_segment(skb)))
</span><span class='line'>&#9;&#9;&#9;&#9;goto out_kfree_skb;
</span><span class='line'>&#9;&#9;&#9;if (skb-&gt;next)
</span><span class='line'>&#9;&#9;&#9;&#9;goto gso;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;if (skb_needs_linearize(skb, dev) &&
</span><span class='line'>&#9;&#9;&#9; __skb_linearize(skb))
</span><span class='line'>&#9;&#9;&#9;&#9;goto out_kfree_skb;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* If packet is not checksummed and device does not
</span><span class='line'>&#9;&#9;&#9; * support checksumming for this protocol, complete
</span><span class='line'>&#9;&#9;&#9; * checksumming here.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;if (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {
</span><span class='line'>&#9;&#9;&#9;&#9;skb_set_transport_header(skb, skb-&gt;csum_start -
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; skb_headroom(skb));
</span><span class='line'>&#9;&#9;&#9;&#9;if (!dev_can_checksum(dev, skb) &&
</span><span class='line'>&#9;&#9;&#9;&#9; skb_checksum_help(skb))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto out_kfree_skb;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;rc = ops-&gt;ndo_start_xmit(skb, dev);//调用网卡的驱动程序发送数据。不同的网络设备有不同的发送函数
</span><span class='line'>&#9;&#9;trace_net_dev_xmit(skb, rc);
</span><span class='line'>&#9;&#9;if (rc == NETDEV_TX_OK)
</span><span class='line'>&#9;&#9;&#9;txq_trans_update(txq);
</span><span class='line'>&#9;&#9;return rc;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>gso:
</span><span class='line'>&#9;do {
</span><span class='line'>&#9;&#9;struct sk_buff *nskb = skb-&gt;next;
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb-&gt;next = nskb-&gt;next;
</span><span class='line'>&#9;&#9;nskb-&gt;next = NULL;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * If device doesnt need nskb-&gt;dst, release it right now while
</span><span class='line'>&#9;&#9; * its hot in this cpu cache
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (dev-&gt;priv_flags & IFF_XMIT_DST_RELEASE)
</span><span class='line'>&#9;&#9;&#9;skb_dst_drop(nskb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;rc = ops-&gt;ndo_start_xmit(nskb, dev); //调用网卡的驱动程序发送数据。不同的网络设备有不同的发送函数
</span><span class='line'>&#9;&#9;trace_net_dev_xmit(nskb, rc);
</span><span class='line'>&#9;&#9;if (unlikely(rc != NETDEV_TX_OK)) {
</span><span class='line'>&#9;&#9;&#9;if (rc & ~NETDEV_TX_MASK)
</span><span class='line'>&#9;&#9;&#9;&#9;goto out_kfree_gso_skb;
</span><span class='line'>&#9;&#9;&#9;nskb-&gt;next = skb-&gt;next;
</span><span class='line'>&#9;&#9;&#9;skb-&gt;next = nskb;
</span><span class='line'>&#9;&#9;&#9;return rc;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;txq_trans_update(txq);
</span><span class='line'>&#9;&#9;if (unlikely(netif_tx_queue_stopped(txq) && skb-&gt;next))
</span><span class='line'>&#9;&#9;&#9;return NETDEV_TX_BUSY;
</span><span class='line'>&#9;} while (skb-&gt;next);
</span><span class='line'>
</span><span class='line'>out_kfree_gso_skb:
</span><span class='line'>&#9;if (likely(skb-&gt;next == NULL))
</span><span class='line'>&#9;&#9;skb-&gt;destructor = DEV_GSO_CB(skb)-&gt;destructor;
</span><span class='line'>out_kfree_skb:
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>out:
</span><span class='line'>&#9;return rc;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>5.下面看一下dev_queue_xmit_nit函数。</h5>

<p>对于通过socket(AF_PACKET,SOCK_RAW,htons(ETH_P_ALL))创建的原始套接口，不但可以接受从外部输入的数据包，而且对于由于本地输出的数据包，如果满足条件，也可以能接受。</p>

<p>该函数就是用来接收由于本地输出的数据包，在链路层的输出过程中，会调用此函数，将满足条件的数据包输入到RAW套接口，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void dev_queue_xmit_nit(struct sk_buff *skb, struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct packet_type *ptype;
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_NET_CLS_ACT
</span><span class='line'>&#9;if (!(skb-&gt;tstamp.tv64 && (G_TC_FROM(skb-&gt;tc_verd) & AT_INGRESS)))
</span><span class='line'>&#9;&#9;net_timestamp_set(skb);-----------------（1）
</span><span class='line'>#else
</span><span class='line'>&#9;net_timestamp_set(skb);
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;list_for_each_entry_rcu(ptype, &ptype_all, list) {-----------------（2）
</span><span class='line'>&#9;&#9;/* Never send packets back to the socket
</span><span class='line'>&#9;&#9; * they originated from - MvS (miquels@drinkel.ow.org)
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if ((ptype-&gt;dev == dev || !ptype-&gt;dev) &&
</span><span class='line'>&#9;&#9; (ptype-&gt;af_packet_priv == NULL ||
</span><span class='line'>&#9;&#9; (struct sock *)ptype-&gt;af_packet_priv != skb-&gt;sk)) {-----------------（3）
</span><span class='line'>&#9;&#9;&#9;struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC); -----------------（4）
</span><span class='line'>&#9;&#9;&#9;if (!skb2)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* skb-&gt;nh should be correctly
</span><span class='line'>&#9;&#9;&#9; set by sender, so that the second statement is
</span><span class='line'>&#9;&#9;&#9; just protection against buggy protocols.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;skb_reset_mac_header(skb2);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (skb_network_header(skb2) &lt; skb2-&gt;data ||
</span><span class='line'>&#9;&#9;&#9; skb2-&gt;network_header &gt; skb2-&gt;tail) {
</span><span class='line'>&#9;&#9;&#9;&#9;if (net_ratelimit())
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;printk(KERN_CRIT "protocol %04x is "
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; "buggy, dev %s\n",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; ntohs(skb2-&gt;protocol),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; dev-&gt;name);
</span><span class='line'>&#9;&#9;&#9;&#9;skb_reset_network_header(skb2); -----------------（5）
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;skb2-&gt;transport_header = skb2-&gt;network_header;
</span><span class='line'>&#9;&#9;&#9;skb2-&gt;pkt_type = PACKET_OUTGOING;
</span><span class='line'>&#9;&#9;&#9;ptype-&gt;func(skb2, skb-&gt;dev, ptype, skb-&gt;dev); -----------------（6）
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>说明：<br/>
（1） 记录该数据包输入的时间戳<br/>
（2） 遍历ptype_all链表，查找所有符合输入条件的原始套接口，并循环将数据包输入到满足条件的套接口<br/>
（3） 数据包的输出设备与套接口的输入设备相符或者套接口不指定输入设备，并且该数据包不是有当前用于比较的套接口输出，此时该套接口满足条件，数据包可以输入<br/>
（4） 由于该数据包是额外输入到这个原始套接口的，因此需要克隆一个数据包<br/>
（5） 校验数据包是否有效<br/>
（6） 将数据包输入原始套接口</p>

<h5>6. 对于lookback设备来说处理有些不同。它的hard_start_xmit函数是loopback_xmit</h5>

<p>在net/lookback.c文件中，定义的struct net_device_ops loopback_ops结构体</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const struct net_device_ops loopback_ops = {
</span><span class='line'>&#9;.ndo_init = loopback_dev_init,
</span><span class='line'>&#9;.ndo_start_xmit= loopback_xmit,
</span><span class='line'>&#9;.ndo_get_stats64 = loopback_get_stats64,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>从这里可以看到起发送函数为loopback_xmit函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static netdev_tx_t loopback_xmit(struct sk_buff *skb,
</span><span class='line'>&#9;&#9;&#9;&#9; struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct pcpu_lstats *lb_stats;
</span><span class='line'>&#9;int len;
</span><span class='line'>
</span><span class='line'>&#9;skb_orphan(skb);
</span><span class='line'>
</span><span class='line'>&#9;skb-&gt;protocol = eth_type_trans(skb, dev);
</span><span class='line'>
</span><span class='line'>&#9;/* it's OK to use per_cpu_ptr() because BHs are off */
</span><span class='line'>&#9;lb_stats = this_cpu_ptr(dev-&gt;lstats);
</span><span class='line'>
</span><span class='line'>&#9;len = skb-&gt;len;
</span><span class='line'>&#9;if (likely(netif_rx(skb) == NET_RX_SUCCESS)) {//直接调用了netif_rx进行了接收处理
</span><span class='line'>&#9;&#9;u64_stats_update_begin(&lb_stats-&gt;syncp);
</span><span class='line'>&#9;&#9;lb_stats-&gt;bytes += len;
</span><span class='line'>&#9;&#9;lb_stats-&gt;packets++;
</span><span class='line'>&#9;&#9;u64_stats_update_end(&lb_stats-&gt;syncp);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;return NETDEV_TX_OK;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>7. 已经有了dev_queue_xmit函数，为什么还需要软中断来发送呢？</h5>

<p>dev_queue_xmit是对skb做些最后的处理并且第一次尝试发送,软中断是将前者发送失败或者没发完的包发送出去。</p>

<p>主要参考文献：</p>

<p>Linux发送函数dev_queue_xmit分析  <a href="http://shaojiashuai123456.iteye.com/blog/842236">http://shaojiashuai123456.iteye.com/blog/842236</a></p>

<p>TC流量控制实现分析（初步）  <a href="http://blog.csdn.net/wwwlkk/article/details/5929308">http://blog.csdn.net/wwwlkk/article/details/5929308</a></p>

<p>Linux内核源码剖析 TCP/IP实现</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/25/kernel-net-rtable/">路由表 rtable</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-25T17:46:00+08:00'><span class='date'>2015-08-25</span> <span class='time'>17:46:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/qy532846454/article/details/6423496">http://blog.csdn.net/qy532846454/article/details/6423496</a></p>

<p><a href="http://blog.csdn.net/qy532846454/article/details/6726171">http://blog.csdn.net/qy532846454/article/details/6726171</a></p>

<p><a href="http://blog.csdn.net/qy532846454/article/details/7568994">http://blog.csdn.net/qy532846454/article/details/7568994</a></p>

<hr />

<h4>路由表</h4>

<p>在内核中存在路由表fib_table_hash和路由缓存表rt_hash_table。路由缓存表主要是为了加速路由的查找，每次路由查询都会先查找路由缓存，再查找路由表。这和cache是一个道理，缓存存储最近使用过的路由项，容量小，查找快速；路由表存储所有路由项，容量大，查找慢。</p>

<p>首先，应该先了解路由表的意义，下面是route命令查看到的路由表：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Destination    Netmask        Gateway         Flags  Interface  Metric
</span><span class='line'>169.254.0.0    255.255.0.0      *               U      eth0       1
</span><span class='line'>192.168.123.0  255.255.255.0    *               U      eth0       1
</span><span class='line'>default        0.0.0.0       192.168.123.254    UG     eth0       1</span></code></pre></td></tr></table></div></figure>


<p>一条路由其实就是告知主机要到达一个目的地址，下一跳应该走哪里。比如发往192.168.22.3报文通过查路由表，会得到下一跳为192.168.123.254，再将其发送出去。在路由表项中，还有一个很重要的属性-scope，它代表了到目的网络的距离。</p>

<p>路由scope可取值：RT_SCOPE_UNIVERSE, RT_SCOPE_LINK, RT_SCOPE_HOST</p>

<p>在报文的转发过程中，显然是每次转发都要使到达目的网络的距离要越来越小或不变，否则根本到达不了目的网络。上面提到的scope很好的实现这个功能，在查找路由表中，表项的scope一定是更小或相等的scope(比如RT_SCOPE_LINK，则表项scope只能为RT_SCOPE_LINK或RT_SCOPE_HOST)。</p>

<h4>路由缓存</h4>

<p>路由缓存用于加速路由的查找，当收到报文或发送报文时，首先会查询路由缓存，在内核中被组织成hash表，就是rt_hash_table。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct rt_hash_bucket          *rt_hash_table __read_mostly;      [net/ipv4/route.c]</span></code></pre></td></tr></table></div></figure>


<p>通过ip_route_input()进行查询，首先是缓存操作时，通过[src_ip, dst_ip, iif,rt_genid]计算出hash值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(daddr, saddr, iif, rt_genid(net));</span></code></pre></td></tr></table></div></figure>


<p>此时rt_hash_table[hash].chain就是要操作的缓存表项的链表，比如遍历该链表</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (rth = rt_hash_table[hash].chain; rth; rth = rth-&gt;u.dst.rt_next)</span></code></pre></td></tr></table></div></figure>


<p>因此，在缓存中查找一个表项，首先计算出hash值，取出这组表项，然后遍历链表，找出指定的表项，这里需要完全匹配[src_ip, dst_ip, iif, tos, mark, net]，实际上struct rtable中有专门的属性用于缓存的查找键值 – struct flowi。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Cache lookup keys */
</span><span class='line'>struct flowi                fl;</span></code></pre></td></tr></table></div></figure>


<p>当找到表项后会更新表项的最后访问时间，并取出dst</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dst_use(&rth-&gt;u.dst, jiffies);
</span><span class='line'>skb_dst_set(skb, &rth-&gt;u.dst);</span></code></pre></td></tr></table></div></figure>


<p>路由缓存的创建</p>

<p>inet_init() -> ip_init() -> ip_rt_init()</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rt_hash_table = (struct rt_hash_bucket *)
</span><span class='line'>&#9;alloc_large_system_hash("IP route cache",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;sizeof(struct rt_hash_bucket),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;rhash_entries,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;(totalram_pages &gt;= 128 * 1024) ?
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;15 : 17,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;0,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&rt_hash_log,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&rt_hash_mask,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;rhash_entries ? 0 : 512 * 1024);</span></code></pre></td></tr></table></div></figure>


<p>其中rt_hash_mask表示表的大小，rt_hash_log = log(rt_hash_mask)，创建后的结构如图所示：</p>

<p><img src="/images/kernel/2015-08-25-1.png" alt="" /></p>

<h4>路由缓存插入条目</h4>

<p>函数rt_intern_hash()</p>

<p>要插入的条目是rt，相应散列值是hash，首先通过hash值找到对应的bucket</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rthp = &rt_hash_table[hash].chain;</span></code></pre></td></tr></table></div></figure>


<p>然后对bucket进行一遍查询，这次查询的目的有两个：如果是超时的条目，则直接删除；如果是与rt相同键值的条目，则删除并将rt插入头部返回。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while ((rth = *rthp) != NULL) {
</span><span class='line'>&#9;if (rt_is_expired(rth)) {     // 超时的条目
</span><span class='line'>&#9;&#9;*rthp = rth-&gt;u.dst.rt_next;
</span><span class='line'>&#9;&#9;rt_free(rth);
</span><span class='line'>&#9;&#9;continue;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (compare_keys(&rth-&gt;fl, &rt-&gt;fl) && compare_netns(rth, rt)) { //重复的条目
</span><span class='line'>&#9;&#9;*rthp = rth-&gt;u.dst.rt_next;
</span><span class='line'>&#9;&#9;rcu_assign_pointer(rth-&gt;u.dst.rt_next, rt_hash_table[hash].chain);
</span><span class='line'>&#9;&#9;rcu_assign_pointer(rt_hash_table[hash].chain, rth);
</span><span class='line'>&#9;&#9;……
</span><span class='line'>&#9;}
</span><span class='line'>&#9;……
</span><span class='line'>&#9;rthp = &rth-&gt;u.dst.rt_next;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在扫描一遍后，如rt还未存在，则将其插入头部</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rt-&gt;u.dst.rt_next = rt_hash_table[hash].chain;
</span><span class='line'>rcu_assign_pointer(rt_hash_table[hash].chain, rt);</span></code></pre></td></tr></table></div></figure>


<p>如果新插入rt满足一定条件，还要与ARP邻居表进行绑定</p>

<p>Hint：缓存的每个bucket是没有头结点的，单向链表，它所使用的插入和删除操作是值得学习的，简单实用。</p>

<h4>路由缓存删除条目</h4>

<p>rt_del()</p>

<p>要删除的条目是rt，相应散列值是hash，首先通过hash值找到对应的bucket，然后遍历，如果条目超时，或找到rt，则删除它。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rthp = &rt_hash_table[hash].chain;
</span><span class='line'>spin_lock_bh(rt_hash_lock_addr(hash));
</span><span class='line'>ip_rt_put(rt);
</span><span class='line'>while ((aux = *rthp) != NULL) {
</span><span class='line'>&#9;if (aux == rt || rt_is_expired(aux)) {
</span><span class='line'>&#9;&#9;*rthp = aux-&gt;u.dst.rt_next;
</span><span class='line'>&#9;&#9;rt_free(aux);
</span><span class='line'>&#9;&#9;continue;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;rthp = &aux-&gt;u.dst.rt_next;
</span><span class='line'>}
</span><span class='line'>spin_unlock_bh(rt_hash_lock_addr(hash));</span></code></pre></td></tr></table></div></figure>


<h4>路由表的创建</h4>

<p>inet_init() -> ip_init() -> ip_fib_init() -> fib_net_init() -> ip_fib_net_init()[net/ipv4/fib_frontend.c]</p>

<p>首先为路由表分配空间，这里的每个表项hlist_head实际都会链接一个单独的路由表，FIB_TABLE_HASHSZ表示了分配多少个路由表，一般情况下至少有两个 –　LOCAL和MAIN。注意这里仅仅是表头的空间分配，还没有真正分配路由表空间。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>net-&gt;ipv4.fib_table_hash = kzalloc(
</span><span class='line'>&#9;&#9;sizeof(struct hlist_head)*FIB_TABLE_HASHSZ, GFP_KERNEL);</span></code></pre></td></tr></table></div></figure>


<p>ip_fib_net_init() -> fib4_rules_init()，这里真正分配了路由表空间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>local_table = fib_hash_table(RT_TABLE_LOCAL);
</span><span class='line'>main_table  = fib_hash_table(RT_TABLE_MAIN);</span></code></pre></td></tr></table></div></figure>


<p>然后将local和main表链入之前的fib_table_hash中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hlist_add_head_rcu(&local_table-&gt;tb_hlist,
</span><span class='line'>&#9;&#9;&net-&gt;ipv4.fib_table_hash[TABLE_LOCAL_INDEX]);
</span><span class='line'>
</span><span class='line'>hlist_add_head_rcu(&main_table-&gt;tb_hlist,
</span><span class='line'>&#9;&#9;&net-&gt;ipv4.fib_table_hash[TABLE_MAIN_INDEX]);</span></code></pre></td></tr></table></div></figure>


<p>最终生成结构如图，LOCAL表位于fib_table_hash[0]，MAIN表位于fib_table_hash[1]；两张表通过结构tb_hlist链入链表，而tb_id则标识了功能，255是LOCAL表，254是MAIN表。</p>

<p>关于这里的struct fn_hash，它表示了不同子网掩码长度的hash表[即fn_zone]，对于ipv4，从0~32共33个。而fn_hash的实现则是fib_table的最后一个参数unsigned char tb_data[0]。</p>

<p><img src="/images/kernel/2015-08-25-2.png" alt="" /></p>

<p>注意到这里fn_zone还只是空指针，我们还只完成了路由表初始化的一部分。在启动阶段还会调用inet_rtm_newroute() -> fib_table_insert() -> fn_new_zone() [fib_hash.c]来创建fn_zone结构，前面已经讲过，fn_zone一共有33个，其中掩码长度为0[/0]表示为默认路由，fn_zone可以理解为相同掩码的地址集合。</p>

<p>首先为fn_zone分配空间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct fn_zone *fz = kzalloc(sizeof(struct fn_zone), GFP_KERNEL);</span></code></pre></td></tr></table></div></figure>


<p>传入参数z代表掩码长度， z = 0的掩码用于默认路由，一般只有一个，所以fz_divisor只需设为1；其它设为16；这里要提到fz_divisor的作用，fz->fz_hash并不是个单链表，而是一个哈希表，而哈希表的大小就是fz_divisor。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (z) {
</span><span class='line'>&#9;fz-&gt;fz_divisor = 16;
</span><span class='line'>} else {
</span><span class='line'>&#9;fz-&gt;fz_divisor = 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>fz_hashmask实际是用于求余数的，当算出hash值，再hash &amp; fz_hashmask就得出了在哈希表的位置；而fz_hash就是下一层的哈希表了，前面已经提过路由表被多组分层了，这里fz_hash就是根据fz_divisor大小来创建的；fz_order就是子网掩码长度；fz_mask就是子网掩码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fz-&gt;fz_hashmask = (fz-&gt;fz_divisor - 1);
</span><span class='line'>fz-&gt;fz_hash = fz_hash_alloc(fz-&gt;fz_divisor);
</span><span class='line'>fz-&gt;fz_order = z;
</span><span class='line'>fz-&gt;fz_mask = inet_make_mask(z);</span></code></pre></td></tr></table></div></figure>


<p>从子网长度大于新添加fz的fn_zone中挑选一个不为空的fn_zones[i]，将新创建的fz设成fn_zones[i].next；然后将fz根据掩码长度添加到fn_zones[]中相应位置；fn_zone_list始终指向掩码长度最长的fn_zone。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (i=z+1; i&lt;=32; i++)
</span><span class='line'>&#9;if (table-&gt;fn_zones[i])
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>if (i&gt;32) {
</span><span class='line'>&#9;fz-&gt;fz_next = table-&gt;fn_zone_list;
</span><span class='line'>&#9;table-&gt;fn_zone_list = fz;
</span><span class='line'>} else {
</span><span class='line'>&#9;fz-&gt;fz_next = table-&gt;fn_zones[i]-&gt;fz_next;
</span><span class='line'>&#9;table-&gt;fn_zones[i]-&gt;fz_next = fz;
</span><span class='line'>}
</span><span class='line'>table-&gt;fn_zones[z] = fz;</span></code></pre></td></tr></table></div></figure>


<p>这里的fn_hash是数组与链表的结合体，看下fn_hash定义</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct fn_hash {
</span><span class='line'>&#9;struct fn_zone *fn_zones[33];
</span><span class='line'>&#9;struct fn_zone *fn_zone_list;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>fn_hash包含33数组元素，每个元素存放一定掩码长度的fn_zone，其中fn_zone[i]存储掩码长度为i。而fn_zone通过内部属性fz_next又彼此串连起来，形成单向链表，其中fn_zone_list可以看作链表头，而这里链表的组织顺序是倒序的，即从掩码长到短。</p>

<p><img src="/images/kernel/2015-08-25-3.png" alt="" /></p>

<p>到这里，fz_hash所分配的哈希表还没有插入内容，这部分为fib_insert_node()完成。</p>

<p>inet_rtm_newroute() -> fib_table_insert() -> fib_insert_node() [net/ipv4/fib_hash.c]</p>

<p>这里f是fib_node，可以理解为具有相同网络地址的路由项集合。根据fn_key(网络地址)和fz(掩码长度)来计算hash值，决定将f插入fz_hash的哪个项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct hlist_head *head = &fz-&gt;fz_hash[fn_hash(f-&gt;fn_key, fz)];
</span><span class='line'>hlist_add_head(&f-&gt;fn_hash, head);</span></code></pre></td></tr></table></div></figure>


<p>如何fib_node还不存在，则会创建它，这里的kmem_cache_zalloc()其实就是内存分配</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>new_f = kmem_cache_zalloc(fn_hash_kmem, GFP_KERNEL);
</span><span class='line'>if (new_f == NULL)
</span><span class='line'>&#9;goto out;
</span><span class='line'>INIT_HLIST_NODE(&new_f-&gt;fn_hash);
</span><span class='line'>INIT_LIST_HEAD(&new_f-&gt;fn_alias);
</span><span class='line'>new_f-&gt;fn_key = key;
</span><span class='line'>f = new_f;</span></code></pre></td></tr></table></div></figure>


<p>路由表最后一层是fib_info，具体的路由信息都存储在此，它由fib_create_info()创建。</p>

<p>首先为fib_info分配空间，由于fib_info的最后一个属性是struct fib_nh fib_nh[0]，因此大小是fib_info + nhs * fib_nh，这里的fib_nh代表了下一跳(next hop)的信息，nhs代表了下一跳的数目，一般情况下nhs=1，除非配置了支持多路径。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fi = kzalloc(sizeof(*fi)+nhs*sizeof(struct fib_nh), GFP_KERNEL);</span></code></pre></td></tr></table></div></figure>


<p>设置fi的相关属性</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fi-&gt;fib_net = hold_net(net);
</span><span class='line'>fi-&gt;fib_protocol = cfg-&gt;fc_protocol;
</span><span class='line'>fi-&gt;fib_flags = cfg-&gt;fc_flags;
</span><span class='line'>fi-&gt;fib_priority = cfg-&gt;fc_priority;
</span><span class='line'>fi-&gt;fib_prefsrc = cfg-&gt;fc_prefsrc;
</span><span class='line'>fi-&gt;fib_nhs = nhs;</span></code></pre></td></tr></table></div></figure>


<p>使fi后面所有的nh->nh_parent指向fi，设置后如图所示</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>change_nexthops(fi) {
</span><span class='line'>&#9;nexthop_nh-&gt;nh_parent = fi;
</span><span class='line'>} endfor_nexthops(fi)</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/kernel/2015-08-25-4.png" alt="" /></p>

<p>设置fib_nh的属性，这里仅展示了单一路径的情况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct fib_nh *nh = fi-&gt;fib_nh;
</span><span class='line'>nh-&gt;nh_oif = cfg-&gt;fc_oif;
</span><span class='line'>nh-&gt;nh_gw = cfg-&gt;fc_gw;
</span><span class='line'>nh-&gt;nh_flags = cfg-&gt;fc_flags;</span></code></pre></td></tr></table></div></figure>


<p>然后，再根据cfg->fc_scope值来设置nh的其余属性。如果scope是RT_SCOPE_HOST，则设置下一跳scope为RT_SCOPE_NOWHERE</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (cfg-&gt;fc_scope == RT_SCOPE_HOST) {
</span><span class='line'>&#9;struct fib_nh *nh = fi-&gt;fib_nh;
</span><span class='line'>&#9;nh-&gt;nh_scope = RT_SCOPE_NOWHERE;
</span><span class='line'>&#9;nh-&gt;nh_dev = dev_get_by_index(net, fi-&gt;fib_nh-&gt;nh_oif);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果scope是RT_SCOPE_LINK或RT_SCOPE_UNIVERSE，则设置下跳</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>change_nexthops(fi) {
</span><span class='line'>&#9;if ((err = fib_check_nh(cfg, fi, nexthop_nh)) != 0)
</span><span class='line'>&#9;&#9;goto failure;
</span><span class='line'>} endfor_nexthops(fi)</span></code></pre></td></tr></table></div></figure>


<p>最后，将fi链入链表中，这里要注意的是所有的fib_info(只要创建了的)都会加入fib_info_hash中，如果路由项使用了优先地址属性，还会加入fib_info_laddrhash中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hlist_add_head(&fi-&gt;fib_hash,
</span><span class='line'>&#9;&#9;&fib_info_hash[fib_info_hashfn(fi)]);
</span><span class='line'>
</span><span class='line'>if (fi-&gt;fib_prefsrc) {
</span><span class='line'>&#9;struct hlist_head *head;
</span><span class='line'>&#9;head = &fib_info_laddrhash[fib_laddr_hashfn(fi-&gt;fib_prefsrc)];
</span><span class='line'>&#9;hlist_add_head(&fi-&gt;fib_lhash, head);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>无论fib_info在路由表中位于哪个掩码、哪个网段结构下，都与fib_info_hash和fib_info_laddrhash无关，这两个哈希表与路由表独立，主要是用于加速路由信息fib_info的查找。哈希表的大小为fib_hash_size，当超过这个限制时，fib_hash_size * 2(如果哈希函数够好，每个bucket都有一个fib_info)。fib_info在哈希表的图示如下：</p>

<p><img src="/images/kernel/2015-08-25-5.png" alt="" /></p>

<p>由于路由表信息也可能要以设备dev为键值搜索，因此还存在fib_info_devhash哈希表，用于存储nh的设置dev->ifindex。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>change_nexthops(fi) {
</span><span class='line'>&#9;hash = fib_devindex_hashfn(nexthop_nh-&gt;nh_dev-&gt;ifindex);
</span><span class='line'>&#9;head = &fib_info_devhash[hash];
</span><span class='line'>&#9;hlist_add_head(&nexthop_nh-&gt;nh_hash, head);
</span><span class='line'>} endfor_nexthops(fi)</span></code></pre></td></tr></table></div></figure>


<p>上面讲过了路由表各个部分的创建，现在来看下它们是如何一起工作的，在fib_table_insert()[net/ipv4/fib_hash.c]完成整个的路由表创建过程。下面来看下fib_table_insert()函数：</p>

<p>从fn_zones中取出掩码长度为fc_dst_len的项，如果该项不存在，则创建它[fn_zone的创建前面已经讲过]。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fz = table-&gt;fn_zones[cfg-&gt;fc_dst_len];
</span><span class='line'>if (!fz && !(fz = fn_new_zone(table, cfg-&gt;fc_dst_len)))
</span><span class='line'>&#9;return -ENOBUFS;</span></code></pre></td></tr></table></div></figure>


<p>然后创建fib_info结构，[前面已经讲过]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fi = fib_create_info(cfg);</span></code></pre></td></tr></table></div></figure>


<p>然后在掩码长度相同项里查找指定网络地址key(如145.222.33.0/24)，查找的结果如图所示</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>f = fib_find_node(fz, key);</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/kernel/2015-08-25-6.png" alt="" /></p>

<p>如果不存在该网络地址项，则创建相应的fib_node，并加入到链表fz_hash中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!f) {
</span><span class='line'>&#9;new_f = kmem_cache_zalloc(fn_hash_kmem, GFP_KERNEL);
</span><span class='line'>&#9;if (new_f == NULL)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'> 
</span><span class='line'>&#9;INIT_HLIST_NODE(&new_f-&gt;fn_hash);
</span><span class='line'>&#9;INIT_LIST_HEAD(&new_f-&gt;fn_alias);
</span><span class='line'>&#9;new_f-&gt;fn_key = key;
</span><span class='line'>&#9;f = new_f;
</span><span class='line'>}
</span><span class='line'>……
</span><span class='line'>fib_insert_node(fz, new_f);</span></code></pre></td></tr></table></div></figure>


<p>如果存在该网络地址项，则在fib_node的属性fn_alias中以tos和fi->fib_priority作为键值查找。一个fib_node可以有多个fib_alias相对应，这些fib_alias以链表形式存在，并按tos并从大到小的顺序排列。因此，fib_find_alias查找到的是第一个fib_alias->tos不大于tos的fib_alias项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fa = fib_find_alias(&f-&gt;fn_alias, tos, fi-&gt;fib_priority);</span></code></pre></td></tr></table></div></figure>


<p>如果查找到的fa与与要插入的路由项完全相同，则按照设置的标置位进行操作，NLM_F_REPLACE则替换掉旧的，NLM_F_APPEND添加在后面。</p>

<p>设置要插入的fib_alias的属性，包括最重要的fib_alias->fa_info设置为fi</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>new_fa-&gt;fa_info = fi;
</span><span class='line'>new_fa-&gt;fa_tos = tos;
</span><span class='line'>new_fa-&gt;fa_type = cfg-&gt;fc_type;
</span><span class='line'>new_fa-&gt;fa_scope = cfg-&gt;fc_scope;
</span><span class='line'>new_fa-&gt;fa_state = 0;</span></code></pre></td></tr></table></div></figure>


<p>如果没有要插入路由的网络地址项fib_node，则之前已经创建了新的，现在将它插入到路由表中fib_insert_node()；然后将new_fa链入到fib_node->fn_alias中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (new_f)
</span><span class='line'>&#9;fib_insert_node(fz, new_f);
</span><span class='line'>
</span><span class='line'>list_add_tail(&new_fa-&gt;fa_list,
</span><span class='line'>&#9;&#9;&#9;(fa ? &fa-&gt;fa_list : &f-&gt;fn_alias));</span></code></pre></td></tr></table></div></figure>


<p>最后，由于新插入的路由表项，会发出通告，告知所以加入RTNLGRP_IPV4_ROUTE组的成员，这个功能可以在linux中使用”ip route monitor”来测试。最终的路由表如图所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rtmsg_fib(RTM_NEWROUTE, key, new_fa, cfg-&gt;fc_dst_len, tb-&gt;tb_id, &cfg-&gt;fc_nlinfo, 0);</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/kernel/2015-08-25-7.png" alt="" /></p>

<p>至此，就完成了路由表项的插入，加上之前的路由表的初始化，整个路由表的创建过程就讲解完了，小小总结一下：</p>

<p>路由表的查找效率是第一位的，因此内核在实现时使用了多级索引来进行加速</p>

<p>第一级：fn_zone　按不同掩码长度分类(如/5和/24)</p>

<p>第二级：fib_node  按不同网络地址分类(如124.44.33.0/24)</p>

<p>第三级：fib_info     下一跳路由信息</p>

<hr />

<p>路由可以分为两部分：路由缓存(rt_hash_table)和路由表()</p>

<p>路由缓存顾名思义就是加速路由查找的，路由缓存的插入是由内核控制的，而非人为的插入，与之相对比的是路由表是人为插入的，而非内核插入的。在内核中，路由缓存组织成rt_hash_table的结构。</p>

<p>下面是一段IP层协议的代码段[net/ipv4/route.c]，传入IP层的协议在查找路由时先在路由缓存中查找，如果已存在，则skb_dst_set(skb, &amp;rth->u.dst)并返回；否则在路由表中查询。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(daddr, saddr, iif, rt_genid(net));  
</span><span class='line'>  
</span><span class='line'>rcu_read_lock();  
</span><span class='line'>for (rth = rcu_dereference(rt_hash_table[hash].chain); rth;  
</span><span class='line'>&#9; rth = rcu_dereference(rth-&gt;u.dst.rt_next)) {  
</span><span class='line'>&#9;if (((rth-&gt;fl.fl4_dst ^ daddr) |  
</span><span class='line'>&#9;&#9; (rth-&gt;fl.fl4_src ^ saddr) |  
</span><span class='line'>&#9;&#9; (rth-&gt;fl.iif ^ iif) |  
</span><span class='line'>&#9;&#9; rth-&gt;fl.oif |  
</span><span class='line'>&#9;&#9; (rth-&gt;fl.fl4_tos ^ tos)) == 0 &&  
</span><span class='line'>&#9;&#9;rth-&gt;fl.mark == skb-&gt;mark &&  
</span><span class='line'>&#9;&#9;net_eq(dev_net(rth-&gt;u.dst.dev), net) &&  
</span><span class='line'>&#9;&#9;!rt_is_expired(rth)) {  
</span><span class='line'>&#9;&#9;dst_use(&rth-&gt;u.dst, jiffies);  
</span><span class='line'>&#9;&#9;RT_CACHE_STAT_INC(in_hit);  
</span><span class='line'>&#9;&#9;rcu_read_unlock();  
</span><span class='line'>&#9;&#9;skb_dst_set(skb, &rth-&gt;u.dst);  
</span><span class='line'>&#9;&#9;return 0;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;RT_CACHE_STAT_INC(in_hlist_search);  
</span><span class='line'>}  
</span><span class='line'>rcu_read_unlock();  </span></code></pre></td></tr></table></div></figure>


<p>在ip_route_input()中查询完陆由缓存后会处理组播地址，如果是组播地址，则下面判断会成功：ipv4_is_multicast(daddr)。</p>

<p>然后执行ip_route_input_mc()，它的主要作用就是生成路由缓存项rth，并插入缓存。rth的生成与初始化只给出了input函数的，其它略去了，可以看出组播报文会通过ip_local_deliver()继续向上传递。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rth-&gt;u.dst.input= ip_local_deliver;  
</span><span class='line'>hash = rt_hash(daddr, saddr, dev-&gt;ifindex, rt_genid(dev_net(dev)));  
</span><span class='line'>return rt_intern_hash(hash, rth, NULL, skb, dev-&gt;ifindex);  </span></code></pre></td></tr></table></div></figure>


<p>路由表又可以分为两个：RT_TABLE_LOCAL和RT_TABLE_MAIN<br/>
  RT_TABLE_LOCAL存储目的地址是本机的路由表项，这些目的地址就是为各个网卡配置的IP地址；<br/>
  RT_TABLE_MAIN存储到其它主机的路由表项；</p>

<p>显然，RT_TABLE_MAIN路由表只有当主机作为路由器时才有作用，一般主机该表是空的，因为主机不具有转发数据包的功能。RT_TABLE_LOCAL对主机就足够了，为各个网卡配置的IP地址都会加入RT_TABLE_LOCAL中，如为eth1配置了1.2.3.4的地址，则RT_TABLE_LOCAL中会存在1.2.3.4的路由项。只有本地的网卡地址会被加入，比如lo、eth1。IP模块在初始化时ip_init() -> ip_rt_init() - > ip_fib_init()会注册notifier机制，当为网卡地址配置时会执行fib_netdev_notifier和fib_inetaddr_notifier，使更改反映到RT_TABLE_LOCAL中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>register_netdevice_notifier(&fib_netdev_notifier);  
</span><span class='line'>register_inetaddr_notifier(&fib_inetaddr_notifier);  </span></code></pre></td></tr></table></div></figure>


<p>而当在路由缓存中没有查找到缓存项时，会进行路由表查询，还是以IP层协议中的代码段为例[net/ipv4/route.c]，fib_lookup()会在MAIN和LOCAL两张表中进行查找。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ((err = fib_lookup(net, &fl, &res)) != 0) {  
</span><span class='line'>&#9;if (!IN_DEV_FORWARD(in_dev))  
</span><span class='line'>&#9;&#9;goto e_hostunreach;  
</span><span class='line'>&#9;goto no_route;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>如果主机配置成了支持转发，则无论在路由表中找到与否，都会生成这次查询的一个缓存，包括源IP、目的IP、接收的网卡，插入路由缓存中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(daddr, saddr, fl.iif, rt_genid(net));  
</span><span class='line'>err = rt_intern_hash(hash, rth, NULL, skb, fl.iif);  </span></code></pre></td></tr></table></div></figure>


<p>不同的是，如果在路由表中查询失败，即数据包不是发往本机，也不能被本机转发，则会设置插入路由缓存的缓存项u.dst.input=ip_error，而u.dst.input即为IP层处理完后向上传递的函数，而ip_error()会丢弃数据包，被发送相应的ICMP错误报文。不在路由表中的路由项也要插入路由缓存，这可以看作路由学习功能，下次就可以直接在路由缓存中找到。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rth-&gt;u.dst.input= ip_error;  
</span><span class='line'>rth-&gt;u.dst.error= -err;  
</span><span class='line'>rth-&gt;rt_flags    &= ~RTCF_LOCAL;  </span></code></pre></td></tr></table></div></figure>


<p>但如果主机不支持转发，即没有路由功能，则只有在找到时才会添加路由缓存项，都不会生成路由缓存项。这是因为在LOCAL表中没有找到，表明数据包不是发往本机的，此时缓存这样的路由项对于主机的数据包传输没有一点意义。它只需要知道哪些数据包是发给它的，其余的一律不管！</p>

<p>路由查询整合起来，就是由ip_route_input()引入，然后依次进行路由缓存和路由表查询，并对路由缓存进行更新。路由缓存在每个数据包到来时都可能发生更新，但路由表则不一样，只能通过RTM机制更新，LOCAL表是在网卡配置时更新的，MAIN表则是由人工插入的(inet_rtm_newroute)。</p>

<p>ip_route_input()<br/>
  - 路由缓存查询<br/>
  - 路由表查询：ip_route_input_slow() -> fib_lookup()</p>

<hr />

<p>这次将以更实际的例子来分析过程中路由表的使用情况，注意下文都是对路由缓存表的描述，因为路由表在配置完网卡地址后就不会再改变了(除非人为的去改动)，测试环境如下图：</p>

<p><img src="/images/kernel/2015-08-25-11.jpg" alt="" /></p>

<p>两台主机Host1与Host2，分别配置了IP地址192.168.1.1与192.168.1.2，两台主机间用网线直连。在两台主机上分别执行如下操作：<br/>
  1. 在Host1上ping主机Host2<br/>
  2. 在Host2上ping主机Host1</p>

<p>很简单常的两台主机互ping的例子，下面来分析这过程中路由表的变化，准备说是路由缓存的变化。首先，路由缓存会存在几个条目？答案不是2条而是3条，这点很关键，具体可以通过/proc/net/rt_cache来查看路由缓存表，下图是执行上述操作后得到的结果：</p>

<p><img src="/images/kernel/2015-08-25-12.jpg" alt="" /></p>

<p> brcm0.1是Host主机上的网卡设备，等同于常用的eth0，lo是环路设备。对结果稍加分析，可以发现，条目1和条目2是完全一样的，除了计数的Use稍有差别，存在这种情况的原因是缓存表是以Hash表的形式存储的，尽管两者内容相同，在实际插入时使用的键值是不同的，下面以Host2主机的路由缓存表为视角，针对互ping的过程进行逐一分析。</p>

<p>假设brcm0.1设备的index = 2</p>

<p>步骤0：初始时陆由缓存为空</p>

<p>步骤1：主机Host1 ping 主机Host2</p>

<p>Host2收到来自Host1的echo报文(dst = 192.168.1.2, src = 192.168.1.1)<br/>
在报文进入IP层后会查询路由表，以确定报文的接收方式，相应调用流程：<br/>
ip_route_input() -> ip_route_input_slow()<br/>
在ip_route_input()中查询路由缓存，使用的键值是[192.168.1.2, 192.168.1.1, 2, id]，由于缓存表为空，查询失败，继续走ip_route_input_slow()来创建并插入新的缓存项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(daddr, saddr, iif, rt_genid(net));  </span></code></pre></td></tr></table></div></figure>


<p>在ip_route_input_slow()中查询路由表，因为发往本机，在会LOCAL表中匹配192.168.1.2条目，查询结果res.type==RTN_LOCAL。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ((err = fib_lookup(net, &fl, &res)) != 0) {  
</span><span class='line'> if (!IN_DEV_FORWARD(in_dev))  
</span><span class='line'>  goto e_hostunreach;  
</span><span class='line'> goto no_route;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>然后根据res.type跳转到local_input代码段，创建新的路由缓存项，并插入陆由缓存。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rth = dst_alloc(&ipv4_dst_ops);  
</span><span class='line'>……  
</span><span class='line'>rth-&gt;u.dst.dev = net-&gt;loopback_dev;  
</span><span class='line'>rth-&gt;rt_dst = daddr;  
</span><span class='line'>rth-&gt;rt_src = saddr;  
</span><span class='line'>rth-&gt;rt_gateway = daddr;  
</span><span class='line'>rth-&gt;rt_spec_dst = spec_dst; (spec_dst=daddr)  
</span><span class='line'>……  
</span><span class='line'>hash = rt_hash(daddr, saddr, fl.iif, rt_genid(net));  
</span><span class='line'>err = rt_intern_hash(hash, rth, NULL, skb, fl.iif);  </span></code></pre></td></tr></table></div></figure>


<p>因此插入的第一条缓存信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;Key = [dst = 192.168.1.2  src = 192.168.1.1 idx = 2 id = id]
</span><span class='line'>&#9;Value = [Iface = lo dst = 192.168.1.2 src = 192.168.1.1 idx = 2 id = id ……]</span></code></pre></td></tr></table></div></figure>


<p>步骤2：
主机Host2 发送echo reply报文给主机 Host1 (dst = 192.168.1.1 src = 192.168.1.2)<br/>
步骤2是紧接着步骤1的，Host2在收到echo报文后会立即回复echo reply报文，相应调用流程：<br/>
icmp_reply() -> ip_route_output_key() -> ip_route_output_flow() -> <strong>ip_route_output_key() -> ip_route_output_slow() -> ip_mkroute_output() -> </strong>mkroute_output()<br/>
在icmp_reply()中生成稍后路由查找中的关键数据flowi，可以看作查找的键值，由于是回复已收到的报文，因此目的与源IP地址者是已知的，下面结构中daddr=192.168.1.1，saddr=192.168.1.2。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct flowi fl = { .nl_u = { .ip4_u =  
</span><span class='line'>  { .daddr = daddr,  
</span><span class='line'>  .saddr = rt-&gt;rt_spec_dst,  
</span><span class='line'>  .tos = RT_TOS(ip_hdr(skb)-&gt;tos) } },  
</span><span class='line'>  .proto = IPPROTO_ICMP };  </span></code></pre></td></tr></table></div></figure>


<p>在__ip_route_output_key()时会查询路由缓存表，查询的键值是[192.168.1.1, 192.168.1.2, 0, id]，由于此时路由缓存中只有一条刚刚插入的从192.168.1.1->192.168.1.2的缓存项，因而查询失败，继续走ip_route_output_slow()来创建并插入新的缓存项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(flp-&gt;fl4_dst, flp-&gt;fl4_src, flp-&gt;oif, rt_genid(net));  </span></code></pre></td></tr></table></div></figure>


<p>在ip_route_input_slow()中查询路由表，因为在同一网段，在会MAIN表中匹配192.168.1.0/24条目，查询结果res.type==RTN_UNICAST。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (fib_lookup(net, &fl, &res)) {  
</span><span class='line'>…..  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>然后调用__mkroute_output()来生成新的路由缓存，信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rth-&gt;u.dst.dev = dev_out;  
</span><span class='line'>rth-&gt;rt_dst = fl-&gt;fl4_dst;  
</span><span class='line'>rth-&gt;rt_src = fl-&gt;fl4_src;  
</span><span class='line'>rth-&gt;rt_gateway = fl-&gt;fl4_dst;  
</span><span class='line'>rth-&gt;rt_spec_dst= fl-&gt;fl4_src;  
</span><span class='line'>rth-&gt;fl.oif = oldflp-&gt;oif; (oldflp-&gt;oif为0)  </span></code></pre></td></tr></table></div></figure>


<p>插入路由缓存表时使用的键值是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(oldflp-&gt;fl4_dst, oldflp-&gt;fl4_src, oldflp-&gt;oif, rt_genid(dev_net(dev_out)));  </span></code></pre></td></tr></table></div></figure>


<p>这条语句很关键，缓存的存储形式是hash表，除了生成缓存信息外，还要有相应的键值，这句的hash就是产生的键值，可以看到，它是由(dst, src, oif, id)四元组生成的，dst和src很好理解，id对于net来说是定值，oif则是关键，注意这里用的是oldflp->oif(它的值为0)，尽管路由缓存对应的出接口设备是dev_out。所以，第二条缓存信息的如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;Key = [dst = 192.168.1.1  src = 192.168.1.2 idx = 0 id = id]
</span><span class='line'>&#9;Value = [Iface = brcm0.1  dst = 192.168.1.1 src = 192.168.1.2 idx = 2 id = id ……]</span></code></pre></td></tr></table></div></figure>


<p>步骤3：</p>

<p>主机Host2 ping 主机Host1  <br/>
Host2向Host1发送echo报文(dst = 192.168.1.1, src = 192.168.1.2)<br/>
Host2主动发送echo报文，使用SOCK_RAW与IPPROTO_ICMP组合的套接字，相应调用流程：<br/>
raw_sendmsg() -> ip_route_output_flow() -> <strong>ip_route_output_key() -> ip_route_output_slow() -> ip_mkroute_output() -> </strong>mkroute_output()<br/>
在raw_sendmsg()中生成稍后路由查找中的关键数据flowi，可以看作查找的键值，由于是主动发送的报文，源IP地址者还是未知的，因为主机可能是多接口的，在查询完路由表后才能得到要走的设备接口和相应的源IP地址。下面结构中daddr=192.168.1.1，saddr=0。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct flowi fl = { .oif = ipc.oif,  
</span><span class='line'>  .mark = sk-&gt;sk_mark,  
</span><span class='line'>  .nl_u = { .ip4_u =  
</span><span class='line'>&#9;{ .daddr = daddr,  
</span><span class='line'>   .saddr = saddr,  
</span><span class='line'>   .tos = tos } },  
</span><span class='line'>  .proto = inet-&gt;hdrincl ? IPPROTO_RAW :  
</span><span class='line'>&#9;&#9;sk-&gt;sk_protocol,  
</span><span class='line'> };  </span></code></pre></td></tr></table></div></figure>


<p>在__ip_route_output_key()时会查询路由缓存表，查询的键值是[192.168.1.1, 0, 0, id]，尽管此时路由缓存中刚刚插入了192.168.1.2->192.168.1.1的条目，但由于两者的键值不同，因而查询依旧失败，继续走ip_route_output_slow()来创建并插入新的缓存项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(flp-&gt;fl4_dst, flp-&gt;fl4_src, flp-&gt;oif, rt_genid(net));  </span></code></pre></td></tr></table></div></figure>


<p>与Host2回复Host1的echo报文相比，除了进入函数不同(前者为icmp_reply，后者为raw_sendmsg)，后续调用流程是完全相同的，导致最终路由缓存不同(准确说是键值)是因为初始时flowi不同。<br/>
此处，raw_sendmsg()中，flowi的初始值：dst = 192.168.1.1, src = 0, oif = 0<br/>
对比icmp_reply()中，flowi的初始值：dst = 192.168.1.1, src = 192.168.1.2, oif = 0<br/>
在上述调用流程中，在__ip_route_output_key()中查找路由缓存，尽管此时路由缓存有从192.168.1.2到192.168.1.1的缓存项，但它的键值与此次查找的键值[192.168.1.1, 192.168.1.2, 0]，从下表可以明显看出：</p>

<p><img src="/images/kernel/2015-08-25-13.jpg" alt="" /></p>

<p>由于查找失败，生成新的路由缓存项并插入路由缓存表，注意在ip_route_output_slow()中查找完路由表后，设置了缓存的src。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!fl.fl4_src)  
</span><span class='line'>&#9;fl.fl4_src = FIB_RES_PREFSRC(res);  </span></code></pre></td></tr></table></div></figure>


<p> 因此插入的第三条缓存信息如下，它与第二条缓存完成相同，区别在于键值不同：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;Key = [dst = 192.168.1.1  src = 0 idx = 0 id = id]
</span><span class='line'>&#9;Value = [Iface = brcm0.1  dst = 192.168.1.1 src = 192.168.1.2 idx = 2 id = id ……]</span></code></pre></td></tr></table></div></figure>


<p>最终，路由缓存表如下：</p>

<p><img src="/images/kernel/2015-08-25-14.jpg" alt="" /></p>

<p> 第三条缓存条目键值使用src=0, idx=0的原因是当主机要发送报文给192.168.1.1的主机时，直到IP层路由查询前，它都无法知道该使用的接口地址(如果没有绑定的话)，而路由缓存的查找发生在路由查询之前，所以src=0,idx=0才能保证后续报文使用该条目。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/25/kernel-net-ifconfig/">ifconfig statistics</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-25T14:27:00+08:00'><span class='date'>2015-08-25</span> <span class='time'>14:27:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://jaseywang.me/2014/08/16/ifconfig-%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%97%E6%AE%B5errors-dropped-overruns/">http://jaseywang.me/2014/08/16/ifconfig-%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%97%E6%AE%B5errors-dropped-overruns/</a></p>

<p><a href="http://unix.stackexchange.com/questions/184604/whats-the-difference-between-errors-dropped-overruns-and-frame-fiel">http://unix.stackexchange.com/questions/184604/whats-the-difference-between-errors-dropped-overruns-and-frame-fiel</a></p>

<p>RX errors: 表示总的收包的错误数量，这包括 too-long-frames 错误，Ring Buffer 溢出错误，crc 校验错误，帧同步错误，fifo overruns 以及 missed pkg 等等。</p>

<p>RX dropped: 表示数据包已经进入了 Ring Buffer，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃。</p>

<p>RX overruns: 表示了 fifo 的 overruns，这是由于 Ring Buffer(aka Driver Queue) 传输的 IO 大于 kernel 能够处理的 IO 导致的，而 Ring Buffer 则是指在发起 IRQ 请求之前的那块 buffer。很明显，overruns 的增大意味着数据包没到 Ring Buffer 就被网卡物理层给丢弃了，而 CPU 无法即使的处理中断是造成 Ring Buffer 满的原因之一，上面那台有问题的机器就是因为 interruprs 分布的不均匀(都压在 core0)，没有做 affinity 而造成的丢包。</p>

<p>RX frame: 表示 misaligned 的 frames，接收到的位长度不是8的倍数，不是字节。it means frames with a length not divisible by 8. Because of that length is not a valid frame and it is simply discarded.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/21/tools-command-iostat/">iostat 命令</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-21T15:57:00+08:00'><span class='date'>2015-08-21</span> <span class='time'>15:57:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/zhangjay/article/details/6656771">http://blog.csdn.net/zhangjay/article/details/6656771</a></p>

<p><a href="http://www.cnblogs.com/mfryf/archive/2012/03/12/2392000.html">http://www.cnblogs.com/mfryf/archive/2012/03/12/2392000.html</a></p>

<p>iostat用于输出CPU和磁盘I/O相关的统计信息.</p>

<p>命令格式:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>iostat [ -c | -d ] [ -k | -m ] [ -t ] [ -V ] [ -x ] [ device [ ... ] | ALL ] [ -p [ device | ALL ]  ]
</span><span class='line'>       [ interval [ count ] ]</span></code></pre></td></tr></table></div></figure>


<h4>1)iostat的 简单使用</h4>

<p>iostat可以显示CPU和I/O系统的负载情况及分区状态信息. 直接执行iostat可以显示下面内容:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># iostat
</span><span class='line'>Linux 2.6.9-8.11.EVAL (ts3-150.ts.cn.tlan)      08/08/2007
</span><span class='line'>
</span><span class='line'>avg-cpu:  %user   %nice    %sys %iowait   %idle
</span><span class='line'>          12.01    0.00        2.15    2.30       83.54
</span><span class='line'>
</span><span class='line'>Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
</span><span class='line'>hda               7.13       200.12        34.73     640119     111076</span></code></pre></td></tr></table></div></figure>


<p>各个输出项目的含义如下:</p>

<p>avg-cpu段:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>%user: 在用户级别运行所使用的CPU的百分比.
</span><span class='line'>%nice: nice操作所使用的CPU的百分比.
</span><span class='line'>%sys: 在系统级别(kernel)运行所使用CPU的百分比.
</span><span class='line'>%iowait: CPU等待硬件I/O时,所占用CPU百分比.
</span><span class='line'>%idle: CPU空闲时间的百分比.</span></code></pre></td></tr></table></div></figure>


<p>Device段:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tps: 每秒钟发送到的I/O请求数.
</span><span class='line'>Blk_read /s: 每秒读取的block数.
</span><span class='line'>Blk_wrtn/s: 每秒写入的block数.
</span><span class='line'>Blk_read:   读入的block总数.
</span><span class='line'>Blk_wrtn:  写入的block总数.</span></code></pre></td></tr></table></div></figure>


<h4>2)iostat参 数说明</h4>

<p>iostat各个参数说明:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-c 仅显示CPU统计信息.与-d选项互斥.
</span><span class='line'>-d 仅显示磁盘统计信息.与-c选项互斥.
</span><span class='line'>-k 以K为单位显示每秒的磁盘请求数,默认单位块.
</span><span class='line'>-p device | ALL
</span><span class='line'> 与-x选项互斥,用于显示块设备及系统分区的统计信息.也可以在-p后指定一个设备名,如:
</span><span class='line'> # iostat -p hda
</span><span class='line'> 或显示所有设备
</span><span class='line'> # iostat -p ALL
</span><span class='line'>-t    在输出数据时,打印搜集数据的时间.
</span><span class='line'>-V    打印版本号和帮助信息.
</span><span class='line'>-x    输出扩展信息.</span></code></pre></td></tr></table></div></figure>


<h4>3)iostat输 出项目说明</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rrqm/s: 每秒进行 merge 的读操作数目。即 delta(rmerge)/s
</span><span class='line'>wrqm/s: 每秒进行 merge 的写操作数目。即 delta(wmerge)/s
</span><span class='line'>r/s: 每秒完成的读 I/O 设备次数。即 delta(rio)/s
</span><span class='line'>w/s: 每秒完成的写 I/O 设备次数。即 delta(wio)/s
</span><span class='line'>rsec/s: 每秒读扇区数。即 delta(rsect)/s
</span><span class='line'>wsec/s: 每秒写扇区数。即 delta(wsect)/s
</span><span class='line'>rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算)
</span><span class='line'>wkB/s: 每秒写K字节数。是 wsect/s 的一半。(需要计算)
</span><span class='line'>avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。delta(rsect+wsect)/delta(rio+wio)
</span><span class='line'>avgqu-sz: 平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。
</span><span class='line'>await: 平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)
</span><span class='line'>svctm: 平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)
</span><span class='line'>%util: 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为use的单位为毫秒)
</span><span class='line'>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。
</span><span class='line'>
</span><span class='line'>Blk_read 读入块的当总数.
</span><span class='line'>Blk_wrtn 写入块的总数.
</span><span class='line'>kB_read/s 每秒从驱动器读入的数据量,单位为K.
</span><span class='line'>kB_wrtn/s 每秒向驱动器写入的数据量,单位为K.
</span><span class='line'>kB_read 读入的数据总量,单位为K.
</span><span class='line'>kB_wrtn 写入的数据总量,单位为K.
</span><span class='line'>rrqm/s 将读入请求合并后,每秒发送到设备的读入请求数.
</span><span class='line'>wrqm/s 将写入请求合并后,每秒发送到设备的写入请求数.
</span><span class='line'>r/s 每秒发送到设备的读入请求数.
</span><span class='line'>w/s 每秒发送到设备的写入请求数.
</span><span class='line'>rsec/s 每秒从设备读入的扇区数.
</span><span class='line'>wsec/s 每秒向设备写入的扇区数.
</span><span class='line'>rkB/s 每秒从设备读入的数据量,单位为K.
</span><span class='line'>wkB/s 每秒向设备写入的数据量,单位为K.
</span><span class='line'>avgrq-sz 发送到设备的请求的平均大小,单位是扇区.
</span><span class='line'>avgqu-sz 发送到设备的请求的平均队列长度.
</span><span class='line'>await I/O请求平均执行时间.包括发送请求和执行的时间.单位是毫秒.
</span><span class='line'>svctm 发送到设备的I/O请求的平均执行时间.单位是毫秒.
</span><span class='line'>%util 在I/O请求发送到设备期间,占用CPU时间的百分比.用于显示设备的带宽利用率.当这个值接近100%时,表示设备带宽已经占满.</span></code></pre></td></tr></table></div></figure>


<h4>4)iostat示 例</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># iostat
</span><span class='line'>显示一条统计记录,包括所有的CPU和设备.
</span><span class='line'>
</span><span class='line'># iostat -d 2
</span><span class='line'>每隔2秒,显示一次设备统计信息.
</span><span class='line'>
</span><span class='line'># iostat -d 2 6
</span><span class='line'>每隔2秒,显示一次设备统计信息.总共输出6次.
</span><span class='line'>
</span><span class='line'># iostat -x hda hdb 2 6
</span><span class='line'>每隔2秒显示一次hda,hdb两个设备的扩展统计信息,共输出6次.
</span><span class='line'>
</span><span class='line'># iostat -p sda 2 6
</span><span class='line'>每隔2秒显示一次sda及上面所有分区的统计信息,共输出6次.</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/21/tools-command-taskset/">taskset 命令</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-21T15:52:00+08:00'><span class='date'>2015-08-21</span> <span class='time'>15:52:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#taskset --help
</span><span class='line'>taskset (util-linux 2.13-pre7)
</span><span class='line'>usage: taskset [options] [mask | cpu-list] [pid | cmd [args...]]
</span><span class='line'>set or get the affinity of a process
</span><span class='line'>
</span><span class='line'>-p, --pid operate on existing given pid
</span><span class='line'>-c, --cpu-list display and specify cpus in list format
</span><span class='line'>-h, --help display this help
</span><span class='line'>-v, --version output version information</span></code></pre></td></tr></table></div></figure>


<ul>
<li>加-c用的是cpu-id，不加-c用的mask</li>
</ul>


<p>举例：</p>

<p>1、开启一个只用0标记的cpu核心的新进程(job.sh是你的工作脚本)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#taskset -c 0 sh job.sh</span></code></pre></td></tr></table></div></figure>


<p>2、查找现有的进程号，调整该进程cpu核心使用情况（23328举例用的进程号）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#taskset -pc 0 23328
</span><span class='line'>pid 23328's current affinity list: 0-3  #0-3表示使用所有4核进行处理
</span><span class='line'>pid 23328's new affinity list: 0 #调整后改为仅适用0标记单核处理</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/9">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/7">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(40)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>23</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>13</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(52)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~haproxy/?opendiv=tools'>haproxy</a><a href='##' onmousedown=showDiv('tools~haproxy') id='aexp_tools~haproxy'><span class='exp_style' id='exp_tools~haproxy'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~haproxy')) document.getElementById('aexp_tools~haproxy').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(51)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~cgroup/?opendiv=system'>cgroup</a><a href='##' onmousedown=showDiv('system~cgroup') id='aexp_system~cgroup'><span class='exp_style' id='exp_system~cgroup'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~cgroup')) document.getElementById('aexp_system~cgroup').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~kvm/?opendiv=system'>kvm</a><a href='##' onmousedown=showDiv('system~kvm') id='aexp_system~kvm'><span class='exp_style' id='exp_system~kvm'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~kvm')) document.getElementById('aexp_system~kvm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~namespace/?opendiv=system'>namespace</a><a href='##' onmousedown=showDiv('system~namespace') id='aexp_system~namespace'><span class='exp_style' id='exp_system~namespace'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~namespace')) document.getElementById('aexp_system~namespace').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(158)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~fs/?opendiv=kernel'>fs</a><a href='##' onmousedown=showDiv('kernel~fs') id='aexp_kernel~fs'><span class='exp_style' id='exp_kernel~fs'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~fs')) document.getElementById('aexp_kernel~fs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>33</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>76</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>19</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(22)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(68)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~perf/?opendiv=debug'>perf</a><a href='##' onmousedown=showDiv('debug~perf') id='aexp_debug~perf'><span class='exp_style' id='exp_debug~perf'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~perf')) document.getElementById('aexp_debug~perf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(27)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>20</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(207)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~12/?opendiv=2015'>2015-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2015~11/?opendiv=2015'>2015-11</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2015~10/?opendiv=2015'>2015-10</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2015~09/?opendiv=2015'>2015-09</a><span class='right_span'>18</span></li>
<li><a href='/blog/cats/2015~08/?opendiv=2015'>2015-08</a><span class='right_span'>25</span></li>
<li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>31</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/27/kernel-net-test-tool/">Web压力测试工具</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/27/alg-mul2_add2/">乘2加1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/08/kernel-net-cwnd-test/">TCP拥塞控制窗口有效性验证机制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/08/android-base-adjust/">Android 系统基本</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/26/lang-c-flock/">c 文件锁flock</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
	<li>
		<a href=http://smilejay.com/ target=_blank>smilejay</a>
	</li>
	<li>
		<a href=http://blog.chinaunix.net/uid/10167808.html target=_blank>godbach</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
