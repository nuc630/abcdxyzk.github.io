
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/21/ubuntu-dota2/">ubuntu dota2</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-21T23:51:00+08:00'><span class='date'>2013-09-21</span> <span class='time'>23:51:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ERROR- You are missing the following 32-bit libraries, and Steam may not run:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib</span></code></pre></td></tr></table></div></figure>


<p>无法输入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export LC_CTYPE="en_US.UTF-8" && steam</span></code></pre></td></tr></table></div></figure>


<h4>一、集显</h4>

<p>  ubuntu下，如果是intel的核心显卡，mesa低于9.2版本的话，会出现看不见树和看不见英雄的情况
  这时候就要更新mesa到9.2，mesa9.2支持3.6之后的内核版本，如果内核低于3.6，就要先更新内核
  ubuntu的解决办法:
  查看当前mesa版本：glxinfo |grep -i opengl
  查看当前内核版本：uname -a</p>

<p>  sudo add-apt-repository ppa:xorg-edgers/ppa
  sudo apt-get update
  sudo apt-get install linux-generic-lts-raring  (更新内核)
  sudo apt-get dist-upgrade mesa                 (更新mesa)
  然后就是重启系统</p>

<h4>二、独显</h4>

<p>ubuntu 装独显 <a href="/blog/2013/03/26/ubuntu-use-nvidia/">ubuntu 12.04 N卡双显卡</a></p>

<p>如果你想用独显玩dota2, 那么你需要用optirun steam来启动steam客户端，然后再启动游戏，这样游戏就是通过独显来渲染的。你也可以用普通的steam命令来启动steam，然后在dota2 游戏的属性中，加入启动方式optirun %command。 这样只有在启动游戏之后独显才会工作。</p>

<p>用optirun -b primus %command%(记得要装primus)，效果更好。 // 用%command%在启动时画面会显示不全，但是好像用%command好像又不会用独显了</p>

<p>primus默认是有垂直同步的，帧数当然会低，加个vblank_mode=0绝对秒杀virtualgl</p>

<p>不能用vblank_mode=0 optirun -b primus programme做桥接启动程序，这样会拉低许多显卡性能，
使用vblank_mode=0 primusrun programme，性能就上来了，我这里确实比optirun提高30%左右</p>

<hr />

<h5>1打开启动选项输入框</h5>

<h5>2 输入所选命令（使用多个命令是中间用空格隔开，例如 -novid -international -console  ）</h5>

<p>-novid （去除开始动画）<br/>
-console（命令面板）<br/>
-high （使dota2 的cpu和内存使用级为最高,也就是说让dota2 可以优先其他程序使用内存）<br/>
-windowed （窗口模式）</p>

<h5>dota 2 console 命令</h5>

<h6>1首先开启命令面板</h6>

<h6>2输入常用命令</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>net_graph 1 （ 网络状况显示）
</span><span class='line'>&#9;再来就是改变位置，有些人不喜欢显示在左边，这个时候可以输入：
</span><span class='line'>&#9;net_graphpos 1
</span><span class='line'>&#9;这样显示的数据就会变到右边
</span><span class='line'>
</span><span class='line'>&#9;net_graphpos 2
</span><span class='line'>&#9;这样会变成中间
</span><span class='line'>
</span><span class='line'>&#9;net_graphpos 3
</span><span class='line'>&#9;这样会变成左边
</span><span class='line'>
</span><span class='line'>dota_minimap_hero_size 650 （英雄在小地图上的大小 650 为正常值，可自行更改）
</span><span class='line'>dota_force_right_click_attack 1 (英雄可以右键直接反补）
</span><span class='line'>dota_hud_healthbars 1 （去掉生命条上的分隔）
</span><span class='line'>dota_health_per_vertical_marker 250 （更改每一个分隔代表的血量 默认为250）
</span><span class='line'>dota_disable_range_finder 0  （随时显示你的施法距离）（很有用）
</span><span class='line'>dota_camera_accelerate 49 （任意调整观看视角）（没用过）
</span><span class='line'>
</span><span class='line'>dota2 一共有数百种命令，包括血的颜色，屏蔽某种声音等等，但是比较实际的就是这几种，其他的就不列举了。
</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>Dota2 录像下载失败</h4>

<p>无法打开录像文件,请确保没有其他进程已打开此文件。</p>

<p>在XXX\Steam\SteamApps\common\dota 2 beta\dota目录下新建一个名为replays的文件夹即可</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>net_graphheight "64"
</span><span class='line'>这个等于是设置高度位置 大家如果分屏率不同 可以修改数字来决定位置 数字越小 会往下移动 
</span><span class='line'>
</span><span class='line'>net_graphinsetbottom "437"
</span><span class='line'>这个等于是设置地步位置 大家如果分屏率不同 可以修改数字来决定位置 数字越小 会往上移动 
</span><span class='line'>
</span><span class='line'>net_graphinsetleft "0"
</span><span class='line'>因为已经设置右边 这个保持0就OK 但是也记得输入一次 以防万一 
</span><span class='line'>
</span><span class='line'>net_graphinsetright "-83"
</span><span class='line'>设置右边距离 记住这里是"-83" 不是83 负数越高 越往右 大家可以根据自己的需要改变数字 
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>net_graphproportionalfont "0"
</span><span class='line'>这个是关键 字体比例问题 默认是1 设定为0以后 就会变成我图中那样的小字 
</span><span class='line'>
</span><span class='line'>net_graphtext "1"
</span><span class='line'>这个没什么大问题 字体样式</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/09/kernel-net-rx/">接收包的主流程</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-09T18:10:00+08:00'><span class='date'>2013-09-09</span> <span class='time'>18:10:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_v4_rcv(struct sk_buff *skb)    linux/net/ipv4/tcp_ipv4.c #1611</span></code></pre></td></tr></table></div></figure>


<p>  //tcp刚刚收到从ipv4发上来的包<br/>
  （struct tcphdr: 定义在/include/net/tcp.h中，即包的tcp首部，不包括options部分）<br/>
  （struct sock ：定义在/include/net/sock.h中，即表示socket）<br/>
  检查skb->pkt_type != PACKET_HOST 则丢弃<br/>
  检查th->doff &lt; sizeof(struct tcphdr) / 4，即首部大小不合理，则丢弃<br/>
  检查checksum</p>

<p>  （TCP_SKB_CB(skb)：定义在tcp.h是获取一个实际指向skb->cb[0]的tcp_skb_cb类型指针；将到达的首部剥离后，从中拷贝一些信息到这个变量，供tcp控制功能使用；tcp_skb_cb是在tcp刚收到时填写在包中的）<br/>
  注意：<br/>
        1. tcp_skb_cb->end_seq = seq + th->fin + th->fin + len-doff*4<br/>
        2. when 和 sacked 没有被赋值</p>

<p>  sk = __inet_lookup(&hellip;) 从一个hash表中获取该收包对应的sock结构，根据源IP地址+端口，目的IP地址+端口，inet_iif检查sk->sk_state == TCP_TIME_WAIT，TCP在该状态下则丢弃任何接收到的包并转入后续的特殊处理（未看，和关闭连接的状态迁移有关需要后续来看$），马上准备进入CLOSED状态了；<br/>
  检查sk_filter(sk,skb)，则被过滤器阻拦，丢弃<br/>
  检查!sock_owned_by_user(sk)，不明白sock->sk_lock的意义是什么，只有检查满足才能进入接收，否则 sk_add_backlog(sk, skb)将该sk_buff记录进sk_backlog队列；（注意这部操作加锁了！）<br/>
（struct tcp_sock *tp = tcp_sk(sk)：tcp_sock定义在tcp.h中，通过tcp_sk直接将sock指针转换为tcp_sock型）</p>

<p>  ret = tcp_v4_do_rcv(sk, skb) 进入进一步接收处理！<br/>
（之后的异常操作未看）</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)    linux/net/ipv4/tcp_ipv4.c #1542</span></code></pre></td></tr></table></div></figure>


<p>  //在正常状态下由tcp_v4_rcv调用，进一步进行针对接收包的处理<br/>
  检查sk->sk_state == TCP_ESTABLISHED<br/>
    则tcp_rcv_established(sk, skb, skb->h.th, skb->len)，连接已经建立，则进入进一步接收处理！<br/>
  检查sk->sk_state == TCP_LISTEN，<br/>
    则struct sock *nsk = tcp_v4_hnd_req(sk, skb);    //该函数中判断能否找到已有的连接请求，如果有则说明接收到的是一个ack并在其中创建一个新的sock即nsk；如果没有则说明接收到的是 syn，nsk即为sk；<br/>
  if(nsk!=sk) tcp_child_process(sk,nsk,skb)    //当nsk==sk时，接收的是SYN，不进行此步直接进入tcp_rcv_state_process；否则是ack说明已经创建好了的nsk，在 tcp_child_process对nsk进行tcp_rcv_state_process状态转移处理；<br/>
  tcp_rcv_state_process(sk, skb, skb->h.th, skb->len); 非常重要函数！处理tcp的状态转移<br/>
  reset: tcp_v4_send_reset(rsk, skb);    reset，未看$<br/>
  discard: kfree_skb(skb);</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_rcv_established(struct sock *sk, struct sk_buff *skb,struct tcphdr *th, unsigned len)    linux/net/ipv4/tcp_input.c #3881</span></code></pre></td></tr></table></div></figure>


<p>Header Prediction：基于效率的考虑，将包的处理后续阶段分为fast path和slow path两种，前者用于普通的包，后者用于特殊的包；该header prediction即用于区分两种包的流向。<br/>
1.(tcp_flag_word(th) &amp; TCP_HP_BITS) == tp->pred_flags 判断标志位是不是正常情况；tcp_flag_word返回指向tcphdr的第三个32位基址（即length前面），而TCP_HP_BITS是把 PSH标志位给屏蔽掉即该位值不影响流向；所以总的来说pred_flag应该等于0xS?10 &lt;&lt; 16 + snd_wnd（那么pred_flag是在tcp_fast_path_check或tcp_fast_path_on中更新值的）<br/>
2.TCP_SKB_CB(skb)->seq == tp->rcv_nxt 判断所收包是否为我们正想要接收的，非乱序包<br/>
3.*ptr != htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16) | (TCPOPT_TIMESTAMP &lt;&lt; 8) | TCPOLEN_TIMESTAMP) 若包中没有正常的timestamp选项则转入slow path
 timestamp选项处理： 从包中的ts选项中获取数据，以此刷新tp->rx_opt的saw_tstamp,rcv_tsval,rcv_tsecr域；ts选项含三个 32bit，其中后两个分别记录着tsval和tsecr；（注意，ts_recent并不在此处更新，在后面的tcp_store_ts_recent 中更新）<br/>
  struct tcp_options_received: 定义在tcp.h中，其中saw_tstamp表明timestamp选项是否有效，ts_recent_stamp是我们最近一次更新 ts_recent的时间，ts_recent是下一次回显的时戳一般等于下次发包中的rcv_tsecr；rcv_tsval是该data从发端发出时的时戳值，rcv_tsecr是回显时间戳（即该ack对应的data或者该data对应的上次ack中的ts_tsval值），（注意两端时钟无需同步；当ack被收端推迟时，所回复的ack中的timestamp指向所回复包群中的第一个确认包 “When an incoming segment belongs to the current window, but arrives out of order (which implies that an earlier segment was lost), the timestamp of the earlier segment is returned as soon as it arrives, rather than the timestamp of the segment that arrived out of order.”这条细节未看明白$）从包中的时间戳选项中记录这两个值</p>

<p>4.PAWS check：(s32)(tp->rx_opt.rcv_tsval - tp->rx_opt.ts_recent) &lt; 0，则转入slow path<br/>
  （PAWS:Protection Against Wrapped Sequence Numbers, SeqNo有可能会有回环交叠（因为它最大只有32bit），两个相同序号的包实际上是不同的两个包，此时判断tsval是否小于ts_recent即判断该包是否是一个过去时间的一个多余的包，然后将其作为一个重复包丢弃）</p>

<h5>Fast Path：</h5>

<p>  1.当len == tcp_header_len，即这是一个纯ack（区别于piggyback），注意这是个纯ack，所以它通过长度来进行判断而不是标识！<br/>
    tcp_store_ts_recent(tp): tp->rx_opt.ts_recent = tp->rx_opt.rcv_tsval;<br/>
    tcp_ack(sk, skb, 0) 处理ack，进一步处理，未看！<br/>
    <code>__kfree_skb(skb)</code> 释放该包<br/>
     tcp_data_snd_check(sk,tp) 检查有无更进一步的data包处理<br/>
  2.当len &lt; tcp_header_len，说明该包的首部太小，清除之；<br/>
  3.当len > tcp_header_len，它是一个data包，tcp_copy_to_iovec函数未看，它决定该payload是否可以直接拷贝给用户空间：<br/>
    可，tcp_store_ts_recent(tp);<br/>
      tcp_rcv_rtt_measure_ts(sk,skb); //计算RTT<br/>
      <code>__skb_pull(skb, tcp_header_len);</code> //剥tcp首部<br/>
       tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq; //更新rcv_next<br/>
($ 那么将data拷贝到用户空间的操作在何处体现？难道是在tcp_copy_to_iovec中？)<br/>
    不可，除了以上的操作之外，还要<br/>
      <code>__skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);</code> //将该包加入到接收sk_buff队列尾部<br/>
    tcp_event_data_recv()：management tasks处理<br/>
    若TCP_SKB_CB(skb)->ack_seq != tp->snd_una，说明这是一个有效的ack包<br/>
      tcp_ack(sk, skb, FLAG_DATA); //FLAG_DATA说明这是一个背在data上的ack<br/>
      tcp_data_snd_check(sk, tp); //该函数调用tcp_push_pending_frames函数，如果sk->sk_send_head存在则最终调用 tcp_write_xmit函数发包<br/>
      <code>__tcp_ack_snd_check(sk, 0);</code> //检查基于该收包事件，有无进一步的ack包处理（Delayed ACK，Quick ACK）</p>

<h5>Slow Path：</h5>

<p>  tcp_checksum_complete_user(sk, skb)：checksum检查<br/>
  tcp_fast_parse_options(skb, th, tp)：timestamp选项检查；tcp_paws_discard(sk, skb)：PAWS检查<br/>
  tcp_sequence(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq)：检查是否乱序，并在其中激活QuickACK模式<br/>
    上面两行中，都会再检查RST标志，若没激活则tcp_send_dupack，作用不明，貌似是针对该错包回复一个冗余的ack<br/>
  检查RST标志，tcp_reset(sk) 该函数没什么操作，填写一些错误信息后进入tcp_done函数(该函数进行一些关闭tcp连接的收尾操作)<br/>
  tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq)：更新timestamp信息<br/>
  检查SYN标志，在连接已建立的状态下，收到SYN是错误的，因此tcp_reset(sk)<br/>
  检查ACK标志，tcp_ack(sk, skb, FLAG_SLOWPATH)<br/>
  tcp_rcv_rtt_measure_ts(sk, skb)：更新RTT<br/>
  tcp_urg(sk, skb, th)：处理URG标志<br/>
  tcp_data_queue(sk, skb)：处理接收包所含数据，未看<br/>
  tcp_data_snd_check(sk, tp) &amp; tcp_ack_snd_check(sk)：检查有无进一步的data或ack发送</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_event_data_recv(struct sock *sk, struct tcp_sock *tp, struct sk_buff *skb)    linux/net/ipv4/tcp_input.c #502</span></code></pre></td></tr></table></div></figure>


<p>  //
  inet_csk_schedule_ack(sk)：将icsk_pending置为ICSK_ACK_SCHED，但具体意义不明<br/>
  （struct inet_connection_sock：/linux/include/net/inet_connection_sock，面向INET连接的 socket结构，记录着和tcp连接有关的很多变量，比如本函数要处理的ATO（Acknowledgement timeout）信息；tcp_sock是其上的拓展，它的具体意义尚待发掘）<br/>
  tcp_measure_rcv_mss(sk, skb)：更新rcv_mss，说是与delayed ACK有关，但是具体是怎么运作的？<br/>
  tcp_rcv_rtt_measure(tp)：更新RTT，为什么又更新一遍$<br/>
  接下来的一些列操作是更新inet_connection_sock中的ATO信息，具体操作代码中有注释，但这些信息的运作方式还不明</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_ack(struct sock *sk, struct sk_buff *skb, int flag)    /linux/net/ipv4/tcp_input.c #2491</span></code></pre></td></tr></table></div></figure>


<p>  //处理接受到的ack，内容非常复杂
  首先介绍一下ack可以携带的各个FLAG：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FLAG_DATA：              Incoming frame contained data.
</span><span class='line'>FLAG_WIN_UPDATE：        Incoming ACK was a window update
</span><span class='line'>FLAG_DATA_ACKED：        This ACK acknowledged new data.
</span><span class='line'>FLAG_RETRANS_DATA_ACKED：Some of which was retransmitted.
</span><span class='line'>FLAG_SYN_ACKED：         This ACK acknowledged SYN.
</span><span class='line'>FLAG_DATA_SACKED：       New SACK.
</span><span class='line'>FLAG_ECE：               ECE in this ACK.
</span><span class='line'>FLAG_DATA_LOST：         SACK detected data lossage.
</span><span class='line'>FLAG_SLOWPATH：          Do not skip RFC checks for window update.
</span><span class='line'>FLAG_ACKED：             (FLAG_DATA_ACKED|FLAG_SYN_ACKED)
</span><span class='line'>FLAG_NOT_DUP：           (FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)
</span><span class='line'>FLAG_CA_ALERT：          (FLAG_DATA_SACKED|FLAG_ECE)
</span><span class='line'>FLAG_FORWARD_PROGRESS： (FLAG_ACKED|FLAG_DATA_SACKED)</span></code></pre></td></tr></table></div></figure>


<p>  prior_snd_una = tp->snd_una;ack_seq = TCP_SKB_CB(skb)->seq; ack = TCP_SKB_CB(skb)->ack_seq;<br/>
  //1记录着上一次被确认的data序号；2记录着所收ack包的序号；3记录着所收ack包确认对象的data序号；<br/>
  首先判断若ack在tp->snd_nxt之后或者在prio_snd_una之前，则说明该ack非法或者过时（在过时的情况下，若sacked打开则还需tcp_sacktag_write_queue处理） 24</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!(flag&FLAG_SLOWPATH) && after(ack, prior_snd_una))
</span><span class='line'>&#9;tcp_update_wl（即tp-&gt;snd_wl1 = ack_seq）; tp-&gt;snd_una=ack; //为什么此种情况下并不更新窗口？
</span><span class='line'>else
</span><span class='line'>&#9;flag |= tcp_ack_update_window(sk, tp, skb, ack, ack_seq);
</span><span class='line'>&#9;//nwin = ntohs(skb-&gt;h.th-&gt;window)从ack中记录通告窗口
</span><span class='line'>&#9;如果检查需要更新发送窗口，则tp-&gt;snd_wl1 = ack_seq; tp-&gt;snd_wnd = nwin;
</span><span class='line'>&#9;tp-&gt;snd_una = ack;
</span><span class='line'>&#9;if (TCP_SKB_CB(skb)-&gt;sacked) flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una); //该函数未看
</span><span class='line'>
</span><span class='line'>&#9;tp-&gt;rcv_tstamp = tcp_time_stamp; //rcv_tstamp记录着最近一次收到ack的时戳
</span><span class='line'>&#9;prior_in_flight = tcp_packets_in_flight(tp);
</span><span class='line'>&#9;if(!tp-&gt;packets_out) icsk-&gt;icsk_prbes_out = 0;
</span><span class='line'>&#9;if (sk-&gt;sk_send_head) tcp_ack_probe(sk);    //若此时网络中没有data，直接进入zero-window probe的ack处理;通告窗口的数据已经得到处理，所以tcp_ack_probe中仅仅是重置probe计时器，即 icsk-&gt;icsk_retransmit_timer
</span><span class='line'>
</span><span class='line'>&#9;flag |= tcp_clean_rtx_queue(sk, &seq_rtt);   //从重传队列中移除被确认的data包
</span><span class='line'>
</span><span class='line'>&#9;if (tcp_ack_is_dubious(sk, flag)) { //该函数判断此ack是否可疑，判真情况下具体是flag不为FLAG_NOT_DUP，或flag是FLAG_CA_ALERT，或 icsk_ca_state不为TCP_CA_OPEN状态
</span><span class='line'>&#9;if ((flag & FLAG_DATA_ACKED) && tcp_may_raise_cwnd(sk, flag))
</span><span class='line'>&#9;//如果这个包是一个对新数据包的ack，那么通过tcp_may_raise_cwnd函数来判断是否要进行窗口操作，判真情况下具体是flag不是 FLAG_ECE或snd_cwnd&lt;snd_ssthresh（慢启动？）且icsk_ca_state不为TCP_CA_RECOVERY和 TCP_CA_CWR状态（所以，为什么TCP_CA_LOSS状态可以增窗呢？）
</span><span class='line'>&#9;&#9;tcp_cong_avoid(sk, ack, seq_rtt, prior_in_flight, 0);  
</span><span class='line'>&#9;//该函数会调用icsk-&gt;icsk_ca_ops-&gt;cong_avoid(sk, ack, rtt, in_flight, good)， 这是个函数指针；另外会更新snd_cwnd_stamp
</span><span class='line'>&#9;tcp_fastretrans_alert(sk, prior_snd_una, prior_packets, flag); //未看，极其重要的函数
</span><span class='line'>}else{
</span><span class='line'>&#9;if ((flag & FLAG_DATA_ACKED)) tcp_cong_avoid(sk, ack, seq_rtt, prior_in_flight, 1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>tcp_ack中有很多新的内容，都还未涉及，要注意！！！！！！</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)    /linux/net/ipv4/tcp_input.c #3139</span></code></pre></td></tr></table></div></figure>


<p>  //将数据拷贝至用户空间<br/>
若TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq 则空包丢弃<br/>
__skb_pull(skb, th->doff*4) //剥离tcp首部</p>

<h5>1.若TCP_SKB_CB(skb)->seq == tp->rcv_nxt且tcp_receive_window(tp)!=0，非乱序且处于接受窗口中，正常的情况</h5>

<p>若tp->ucopy.task == current, tp->copied_seq == tp->rcv_nxt, tp->ucopy.len等条件满足，则可以拷贝至用户空间<br/>
  //current是什么不明？ucopy.len貌似是用户最先设定的数据包的量，每次收包之后减小直至零<br/>
    skb_copy_datagram_iovec(skb, 0, tp->ucopy.iov, chunk) //向ucopy.iov拷贝数据<br/>
    tcp_rcv_space_adjust(sk) //计算TCP接受buffer空间大小，拷贝完<br/>
tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;<br/>
if(th->fin) tcp_fin(skb, sk, th); //原来fin的处理在这里！<br/>
若!skb_queue_empty(&amp;tp->out_of_order_queue)<br/>
    tcp_ofo_queue(sk); //看out_of_order_queue中有没有可以移到receive_queue中<br/>
    tcp_sack_remove(tp) //RCV.NXT advances, some SACKs should be eaten<br/>
    tcp_fast_path_check(sk,tp)   //tp->pred_flag值的更新<br/>
  清除skb并return</p>

<h5>2.若!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt) 说明这是一个重传的包</h5>

<p>  tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);   //在其中打开并填写dsack信息,在dyokucate_sack[0]中从seq到end_seq，修改dsack和eff_sacks值<br/>
  tcp_enter_quickack_mode(sk); //进入quick ack模式<br/>
  清除skb并return<br/>
若!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt + tcp_receive_window(tp))<br/>
  清除skb并return<br/>
若before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt) 说明这是一个Partial包，即seq&lt;rcv_next&lt;end_seq<br/>
  tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, tp->rcv_nxt); //填写dsack信息，从seq到rcv_nxt</p>

<h5>3. 其他情况，说明收到了一个乱序包</h5>

<p>若out_of_order_queue为空，则<br/>
（注：out_of_order_queue是一个sk_buff_head结构，它的prev/next指针分别指向最后一个和第一个sk_buff结构，块的排放顺序对应其序号的大小顺序）<br/>
  初始化sack相关域，num_sacks/eff_sacks为1，dsack为0，selective_acks[0]从seq到end_seq；<br/>
  <code>__skb_queue_head(&amp;tp-&gt;out_of_order_queue,skb);</code> //将收包加入out_of_order_queue的头部</p>

<p>若out_of_order_queue不为空，则首先获取skb1 = tp->out_of_order_queue.prev即最新的一个乱序块<br/>
  若seq == TCP_SKB_CB(skb1)->end_seq，说明收包能够接在最新乱序块的右边<br/>
    <code>__skb_append(skb1, skb, &amp;tp-&gt;out_of_order_queue);</code><br/>
    tp->selective_acks[0].end_seq = end_seq; //将新收包接在skb1的右边，看来第一个selective_acks块对应的是最新的乱序序列<br/>
  循环执行skb1=skb1->prev，直到找到!after(TCP_SKB_CB(skb1)->seq, seq)表明需要将收包插在此块之后，或skb1=(struct sk_buff<em>)&amp;tp->out_of_order_queue表明收包比队列中的所与块的序列都要小<br/>
    循环内需要找到收包与队列已有包中的重复部分，然后tcp_dsack_set设置该部分为dsack内容<br/>
  <code>__skb_insert(skb, skb1, skb1-&gt;next, &amp;tp-&gt;out_of_order_queue);</code> //将收包对应的块插入到队列中<br/>
  再次循环执行skb1=skb1->next，直到找到!after(end_seq, TCP_SKB_CB(skb1)->seq)表明需要将从收包到该包之间的所有包全部从队列中移除，或者skb1=(struct sk_buff</em>)&amp;tp->out_of_order_queue表明需要将收包之后的所有包都移出<br/>
    循环内需要将当前的队列包与收包的交叠部分设置为dsack值（当然随着循环的推进，dsack处于不断更新的状况），还要通过 <code>__skb_unlink(skb1, &amp;tp-&gt;out_of_order_queue)，__kfree_skb(skb1);</code>将当前的队列包移除<br/>
  （该处的两部循环，旨在通过比较队列中块的序号和所收包的序号范围，将队列中的包连续化，即消除孔洞）</p>

<hr />
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/06/kernel-net-sack/">内核tcp协议栈SACK的处理tcp_sacktag_write_queue</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-06T15:41:00+08:00'><span class='date'>2013-09-06</span> <span class='time'>15:41:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://simohayha.iteye.com/blog/578744">http://simohayha.iteye.com/blog/578744</a></p>

<p>  上一篇处理ack的blog中我们知道当我们接收到ack的时候，我们会判断sack段，如果包含sack段的话，我们就要进行处理。这篇blog就主要来介绍内核如何处理sack段。</p>

<p>  SACK是包含在tcp的option中的，由于tcp的头的长度的限制，因此SACK也就是最多包含4个段，也就是32个字节。我们先来看tcp中的SACK段的表示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_sack_block {
</span><span class='line'>&#9;u32   start_seq; //起始序列号
</span><span class='line'>&#9;u32   end_seq;   //结束序列号
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>可以看到很简单，就是一个段的起始序列号和一个结束序列号。</p>

<p>前一篇blog我们知道tcp_skb_cb的sacked域也就是sack option的偏移值，而在tcp的option它的组成是由3部分组成的，第一部分为option类型，第二部分为当前option的长度，第三部分才是数据段，因此我们如果要取得SACK的段，就必须这样计算。</p>

<p>这里ack_skb也就是我们要处理的skbuffer。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//首先得到sack option的起始指针。
</span><span class='line'>unsigned char *ptr = (skb_transport_header(ack_skb) +
</span><span class='line'>&#9;&#9;&#9;  TCP_SKB_CB(ack_skb)-&gt;sacked);
</span><span class='line'>//加2的意思也就是加上类型和长度，这里刚好是2个字节。最终结果也就是sack option的数据段。
</span><span class='line'>struct tcp_sack_block_wire *sp_wire = (struct tcp_sack_block_wire *)(ptr+2);</span></code></pre></td></tr></table></div></figure>


<p>这里很奇怪，内核还有一个tcp_sack_block_wire类型的结构，它和tcp_sack_block是完全一样的。</p>

<p>而我们如果要得到当前的SACK段的个数我们要这样做:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define TCPOLEN_SACK_BASE        2
</span><span class='line'>int num_sacks = min(TCP_NUM_SACKS, (ptr[1] - TCPOLEN_SACK_BASE) &gt;&gt; 3);</span></code></pre></td></tr></table></div></figure>


<p>这里ptr1也就是sack option的长度(字节数),而TCPOLEN_SACK_BASE为类型和长度字段的长度，因此这两个值的差也就是sack段的总长度，而这里每个段都是8个字节，因此我们右移3位就得到了它的个数，最后sack的段的长度不能大于4,因此我们要取一个最小值。</p>

<p>上面的结构下面这张图非常清晰的展示了，这几个域的关系：</p>

<p><img src="/images/kernel/2013-09-06.jpeg" alt="" /></p>

<p>然后我们来看SACK的处理，在内核中SACK的处理是通过tcp_sacktag_write_queue来实现的，这个函数比较长，因此这里我们分段来看。</p>

<p>先来看函数的原型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int
</span><span class='line'>tcp_sacktag_write_queue(struct sock *sk, struct sk_buff *ack_skb,
</span><span class='line'>&#9;&#9;&#9;u32 prior_snd_una)</span></code></pre></td></tr></table></div></figure>


<p>第一个参数是当前的sock，第二个参数是要处理的skb，第三个参数是接受ack的时候的snd_una.</p>

<p>在看之前这里有几个重要的域要再要说明下。<br/>
1 tcp socket的sacked_out域，这个域保存了所有被sack的段的个数。<br/>
2 还有一个就是tcp_sacktag_state结构，这个结构保存了当前skb的一些信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_sacktag_state {
</span><span class='line'>&#9;int reord;
</span><span class='line'>&#9;int fack_count;
</span><span class='line'>&#9;int flag;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>3 tcp socket的highest_sack域，这个域也就是被sack确认的最大序列号的skb。</p>

<p>先来看第一部分，这部分的代码主要功能是初始化一些用到的值，比如sack的指针，当前有多少sack段等等，以及一些合法性校验。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//sack段的最大个数
</span><span class='line'>#define TCP_NUM_SACKS 4
</span><span class='line'>......
</span><span class='line'>......
</span><span class='line'>&#9;const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;//下面两句代码，前面已经分析过了，也就是取得sack的指针以及sack 数据段的指针。
</span><span class='line'>&#9;unsigned char *ptr = (skb_transport_header(ack_skb) +
</span><span class='line'>&#9;&#9;&#9;&#9;  TCP_SKB_CB(ack_skb)-&gt;sacked);
</span><span class='line'>&#9;struct tcp_sack_block_wire *sp_wire = (struct tcp_sack_block_wire *)(ptr+2);
</span><span class='line'>&#9;//这个数组最终会用来保存所有的SACK段。
</span><span class='line'>&#9;struct tcp_sack_block sp[TCP_NUM_SACKS];
</span><span class='line'>&#9;struct tcp_sack_block *cache;
</span><span class='line'>&#9;struct tcp_sacktag_state state;
</span><span class='line'>&#9;struct sk_buff *skb;
</span><span class='line'>&#9;//这里得到当前的sack段的个数，这段代码前面也介绍过了。
</span><span class='line'>&#9;int num_sacks = min(TCP_NUM_SACKS, (ptr[1] - TCPOLEN_SACK_BASE) &gt;&gt; 3);
</span><span class='line'>&#9;int used_sacks;
</span><span class='line'>&#9;//重复的sack的个数。
</span><span class='line'>&#9;int found_dup_sack = 0;
</span><span class='line'>&#9;int i, j;
</span><span class='line'>&#9;int first_sack_index;
</span><span class='line'>
</span><span class='line'>&#9;state.flag = 0;
</span><span class='line'>&#9;state.reord = tp-&gt;packets_out;
</span><span class='line'>&#9;//如果sack的个数为0,则我们要更新相关的域。
</span><span class='line'>&#9;if (!tp-&gt;sacked_out) {
</span><span class='line'>&#9;&#9;if (WARN_ON(tp-&gt;fackets_out))
</span><span class='line'>&#9;&#9;&#9;tp-&gt;fackets_out = 0;
</span><span class='line'>&#9;//这个函数主要更新highest_sack域。
</span><span class='line'>&#9;&#9;tcp_highest_sack_reset(sk);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//开始检测是否有重复的sack。这个函数紧接着会详细分析。
</span><span class='line'>&#9;found_dup_sack = tcp_check_dsack(sk, ack_skb, sp_wire,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; num_sacks, prior_snd_una);
</span><span class='line'>&#9;//如果有发现，则设置flag。
</span><span class='line'>&#9;if (found_dup_sack)
</span><span class='line'>&#9;&#9;state.flag |= FLAG_DSACKING_ACK;
</span><span class='line'>
</span><span class='line'>&#9;//再次判断ack的序列号是否太老。
</span><span class='line'>&#9;if (before(TCP_SKB_CB(ack_skb)-&gt;ack_seq, prior_snd_una - tp-&gt;max_window))
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;//如果packets_out为0,则说明我们没有发送还没有确认的段，此时进入out，也就是错误处理。
</span><span class='line'>&#9;if (!tp-&gt;packets_out)
</span><span class='line'>&#9;&#9;goto out;</span></code></pre></td></tr></table></div></figure>


<p>在看接下来的部分之前我们先来看tcp_highest_sack_reset和tcp_check_dsack函数，先是tcp_highest_sack_reset函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void tcp_highest_sack_reset(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;//设置highest_sack为写队列的头。
</span><span class='line'>&#9;tcp_sk(sk)-&gt;highest_sack = tcp_write_queue_head(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里原因很简单，因为当sacked_out为0,则说明没有通过sack确认的段，此时highest_sack自然就指向写队列的头。<br/>
第二个是tcp_check_dsack函数，这个函数比较复杂，他主要是为了检测D-SACK,也就是重复的sack。<br/>
有关dsack的概念可以去看RFC 2883和3708.<br/>
我这里简要的提一下dsack的功能，D-SACK的功能主要是使接受者能够通过sack的块来报道接收到的重复的段，从而使发送者更好的进行拥塞控制。<br/>
这里D-SACK的判断是通过RFC2883中所描述的进行的。如果是下面两种情况，则说明收到了一个D-SACK。<br/>
1 如果SACK的第一个段所ack的区域被当前skb的ack所确认的段覆盖了一部分，则说明我们收到了一个d-sack,而代码中也就是sack第一个段的起始序列号小于snd_una。下面的图描述了这种情况：</p>

<p><img src="/images/kernel/2013-09-06-2.jpeg" alt="" /></p>

<p>2 如果sack的第二个段完全包含了第二个段，则说明我们收到了重复的sack，下面这张图描述了这种关系。</p>

<p><img src="/images/kernel/2013-09-06-3.jpeg" alt="" /></p>

<p>最后要注意的是，这里收到D-SACK后，我们需要打开当前sock d-sack的option。并设置dsack的flag。</p>

<p>然后我们还需要判断dsack的数据是否已经被ack完全确认过了，如果确认过了，我们就需要更新undo_retrans域，这个域表示重传的数据段的个数。</p>

<p>来看代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_check_dsack(struct sock *sk, struct sk_buff *ack_skb,
</span><span class='line'>&#9;&#9;&#9;   struct tcp_sack_block_wire *sp, int num_sacks,
</span><span class='line'>&#9;&#9;&#9;   u32 prior_snd_una)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;//首先取得sack的第一个段的起始和结束序列号
</span><span class='line'>&#9;u32 start_seq_0 = get_unaligned_be32(&sp[0].start_seq);
</span><span class='line'>&#9;u32 end_seq_0 = get_unaligned_be32(&sp[0].end_seq);
</span><span class='line'>&#9;int dup_sack = 0;
</span><span class='line'>
</span><span class='line'>&#9;//判断D-sack,首先判断第一个条件，也就是起始序列号小于ack的序列号
</span><span class='line'>&#9;if (before(start_seq_0, TCP_SKB_CB(ack_skb)-&gt;ack_seq)) {
</span><span class='line'>&#9;&#9;//设置dsack标记。
</span><span class='line'>&#9;&#9;dup_sack = 1;
</span><span class='line'>&#9;&#9;//这里更新tcp的option的sack_ok域。
</span><span class='line'>&#9;&#9;tcp_dsack_seen(tp);
</span><span class='line'>&#9;&#9;NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKRECV);
</span><span class='line'>&#9;} else if (num_sacks &gt; 1) {
</span><span class='line'>&#9;&#9;//然后执行第二个判断，取得第二个段的起始和结束序列号。
</span><span class='line'>&#9;&#9;u32 end_seq_1 = get_unaligned_be32(&sp[1].end_seq);
</span><span class='line'>&#9;&#9;u32 start_seq_1 = get_unaligned_be32(&sp[1].start_seq);
</span><span class='line'>&#9;&#9;//执行第二个判断，也就是第二个段完全包含第一个段。
</span><span class='line'>&#9;&#9;if (!after(end_seq_0, end_seq_1) &&
</span><span class='line'>&#9;&#9;&#9;!before(start_seq_0, start_seq_1)) {
</span><span class='line'>&#9;&#9;&#9;dup_sack = 1;
</span><span class='line'>&#9;&#9;&#9;tcp_dsack_seen(tp);
</span><span class='line'>&#9;&#9;&#9;NET_INC_STATS_BH(sock_net(sk),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;LINUX_MIB_TCPDSACKOFORECV);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//判断是否dsack的数据段完全被ack所确认。
</span><span class='line'>&#9;if (dup_sack &&
</span><span class='line'>&#9;&#9;!after(end_seq_0, prior_snd_una) &&
</span><span class='line'>&#9;&#9;after(end_seq_0, tp-&gt;undo_marker))
</span><span class='line'>&#9;&#9;//更新重传段的个数。
</span><span class='line'>&#9;&#9;tp-&gt;undo_retrans--;
</span><span class='line'>
</span><span class='line'>&#9;return dup_sack;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后回到tcp_sacktag_write_queue，接下来这部分很简单，主要是提取sack的段到sp中，并校验每个段的合法性，然后统计一些信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//开始遍历，这里num_sacks也就是我们前面计算的sack段的个数
</span><span class='line'>for (i = 0; i &lt; num_sacks; i++) {
</span><span class='line'>&#9;int dup_sack = !i && found_dup_sack;
</span><span class='line'>
</span><span class='line'>&#9;//赋值。
</span><span class='line'>&#9;sp[used_sacks].start_seq = get_unaligned_be32(&sp_wire[i].start_seq);
</span><span class='line'>&#9;sp[used_sacks].end_seq = get_unaligned_be32(&sp_wire[i].end_seq);
</span><span class='line'>
</span><span class='line'>&#9;//检测段的合法性。
</span><span class='line'>&#9;if (!tcp_is_sackblock_valid(tp, dup_sack,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;sp[used_sacks].start_seq,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;sp[used_sacks].end_seq)) {
</span><span class='line'>&#9;&#9;int mib_idx;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (dup_sack) {
</span><span class='line'>&#9;&#9;&#9;if (!tp-&gt;undo_marker)
</span><span class='line'>&#9;&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPDSACKIGNOREDNOUNDO;
</span><span class='line'>&#9;&#9;&#9;else
</span><span class='line'>&#9;&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPDSACKIGNOREDOLD;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;/* Don't count olds caused by ACK reordering */
</span><span class='line'>&#9;&#9;&#9;if ((TCP_SKB_CB(ack_skb)-&gt;ack_seq != tp-&gt;snd_una) &&
</span><span class='line'>&#9;&#9;&#9;&#9;!after(sp[used_sacks].end_seq, tp-&gt;snd_una))
</span><span class='line'>&#9;&#9;&#9;&#9;continue;
</span><span class='line'>&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPSACKDISCARD;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//更新统计信息。
</span><span class='line'>&#9;&#9;NET_INC_STATS_BH(sock_net(sk), mib_idx);
</span><span class='line'>&#9;&#9;if (i == 0)
</span><span class='line'>&#9;&#9;&#9;first_sack_index = -1;
</span><span class='line'>&#9;&#9;continue;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//忽略已经确认过的段。
</span><span class='line'>&#9;if (!after(sp[used_sacks].end_seq, prior_snd_una))
</span><span class='line'>&#9;&#9;continue;
</span><span class='line'>&#9;//这个值表示我们要使用的sack的段的个数。
</span><span class='line'>&#9;used_sacks++;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后接下来的代码就是排序sack的段，也就是按照序列号的大小来排序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (i = used_sacks - 1; i &gt; 0; i--) {
</span><span class='line'>&#9;for (j = 0; j &lt; i; j++) {
</span><span class='line'>&#9;&#9;//可以看到这里通过比较起始序列号来排序。
</span><span class='line'>&#9;&#9;if (after(sp[j].start_seq, sp[j + 1].start_seq)) {
</span><span class='line'>&#9;&#9;&#9;//交换对应的值。
</span><span class='line'>&#9;&#9;&#9;swap(sp[j], sp[j + 1]);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* Track where the first SACK block goes to */
</span><span class='line'>&#9;&#9;&#9;if (j == first_sack_index)
</span><span class='line'>&#9;&#9;&#9;&#9;first_sack_index = j + 1;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后就是cache的初始化，这里的tcp socket的recv_sack_cache域要注意，这个域保存了上一次处理的sack的段的序列号。可以看到这个域类型也是tcp_sack_block，而且大小也是4,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//如果sack的数据段的个数为0,则说明我们要忽略调cache，此时可以看到cache指向recv_sack_cache的末尾。
</span><span class='line'>if (!tp-&gt;sacked_out) {
</span><span class='line'>&#9;/* It's already past, so skip checking against it */
</span><span class='line'>&#9;cache = tp-&gt;recv_sack_cache + ARRAY_SIZE(tp-&gt;recv_sack_cache);
</span><span class='line'>} else {
</span><span class='line'>&#9;//否则取出cache，然后跳过空的块。
</span><span class='line'>&#9;cache = tp-&gt;recv_sack_cache;
</span><span class='line'>&#9;/* Skip empty blocks in at head of the cache */
</span><span class='line'>&#9;while (tcp_sack_cache_ok(tp, cache) && !cache-&gt;start_seq &&
</span><span class='line'>&#9;&#9;   !cache-&gt;end_seq)
</span><span class='line'>&#9;&#9;//跳过空的块。
</span><span class='line'>&#9;&#9;cache++;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后就是开始真正处理重传队列中的skb了。</p>

<p>我们要知道重传队列中的skb有三种类型，分别是SACKED(S), RETRANS&reg; 和LOST(L)，而每种类型所处理的数据包的个数分别保存在sacked_out, retrans_out 和lost_out中。</p>

<p>而处于重传队列的skb也就是会处于下面6中状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> * Tag  InFlight    Description
</span><span class='line'> * 0       1        - orig segment is in flight.
</span><span class='line'> * S       0        - nothing flies, orig reached receiver.
</span><span class='line'> * L       0        - nothing flies, orig lost by net.
</span><span class='line'> * R       2        - both orig and retransmit are in flight.
</span><span class='line'> * L|R     1        - orig is lost, retransmit is in flight.
</span><span class='line'> * S|R     1        - orig reached receiver, retrans is still in flight.</span></code></pre></td></tr></table></div></figure>


<p>这里Tag也就是上面所说的三种类型，而InFlight也就是表示还在网络中的段的个数。</p>

<p>然后重传队列中的skb的状态变迁是通过下面这几种事件来触发的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 1. New ACK (+SACK) arrives. (tcp_sacktag_write_queue())
</span><span class='line'> * 2. Retransmission. (tcp_retransmit_skb(), tcp_xmit_retransmit_queue())
</span><span class='line'> * 3. Loss detection event of one of three flavors:
</span><span class='line'> *    A. Scoreboard estimator decided the packet is lost.
</span><span class='line'> *       A'. Reno "three dupacks" marks head of queue lost.
</span><span class='line'> *       A''. Its FACK modfication, head until snd.fack is lost.
</span><span class='line'> *    B. SACK arrives sacking data transmitted after never retransmitted
</span><span class='line'> *       hole was sent out.
</span><span class='line'> *    C. SACK arrives sacking SND.NXT at the moment, when the
</span><span class='line'> *       segment was retransmitted.
</span><span class='line'> * 4. D-SACK added new rule: D-SACK changes any tag to S.</span></code></pre></td></tr></table></div></figure>


<p>在进入这段代码分析之前，我们先来看几个重要的域。</p>

<p>tcp socket的high_seq域，这个域是我们进入拥塞控制的时候最大的发送序列号，也就是snd_nxt.</p>

<p>然后这里还有FACK的概念，FACK算法也就是收到的不同的SACK块之间的hole，他就认为是这些段丢失掉了。因此这里tcp socket有一个fackets_out域，这个域表示了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;//首先取得写队列的头，以便与下面的遍历。
</span><span class='line'>&#9;skb = tcp_write_queue_head(sk);
</span><span class='line'>&#9;state.fack_count = 0;
</span><span class='line'>&#9;i = 0;
</span><span class='line'>
</span><span class='line'>&#9;//这里used_sacks表示我们需要处理的sack段的个数。
</span><span class='line'>&#9;while (i &lt; used_sacks) {
</span><span class='line'>&#9;&#9;u32 start_seq = sp[i].start_seq;
</span><span class='line'>&#9;&#9;u32 end_seq = sp[i].end_seq;
</span><span class='line'>&#9;&#9;//得到是否是重复的sack
</span><span class='line'>&#9;&#9;int dup_sack = (found_dup_sack && (i == first_sack_index));
</span><span class='line'>&#9;&#9;struct tcp_sack_block *next_dup = NULL;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (found_dup_sack && ((i + 1) == first_sack_index))
</span><span class='line'>&#9;&#9;&#9;next_dup = &sp[i + 1];
</span><span class='line'>
</span><span class='line'>&#9;&#9;//如果sack段的结束序列号大于将要发送的最大序列号，这个情况说明我们可能有数据丢失。因此设置丢失标记。这里可以看到也就是上面所说的事件B到达。
</span><span class='line'>&#9;&#9;if (after(end_seq, tp-&gt;high_seq))
</span><span class='line'>&#9;&#9;&#9;state.flag |= FLAG_DATA_LOST;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//跳过一些太老的cache
</span><span class='line'>&#9;&#9;while (tcp_sack_cache_ok(tp, cache) &&
</span><span class='line'>&#9;&#9;&#9;   !before(start_seq, cache-&gt;end_seq))
</span><span class='line'>&#9;&#9;&#9;cache++;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//如果有cache，就先处理cache的sack块。
</span><span class='line'>&#9;&#9;if (tcp_sack_cache_ok(tp, cache) && !dup_sack &&
</span><span class='line'>&#9;&#9;&#9;after(end_seq, cache-&gt;start_seq)) {
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;//如果当前的段的起始序列号小于cache的起始序列号(这个说明他们之间有交叉)，则我们处理他们之间的段。
</span><span class='line'>&#9;&#9;&#9;if (before(start_seq, cache-&gt;start_seq)) {
</span><span class='line'>&#9;&#9;&#9;&#9;skb = tcp_sacktag_skip(skb, sk, &state,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;   start_seq);
</span><span class='line'>&#9;&#9;&#9;&#9;skb = tcp_sacktag_walk(skb, sk, next_dup,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;   &state,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;   start_seq,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;   cache-&gt;start_seq,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;   dup_sack);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;//处理剩下的块，也就是cache-&gt;end_seq和ned_seq之间的段。
</span><span class='line'>&#9;&#9;&#9;if (!after(end_seq, cache-&gt;end_seq))
</span><span class='line'>&#9;&#9;&#9;&#9;goto advance_sp;
</span><span class='line'>&#9;&#9;&#9;//是否有需要跳过处理的skb
</span><span class='line'>&#9;&#9;&#9;skb = tcp_maybe_skipping_dsack(skb, sk, next_dup,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;   &state,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;   cache-&gt;end_seq);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* ...tail remains todo... */
</span><span class='line'>&#9;&#9;&#9;//如果刚好等于sack处理的最大序列号，则我们需要处理这个段。
</span><span class='line'>&#9;&#9;&#9;if (tcp_highest_sack_seq(tp) == cache-&gt;end_seq) {
</span><span class='line'>&#9;&#9;&#9;&#9;/* ...but better entrypoint exists! */
</span><span class='line'>&#9;&#9;&#9;&#9;skb = tcp_highest_sack(sk);
</span><span class='line'>&#9;&#9;&#9;&#9;if (skb == NULL)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;&#9;state.fack_count = tp-&gt;fackets_out;
</span><span class='line'>&#9;&#9;&#9;&#9;cache++;
</span><span class='line'>&#9;&#9;&#9;&#9;goto walk;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;//再次检测是否有需要skip的段。
</span><span class='line'>&#9;&#9;&#9;skb = tcp_sacktag_skip(skb, sk, &state, cache-&gt;end_seq);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;//紧接着处理下一个cache。
</span><span class='line'>&#9;&#9;&#9;cache++;
</span><span class='line'>&#9;&#9;&#9;continue;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;//然后处理这次新的sack段。
</span><span class='line'>&#9;&#9;if (!before(start_seq, tcp_highest_sack_seq(tp))) {
</span><span class='line'>&#9;&#9;&#9;skb = tcp_highest_sack(sk);
</span><span class='line'>&#9;&#9;&#9;if (skb == NULL)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;state.fack_count = tp-&gt;fackets_out;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;skb = tcp_sacktag_skip(skb, sk, &state, start_seq);
</span><span class='line'>
</span><span class='line'>walk:
</span><span class='line'>&#9;&#9;//处理sack的段，主要是tag赋值。
</span><span class='line'>&#9;&#9;skb = tcp_sacktag_walk(skb, sk, next_dup, &state,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;   start_seq, end_seq, dup_sack);
</span><span class='line'>
</span><span class='line'>advance_sp:
</span><span class='line'>&#9;&#9;/* SACK enhanced FRTO (RFC4138, Appendix B): Clearing correct
</span><span class='line'>&#9;&#9; * due to in-order walk
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (after(end_seq, tp-&gt;frto_highmark))
</span><span class='line'>&#9;&#9;&#9;state.flag &= ~FLAG_ONLY_ORIG_SACKED;
</span><span class='line'>
</span><span class='line'>&#9;&#9;i++;
</span><span class='line'>&#9;}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码并不复杂，这里主要有两个函数，我们需要详细的来分析，一个是tcp_sacktag_skip，一个是tcp_sacktag_walk。</p>

<p>先来看tcp_sacktag_skip，我们给重传队列的skb的tag赋值时，我们需要遍历整个队列，可是由于我们有序列号，因此我们可以先确认起始的skb，然后从这个skb开始遍历，这里这个函数就是用来确认起始skb的，这里确认的步骤主要是通过start_seq来确认的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct sk_buff *tcp_sacktag_skip(struct sk_buff *skb, struct sock *sk,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;struct tcp_sacktag_state *state,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;u32 skip_to_seq)
</span><span class='line'>{
</span><span class='line'>&#9;//开始遍历重传队列。
</span><span class='line'>&#9;tcp_for_write_queue_from(skb, sk) {
</span><span class='line'>&#9;&#9;//如果当前的skb刚好等于发送队列的头，则说明我们这个是第一个数据包，则我们直接跳出循环。
</span><span class='line'>&#9;&#9;if (skb == tcp_send_head(sk))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//如果skb的结束序列号大于我们传递进来的序列号，则说明这个skb包含了我们sack确认的段，因此我们退出循环。
</span><span class='line'>&#9;&#9;if (after(TCP_SKB_CB(skb)-&gt;end_seq, skip_to_seq))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;//更新fack的计数。
</span><span class='line'>&#9;&#9;state-&gt;fack_count += tcp_skb_pcount(skb);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//返回skb
</span><span class='line'>&#9;return skb;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是最关键的一个函数tcp_sacktag_walk，这个函数主要是遍历重传队列，找到对应需要设置的段，然后设置tcp_cb的sacked域为TCPCB_SACKED_ACKED，这里要注意，还有一种情况就是sack确认了多个skb，这个时候我们就需要合并这些skb，然后再处理。</p>

<p>然后来看代码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct sk_buff *tcp_sacktag_walk(struct sk_buff *skb, struct sock *sk,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;struct tcp_sack_block *next_dup,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;struct tcp_sacktag_state *state,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;u32 start_seq, u32 end_seq,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;int dup_sack_in)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;struct sk_buff *tmp;
</span><span class='line'>
</span><span class='line'>&#9;//开始遍历skb队列。
</span><span class='line'>&#9;tcp_for_write_queue_from(skb, sk) {
</span><span class='line'>&#9;&#9;//in_sack不为0的话表示当前的skb就是我们要设置标记的skb。
</span><span class='line'>&#9;&#9;int in_sack = 0;
</span><span class='line'>&#9;&#9;int dup_sack = dup_sack_in;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (skb == tcp_send_head(sk))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//由于skb是有序的，因此如果某个skb的序列号大于sack段的结束序列号，我们就退出循环。
</span><span class='line'>&#9;&#9;if (!before(TCP_SKB_CB(skb)-&gt;seq, end_seq))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;//如果存在next_dup,则判断是否需要进入处理。这里就是skb的序列号小于dup的结束序列号
</span><span class='line'>&#9;&#9;if ((next_dup != NULL) &&
</span><span class='line'>&#9;&#9;&#9;before(TCP_SKB_CB(skb)-&gt;seq, next_dup-&gt;end_seq)) {
</span><span class='line'>&#9;&#9;&#9;//返回值付给in_sack,也就是这个函数会返回当前skb是否能够被sack的段确认。
</span><span class='line'>&#9;&#9;&#9;in_sack = tcp_match_skb_to_sack(sk, skb,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;next_dup-&gt;start_seq,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;next_dup-&gt;end_seq);
</span><span class='line'>&#9;&#9;&#9;if (in_sack &gt; 0)
</span><span class='line'>&#9;&#9;&#9;&#9;dup_sack = 1;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;//如果小于等于0,则尝试着合并多个skb段(主要是由于可能一个sack段确认了多个skb，这样我们尝试着合并他们)
</span><span class='line'>&#9;&#9;if (in_sack &lt;= 0) {
</span><span class='line'>&#9;&#9;&#9;tmp = tcp_shift_skb_data(sk, skb, state,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9; start_seq, end_seq, dup_sack);
</span><span class='line'>&#9;&#9;&#9;//这里tmp就为我们合并成功的skb。
</span><span class='line'>&#9;&#9;&#9;if (tmp != NULL) {
</span><span class='line'>&#9;&#9;&#9;&#9;//如果不等，则我们从合并成功的skb重新开始处理。
</span><span class='line'>&#9;&#9;&#9;&#9;if (tmp != skb) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;skb = tmp;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;continue;
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;in_sack = 0;
</span><span class='line'>&#9;&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;&#9;//否则我们单独处理这个skb
</span><span class='line'>&#9;&#9;&#9;&#9;in_sack = tcp_match_skb_to_sack(sk, skb,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;start_seq,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end_seq);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (unlikely(in_sack &lt; 0))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;//如果in_sack大于0,则说明我们需要处理这个skb了。
</span><span class='line'>&#9;&#9;if (in_sack) {
</span><span class='line'>&#9;&#9;&#9;//开始处理skb，紧接着我们会分析这个函数。
</span><span class='line'>&#9;&#9;&#9;TCP_SKB_CB(skb)-&gt;sacked = tcp_sacktag_one(skb, sk,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  state,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  dup_sack,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;  tcp_skb_pcount(skb));
</span><span class='line'>&#9;&#9;&#9;//是否需要更新sack处理的那个最大的skb。
</span><span class='line'>&#9;&#9;&#9;if (!before(TCP_SKB_CB(skb)-&gt;seq,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tcp_highest_sack_seq(tp)))
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_advance_highest_sack(sk, skb);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;state-&gt;fack_count += tcp_skb_pcount(skb);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return skb;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后我们来看tcp_sacktag_one函数，这个函数用来设置对应的tag，这里所要设置的也就是tcp_cb的sacked域。我们再来回顾一下它的值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define TCPCB_SACKED_ACKED      0x01 /* SKB ACK'd by a SACK block    */
</span><span class='line'>#define TCPCB_SACKED_RETRANS    0x02  /* SKB retransmitted        */
</span><span class='line'>#define TCPCB_LOST              0x04  /* SKB is lost          */
</span><span class='line'>#define TCPCB_TAGBITS           0x07  /* All tag bits         */
</span><span class='line'>#define TCPCB_EVER_RETRANS      0x80  /* Ever retransmitted frame */
</span><span class='line'>#define TCPCB_RETRANS     (TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS)</span></code></pre></td></tr></table></div></figure>


<p>如果一切都正常的话，我们最终就会设置skb的这个域为TCPCB_SACKED_ACKED，也就是已经被sack过了。</p>

<p>这个函数处理比较简单，主要就是通过序列号以及sacked本身的值最终来确认sacked要被设置的值。</p>

<p>这里我们还记得，一开始sacked是被初始化为sack option的偏移(如果是正确的sack)的.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static u8 tcp_sacktag_one(struct sk_buff *skb, struct sock *sk,
</span><span class='line'>&#9;&#9;&#9;  struct tcp_sacktag_state *state,
</span><span class='line'>&#9;&#9;&#9;  int dup_sack, int pcount)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;u8 sacked = TCP_SKB_CB(skb)-&gt;sacked;
</span><span class='line'>&#9;int fack_count = state-&gt;fack_count;
</span><span class='line'>
</span><span class='line'>&#9;......
</span><span class='line'>
</span><span class='line'>&#9;//如果skb的结束序列号小于发送未确认的，则说明这个帧应当被丢弃。
</span><span class='line'>&#9;if (!after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una))
</span><span class='line'>&#9;&#9;return sacked;
</span><span class='line'>&#9;//如果当前的skb还未被sack确认过，则我们才会进入处理。
</span><span class='line'>&#9;if (!(sacked & TCPCB_SACKED_ACKED)) {
</span><span class='line'>&#9;&#9;//如果是重传被sack确认的。
</span><span class='line'>&#9;&#9;if (sacked & TCPCB_SACKED_RETRANS) {
</span><span class='line'>&#9;&#9;&#9;//如果设置了lost，则我们需要修改它的tag。
</span><span class='line'>&#9;&#9;&#9;if (sacked & TCPCB_LOST) {
</span><span class='line'>&#9;&#9;&#9;&#9;sacked &= ~(TCPCB_LOST|TCPCB_SACKED_RETRANS);
</span><span class='line'>&#9;&#9;&#9;&#9;//更新lost的数据包
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;lost_out -= pcount;
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;retrans_out -= pcount;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;.......
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//开始修改sacked，设置flag。
</span><span class='line'>&#9;&#9;sacked |= TCPCB_SACKED_ACKED;
</span><span class='line'>&#9;&#9;state-&gt;flag |= FLAG_DATA_SACKED;
</span><span class='line'>&#9;&#9;//增加sack确认的包的个数/
</span><span class='line'>&#9;&#9;tp-&gt;sacked_out += pcount;
</span><span class='line'>
</span><span class='line'>&#9;&#9;fack_count += pcount;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//处理fack
</span><span class='line'>&#9;&#9;if (!tcp_is_fack(tp) && (tp-&gt;lost_skb_hint != NULL) &&
</span><span class='line'>&#9;&#9;&#9;before(TCP_SKB_CB(skb)-&gt;seq,
</span><span class='line'>&#9;&#9;&#9;   TCP_SKB_CB(tp-&gt;lost_skb_hint)-&gt;seq))
</span><span class='line'>&#9;&#9;&#9;tp-&gt;lost_cnt_hint += pcount;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (fack_count &gt; tp-&gt;fackets_out)
</span><span class='line'>&#9;&#9;&#9;tp-&gt;fackets_out = fack_count;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/* D-SACK. We can detect redundant retransmission in S|R and plain R
</span><span class='line'>&#9; * frames and clear it. undo_retrans is decreased above, L|R frames
</span><span class='line'>&#9; * are accounted above as well.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (dup_sack && (sacked & TCPCB_SACKED_RETRANS)) {
</span><span class='line'>&#9;&#9;sacked &= ~TCPCB_SACKED_RETRANS;
</span><span class='line'>&#9;&#9;tp-&gt;retrans_out -= pcount;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;return sacked;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后我们来看tcp_sacktag_write_queue的最后一部分，也就是更新cache的部分。</p>

<p>它也就是将处理过的sack清0,没处理过的保存到cache中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//开始遍历，可以看到这里将将我们未处理的sack段的序列号清0.
</span><span class='line'>for (i = 0; i &lt; ARRAY_SIZE(tp-&gt;recv_sack_cache) - used_sacks; i++) {
</span><span class='line'>&#9;&#9;tp-&gt;recv_sack_cache[i].start_seq = 0;
</span><span class='line'>&#9;&#9;tp-&gt;recv_sack_cache[i].end_seq = 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//然后保存这次处理了的段。
</span><span class='line'>&#9;for (j = 0; j &lt; used_sacks; j++)
</span><span class='line'>&#9;&#9;tp-&gt;recv_sack_cache[i++] = sp[j];
</span><span class='line'>
</span><span class='line'>&#9;//标记丢失的段。
</span><span class='line'>&#9;tcp_mark_lost_retrans(sk);
</span><span class='line'>
</span><span class='line'>&#9;tcp_verify_left_out(tp);
</span><span class='line'>
</span><span class='line'>&#9;if ((state.reord &lt; tp-&gt;fackets_out) &&
</span><span class='line'>&#9;&#9;((icsk-&gt;icsk_ca_state != TCP_CA_Loss) || tp-&gt;undo_marker) &&
</span><span class='line'>&#9;&#9;(!tp-&gt;frto_highmark || after(tp-&gt;snd_una, tp-&gt;frto_highmark)))
</span><span class='line'>&#9;&#9;tcp_update_reordering(sk, tp-&gt;fackets_out - state.reord, 0);</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/06/kernel-net-ack/">内核tcp的ack的处理tcp_ack</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-06T15:40:00+08:00'><span class='date'>2013-09-06</span> <span class='time'>15:40:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://simohayha.iteye.com/blog/572505">http://simohayha.iteye.com/blog/572505</a></p>

<p>我们来看tcp输入对于ack，段的处理。</p>

<ul>
<li>先是ack的处理，在内核中，处理ack段是通过tcp_ack来进行的。<br/>
这个函数主要功能是：</li>
<li>update重传队列，并基于sack来设置skb的相关buf。</li>
<li>update发送窗口。</li>
<li>基于sack的信息或者重复ack来决定是否进入拥塞模式。<br/>
在看之前我们要知道tcp是累积确认的。为了解决带来的缺点，我们才需要sack的。</li>
</ul>


<p>  然后我们来看几个很重要的数据结构，先是tcp_skb_cb，它其实就是表示skb中所保存的tcp的控制信息。而他是保存在skb的cb中的(这个域可以看我前面的blog）。所以这里我们经常会用TCP_SKB_CB来存取这个结构。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define TCP_SKB_CB(__skb)   ((struct tcp_skb_cb *)&((__skb)-&gt;cb[0]))</span></code></pre></td></tr></table></div></figure>


<p>这里还有一个inet_skb_parm，这个结构保存了ipoption的一些信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct inet_skb_parm
</span><span class='line'>{
</span><span class='line'>&#9;struct ip_options   opt;        /* Compiled IP options      */
</span><span class='line'>&#9;unsigned char       flags;
</span><span class='line'>
</span><span class='line'>&#9;#define IPSKB_FORWARDED           1
</span><span class='line'>&#9;#define IPSKB_XFRM_TUNNEL_SIZE    2
</span><span class='line'>&#9;#define IPSKB_XFRM_TRANSFORMED    4
</span><span class='line'>&#9;#define IPSKB_FRAG_COMPLETE       8
</span><span class='line'>&#9;#define IPSKB_REROUTED            16
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>然后来看tcp_skb_cb：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_skb_cb {
</span><span class='line'>&#9;union {
</span><span class='line'>&#9;&#9;struct inet_skb_parm    h4;
</span><span class='line'>#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
</span><span class='line'>&#9;&#9;struct inet6_skb_parm   h6;
</span><span class='line'>#endif
</span><span class='line'>&#9;} header;   /* For incoming frames      */
</span><span class='line'>//这个表示当前tcp包的序列号
</span><span class='line'>&#9;__u32       seq;
</span><span class='line'>//这个表示结束序列号，也就是SEQ + FIN + SYN + datalen。
</span><span class='line'>&#9;__u32       end_seq;
</span><span class='line'>//主要用来计算rtt
</span><span class='line'>&#9;__u32       when;
</span><span class='line'>//tcp头的flag（比如syn，fin等)，它能取的值，我们下面会介绍。
</span><span class='line'>&#9;__u8        flags;
</span><span class='line'>
</span><span class='line'>//SACK/FACK的状态flag或者是sack option的偏移(相对于tcp头的)。我们下面会介绍
</span><span class='line'>&#9;__u8        sacked;
</span><span class='line'>//ack的序列号。
</span><span class='line'>&#9;__u32       ack_seq;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>下面就是flags所能取的值，可以看到也就是tcp头的控制位。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define TCPCB_FLAG_FIN      0x01
</span><span class='line'>#define TCPCB_FLAG_SYN      0x02
</span><span class='line'>#define TCPCB_FLAG_RST      0x04
</span><span class='line'>#define TCPCB_FLAG_PSH      0x08
</span><span class='line'>#define TCPCB_FLAG_ACK      0x10
</span><span class='line'>#define TCPCB_FLAG_URG      0x20
</span><span class='line'>#define TCPCB_FLAG_ECE      0x40
</span><span class='line'>#define TCPCB_FLAG_CWR      0x80</span></code></pre></td></tr></table></div></figure>


<p>然后是sack/fack的状态标记：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//有这个域说明当前的tcpcb是被sack块确认的。
</span><span class='line'>#define TCPCB_SACKED_ACKED  0x01
</span><span class='line'>//表示重传的帧
</span><span class='line'>#define TCPCB_SACKED_RETRANS    0x02
</span><span class='line'>//丢失
</span><span class='line'>#define TCPCB_LOST      0x04
</span><span class='line'>#define TCPCB_TAGBITS       0x07
</span><span class='line'>//重传的帧。
</span><span class='line'>#define TCPCB_EVER_RETRANS  0x80
</span><span class='line'>#define TCPCB_RETRANS       (TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS)</span></code></pre></td></tr></table></div></figure>


<p>  这里要注意，当我们接收到正确的SACK后，这个域就会被初始化为sack所在的相对偏移(也就是相对于tcp头的偏移值，这样我们就能很容易得到sack option的位置).
然后是tcp_sock，这个结构保存了我们整个tcp层所需要得所有必要的信息（也就是从sock中提取出来).我们分两个部分来看这个结构，这里只看我们关注的两部分，第一部分是窗口相关的一些域。第二部分是拥塞控制的一些相关域。
先来看窗口相关的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//我们期待从另一台设备接收的下一个数据字节的序列号。
</span><span class='line'>u32 rcv_nxt;
</span><span class='line'>//还没有被读取的数据的序列号。
</span><span class='line'>u32 copied_seq;
</span><span class='line'>//当最后一次窗口update被发送之前我们的rcv_nxt.
</span><span class='line'>u32 rcv_wup;
</span><span class='line'>//将要发送给另一台设备的下一个数据字节的序列号。
</span><span class='line'>u32 snd_nxt;
</span><span class='line'>//已经发送但尚未被确认的第一个数据字节的序列号。
</span><span class='line'>u32 snd_una;
</span><span class='line'>//
</span><span class='line'>u32 snd_sml;
</span><span class='line'>//最后一次接收到ack的时间戳，主要用于keepalive
</span><span class='line'>u32 rcv_tstamp;
</span><span class='line'>//最后一次发送数据包的时间戳。
</span><span class='line'>u32 lsndtime;
</span><span class='line'>//发送窗口长度
</span><span class='line'>u32 snd_wnd;
</span><span class='line'>//接收窗口长度。
</span><span class='line'>u32 rcv_wnd
</span><span class='line'>//发送未确认的数据包的个数（或者字节数？）
</span><span class='line'>u32 packets_out;
</span><span class='line'>//重传的数据包的个数
</span><span class='line'>u32 retrans_out;</span></code></pre></td></tr></table></div></figure>


<p>然后是拥塞部分，看这里之前还是需要取熟悉一下tcp拥塞控制的相关概念。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//慢开始的阀值，也就是超过这个我们就要进入拥塞避免的阶段
</span><span class='line'>u32  snd_ssthresh;
</span><span class='line'>//发送的拥塞窗口
</span><span class='line'>u32 snd_cwnd;
</span><span class='line'>//这个应该是拥塞状态下所发松的数据字节数
</span><span class='line'>u32 snd_cwnd_cnt;
</span><span class='line'>//这里也就是cwnd的最大值
</span><span class='line'>u32 snd_cwnd_clamp;
</span><span class='line'>//这两个值不太理解什么意思。
</span><span class='line'>u32 snd_cwnd_used;
</span><span class='line'>u32 snd_cwnd_stamp;
</span><span class='line'>
</span><span class='line'>//接收窗口打消
</span><span class='line'>u32 rcv_wnd;
</span><span class='line'>//tcp的发送buf数据的尾部序列号。
</span><span class='line'>u32 write_seq;
</span><span class='line'>//最后一次push的数据的序列号
</span><span class='line'>u32 pushed_seq;
</span><span class='line'>//丢失的数据包字节数
</span><span class='line'>u32 lost_out;
</span><span class='line'>//sack的数据包的字节数
</span><span class='line'>u32 sacked_out;
</span><span class='line'>//fack处理的数据包的字节数
</span><span class='line'>u32 fackets_out;
</span><span class='line'>u32 tso_deferred;
</span><span class='line'>//计数
</span><span class='line'>u32 bytes_acked;</span></code></pre></td></tr></table></div></figure>


<p>分析完相关的数据结构我们来看函数的实现。<br/>
来看tcp_ack的代码,函数比较大，因此我们分段来看，先来看一开始的一些校验部分。<br/>
这里有一个tcp_abc也就是proc下面的可以设置的东西，这个主要是看要不要每个ack都要进行拥塞控制。</p>

<blockquote><p>Controls Appropriate Byte Count defined in RFC3465. If set to 0 then does congestion avoid once per ACK. 1 is conservative value, and 2 is more aggressive. The default value is 1.</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>//等待ack，也就是发送未确认的序列号。
</span><span class='line'>u32 prior_snd_una = tp-&gt;snd_una;
</span><span class='line'>u32 ack_seq = TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>//得到ack的序列号。
</span><span class='line'>u32 ack = TCP_SKB_CB(skb)-&gt;ack_seq;
</span><span class='line'>u32 prior_in_flight;
</span><span class='line'>u32 prior_fackets;
</span><span class='line'>int prior_packets;
</span><span class='line'>int frto_cwnd = 0;
</span><span class='line'>
</span><span class='line'>//如果ack的序列号小于发送未确认的，也就是说可能这个ack只是重传老的ack，因此我们忽略它。
</span><span class='line'>if (before(ack, prior_snd_una))
</span><span class='line'>&#9;goto old_ack;
</span><span class='line'>
</span><span class='line'>//如果ack大于snd_nxt,也就是它确认了我们还没发送的数据段，因此我们discard这个段。
</span><span class='line'>if (after(ack, tp-&gt;snd_nxt))
</span><span class='line'>&#9;goto invalid_ack;
</span><span class='line'>//如果ack大于发送未确认，则设置flag
</span><span class='line'>if (after(ack, prior_snd_una))
</span><span class='line'>&#9;flag |= FLAG_SND_UNA_ADVANCED;
</span><span class='line'>
</span><span class='line'>//是否设置tcp_abc，有设置的话，说明我们不需要每个ack都要拥塞避免，因此我们需要计算已经ack的字节数。
</span><span class='line'>if (sysctl_tcp_abc) {
</span><span class='line'>&#9;if (icsk-&gt;icsk_ca_state &lt; TCP_CA_CWR)
</span><span class='line'>&#9;&#9;tp-&gt;bytes_acked += ack - prior_snd_una;
</span><span class='line'>&#9;else if (icsk-&gt;icsk_ca_state == TCP_CA_Loss)
</span><span class='line'>&#9;&#9; tp-&gt;bytes_acked += min(ack - prior_snd_una,qtp-&gt;mss_cache);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//得到fack的数据包的字节数
</span><span class='line'>prior_fackets = tp-&gt;fackets_out;
</span><span class='line'>//计算还在传输的数据段的字节数,下面会详细分析这个函数。
</span><span class='line'>prior_in_flight = tcp_packets_in_flight(tp);</span></code></pre></td></tr></table></div></figure>


<p>packets_out这个表示已经发送还没有ack的数据段的字节数(这个值不会重复加的，比如重传的话不会增加这个值）。<br/>
sakced_out :sack了的字节数。<br/>
lost_out:丢失了的字节数。<br/>
retrans_out:重传的字节数。<br/>
现在我们就对这个函数的返回值很清楚了，它也就是包含了还没有到达对方的数据段的字节数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline unsigned int tcp_left_out(const struct tcp_sock *tp)
</span><span class='line'>{
</span><span class='line'>&#9;return tp-&gt;sacked_out + tp-&gt;lost_out;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static inline unsigned int tcp_packets_in_flight(const struct tcp_sock *tp)
</span><span class='line'>{
</span><span class='line'>&#9;return tp-&gt;packets_out - tcp_left_out(tp) + tp-&gt;retrans_out;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来这一段主要是通过判断flag(slow还是fast)来进行一些窗口的操作。有关slow_path和fast_path的区别，可以看我前面的blog。<br/>
fast_path的话很简单，我们就更新相关的域以及snd_wl1(这个域主要是用于update窗口的时候).它这里会被赋值为我们这次的数据包的序列号。然后进行拥塞控制的操作。<br/>
snd_wl1是只要我们需要更新发送窗口的话，这个值是都会被更新的。<br/>
slow_path的话，我们就需要判断要不要update窗口的大小了。以及是否要处理sack等。<br/>
在看下面的代码之前，我们先来看传递进tcp_ack这个函数中的第三个参数flag，这里我们在函数中也还会修改这个值，这个flag也就是当前的skb的类型信息。看了注释后就清楚了。可疑看到好几个都是ack的类型。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//这个说明当前的输入帧包含有数据。
</span><span class='line'>#define FLAG_DATA       0x01
</span><span class='line'>//这个说明当前的ack是一个窗口更新的ack
</span><span class='line'>#define FLAG_WIN_UPDATE     0x02
</span><span class='line'>//这个ack确认了一些数据
</span><span class='line'>#define FLAG_DATA_ACKED     0x04
</span><span class='line'>//这个表示ack确认了一些我们重传的段。
</span><span class='line'>#define FLAG_RETRANS_DATA_ACKED 0x08
</span><span class='line'>//这个表示这个ack是对syn的回复。
</span><span class='line'>#define FLAG_SYN_ACKED      0x10
</span><span class='line'>//新的sack
</span><span class='line'>#define FLAG_DATA_SACKED    0x20
</span><span class='line'>//ack中包含ECE
</span><span class='line'>#define FLAG_ECE        0x40
</span><span class='line'>//sack检测到了数据丢失。
</span><span class='line'>#define FLAG_DATA_LOST      0x80
</span><span class='line'>//当更新窗口的时候不跳过RFC的检测。
</span><span class='line'>#define FLAG_SLOWPATH       0x100
</span><span class='line'>
</span><span class='line'>#define FLAG_ONLY_ORIG_SACKED   0x200
</span><span class='line'>//snd_una被改变了。也就是更新了。
</span><span class='line'>#define FLAG_SND_UNA_ADVANCED   0x400
</span><span class='line'>//包含D-sack
</span><span class='line'>#define FLAG_DSACKING_ACK   0x800
</span><span class='line'>//这个不太理解什么意思。
</span><span class='line'>#define FLAG_NONHEAD_RETRANS_ACKED  0x1000
</span><span class='line'>//
</span><span class='line'>#define FLAG_SACK_RENEGING  0x2000
</span><span class='line'>
</span><span class='line'>//下面也就是一些组合。
</span><span class='line'>#define FLAG_ACKED  (FLAG_DATA_ACKED|FLAG_SYN_ACKED)
</span><span class='line'>#define FLAG_NOT_DUP (FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)
</span><span class='line'>#define FLAG_CA_ALERT       (FLAG_DATA_SACKED|FLAG_ECE)
</span><span class='line'>#define FLAG_FORWARD_PROGRESS   (FLAG_ACKED|FLAG_DATA_SACKED)
</span><span class='line'>#define FLAG_ANY_PROGRESS   (FLAG_FORWARD_PROGRESS|FLAG_SND_UNA_ADVANCED)</span></code></pre></td></tr></table></div></figure>


<p>然后我们来看代码，下面的代码会设置flag，也就是用上面的宏。<br/>
这里有一个很大的不同就是slow_path中，我们需要update窗口的大小，而在fast模式中，我们不需要，这个详细去看我前面的blog介绍的fast和slow的区别。fast就是最理想的情况，因此我们不需要update窗口。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//如果不是slowpath并且ack确实是正确的序列号(必须大于snd_una).
</span><span class='line'>&#9;if (!(flag & FLAG_SLOWPATH) && after(ack, prior_snd_una)) {
</span><span class='line'>//更新snd_wl1域为ack_seq;
</span><span class='line'>&#9;&#9;tcp_update_wl(tp, ack_seq);
</span><span class='line'>//snd_una更新为ack也就是确认的序列号
</span><span class='line'>&#9;&#9;tp-&gt;snd_una = ack;
</span><span class='line'>//更新flag域。
</span><span class='line'>&#9;&#9;flag |= FLAG_WIN_UPDATE;
</span><span class='line'>//进入拥塞的操作。
</span><span class='line'>&#9;&#9;tcp_ca_event(sk, CA_EVENT_FAST_ACK);
</span><span class='line'>................................
</span><span class='line'>&#9;} else {
</span><span class='line'>//这个判断主要是为了判断是否输入帧包含数据。也就是ack还包含了数据，如果有的话，我们设置标记然后后面会处理。
</span><span class='line'>&#9;&#9;if (ack_seq != TCP_SKB_CB(skb)-&gt;end_seq)
</span><span class='line'>&#9;&#9;&#9;flag |= FLAG_DATA;
</span><span class='line'>&#9;&#9;else
</span><span class='line'>.....................................
</span><span class='line'>
</span><span class='line'>//然后进入更新窗口的操作。
</span><span class='line'>&#9;&#9;flag |= tcp_ack_update_window(sk, skb, ack, ack_seq);
</span><span class='line'>//然后判断是否有sack段，有的话，我们进入sack段的处理。
</span><span class='line'>&#9;&#9;if (TCP_SKB_CB(skb)-&gt;sacked)
</span><span class='line'>&#9;&#9;&#9;flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una);
</span><span class='line'>//判断是否有ecn标记，如果有的话，设置ecn标记。
</span><span class='line'>&#9;&#9;if (TCP_ECN_rcv_ecn_echo(tp, tcp_hdr(skb)))
</span><span class='line'>&#9;&#9;&#9;flag |= FLAG_ECE;
</span><span class='line'>//进入拥塞的处理。
</span><span class='line'>&#9;&#9;tcp_ca_event(sk, CA_EVENT_SLOW_ACK);
</span><span class='line'>&#9;}</span></code></pre></td></tr></table></div></figure>


<p>接下来这段主要工作是：<br/>
1 清理重传队列中的已经ack的段。<br/>
2 处理F-RTO。<br/>
3 判断是否是零窗口探测的回复ack。<br/>
4 检测是否要进入拥塞处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sk-&gt;sk_err_soft = 0;
</span><span class='line'>icsk-&gt;icsk_probes_out = 0;
</span><span class='line'>tp-&gt;rcv_tstamp = tcp_time_stamp;
</span><span class='line'>//如果发送并且没有ack的数据段的值为0,则说明这个有可能是0窗口探测的回复，因此我们进入no_queue的处理，这个我们紧接着会详细介绍。
</span><span class='line'>prior_packets = tp-&gt;packets_out;
</span><span class='line'>if (!prior_packets)
</span><span class='line'>&#9;goto no_queue;
</span><span class='line'>//清理重传队列中的已经ack的数据段。
</span><span class='line'>flag |= tcp_clean_rtx_queue(sk, prior_fackets, prior_snd_una);
</span><span class='line'>
</span><span class='line'>//处理F-RTO
</span><span class='line'>if (tp-&gt;frto_counter)
</span><span class='line'>&#9;frto_cwnd = tcp_process_frto(sk, flag);
</span><span class='line'>
</span><span class='line'>if (before(tp-&gt;frto_highmark, tp-&gt;snd_una))
</span><span class='line'>&#9;tp-&gt;frto_highmark = 0;
</span><span class='line'>//判断ack是否是可疑的。它主要是检测我们是否进入拥塞状态，或者已经处于拥塞状态。
</span><span class='line'>if (tcp_ack_is_dubious(sk, flag)) {
</span><span class='line'>//检测flag以及是否需要update拥塞窗口的大小。
</span><span class='line'>if ((flag & FLAG_DATA_ACKED) && !frto_cwnd &&
</span><span class='line'>&#9;tcp_may_raise_cwnd(sk, flag))
</span><span class='line'>//如果都为真，则更新拥塞窗口。
</span><span class='line'>&#9;tcp_cong_avoid(sk, ack, prior_in_flight);
</span><span class='line'>//这里进入拥塞状态的处理(这个函数是一个非常关键的函数,等到后面详细分析拥塞的时候，会分析到)。
</span><span class='line'>&#9;tcp_fastretrans_alert(sk, prior_packets - tp-&gt;packets_out,flag);
</span><span class='line'>} else {
</span><span class='line'>//这里可以看到和上面相比，没有tcp_may_raise_cwnd这个，我们紧接着就会分析到。
</span><span class='line'>&#9;if ((flag & FLAG_DATA_ACKED) && !frto_cwnd)
</span><span class='line'>&#9;&#9;tcp_cong_avoid(sk, ack, prior_in_flight);
</span><span class='line'>}
</span><span class='line'>//是否更新neigh子系统。
</span><span class='line'>if ((flag & FLAG_FORWARD_PROGRESS) || !(flag & FLAG_NOT_DUP))
</span><span class='line'>&#9;dst_confirm(sk-&gt;sk_dst_cache);
</span><span class='line'>
</span><span class='line'>return 1;
</span><span class='line'>
</span><span class='line'>no_queue:
</span><span class='line'>//这里判断发送缓冲区是否为空，如果不为空，则我们进入判断需要重启keepalive定时器还是关闭定时器
</span><span class='line'>&#9;if (tcp_send_head(sk))
</span><span class='line'>&#9;&#9;tcp_ack_probe(sk);
</span><span class='line'>&#9;return 1;</span></code></pre></td></tr></table></div></figure>


<p>ok，，接着来看上面略过的几个函数，先来看tcp_ack_is_dubious，这里的条件我们一个个来看<br/>
1 说明flag不能是 FLAG_NOT_DUP的， FLAG_NOT_DUP表示我们的ack不是重复的。<br/>
2 是flag是CA_ALERT,它的意思是我们是否在我们进入拥塞状态时被alert。<br/>
3 拥塞状态不能为TCP_CA_OPEN不为这个，就说明我们已经进入了拥塞状态。<br/>
可以看下面这几个宏的定义，就比较清楚了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define FLAG_ACKED  (FLAG_DATA_ACKED|FLAG_SYN_ACKED)
</span><span class='line'>#define FLAG_NOT_DUP (FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)
</span><span class='line'>
</span><span class='line'>//收到sack则说明可能有的段丢失了。而ECE则是路由器提示我们有拥塞了。我们必须处理。
</span><span class='line'>#define FLAG_CA_ALERT       (FLAG_DATA_SACKED|FLAG_ECE)</span></code></pre></td></tr></table></div></figure>


<p>上面的任意一个为真。就说明ack是可疑的。这里起始也可以说我们就必须进入拥塞的处理了(tcp_fastretrans_alert)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_ack_is_dubious(const struct sock *sk, const int flag)
</span><span class='line'>{
</span><span class='line'>&#9;return (!(flag & FLAG_NOT_DUP) || (flag & FLAG_CA_ALERT) ||inet_csk(sk)-&gt;icsk_ca_state != TCP_CA_Open);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是 tcp_may_raise_cwnd，这个函数用来判断是否需要增大拥塞窗口。<br/>
1 不能有ECE flag或者发送的拥塞窗口不能大于slow start的阀值。<br/>
3 拥塞状态为RECO或者CWR.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_may_raise_cwnd(const struct sock *sk, const int flag)
</span><span class='line'>{
</span><span class='line'>&#9;const struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;return (!(flag & FLAG_ECE) || tp-&gt;snd_cwnd &lt; tp-&gt;snd_ssthresh) &&!((1 &lt;&lt; inet_csk(sk)-&gt;icsk_ca_state) & (TCPF_CA_Recovery | TCPF_CA_CWR));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在看tcp_ack_update_window函数之前，我们先来看tcp_may_update_window，这个函数用来判断是否需要更新发送窗口。<br/>
1 新的数据已经被ack了。<br/>
2 当前的数据包的序列号大于当窗口更新的时候那个数据包的序列号。<br/>
3 当前的数据包的序列号等于窗口更新时的序列号并且新的窗口大小大于当前的发送窗口大小。这个说明对端可能已经增加了窗口的大小</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_may_update_window(const struct tcp_sock *tp,const u32 ack, const u32 ack_seq,const u32 nwin)
</span><span class='line'>{
</span><span class='line'>&#9;return (after(ack, tp-&gt;snd_una) ||
</span><span class='line'>&#9;&#9;after(ack_seq, tp-&gt;snd_wl1) ||
</span><span class='line'>&#9;&#9;(ack_seq == tp-&gt;snd_wl1 && nwin &gt; tp-&gt;snd_wnd));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是tcp_ack_update_window函数，这个主要用来更新发送窗口的大小。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_ack_update_window(struct sock *sk, struct sk_buff *skb, u32 ack, u32 ack_seq)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;int flag = 0;
</span><span class='line'>&#9;//得到窗口的大小。
</span><span class='line'>&#9;u32 nwin = ntohs(tcp_hdr(skb)-&gt;window);
</span><span class='line'>
</span><span class='line'>&#9;if (likely(!tcp_hdr(skb)-&gt;syn))
</span><span class='line'>&#9;&#9;nwin &lt;&lt;= tp-&gt;rx_opt.snd_wscale;
</span><span class='line'>
</span><span class='line'>&#9;//判断是否需要update窗口。
</span><span class='line'>&#9;if (tcp_may_update_window(tp, ack, ack_seq, nwin)) {
</span><span class='line'>&#9;&#9;flag |= FLAG_WIN_UPDATE;
</span><span class='line'>&#9;//更新snd_wl1
</span><span class='line'>&#9;&#9;tcp_update_wl(tp, ack_seq);
</span><span class='line'>&#9;//如果不等于，则说明我们需要更新窗口。
</span><span class='line'>&#9;&#9;if (tp-&gt;snd_wnd != nwin) {
</span><span class='line'>&#9;&#9;&#9;tp-&gt;snd_wnd = nwin;
</span><span class='line'>&#9;...................................
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;tp-&gt;snd_una = ack;
</span><span class='line'>&#9;return flag;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是tcp_cong_avoid函数，这个函数用来实现慢开始和快重传的拥塞算法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
</span><span class='line'>{
</span><span class='line'>&#9;const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>&#9;icsk-&gt;icsk_ca_ops-&gt;cong_avoid(sk, ack, in_flight);
</span><span class='line'>&#9;tcp_sk(sk)-&gt;snd_cwnd_stamp = tcp_time_stamp;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到它主要是调用cong_avoid回调函数，而这个函数被初始化为tcp_reno_cong_avoid，我们来看这个函数，在看这个函数之前我们要知道一些慢开始和快回复的概念。这些东西随便介绍tcp的书上都有介绍的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;//是否已经到达拥塞窗口的限制。
</span><span class='line'>&#9;if (!tcp_is_cwnd_limited(sk, in_flight))
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;//如果拥塞窗口还没有到达慢开始的阈值，我们就进入慢开始处理。
</span><span class='line'>&#9;if (tp-&gt;snd_cwnd &lt;= tp-&gt;snd_ssthresh)
</span><span class='line'>&#9;&#9;tcp_slow_start(tp);
</span><span class='line'>
</span><span class='line'>&#9;//否则我们就要进入拥塞避免阶段。
</span><span class='line'>&#9;else if (sysctl_tcp_abc) {
</span><span class='line'>&#9;//RFC3465,只有当当前的拥塞窗口的所有段都被ack了，窗口才被允许增加。
</span><span class='line'>&#9;if (tp-&gt;bytes_acked &gt;= tp-&gt;snd_cwnd*tp-&gt;mss_cache) {
</span><span class='line'>&#9;&#9;tp-&gt;bytes_acked -= tp-&gt;snd_cwnd*tp-&gt;mss_cache;
</span><span class='line'>&#9;&#9;&#9;if (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;snd_cwnd++;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;//和上面处理方式类似。
</span><span class='line'>&#9;&#9;tcp_cong_avoid_ai(tp, tp-&gt;snd_cwnd);
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后我们来看tcp_clean_rtx_queue函数，这个函数主要用于清理发送队列中已经被ack的数据段。函数比较大，我们来分段看。<br/>
这里有使用karn算法，也就是如果重传的段，则计算rto的话，不采样这次的值。<br/>
还有就是要判断是syn的ack回复，还是数据的ack回复。以及sack的判断。<br/>
首先是遍历部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while ((skb = tcp_write_queue_head(sk)) && skb != tcp_send_head(sk)) {
</span><span class='line'>&#9;struct tcp_skb_cb *scb = TCP_SKB_CB(skb);
</span><span class='line'>&#9;u32 acked_pcount;
</span><span class='line'>&#9;u8 sacked = scb-&gt;sacked;
</span><span class='line'>&#9;//这个说明当前的数据已经在发送未确认的段里面了。
</span><span class='line'>&#9;if (after(scb-&gt;end_seq, tp-&gt;snd_una)) {
</span><span class='line'>&#9;&#9;//这边不是很懂。
</span><span class='line'>&#9;&#9;if (tcp_skb_pcount(skb) == 1 ||
</span><span class='line'>&#9;&#9;&#9;!after(tp-&gt;snd_una, scb-&gt;seq))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;acked_pcount = tcp_tso_acked(sk, skb);
</span><span class='line'>&#9;&#9;if (!acked_pcount)
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;fully_acked = 0;
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;acked_pcount = tcp_skb_pcount(skb);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//如果sack的状态有被设置重传，则我们会使用karn算法。
</span><span class='line'>&#9;if (sacked & TCPCB_RETRANS) {
</span><span class='line'>&#9;&#9;//如果标记为sack了重传段，则更新重传的计数。
</span><span class='line'>&#9;&#9;if (sacked & TCPCB_SACKED_RETRANS)
</span><span class='line'>&#9;&#9;&#9;tp-&gt;retrans_out -= acked_pcount;
</span><span class='line'>&#9;&#9;flag |= FLAG_RETRANS_DATA_ACKED;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//都为-1，也就是后面计算rtt，不会采样这次值。
</span><span class='line'>&#9;&#9;ca_seq_rtt = -1;
</span><span class='line'>&#9;&#9;seq_rtt = -1;
</span><span class='line'>&#9;&#9;&#9;if ((flag & FLAG_DATA_ACKED) || (acked_pcount &gt; 1))
</span><span class='line'>&#9;&#9;flag |= FLAG_NONHEAD_RETRANS_ACKED;
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;//否则根据时间戳得到对应的rtt
</span><span class='line'>&#9;&#9;ca_seq_rtt = now - scb-&gt;when;
</span><span class='line'>&#9;&#9;last_ackt = skb-&gt;tstamp;
</span><span class='line'>&#9;&#9;if (seq_rtt &lt; 0) {
</span><span class='line'>&#9;&#9;&#9;seq_rtt = ca_seq_rtt;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;if (!(sacked & TCPCB_SACKED_ACKED))
</span><span class='line'>&#9;&#9;&#9;reord = min(pkts_acked, reord);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//如果有sack的数据包被ack确认了，则我们需要减小sack的计数
</span><span class='line'>&#9;if (sacked & TCPCB_SACKED_ACKED)
</span><span class='line'>&#9;&#9;tp-&gt;sacked_out -= acked_pcount;
</span><span class='line'>&#9;if (sacked & TCPCB_LOST)
</span><span class='line'>&#9;&#9;tp-&gt;lost_out -= acked_pcount;
</span><span class='line'>&#9;//总得发送为ack的数据字节计数更新。
</span><span class='line'>&#9;tp-&gt;packets_out -= acked_pcount;
</span><span class='line'>&#9;pkts_acked += acked_pcount;
</span><span class='line'>&#9;//判断是否为syn的ack。
</span><span class='line'>&#9;if (!(scb-&gt;flags & TCPCB_FLAG_SYN)) {
</span><span class='line'>&#9;&#9;flag |= FLAG_DATA_ACKED;
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;//如果是设置标记
</span><span class='line'>&#9;&#9;flag |= FLAG_SYN_ACKED;
</span><span class='line'>&#9;&#9;tp-&gt;retrans_stamp = 0;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (!fully_acked)
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;//从写buf，unlink掉。
</span><span class='line'>&#9;tcp_unlink_write_queue(skb, sk);
</span><span class='line'>&#9;//释放内存。
</span><span class='line'>&#9;sk_wmem_free_skb(sk, skb);
</span><span class='line'>&#9;tp-&gt;scoreboard_skb_hint = NULL;
</span><span class='line'>&#9;if (skb == tp-&gt;retransmit_skb_hint)
</span><span class='line'>&#9;&#9;tp-&gt;retransmit_skb_hint = NULL;
</span><span class='line'>&#9;if (skb == tp-&gt;lost_skb_hint)
</span><span class='line'>&#9;&#9;tp-&gt;lost_skb_hint = NULL;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>剩下的部分就是计算rtt的部分，这里就不介绍了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/08/29/tools-git-svn-base/">git-svn</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-29T14:37:00+08:00'><span class='date'>2013-08-29</span> <span class='time'>14:37:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>常用</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1、git-svn clone your_svn_repository
</span><span class='line'>2、git add/commit
</span><span class='line'>3、git-svn rebase    获取中心svn repository的更新；
</span><span class='line'>4、git-svn dcommit   将本地git库的修改同步到中心svn库。</span></code></pre></td></tr></table></div></figure>


<hr />

<p>git-svn默认包含在Git的安装包中，不过在Ubuntu中，git-svn是作为一个独立的Package需要额外安装的(sudo apt-get install git-svn)。安装后你就可以使用git svn xxx命令来操作中心SVN代码库了。当然如果你要使用与git svn等价的git-svn命令的话，你还需要将/usr/lib/git-core配置到你的PATH环境变量中，否则Shell会提示你无法找到 git-svn这个命令。</p>

<ul>
<li><p>检出一个已存在svn repository(类似于svn checkout)<br/>
我们可以通过git-svn clone命令完成这个操作： git-svn clone your_svn_repository_url</p></li>
<li><p>从中心服务器的svn repository获取最新更新<br/>
这个操作可以通过"git-svn rebase"完成。注意这里用的是rebase，而不是update。update命令对于通过git-svn检出的svn repostory的git版本库是不可用的。</p></li>
<li><p>查看提交历史日志<br/>
这个简单，使用"git-svn log"，加上-v选项，还可以提供每次commit操作涉及的相关文件的详细信息。</p></li>
<li><p>将本地代码同步到Svn服务器<br/>
完成这一操作需要通过"git-svn dcommit"命令。这个命令会将你在本地使用git commit提交到本地代码库的所有更改逐一提交到svn库中。加上-n选项，则该命令不会真正执行commit到svn的操作，而是会显示会有哪些本地 变动将被commit到svn服务器。git-svn dcommit似乎不能单独提交某个本地版本的修改，而是一次批量提交所有与svn中心版本库的差异。</p></li>
</ul>


<h5>下面是一个git-svn的一般使用流程：</h5>

<p>1、git-svn clone your_svn_repository；<br/>
2、修改本地代码，使用git add/commit将修改提交到本地git库；<br/>
3、定期使用git-svn rebase获取中心svn repository的更新；<br/>
4、使用git-svn dcommit命令将本地git库的修改同步到中心svn库。</p>

<h5>冲突</h5>

<p>使用git-svn处理代码冲突的步骤有些繁琐，不过瑕不掩瑜吧。这里用一个小例子来说明一下。</p>

<p>假设某svn中心库上的某个项目foo中只有一个源码文件foo.c：<br/>
* 我在使用git-svn clone检出版本时，foo.c当时只有一个commit版本信息："svn v1"；<br/>
* clone出来后，我在本地git库中修改foo.c，并通过git commit提交到本地git库中，版本为"git v1"；<br/>
* 不过与此同时另外一个同事也在修改foo.c这个文件，并已经将他的修改提交到了svn库中，版本为"svn v2"；<br/>
* 此时我使用git-svn dcommit尝试提交我的改动，git-svn提示我：<br/>
  Committing to svn://10.10.1.1:80/foo &hellip;<br/>
  M foo.c<br/>
  事务过时: 过期: ”foo/foo.c“在事务“260-1” at /usr/lib/git-core/git-svn line 570<br/>
* 使用git-svn rebase获取svn服务器上的最新foo.c，导致与foo.c冲突，不过此时svn版本信息已经添加到本地git库中(通过git log可以查看)，git-svn rebase提示你在解决foo.c的冲突后，运行git rebase &ndash;continue完成rebase操作；<br/>
* 打开foo.c，修改代码，解决冲突；<br/>
* 执行git rebase &ndash;continue，git提示我：<br/>
You must edit all merge conflicts and then<br/>
mark them as resolved using git add<br/>
* 执行git add foo.c，告知git已完成冲突解决；<br/>
* 再次执行git rebase &ndash;continue，提示"Applying: git v1"，此时"git v1"版本又一次成功加入本地版本库，你可通过git log查看；<br/>
* 执行git-svn dcommit将foo.c的改动同步到svn中心库，到此算是完成一次冲突解决。</p>

<ul>
<li>设置忽略文件<br/>
要忽略某些文件, 需要首先执行如下命令:<br/>
git config &ndash;global core.excludesfile ~/.gitignore<br/>
然后编辑 vi ~/.gitignore.<br/>
例如: 需要忽略vim的临时文件，就写:<br/>
.*.swp</li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/74">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/72">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(40)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>23</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>13</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(55)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~graphviz,-codeviz/?opendiv=tools'>graphviz、codeviz</a><a href='##' onmousedown=showDiv('tools~graphviz、codeviz') id='aexp_tools~graphviz、codeviz'><span class='exp_style' id='exp_tools~graphviz、codeviz'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~graphviz、codeviz')) document.getElementById('aexp_tools~graphviz、codeviz').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~haproxy/?opendiv=tools'>haproxy</a><a href='##' onmousedown=showDiv('tools~haproxy') id='aexp_tools~haproxy'><span class='exp_style' id='exp_tools~haproxy'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~haproxy')) document.getElementById('aexp_tools~haproxy').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(54)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>17</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~cgroup/?opendiv=system'>cgroup</a><a href='##' onmousedown=showDiv('system~cgroup') id='aexp_system~cgroup'><span class='exp_style' id='exp_system~cgroup'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~cgroup')) document.getElementById('aexp_system~cgroup').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~kvm/?opendiv=system'>kvm</a><a href='##' onmousedown=showDiv('system~kvm') id='aexp_system~kvm'><span class='exp_style' id='exp_system~kvm'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~kvm')) document.getElementById('aexp_system~kvm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~namespace/?opendiv=system'>namespace</a><a href='##' onmousedown=showDiv('system~namespace') id='aexp_system~namespace'><span class='exp_style' id='exp_system~namespace'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~namespace')) document.getElementById('aexp_system~namespace').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(163)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~fs/?opendiv=kernel'>fs</a><a href='##' onmousedown=showDiv('kernel~fs') id='aexp_kernel~fs'><span class='exp_style' id='exp_kernel~fs'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~fs')) document.getElementById('aexp_kernel~fs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>33</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>80</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>19</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(22)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(76)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~ksplice/?opendiv=debug'>ksplice</a><a href='##' onmousedown=showDiv('debug~ksplice') id='aexp_debug~ksplice'><span class='exp_style' id='exp_debug~ksplice'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~ksplice')) document.getElementById('aexp_debug~ksplice').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>17</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~perf/?opendiv=debug'>perf</a><a href='##' onmousedown=showDiv('debug~perf') id='aexp_debug~perf'><span class='exp_style' id='exp_debug~perf'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~perf')) document.getElementById('aexp_debug~perf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(27)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>20</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2016/'>2016</a><a href='##' onmousedown=showDiv('2016')><span class='exp_style' id='exp_2016'>[+]</span></a><span class='right_span'>(19)</span></li>
<div id='2016' class='catsub'><li><a href='/blog/cats/2016~05/?opendiv=2016'>2016-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2016~03/?opendiv=2016'>2016-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2016~02/?opendiv=2016'>2016-02</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2016~01/?opendiv=2016'>2016-01</a><span class='right_span'>6</span></li>
</div><li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(207)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~12/?opendiv=2015'>2015-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2015~11/?opendiv=2015'>2015-11</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2015~10/?opendiv=2015'>2015-10</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2015~09/?opendiv=2015'>2015-09</a><span class='right_span'>18</span></li>
<li><a href='/blog/cats/2015~08/?opendiv=2015'>2015-08</a><span class='right_span'>25</span></li>
<li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>31</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 134%" href="/tags/gdb/">gdb(7)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/05/11/debug-gdb-thread/">gdb线程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/29/debug-ksplice-detail/">理解Ksplice执行过程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/29/debug-ksplice-base/">内核热补丁技术揭秘</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/29/debug-ksplice/">ksplice 使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/28/debug-ftrace/">ftrace 简介</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
	<li>
		<a href=http://smilejay.com/ target=_blank>smilejay</a>
	</li>
	<li>
		<a href=http://blog.chinaunix.net/uid/10167808.html target=_blank>godbach</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
