
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/27/kernel-net-napi/">NAPI机制分析</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-27T01:29:00+08:00'><span class='date'>2015-08-27</span> <span class='time'>01:29:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/shanshanpt/article/details/20564845">http://blog.csdn.net/shanshanpt/article/details/20564845</a></p>

<p>NAPI 的核心在于：在一个繁忙网络，每次有网络数据包到达时，不需要都引发中断，因为高频率的中断可能会影响系统的整体效率，假象一个场景，我们此时使用标准的 100M 网卡，可能实际达到的接收速率为 80MBits/s，而此时数据包平均长度为 1500Bytes，则每秒产生的中断数目为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>80M bits/s / (8 Bits/Byte * 1500 Byte) = 6667 个中断 /s</span></code></pre></td></tr></table></div></figure>


<p>每秒 6667 个中断，对于系统是个很大的压力，此时其实可以转为使用轮询 (polling) 来处理，而不是中断;但轮询在网络流量较小的时没有效率，因此低流量时，基于中断的方式则比较合适，这就是 NAPI 出现的原因，在低流量时候使用中断接收数据包，而在高流量时候则使用基于轮询的方式接收。</p>

<p>现在内核中 NIC 基本上已经全部支持 NAPI 功能，由前面的叙述可知，NAPI 适合处理高速率数据包的处理，而带来的好处则是：</p>

<p>  1、中断缓和 (Interrupt mitigation)，由上面的例子可以看到，在高流量下，网卡产生的中断可能达到每秒几千次，而如果每次中断都需要系统来处理，是一个很大的压力，而 NAPI 使用轮询时是禁止了网卡的接收中断的，这样会减小系统处理中断的压力；</p>

<p>  2、数据包节流 (Packet throttling)，NAPI 之前的 Linux NIC 驱动总在接收到数据包之后产生一个 IRQ，接着在中断服务例程里将这个 skb 加入本地的 softnet，然后触发本地 NET_RX_SOFTIRQ 软中断后续处理。如果包速过高，因为 IRQ 的优先级高于 SoftIRQ，导致系统的大部分资源都在响应中断，但 softnet 的队列大小有限，接收到的超额数据包也只能丢掉，所以这时这个模型是在用宝贵的系统资源做无用功。而 NAPI 则在这样的情况下，直接把包丢掉，不会继续将需要丢掉的数据包扔给内核去处理，这样，网卡将需要丢掉的数据包尽可能的早丢弃掉，内核将不可见需要丢掉的数据包，这样也减少了内核的压力。</p>

<p>对NAPI 的使用，一般包括以下的几个步骤：</p>

<p>  1、在中断处理函数中，先禁止接收中断，且告诉网络子系统，将以轮询方式快速收包，其中禁止接收中断完全由硬件功能决定，而告诉内核将以轮询方式处理包则是使用函数 netif_rx_schedule()，也可以使用下面的方式，其中的 netif_rx_schedule_prep 是为了判定现在是否已经进入了轮询模式：</p>

<p>将网卡预定为轮询模式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void netif_rx_schedule(struct net_device *dev);</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (netif_rx_schedule_prep(dev))
</span><span class='line'>&#9;__netif_rx_schedule(dev);</span></code></pre></td></tr></table></div></figure>


<p>  2、在驱动中创建轮询函数，它的工作是从网卡获取数据包并将其送入到网络子系统，其原型是：</p>

<p>NAPI 的轮询方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int (*poll)(struct net_device *dev, int *budget);</span></code></pre></td></tr></table></div></figure>


<p>这里的轮询函数用于在将网卡切换为轮询模式之后，用 poll() 方法处理接收队列中的数据包，如队列为空，则重新切换为中断模式。切换回中断模式需要先关闭轮询模式，使用的是函数 netif_rx_complete ()，接着开启网卡接收中断 .。</p>

<p>退出轮询模式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void netif_rx_complete(struct net_device *dev);</span></code></pre></td></tr></table></div></figure>


<p>  3、在驱动中创建轮询函数，需要和实际的网络设备 struct net_device 关联起来，这一般在网卡的初始化时候完成，示例代码如下：</p>

<p>设置网卡支持轮询模式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dev-&gt;poll = my_poll;
</span><span class='line'>dev-&gt;weight = 64;</span></code></pre></td></tr></table></div></figure>


<p>里面另外一个字段为权重 (weight)，该值并没有一个非常严格的要求，实际上是个经验数据，一般 10Mb 的网卡，我们设置为 16，而更快的网卡，我们则设置为 64。</p>

<p>NAPI的一些相关Interface</p>

<p>下面是 NAPI 功能的一些接口，在前面都基本有涉及，我们简单看看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>netif_rx_schedule(dev)</span></code></pre></td></tr></table></div></figure>


<p>在网卡的中断处理函数中调用，用于将网卡的接收模式切换为轮询</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>netif_rx_schedule_prep(dev)</span></code></pre></td></tr></table></div></figure>


<p>在网卡是 Up 且运行状态时，将该网卡设置为准备将其加入到轮询列表的状态，可以将该函数看做是 netif_rx_schedule(dev) 的前半部分</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__netif_rx_schedule(dev)</span></code></pre></td></tr></table></div></figure>


<p>将设备加入轮询列表，前提是需要 netif_schedule_prep(dev) 函数已经返回了 1</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__netif_rx_schedule_prep(dev)</span></code></pre></td></tr></table></div></figure>


<p>与 netif_rx_schedule_prep(dev) 相似，但是没有判断网卡设备是否 Up 及运行，不建议使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>netif_rx_complete(dev)</span></code></pre></td></tr></table></div></figure>


<p>用于将网卡接口从轮询列表中移除，一般在轮询函数完成之后调用该函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__netif_rx_complete(dev)</span></code></pre></td></tr></table></div></figure>


<h4>Newer newer NAPI</h4>

<p>其实之前的 NAPI(New API) 这样的命名已经有点让人忍俊不禁了，可见 Linux 的内核极客们对名字的掌控，比对代码的掌控差太多，于是乎，连续的两次对 NAPI 的重构，被戏称为 Newer newer NAPI 了。</p>

<p>与 netif_rx_complete(dev) 类似，但是需要确保本地中断被禁止</p>

<p>Newer newer NAPI</p>

<p>在最初实现的 NAPI 中，有 2 个字段在结构体 net_device 中，分别为轮询函数 poll() 和权重 weight，而所谓的 Newer newer NAPI，是在 2.6.24 版内核之后，对原有的 NAPI 实现的几次重构，其核心是将 NAPI 相关功能和 net_device 分离，这样减少了耦合，代码更加的灵活，因为 NAPI 的相关信息已经从特定的网络设备剥离了，不再是以前的一对一的关系了。例如有些网络适配器，可能提供了多个 port，但所有的 port 却是共用同一个接受数据包的中断，这时候，分离的 NAPI 信息只用存一份，同时被所有的 port 来共享，这样，代码框架上更好地适应了真实的硬件能力。Newer newer NAPI 的中心结构体是napi_struct:</p>

<p>NAPI 结构体</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 
</span><span class='line'> * Structure for NAPI scheduling similar to tasklet but with weighting 
</span><span class='line'>*/ 
</span><span class='line'>struct napi_struct { 
</span><span class='line'>&#9;/* The poll_list must only be managed by the entity which 
</span><span class='line'>&#9; * changes the state of the NAPI_STATE_SCHED bit.  This means 
</span><span class='line'>&#9; * whoever atomically sets that bit can add this napi_struct 
</span><span class='line'>&#9; * to the per-cpu poll_list, and whoever clears that bit 
</span><span class='line'>&#9; * can remove from the list right before clearing the bit. 
</span><span class='line'>&#9; */ 
</span><span class='line'>&#9;struct list_head      poll_list; 
</span><span class='line'>
</span><span class='line'>&#9;unsigned long          state; 
</span><span class='line'>&#9;int              weight; 
</span><span class='line'>&#9;int              (*poll)(struct napi_struct *, int); 
</span><span class='line'> #ifdef CONFIG_NETPOLL 
</span><span class='line'>&#9;spinlock_t          poll_lock; 
</span><span class='line'>&#9;int              poll_owner; 
</span><span class='line'> #endif 
</span><span class='line'>
</span><span class='line'>&#9;unsigned int          gro_count; 
</span><span class='line'>
</span><span class='line'>&#9;struct net_device      *dev; 
</span><span class='line'>&#9;struct list_head      dev_list; 
</span><span class='line'>&#9;struct sk_buff          *gro_list; 
</span><span class='line'>&#9;struct sk_buff          *skb; 
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>熟悉老的 NAPI 接口实现的话，里面的字段 poll_list、state、weight、poll、dev、没什么好说的，gro_count 和 gro_list 会在后面讲述 GRO 时候会讲述。需要注意的是，与之前的 NAPI 实现的最大的区别是该结构体不再是 net_device 的一部分，事实上，现在希望网卡驱动自己单独分配与管理 napi 实例，通常将其放在了网卡驱动的私有信息，这样最主要的好处在于，如果驱动愿意，可以创建多个 napi_struct，因为现在越来越多的硬件已经开始支持多接收队列 (multiple receive queues)，这样，多个 napi_struct 的实现使得多队列的使用也更加的有效。</p>

<p>与最初的 NAPI 相比较，轮询函数的注册有些变化，现在使用的新接口是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void netif_napi_add(struct net_device *dev, struct napi_struct *napi, 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;int (*poll)(struct napi_struct *, int), int weight)</span></code></pre></td></tr></table></div></figure>


<p>熟悉老的 NAPI 接口的话，这个函数也没什么好说的。</p>

<p>值得注意的是，前面的轮询 poll() 方法原型也开始需要一些小小的改变：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int (*poll)(struct napi_struct *napi, int budget);</span></code></pre></td></tr></table></div></figure>


<p>大部分 NAPI 相关的函数也需要改变之前的原型，下面是打开轮询功能的 API：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void netif_rx_schedule(struct net_device *dev, 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;struct napi_struct *napi); 
</span><span class='line'>/* ...or... */ 
</span><span class='line'>int netif_rx_schedule_prep(struct net_device *dev, 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;struct napi_struct *napi); 
</span><span class='line'>void __netif_rx_schedule(struct net_device *dev, 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;struct napi_struct *napi);</span></code></pre></td></tr></table></div></figure>


<p>轮询功能的关闭则需要使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void netif_rx_complete(struct net_device *dev, 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;struct napi_struct *napi);</span></code></pre></td></tr></table></div></figure>


<p>因为可能存在多个 napi_struct 的实例，要求每个实例能够独立的使能或者禁止，因此，需要驱动作者保证在网卡接口关闭时，禁止所有的 napi_struct 的实例。</p>

<p>函数 netif_poll_enable() 和 netif_poll_disable() 不再需要，因为轮询管理不再和 net_device 直接管理，取而代之的是下面的两个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void napi_enable(struct napi *napi); 
</span><span class='line'>void napi_disable(struct napi *napi);</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/25/kernel-net-ipv4/">linux下ip协议(V4)的实现</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-25T23:34:00+08:00'><span class='date'>2015-08-25</span> <span class='time'>23:34:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这次主要介绍的是ip层的切片与组包的实现。</p>

<p>首先来看一下分片好的帧的一些概念：</p>

<p>1 第一个帧的offset位非0并且MF位为1</p>

<p>2 所有的在第一个帧和最后一个帧之间的帧都拥有长度大于0的域</p>

<p>3 最后一个帧MF位为0 并且offset位非0。(这样就能判断是否是最后一个帧了).</p>

<p>这里要注意在linux中，ip头的frag_off域包含了 rfcip头的定义中的nf,df,以及offset域，因此我们每次需要按位与来取得相应的域的值,看下面</p>

<p>ip_local_deliver的代码片段就清楚了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;// 取出mf位和offset域，从而决定是否要组包。
</span><span class='line'>&#9;if (ip_hdr(skb)-&gt;frag_off & htons(IP_MF | IP_OFFSET)) {
</span><span class='line'>&#9;&#9;if (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))
</span><span class='line'>&#9;&#9;&#9;return 0;
</span><span class='line'>&#9;}</span></code></pre></td></tr></table></div></figure>


<p>而fragmentation/defragmentation 子系统的初始化是通过ipfrag_init来实现了，而它是被inet_init来调用的。它主要做的是注册sys文件系统节点，并开启一个定时器，以及初始化一些相关的变量.这个函数的初始化以及相关的数据结构的详细介绍，我们会在后面的组包小节中介绍。现在我们先来看切片的处理。</p>

<p>相对于组包，切片逻辑什么的都比较简单。切片的主要函数是ip_fragment.它的输入包包括下面几种：</p>

<p>1 要被转发的包(没有切片的)。</p>

<p>2 要被转发的包(已经被路由器或者源主机切片了的).</p>

<p>3 被本地函数所创建的buffer，简而言之也就是本地所要传输的数据包(还未加包头)，但是需要被切片的。</p>

<p>而ip_fragment所必须处理下面几种情况：</p>

<p>1 一大块数据需要被分割为更小的部分。</p>

<p>2 一堆数据片段(我的上篇blog有介绍，也就是ip_append_data已经切好的数据包，或者tcp已经切好的数据包)不需要再被切片。</p>

<p>上面的两种情况其实就是看高层(4层)协议有没有做切片工作(按照PMTU）了。如果已经被切片(其实也算不上切片(4层不能处理ip头)，只能说i4层为了ip层更好的处理数据包，从而帮ip层做了一部分工作)，则ip层所做的很简单，就是给每个包加上ip头就可以了。</p>

<p>切片分为两种类型，一种是fast (或者说 efficient)切片，这种也就是4层已经切好片，这里只需要加上ip头就可以了，一种是slow切片，也就是需要现在切片。</p>

<p>下来来看切片的主要任务：</p>

<p>1 将数据包切片为MTU大小(通过ptmu).</p>

<p>2 初始化每一个fragment的ip 头。还要判断一些option的copy位，因为并不是每一种option都要放在所有已切片的fragment 的ip头中的。</p>

<p>3 计算ip层的校验值。</p>

<p>4 通过netfilter过滤。</p>

<p>5 update 一些kernel 域以及snmp 统计值。</p>

<p>接下来来看ip_fragment的具体实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff*))</span></code></pre></td></tr></table></div></figure>


<p>第一个参数skb表示将要被切片的ip包，第二个参数是一个传输切片的输出函数(切片完毕后就交给这个函数处理)。比如ip_finish_output2类似的。</p>

<p>这个函数我们来分段看，首先来看它进行切片前的一些准备工作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;// 先是取出了一些下面将要使用的变量。
</span><span class='line'>&#9;struct iphdr *iph;
</span><span class='line'>&#9;int raw = 0;
</span><span class='line'>&#9;int ptr;
</span><span class='line'>&#9;struct net_device *dev;
</span><span class='line'>&#9;struct sk_buff *skb2;
</span><span class='line'>&#9;unsigned int mtu, hlen, left, len, ll_rs, pad;
</span><span class='line'>&#9;int offset;
</span><span class='line'>&#9;__be16 not_last_frag;
</span><span class='line'>&#9;// 路由表
</span><span class='line'>&#9;struct rtable *rt = skb-&gt;rtable;
</span><span class='line'>&#9;int err = 0;
</span><span class='line'>&#9;// 网络设备
</span><span class='line'>&#9;dev = rt-&gt;u.dst.dev;
</span><span class='line'>
</span><span class='line'>&#9;// ip头
</span><span class='line'>&#9;iph = ip_hdr(skb);
</span><span class='line'>&#9;// 判断DF位，我们知道如果df位被设置了话就表示不要被切片，这时ip_fragment将会发送一个icmp豹纹返回到源主机。这里主要是为forward数据所判断。
</span><span class='line'>&#9;if (unlikely((iph-&gt;frag_off & htons(IP_DF)) && !skb-&gt;local_df)) {
</span><span class='line'>&#9;&#9;IP_INC_STATS(dev_net(dev), IPSTATS_MIB_FRAGFAILS);
</span><span class='line'>&#9;&#9;icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
</span><span class='line'>&#9;&#9;&#9;  htonl(ip_skb_dst_mtu(skb)));
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;return -EMSGSIZE;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;// 得到ip头的长度
</span><span class='line'>&#9;hlen = iph-&gt;ihl * 4;
</span><span class='line'>&#9;// 得到mtu的大小。这里要注意，他的大小减去了hlen，也就是ip头的大小。
</span><span class='line'>&#9;mtu = dst_mtu(&rt-&gt;u.dst) - hlen;    /* Size of data space */
</span><span class='line'>&#9;IPCB(skb)-&gt;flags |= IPSKB_FRAG_COMPLETE;</span></code></pre></td></tr></table></div></figure>


<p>不管是slow还是fast 被切片的任何一个帧如果传输失败，ip_fragment都会立即返回一个错误给4层，并且紧跟着的帧也不会再被传输，然后将处理方法交给4层去做。</p>

<p>接下来我们来看fast 切片。 一般用fast切片的都是经由4层的ip_append_data和ip_push_pending函数(udp)将数据包已经切片好的，或者是tcp层已经切片好的数据包，才会用fast切片.</p>

<p>这里要主要几个问题：<br/>
1 每一个切片的大小都不能超过PMTU。<br/>
2 只有最后一个切片才会有3层的整个数据包的大小。<br/>
3 每一个切片都必须有足够的大小来允许2层加上自己的头。</p>

<p>我们先看一下skb_pagelen这个函数(下面的处理会用到),这个函数用来得到当前skb的len，首先我们要知道(我前面的blog有介绍)在sk_write_queue的sk_buff队列中，每一个sk_buff的len = x(也就是么一个第一个切片的包的l4 payload的长度) + S1 (这里表示所有的frags域的数据的总大小，也就是data_len的长度)。可以先看下面的图：</p>

<p><img src="/images/kernel/2015-08-25-21.jpg" alt="" /></p>

<p>很容易一目了然。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int skb_pagelen(const struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int i, len = 0;
</span><span class='line'>&#9;// 我们知道如果设备支持S/G IO的话，nr_frags会包含一些L4 payload，因此我们需要先遍历nr_frags.然后加入它的长度。
</span><span class='line'>&#9;for (i = (int)skb_shinfo(skb)-&gt;nr_frags - 1; i &gt;= 0; i--)
</span><span class='line'>&#9;&#9;len += skb_shinfo(skb)-&gt;frags[i].size;
</span><span class='line'>&#9;// 最后加上skb_headlen,而skb_headlen = skb-&gt;len - skb-&gt;data_len;因此这里就会返回这个数据包的len。
</span><span class='line'>&#9;return len + skb_headlen(skb);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;// 通过上一篇blog我们知道，如果4层将数据包分片了，那么就会把这些数据包放到skb的frag_list链表中，因此我们这里首先先判断frag_list链表是否为空，为空的话我们将会进行slow 切片。
</span><span class='line'>&#9;if (skb_shinfo(skb)-&gt;frag_list) {
</span><span class='line'>&#9;&#9;struct sk_buff *frag;
</span><span class='line'>&#9;&#9;// 取得第一个数据报的len.我们知道当sk_write_queue队列被flush后，除了第一个切好包的另外的包都会加入到frag_list中，而这里我们我们需要得到的第一个包(也就是本身这个sk_buff）的长度。
</span><span class='line'>&#9;&#9;int first_len = skb_pagelen(skb);
</span><span class='line'>&#9;&#9;int truesizes = 0;
</span><span class='line'>&#9;&#9;// 接下来的判断都是为了确定我们能进行fast切片。切片不能被共享，这是因为在fast path 中，我们需要加给每个切片不同的ip头(而并不会复制每个切片)。因此在fast path中是不可接受的。而在slow path中，就算有共享也无所谓，因为他会复制每一个切片，使用一个新的buff。
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 判断第一个包长度是否符合一些限制(包括mtu，mf位等一些限制).如果第一个数据报的len没有包含mtu的大小这里之所以要把第一个切好片的数据包单独拿出来检测，是因为一些域是第一个包所独有的(比如IP_MF要为1）。这里由于这个mtu是不包括hlen的mtu，因此我们需要减去一个hlen。
</span><span class='line'>&#9;&#9;if (first_len - hlen &gt; mtu ||
</span><span class='line'>&#9;&#9;&#9;((first_len - hlen) & 7) ||
</span><span class='line'>&#9;&#9;&#9;(iph-&gt;frag_off & htons(IP_MF|IP_OFFSET)) ||
</span><span class='line'>&#9;&#9;&#9;skb_cloned(skb))
</span><span class='line'>&#9;&#9;&#9;goto slow_path;
</span><span class='line'>&#9;&#9;// 遍历剩余的frag。
</span><span class='line'>&#9;&#9;for (frag = skb_shinfo(skb)-&gt;frag_list; frag; frag = frag-&gt;next) {
</span><span class='line'>&#9;&#9;&#9;/* Correct geometry. */
</span><span class='line'>&#9;&#9;&#9;// 判断每个帧的mtu，以及相关的东西，如果不符合条件则要进行slow path,基本和上面的第一个skb的判断类似。
</span><span class='line'>&#9;&#9;&#9;if (frag-&gt;len &gt; mtu ||
</span><span class='line'>&#9;&#9;&#9;&#9;((frag-&gt;len & 7) && frag-&gt;next) ||
</span><span class='line'>&#9;&#9;&#9;&#9;skb_headroom(frag) &lt; hlen)
</span><span class='line'>&#9;&#9;&#9;&#9;goto slow_path;
</span><span class='line'>&#9;&#9;&#9;// 判断是否共享。
</span><span class='line'>&#9;&#9;&#9;/* Partially cloned skb? */
</span><span class='line'>&#9;&#9;&#9;if (skb_shared(frag))
</span><span class='line'>&#9;&#9;&#9;&#9;goto slow_path;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;BUG_ON(frag-&gt;sk);
</span><span class='line'>&#9;&#9;&#9;// 进行socket的一些操作。
</span><span class='line'>&#9;&#9;&#9;if (skb-&gt;sk) {
</span><span class='line'>&#9;&#9;&#9;&#9;sock_hold(skb-&gt;sk);
</span><span class='line'>&#9;&#9;&#9;&#9;frag-&gt;sk = skb-&gt;sk;
</span><span class='line'>&#9;&#9;&#9;&#9;frag-&gt;destructor = sock_wfree;
</span><span class='line'>&#9;&#9;&#9;&#9;truesizes += frag-&gt;truesize;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 通过上面的检测，都通过了，因此我们可以进行fast path切片了。
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 先是设置一些将要处理的变量的值。
</span><span class='line'>&#9;&#9;err = 0;
</span><span class='line'>&#9;&#9;offset = 0;
</span><span class='line'>&#9;&#9;// 取得frag_list列表
</span><span class='line'>&#9;&#9;frag = skb_shinfo(skb)-&gt;frag_list;
</span><span class='line'>&#9;&#9;skb_shinfo(skb)-&gt;frag_list = NULL;
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 得到数据(不包括头)的大小。
</span><span class='line'>&#9;&#9;skb-&gt;data_len = first_len - skb_headlen(skb);
</span><span class='line'>&#9;&#9;skb-&gt;truesize -= truesizes;
</span><span class='line'>&#9;&#9;// 得到
</span><span class='line'>&#9;&#9;skb-&gt;len = first_len;
</span><span class='line'>&#9;&#9;iph-&gt;tot_len = htons(first_len);
</span><span class='line'>&#9;&#9;// 设置mf位
</span><span class='line'>&#9;&#9;iph-&gt;frag_off = htons(IP_MF);
</span><span class='line'>&#9;&#9;// 执行校验
</span><span class='line'>&#9;&#9;ip_send_check(iph);
</span><span class='line'>
</span><span class='line'>&#9;&#9;for (;;) {
</span><span class='line'>&#9;&#9;&#9;// 开始进行发送。
</span><span class='line'>&#9;&#9;&#9;if (frag) {
</span><span class='line'>&#9;&#9;&#9;&#9;// 设置校验位
</span><span class='line'>&#9;&#9;&#9;&#9;frag-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>&#9;&#9;&#9;&#9;// 设置相应的头部。
</span><span class='line'>&#9;&#9;&#9;&#9;skb_reset_transport_header(frag);
</span><span class='line'>&#9;&#9;&#9;&#9;__skb_push(frag, hlen);
</span><span class='line'>&#9;&#9;&#9;&#9;skb_reset_network_header(frag);
</span><span class='line'>&#9;&#9;&#9;&#9;// 复制ip头。
</span><span class='line'>&#9;&#9;&#9;&#9;memcpy(skb_network_header(frag), iph, hlen);
</span><span class='line'>&#9;&#9;&#9;&#9;// 修改每个切片的ip头的一些属性。
</span><span class='line'>&#9;&#9;&#9;&#9;iph = ip_hdr(frag);
</span><span class='line'>&#9;&#9;&#9;&#9;iph-&gt;tot_len = htons(frag-&gt;len);
</span><span class='line'>&#9;&#9;&#9;&#9;// 将当前skb的一些属性付给将要传递的切片好的帧。
</span><span class='line'>&#9;&#9;&#9;&#9;ip_copy_metadata(frag, skb);
</span><span class='line'>&#9;&#9;&#9;&#9;if (offset == 0)
</span><span class='line'>&#9;&#9;&#9;&#9;// 处理ip_option
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;ip_options_fragment(frag);
</span><span class='line'>&#9;&#9;&#9;&#9;offset += skb-&gt;len - hlen;
</span><span class='line'>&#9;&#9;&#9;&#9;// 设置位移。
</span><span class='line'>&#9;&#9;&#9;&#9;iph-&gt;frag_off = htons(offset&gt;&gt;3);
</span><span class='line'>&#9;&#9;&#9;&#9;if (frag-&gt;next != NULL)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;iph-&gt;frag_off |= htons(IP_MF);
</span><span class='line'>&#9;&#9;&#9;&#9;/* Ready, complete checksum */
</span><span class='line'>&#9;&#9;&#9;&#9;ip_send_check(iph);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;// 调用输出函数。
</span><span class='line'>&#9;&#9;&#9;err = output(skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (!err)
</span><span class='line'>&#9;&#9;&#9;&#9;IP_INC_STATS(dev_net(dev), IPSTATS_MIB_FRAGCREATES);
</span><span class='line'>&#9;&#9;&#9;if (err || !frag)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;// 处理链表中下一个buf。
</span><span class='line'>&#9;&#9;&#9;skb = frag;
</span><span class='line'>&#9;&#9;&#9;frag = skb-&gt;next;
</span><span class='line'>&#9;&#9;&#9;skb-&gt;next = NULL;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (err == 0) {
</span><span class='line'>&#9;&#9;&#9;IP_INC_STATS(dev_net(dev), IPSTATS_MIB_FRAGOKS);
</span><span class='line'>&#9;&#9;&#9;return 0;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;// 释放内存。
</span><span class='line'>&#9;&#9;while (frag) {
</span><span class='line'>&#9;&#9;&#9;skb = frag-&gt;next;
</span><span class='line'>&#9;&#9;&#9;kfree_skb(frag);
</span><span class='line'>&#9;&#9;&#9;frag = skb;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;IP_INC_STATS(dev_net(dev), IPSTATS_MIB_FRAGFAILS);
</span><span class='line'>&#9;&#9;return err;
</span><span class='line'>&#9;}
</span></code></pre></td></tr></table></div></figure>


<p>再接下来我们来看slow fragmentation：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;// 切片开始的位移
</span><span class='line'>&#9;left = skb-&gt;len - hlen;      /* Space per frame */
</span><span class='line'>&#9;// 而ptr就是切片开始的指针。
</span><span class='line'>&#9;ptr = raw + hlen;       /* Where to start from */
</span><span class='line'>
</span><span class='line'>&#9;/* for bridged IP traffic encapsulated inside f.e. a vlan header,
</span><span class='line'>&#9; * we need to make room for the encapsulating header
</span><span class='line'>&#9; */
</span><span class='line'>&#9;// 处理桥接的相关操作。
</span><span class='line'>&#9;pad = nf_bridge_pad(skb);
</span><span class='line'>&#9;ll_rs = LL_RESERVED_SPACE_EXTRA(rt-&gt;u.dst.dev, pad);
</span><span class='line'>&#9;mtu -= pad;
</span><span class='line'>
</span><span class='line'>&#9;// 其实也就是取出取出ip offset域。
</span><span class='line'>&#9;offset = (ntohs(iph-&gt;frag_off) & IP_OFFSET) &lt;&lt; 3;
</span><span class='line'>&#9;// not_last_frag，顾名思义，其实也就是表明这个帧是否是最后一个切片。
</span><span class='line'>&#9;not_last_frag = iph-&gt;frag_off & htons(IP_MF);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&#9;// 开始为循环处理，每一个切片创建一个skb buffer。
</span><span class='line'>&#9;while (left &gt; 0) {
</span><span class='line'>&#9;&#9;len = left;
</span><span class='line'>&#9;&#9;// 如果len大于mtu，我们设置当前的将要切片的数据大小为mtu。
</span><span class='line'>&#9;&#9;if (len &gt; mtu)
</span><span class='line'>&#9;&#9;&#9;len = mtu;
</span><span class='line'>&#9;&#9;// 长度也必须位对齐。
</span><span class='line'>&#9;&#9;if (len &lt; left)  {
</span><span class='line'>&#9;&#9;&#9;len &= ~7;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;// malloc一个新的buff。它的大小包括ip payload,ip head,以及L2 head.
</span><span class='line'>&#9;&#9;if ((skb2 = alloc_skb(len+hlen+ll_rs, GFP_ATOMIC)) == NULL) {
</span><span class='line'>&#9;&#9;&#9;NETDEBUG(KERN_INFO "IP: frag: no memory for new fragment!\n");
</span><span class='line'>&#9;&#9;&#9;err = -ENOMEM;
</span><span class='line'>&#9;&#9;&#9;goto fail;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;// 调用ip_copy_metadata复制一些相同的值的域。
</span><span class='line'>&#9;&#9;ip_copy_metadata(skb2, skb);
</span><span class='line'>&#9;&#9;// 进行skb的相关操作。为了加上ip头。
</span><span class='line'>&#9;&#9;skb_reserve(skb2, ll_rs);
</span><span class='line'>&#9;&#9;skb_put(skb2, len + hlen);
</span><span class='line'>&#9;&#9;skb_reset_network_header(skb2);
</span><span class='line'>&#9;&#9;skb2-&gt;transport_header = skb2-&gt;network_header + hlen;
</span><span class='line'>&#9;&#9;// 将每一个分片的ip包都关联到源包的socket上。
</span><span class='line'>&#9;&#9;if (skb-&gt;sk)
</span><span class='line'>&#9;&#9;&#9;skb_set_owner_w(skb2, skb-&gt;sk);
</span><span class='line'>&#9;&#9;// 开始填充新的ip包的数据。
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 先拷贝包头。
</span><span class='line'>&#9;&#9;skb_copy_from_linear_data(skb, skb_network_header(skb2), hlen);
</span><span class='line'>&#9;&#9;// 拷贝数据部分，这个函数实现的比较复杂。
</span><span class='line'>&#9;&#9;if (skb_copy_bits(skb, ptr, skb_transport_header(skb2), len))
</span><span class='line'>&#9;&#9;&#9;BUG();
</span><span class='line'>&#9;&#9;left -= len;
</span><span class='line'>&#9;&#9;// 填充相应的ip头。
</span><span class='line'>&#9;&#9;iph = ip_hdr(skb2);
</span><span class='line'>&#9;&#9;iph-&gt;frag_off = htons((offset &gt;&gt; 3));
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 第一个包，因此进行ip_option处理。
</span><span class='line'>&#9;&#9;if (offset == 0)
</span><span class='line'>&#9;&#9;&#9;ip_options_fragment(skb);
</span><span class='line'>&#9;&#9;// 不是最后一个包，因此设置mf位。
</span><span class='line'>&#9;&#9;if (left &gt; 0 || not_last_frag)
</span><span class='line'>&#9;&#9;&#9;iph-&gt;frag_off |= htons(IP_MF);
</span><span class='line'>&#9;&#9;// 移动指针以及更改位移大小。
</span><span class='line'>&#9;&#9;ptr += len;
</span><span class='line'>&#9;&#9;offset += len;
</span><span class='line'>&#9;&#9;// update包头的大小。
</span><span class='line'>&#9;&#9;iph-&gt;tot_len = htons(len + hlen);
</span><span class='line'>&#9;&#9;// 重新计算校验。
</span><span class='line'>&#9;&#9;ip_send_check(iph);
</span><span class='line'>&#9;&#9;//最终输出。
</span><span class='line'>&#9;&#9;err = output(skb2);
</span><span class='line'>&#9;&#9;if (err)
</span><span class='line'>&#9;&#9;&#9;goto fail;
</span><span class='line'>
</span><span class='line'>&#9;&#9;IP_INC_STATS(dev_net(dev), IPSTATS_MIB_FRAGCREATES);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;IP_INC_STATS(dev_net(dev), IPSTATS_MIB_FRAGOKS);
</span><span class='line'>&#9;return err;</span></code></pre></td></tr></table></div></figure>


<p>接下来来看ip组包的实现。首先要知道每一个切片(属于同一个源包的)的ip包 id都是相同的。</p>

<p>首先来看相应的数据结构。在内核中，每一个ip包(切片好的)都是一个struct ipq链表。而不同的数据包(这里指不是属于同一个源包的数据包)都保</p>

<p>存在一个hash表中。也就是ip4_frags这个变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct inet_frags ip4_frags;
</span><span class='line'>
</span><span class='line'>#define INETFRAGS_HASHSZ        64
</span><span class='line'>
</span><span class='line'>struct inet_frags {
</span><span class='line'>&#9;struct hlist_head   hash[INETFRAGS_HASHSZ];
</span><span class='line'>&#9;rwlock_t        lock;
</span><span class='line'>&#9;// 随机值，它被用在计算hash值上面，下面会介绍到，过一段时间，内核就会更新这个值。
</span><span class='line'>&#9;u32         rnd;
</span><span class='line'>&#9;int         qsize;
</span><span class='line'>&#9;int         secret_interval;
</span><span class='line'>&#9;struct timer_list   secret_timer;
</span><span class='line'>&#9;// hash函数
</span><span class='line'>&#9;unsigned int        (*hashfn)(struct inet_frag_queue *);
</span><span class='line'>&#9;void            (*constructor)(struct inet_frag_queue *q,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;void *arg);
</span><span class='line'>&#9;void            (*destructor)(struct inet_frag_queue *);
</span><span class='line'>&#9;void            (*skb_free)(struct sk_buff *);
</span><span class='line'>&#9;int         (*match)(struct inet_frag_queue *q,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;void *arg);
</span><span class='line'>&#9;void            (*frag_expire)(unsigned long data);
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct ipq {
</span><span class='line'>&#9;struct inet_frag_queue q;
</span><span class='line'>&#9;u32     user;
</span><span class='line'>&#9;// 都是ip头相关的一些域。
</span><span class='line'>&#9;__be32      saddr;
</span><span class='line'>&#9;__be32      daddr;
</span><span class='line'>&#9;__be16      id;
</span><span class='line'>&#9;u8      protocol;
</span><span class='line'>&#9;int             iif;
</span><span class='line'>&#9;unsigned int    rid;
</span><span class='line'>&#9;struct inet_peer *peer;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct inet_frag_queue {
</span><span class='line'>&#9;struct hlist_node   list;
</span><span class='line'>&#9;struct netns_frags  *net;
</span><span class='line'>&#9;// 基于LRU算法，主要用在GC上。
</span><span class='line'>&#9;struct list_head    lru_list;   /* lru list member */
</span><span class='line'>&#9;spinlock_t      lock;
</span><span class='line'>&#9;atomic_t        refcnt;
</span><span class='line'>&#9;// 属于同一个源的数据包的定时器，当定时器到期，切片还没到达，此时就会drop掉所有的数据切片。
</span><span class='line'>&#9;struct timer_list   timer;      /* when will this queue expire? */
</span><span class='line'>&#9;// 保存有所有的切片链表(从属于同一个ip包)
</span><span class='line'>&#9;struct sk_buff      *fragments; /* list of received fragments */
</span><span class='line'>&#9;ktime_t         stamp;
</span><span class='line'>&#9;int         len;        /* total length of orig datagram */
</span><span class='line'>&#9;// 表示从源ip包已经接收的字节数。
</span><span class='line'>&#9;int         meat;
</span><span class='line'>&#9;// 这个域主要可以设置为下面的3种值。
</span><span class='line'>&#9;__u8            last_in;    /* first/last segment arrived? */
</span><span class='line'>
</span><span class='line'>// 完成，第一个帧以及最后一个帧。
</span><span class='line'>#define INET_FRAG_COMPLETE  4
</span><span class='line'>#define INET_FRAG_FIRST_IN  2
</span><span class='line'>#define INET_FRAG_LAST_IN   1
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>看下面的图就一目了然了：</p>

<p><img src="/images/kernel/2015-08-25-22.jpg" alt="" /></p>

<p>首先来看组包要解决的一些问题：</p>

<p>1 fragment必须存储在内存中，知道他们全部都被网络子系统处理。才会释放，因此内存会是个巨大的浪费。</p>

<p>2 这里虽然使用了hash表，可是假设恶意攻击者得到散列算法并且伪造数据包来尝试着降低一些hash表中的元素的比重，从而使执行变得缓慢。这里linux使用一个定时器通过制造的随机数来使hash值的生成不可预测。</p>

<p>这个定时器的初始化是通过ipfrag_init(它会初始化上面提到的ip4_frags全局变量)调用inet_frags_init进行的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void inet_frags_init(struct inet_frags *f)
</span><span class='line'>{
</span><span class='line'>&#9;int i;
</span><span class='line'>
</span><span class='line'>&#9;for (i = 0; i &lt; INETFRAGS_HASHSZ; i++)
</span><span class='line'>&#9;&#9;INIT_HLIST_HEAD(&f-&gt;hash[i]);
</span><span class='line'>
</span><span class='line'>&#9;rwlock_init(&f-&gt;lock);
</span><span class='line'>
</span><span class='line'>&#9;f-&gt;rnd = (u32) ((num_physpages ^ (num_physpages&gt;&gt;7)) ^
</span><span class='line'>&#9;&#9;&#9;&#9;   (jiffies ^ (jiffies &gt;&gt; 6)));
</span><span class='line'>&#9;// 安装定时器，当定时器到期就会调用inet_frag_secret_rebuild方法。
</span><span class='line'>&#9;setup_timer(&f-&gt;secret_timer, inet_frag_secret_rebuild,
</span><span class='line'>&#9;&#9;&#9;(unsigned long)f);
</span><span class='line'>&#9;f-&gt;secret_timer.expires = jiffies + f-&gt;secret_interval;
</span><span class='line'>&#9;add_timer(&f-&gt;secret_timer);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static void inet_frag_secret_rebuild(unsigned long dummy)
</span><span class='line'>{
</span><span class='line'>................................................
</span><span class='line'>
</span><span class='line'>&#9;write_lock(&f-&gt;lock);
</span><span class='line'>&#9;// 得到随机值
</span><span class='line'>&#9;get_random_bytes(&f-&gt;rnd, sizeof(u32));
</span><span class='line'>
</span><span class='line'>&#9;// 然后通过这个随机值重新计算整个hash表的hash值。
</span><span class='line'>&#9;for (i = 0; i &lt; INETFRAGS_HASHSZ; i++) {
</span><span class='line'>&#9;&#9;struct inet_frag_queue *q;
</span><span class='line'>&#9;&#9;struct hlist_node *p, *n;
</span><span class='line'>
</span><span class='line'>&#9;&#9;hlist_for_each_entry_safe(q, p, n, &f-&gt;hash[i], list) {
</span><span class='line'>&#9;&#9;&#9;unsigned int hval = f-&gt;hashfn(q);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (hval != i) {
</span><span class='line'>&#9;&#9;&#9;&#9;hlist_del(&q-&gt;list);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;/* Relink to new hash chain. */
</span><span class='line'>&#9;&#9;&#9;&#9;hlist_add_head(&q-&gt;list, &f-&gt;hash[hval]);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>..............................................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>3 ip协议是不可靠的，因此切片有可能被丢失。内核处理这个，是使用了一个定时器(每个数据包(也就是这个切片从属于的那个数据包)).当定时器到期，而切片没有到达，就会丢弃这个包。</p>

<p>4 由于ip协议是无连接的，因此当高层决定重传数据包的时候，组包时有可能会出现多个重复分片的情况。这是因为ip包是由4个域来判断的，源和目的地址，包id以及4层的协议类型。而最主要的是包id。可是包id只有16位，因此一个gigabit网卡几乎在半秒时间就能用完这个id一次。而第二次重传的数据包有可能走的和第一个第一次时不同的路径，因此内核必须每个切片都要检测和前面接受的切片的重叠情况的发生。</p>

<p>先来看ip_defrag用到的几个函数：</p>

<p>inet_frag_create: 创建一个新的ipq实例</p>

<p>ip_evitor: remove掉所有的未完成的数据包。它每次都会update一个LRU链表。每次都会把一个新的ipq数据结构加到ipq_lru_list的结尾。</p>

<p>ip_find: 发现切片所从属的数据包的切片链表。</p>

<p>ip_frag_queue: 排队一个给定的切片刀一个切片列表。这个经常和上一个方法一起使用。</p>

<p>ip_frag_reasm: 当所有的切片都到达后，build一个ip数据包。</p>

<p>ip_frag_destroy: remove掉传进来的ipq数据结构。包括和他有联系的所有的ip切片。</p>

<p>ipq_put: 将引用计数减一，如果为0，则直接调用ip_frag_destroy.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void inet_frag_put(struct inet_frag_queue *q, struct inet_frags *f)
</span><span class='line'>{
</span><span class='line'>&#9;if (atomic_dec_and_test(&q-&gt;refcnt))
</span><span class='line'>&#9;&#9;inet_frag_destroy(q, f, NULL);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ipq_kill: 主要用在gc上，标记一个ipq数据结构可以被remove，由于一些帧没有按时到达。</p>

<p>接下来来看ip_defrag的实现。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int ip_defrag(struct sk_buff *skb, u32 user)
</span><span class='line'>{
</span><span class='line'>&#9;struct ipq *qp;
</span><span class='line'>&#9;struct net *net;
</span><span class='line'>
</span><span class='line'>&#9;net = skb-&gt;dev ? dev_net(skb-&gt;dev) : dev_net(skb-&gt;dst-&gt;dev);
</span><span class='line'>&#9;IP_INC_STATS_BH(net, IPSTATS_MIB_REASMREQDS);
</span><span class='line'>
</span><span class='line'>&#9;// 如果内存不够，则依据lru算法进行清理。
</span><span class='line'>&#9;if (atomic_read(&net-&gt;ipv4.frags.mem) &gt; net-&gt;ipv4.frags.high_thresh)
</span><span class='line'>&#9;&#9;ip_evictor(net);
</span><span class='line'>
</span><span class='line'>&#9;// 查找相应的iqp，如果不存在则会新创建一个(这些都在ip_find里面实现)
</span><span class='line'>&#9;if ((qp = ip_find(net, ip_hdr(skb), user)) != NULL) {
</span><span class='line'>&#9;&#9;int ret;
</span><span class='line'>
</span><span class='line'>&#9;&#9;spin_lock(&qp-&gt;q.lock);
</span><span class='line'>&#9;&#9;// 排队进队列。
</span><span class='line'>&#9;&#9;ret = ip_frag_queue(qp, skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;spin_unlock(&qp-&gt;q.lock);
</span><span class='line'>&#9;&#9;ipq_put(qp);
</span><span class='line'>&#9;&#9;return ret;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;IP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return -ENOMEM;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到这里最重要的一个函数其实是ip_frag_queue,它主要任务是：</p>

<p>1 发现输入帧在源包的位置。<br/>
2 基于blog刚开始所描述的，判断是否是最后一个切片。<br/>
3 插入切片到切片列表(从属于相同的ip包)<br/>
4 update 垃圾回收所用到的ipq的一些相关域。<br/>
5 校验l4层的校验值(在硬件计算).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 其中qp是源ip包的所有切片链表，而skb是将要加进来切片。
</span><span class='line'>static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;.............................
</span><span class='line'>&#9;//  INET_FRAG_COMPLETE表示所有的切片包都已经抵达，这个时侯就不需要再组包了，因此这里就是校验函数有没有被错误的调用。
</span><span class='line'>&#9;if (qp-&gt;q.last_in & INET_FRAG_COMPLETE)
</span><span class='line'>&#9;&#9;goto err;
</span><span class='line'>&#9;.................................................
</span><span class='line'>&#9;// 将offset 8字节对齐、
</span><span class='line'>&#9;offset = ntohs(ip_hdr(skb)-&gt;frag_off);
</span><span class='line'>&#9;flags = offset & ~IP_OFFSET;
</span><span class='line'>&#9;offset &= IP_OFFSET;
</span><span class='line'>&#9;offset &lt;&lt;= 3;     /* offset is in 8-byte chunks */
</span><span class='line'>&#9;ihl = ip_hdrlen(skb);
</span><span class='line'>
</span><span class='line'>&#9;// 计算这个新的切片包的结束位置。
</span><span class='line'>&#9;end = offset + skb-&gt;len - ihl;
</span><span class='line'>&#9;err = -EINVAL;
</span><span class='line'>
</span><span class='line'>&#9;// MF没有设置，表明这个帧是最后一个帧。进入相关处理。
</span><span class='line'>&#9;if ((flags & IP_MF) == 0) {
</span><span class='line'>&#9;&#9;/* If we already have some bits beyond end
</span><span class='line'>&#9;&#9; * or have different end, the segment is corrrupted.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;// 设置相应的len位置，以及last_in域。
</span><span class='line'>&#9;&#9;if (end &lt; qp-&gt;q.len ||
</span><span class='line'>&#9;&#9;&#9;((qp-&gt;q.last_in & INET_FRAG_LAST_IN) && end != qp-&gt;q.len))
</span><span class='line'>&#9;&#9;&#9;goto err;
</span><span class='line'>&#9;&#9;qp-&gt;q.last_in |= INET_FRAG_LAST_IN;
</span><span class='line'>&#9;&#9;qp-&gt;q.len = end;
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;// 除了最后一个切片，每个切片都必须是8字节的倍数。
</span><span class='line'>&#9;&#9;if (end&7) {
</span><span class='line'>&#9;&#9;&#9;// 不是8字节的倍数，kernel截断这个切片。此时就需要l4层的校验重新计算，因此设置ip_summed为 CHECKSUM_NONE
</span><span class='line'>&#9;&#9;&#9;end &= ~7;
</span><span class='line'>&#9;&#9;&#9;if (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)
</span><span class='line'>&#9;&#9;&#9;&#9;skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;if (end &gt; qp-&gt;q.len) {
</span><span class='line'>&#9;&#9;&#9;// 数据包太大，并且是最后一个包，则表明这个数据包出错，因此drop它。
</span><span class='line'>&#9;&#9;&#9;/* Some bits beyond end -&gt; corruption. */
</span><span class='line'>&#9;&#9;&#9;if (qp-&gt;q.last_in & INET_FRAG_LAST_IN)
</span><span class='line'>&#9;&#9;&#9;&#9;goto err;
</span><span class='line'>&#9;&#9;&#9;qp-&gt;q.len = end;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;// ip头不能被切片，因此end肯定会大于offset。
</span><span class='line'>&#9;if (end == offset)
</span><span class='line'>&#9;&#9;goto err;
</span><span class='line'>
</span><span class='line'>&#9;err = -ENOMEM;
</span><span class='line'>&#9;// remove掉ip头。
</span><span class='line'>&#9;if (pskb_pull(skb, ihl) == NULL)
</span><span class='line'>&#9;&#9;goto err;
</span><span class='line'>&#9;// trim掉一些padding，然后重新计算checksum。
</span><span class='line'>&#9;err = pskb_trim_rcsum(skb, end - offset);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto err;
</span><span class='line'>
</span><span class='line'>&#9;// 接下来遍历并将切片(为了找出当前将要插入的切片的位置)，是以offset为基准。这里要合租要FRAG_CB宏是用来提取sk_buff-&gt;cb域。
</span><span class='line'>&#9;prev = NULL;
</span><span class='line'>&#9;for (next = qp-&gt;q.fragments; next != NULL; next = next-&gt;next) {
</span><span class='line'>&#9;&#9;if (FRAG_CB(next)-&gt;offset &gt;= offset)
</span><span class='line'>&#9;&#9;&#9;break;  /* bingo! */
</span><span class='line'>&#9;&#9;prev = next;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;// 当prev!=NULL时，说明这个切片要插入到列表当中。
</span><span class='line'>&#9;if (prev) {
</span><span class='line'>&#9;&#9;// 计算有没有重叠。
</span><span class='line'>&#9;&#9;int i = (FRAG_CB(prev)-&gt;offset + prev-&gt;len) - offset;
</span><span class='line'>&#9;&#9;// 大于0.证明有重叠，因此进行相关处理
</span><span class='line'>&#9;&#9;if (i &gt; 0) {
</span><span class='line'>&#9;&#9;&#9;// 将重叠部分用新的切片覆盖。
</span><span class='line'>&#9;&#9;&#9;offset += i;
</span><span class='line'>&#9;&#9;&#9;err = -EINVAL;
</span><span class='line'>&#9;&#9;&#9;if (end &lt;= offset)
</span><span class='line'>&#9;&#9;&#9;&#9;goto err;
</span><span class='line'>&#9;&#9;&#9;err = -ENOMEM;
</span><span class='line'>&#9;&#9;&#9;//移动i个位置。
</span><span class='line'>&#9;&#9;&#9;if (!pskb_pull(skb, i))
</span><span class='line'>&#9;&#9;&#9;&#9;goto err;
</span><span class='line'>&#9;&#9;&#9;// 需要重新计算L4的校验。
</span><span class='line'>&#9;&#9;&#9;if (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)
</span><span class='line'>&#9;&#9;&#9;&#9;skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;err = -ENOMEM;
</span><span class='line'>
</span><span class='line'>&#9;while (next && FRAG_CB(next)-&gt;offset &lt; end) {
</span><span class='line'>&#9;&#9;// 和上面的判断很类似，也是先计算重叠数。这里要注意重叠分为两种情况：1；一个或多个切片被新的切片完全覆盖。2；被部分覆盖，因此这里我们需要分两种情况进行处理。
</span><span class='line'>&#9;&#9;int i = end - FRAG_CB(next)-&gt;offset; /* overlap is 'i' bytes */
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (i &lt; next-&gt;len) {
</span><span class='line'>&#9;&#9;&#9;// 被部分覆盖的情况。将新的切片offset移动i字节，然后remove掉老的切片中的i个字节。
</span><span class='line'>&#9;&#9;&#9;/* Eat head of the next overlapped fragment
</span><span class='line'>&#9;&#9;&#9; * and leave the loop. The next ones cannot overlap.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;if (!pskb_pull(next, i))
</span><span class='line'>&#9;&#9;&#9;&#9;goto err;
</span><span class='line'>&#9;&#9;&#9;FRAG_CB(next)-&gt;offset += i;
</span><span class='line'>&#9;&#9;&#9;// 将接收到的源数据报的大小减去i，也就是remove掉不完全覆盖的那一部分。
</span><span class='line'>&#9;&#9;&#9;qp-&gt;q.meat -= i;
</span><span class='line'>&#9;&#9;&#9;// 重新计算l4层的校验。
</span><span class='line'>&#9;&#9;&#9;if (next-&gt;ip_summed != CHECKSUM_UNNECESSARY)
</span><span class='line'>&#9;&#9;&#9;&#9;next-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;// 老的切片完全被新的切片覆盖，此时只需要remove掉老的切片就可以了。
</span><span class='line'>&#9;&#9;&#9;struct sk_buff *free_it = next;
</span><span class='line'>&#9;&#9;&#9;next = next-&gt;next;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (prev)
</span><span class='line'>&#9;&#9;&#9;&#9;prev-&gt;next = next;
</span><span class='line'>&#9;&#9;&#9;else
</span><span class='line'>&#9;&#9;&#9;&#9;qp-&gt;q.fragments = next;
</span><span class='line'>&#9;&#9;&#9;// 将qp的接受字节数更新。
</span><span class='line'>&#9;&#9;&#9;qp-&gt;q.meat -= free_it-&gt;len;
</span><span class='line'>&#9;&#9;&#9;frag_kfree_skb(qp-&gt;q.net, free_it, NULL);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;FRAG_CB(skb)-&gt;offset = offset;
</span><span class='line'>
</span><span class='line'>....................................................
</span><span class='line'>&#9;atomic_add(skb-&gt;truesize, &qp-&gt;q.net-&gt;mem);
</span><span class='line'>&#9;// offset为0说明是第一个切片，因此设置相应的位。
</span><span class='line'>&#9;if (offset == 0)
</span><span class='line'>&#9;&#9;qp-&gt;q.last_in |= INET_FRAG_FIRST_IN;
</span><span class='line'>
</span><span class='line'>&#9;if (qp-&gt;q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&
</span><span class='line'>&#9;&#9;qp-&gt;q.meat == qp-&gt;q.len)
</span><span class='line'>&#9;&#9;// 所有条件的满足了，就开始buildip包。
</span><span class='line'>&#9;&#9;return ip_frag_reasm(qp, prev, dev);
</span><span class='line'>&#9;write_lock(&ip4_frags.lock);
</span><span class='line'>&#9;// 从将此切片加入到lry链表中。
</span><span class='line'>&#9;list_move_tail(&qp-&gt;q.lru_list, &qp-&gt;q.net-&gt;lru_list);
</span><span class='line'>&#9;write_unlock(&ip4_frags.lock);
</span><span class='line'>&#9;return -EINPROGRESS;
</span><span class='line'>
</span><span class='line'>err:
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return err;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果网络设备提供L4层的硬件校验的话，输入ip帧还会进行L4的校验计算。当帧通过ip_frag_reasm组合好，它会进行校验的重新计算。我们这里通过设置skb->ip_summed到CHECKSUM_NONE，来表示需要娇艳的标志。</p>

<p>最后来看下GC。</p>

<p>内核为ip切片数据包实现了两种类型的垃圾回收。</p>

<p>1 系统内存使用限制。</p>

<p>2 组包的定时器</p>

<p>这里有一个全局的ip_frag_mem变量，来表示当前被切片所占用的内存数。每次一个新的切片被加入，这个值都会更新。而所能使用的最大内存可以在运行时改变，是通过/proc的sysctl_ipfrag_high_thresh来改变的，因此我们能看到当ip_defrag时，一开始会先判断内存的限制：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (atomic_read(&net-&gt;ipv4.frags.mem) &gt; net-&gt;ipv4.frags.high_thresh)
</span><span class='line'>&#9;&#9;ip_evictor(net);</span></code></pre></td></tr></table></div></figure>


<p>当一个切片数据包到达后，内核会启动一个组包定时器，他是为了避免一个数据包占据ipq_hash太长时间，因此当定时器到期后，它就会清理掉在hash表中的相应的qp结构(也就是所有的未完成切片包).这个处理函数就是ip_expire,它的初始化是在ipfrag_init进行的。:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void ip_expire(unsigned long arg)
</span><span class='line'>{
</span><span class='line'>&#9;struct ipq *qp;
</span><span class='line'>&#9;struct net *net;
</span><span class='line'>&#9;// 取出相应的qp，以及net域。
</span><span class='line'>&#9;qp = container_of((struct inet_frag_queue *) arg, struct ipq, q);
</span><span class='line'>&#9;net = container_of(qp-&gt;q.net, struct net, ipv4.frags);
</span><span class='line'>
</span><span class='line'>&#9;spin_lock(&qp-&gt;q.lock);
</span><span class='line'>&#9;// 如果数据包已经传输完毕，则不进行任何处理，直接退出。
</span><span class='line'>&#9;if (qp-&gt;q.last_in & INET_FRAG_COMPLETE)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;// 调用ipq_kill，这个函数主要是减少qp的引用计数，并从相关链表(比如LRU_LIST)中移除它。
</span><span class='line'>&#9;ipq_kill(qp);
</span><span class='line'>
</span><span class='line'>&#9;IP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);
</span><span class='line'>&#9;IP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);
</span><span class='line'>
</span><span class='line'>&#9;// 如果是第一个切片，则发送一个ICMP给源主机。
</span><span class='line'>&#9;if ((qp-&gt;q.last_in & INET_FRAG_FIRST_IN) && qp-&gt;q.fragments != NULL) {
</span><span class='line'>&#9;&#9;struct sk_buff *head = qp-&gt;q.fragments;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Send an ICMP "Fragment Reassembly Timeout" message. */
</span><span class='line'>&#9;&#9;if ((head-&gt;dev = dev_get_by_index(net, qp-&gt;iif)) != NULL) {
</span><span class='line'>&#9;&#9;&#9;icmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);
</span><span class='line'>&#9;&#9;&#9;dev_put(head-&gt;dev);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>out:
</span><span class='line'>&#9;spin_unlock(&qp-&gt;q.lock);
</span><span class='line'>&#9;ipq_put(qp);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/25/kernel-net-dev_queue_xmit/">dev_queue_xmi函数详解</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-25T23:20:00+08:00'><span class='date'>2015-08-25</span> <span class='time'>23:20:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>blog.chinaunix.net/uid-20788636-id-3181312.html</p>

<p>前面在分析IPv6的数据流程时，当所有的信息都准备好了之后，例如，出口设备，下一跳的地址，以及链路层地址。就会调用dev.c文件中的dev_queue_xmin函数，该函数是设备驱动程序执行传输的接口。也就是所有的数据包在填充完成后，最终发送数据时，都会调用该函数。</p>

<p>dev_queue_xmit函数只接收一个skb_buff结构作为输入的值。此数据结构包含了此函数所需要的一切信息。Skb->dev是出口设备，skb->data为有效的载荷的开头，其长度为skb->len.下面是2.6.37版本内核中的dev_queue_xmit函数，该版本的内核与之前的版本有了不少的区别。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int dev_queue_xmit(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_device *dev = skb-&gt;dev;
</span><span class='line'>&#9;struct netdev_queue *txq;
</span><span class='line'>&#9;struct Qdisc *q;
</span><span class='line'>&#9;int rc = -ENOMEM;
</span><span class='line'>
</span><span class='line'>&#9;/* Disable soft irqs for various locks below. Also
</span><span class='line'>&#9; * stops preemption for RCU.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;//关闭软中断 - __rcu_read_lock_bh()---&gt;local_bh_disable();
</span><span class='line'>&#9;rcu_read_lock_bh();
</span><span class='line'>&#9;// 选择一个发送队列，如果设备提供了select_queue回调函数就使用它，否则由内核选择一个队列,这里只是Linux内核多队列的实现，但是要真正的使用都队列，需要网卡支持多队列才可以，一般的网卡都只有一个队列。在调用alloc_etherdev分配net_device是，设置队列的个数
</span><span class='line'>&#9;txq = dev_pick_tx(dev, skb);
</span><span class='line'>&#9;//从netdev_queue结构上获取设备的qdisc
</span><span class='line'>&#9;q = rcu_dereference_bh(txq-&gt;qdisc);
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_NET_CLS_ACT
</span><span class='line'>&#9;skb-&gt;tc_verd = SET_TC_AT(skb-&gt;tc_verd, AT_EGRESS);
</span><span class='line'>#endif
</span><span class='line'>&#9;//如果硬件设备有队列可以使用，该函数由dev_queue_xmit函数直接调用或由dev_queue_xmit通过qdisc_run函数调用
</span><span class='line'>&#9;trace_net_dev_queue(skb);
</span><span class='line'>&#9;if (q-&gt;enqueue) {
</span><span class='line'>&#9;&#9;rc = __dev_xmit_skb(skb, q, dev, txq); //使用流控对象发送数据包(包含入队和出队)
</span><span class='line'>&#9;&#9;//更详细的内容参考说明3
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//下面的处理是在没有发送队列的情况下
</span><span class='line'>&#9;/* The device has no queue. Common case for software devices:
</span><span class='line'>&#9; loopback, all the sorts of tunnels...
</span><span class='line'>
</span><span class='line'>&#9; Really, it is unlikely that netif_tx_lock protection is necessary
</span><span class='line'>&#9; here. (f.e. loopback and IP tunnels are clean ignoring statistics
</span><span class='line'>&#9; counters.)
</span><span class='line'>&#9; However, it is possible, that they rely on protection
</span><span class='line'>&#9; made by us here.
</span><span class='line'>
</span><span class='line'>&#9; Check this and shot the lock. It is not prone from deadlocks.
</span><span class='line'>&#9; Either shot noqueue qdisc, it is even simpler 8)
</span><span class='line'>&#9; */
</span><span class='line'>&#9;//首先，确定设备是开启的，并且还要确定队列是运行的，启动和停止队列有驱动程序决定
</span><span class='line'>&#9;//设备没有输出队列典型的是回环设备。这里需要做的就是直接调用dev_start_queue_xmit、、函数，经过驱动发送出去，如果发送失败，就直接丢弃，没有队列可以保存。
</span><span class='line'>&#9;if (dev-&gt;flags & IFF_UP) {
</span><span class='line'>&#9;&#9;int cpu = smp_processor_id(); /* ok because BHs are off */
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (txq-&gt;xmit_lock_owner != cpu) {
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (__this_cpu_read(xmit_recursion) &gt; RECURSION_LIMIT)
</span><span class='line'>&#9;&#9;&#9;&#9;goto recursion_alert;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;HARD_TX_LOCK(dev, txq, cpu);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (!netif_tx_queue_stopped(txq)) {
</span><span class='line'>&#9;&#9;&#9;&#9;__this_cpu_inc(xmit_recursion);
</span><span class='line'>&#9;&#9;&#9;&#9;rc = dev_hard_start_xmit(skb, dev, txq);//见说明4
</span><span class='line'>&#9;&#9;&#9;&#9;__this_cpu_dec(xmit_recursion);
</span><span class='line'>&#9;&#9;&#9;&#9;if (dev_xmit_complete(rc)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;HARD_TX_UNLOCK(dev, txq);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;HARD_TX_UNLOCK(dev, txq);
</span><span class='line'>&#9;&#9;&#9;if (net_ratelimit())
</span><span class='line'>&#9;&#9;&#9;&#9;printk(KERN_CRIT "Virtual device %s asks to "
</span><span class='line'>&#9;&#9;&#9;&#9; "queue packet!\n", dev-&gt;name);
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;/* Recursion is It is possible,
</span><span class='line'>&#9;&#9;&#9; * unfortunately
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>recursion_alert:
</span><span class='line'>&#9;&#9;&#9;if (net_ratelimit())
</span><span class='line'>&#9;&#9;&#9;&#9;printk(KERN_CRIT "Dead loop on virtual device "
</span><span class='line'>&#9;&#9;&#9;&#9; "%s, fix it urgently!\n", dev-&gt;name);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;rc = -ENETDOWN;
</span><span class='line'>&#9;rcu_read_unlock_bh();
</span><span class='line'>
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return rc;
</span><span class='line'>out:
</span><span class='line'>&#9;rcu_read_unlock_bh();
</span><span class='line'>&#9;return rc;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>1. 下面是dev_pick_tx函数。</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct netdev_queue *dev_pick_tx(struct net_device *dev,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int queue_index;
</span><span class='line'>&#9;const struct net_device_ops *ops = dev-&gt;netdev_ops;
</span><span class='line'>
</span><span class='line'>&#9;if (ops-&gt;ndo_select_queue) {
</span><span class='line'>&#9;&#9;//选择一个索引，这个策略可以设置，比如优先选择视频和音频队列，而哪个队列邦定哪个策略也是设定的。
</span><span class='line'>&#9;&#9;queue_index = ops-&gt;ndo_select_queue(dev, skb);
</span><span class='line'>&#9;&#9;queue_index = dev_cap_txqueue(dev, queue_index);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;struct sock *sk = skb-&gt;sk;
</span><span class='line'>&#9;&#9;queue_index = sk_tx_queue_get(sk);
</span><span class='line'>&#9;&#9;if (queue_index &lt; 0 || queue_index &gt;= dev-&gt;real_num_tx_queues) {
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;queue_index = 0;
</span><span class='line'>&#9;&#9;&#9;if (dev-&gt;real_num_tx_queues &gt; 1)
</span><span class='line'>&#9;&#9;&#9;&#9;queue_index = skb_tx_hash(dev, skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (sk) {
</span><span class='line'>&#9;&#9;&#9;&#9;struct dst_entry *dst = rcu_dereference_check(sk-&gt;sk_dst_cache, 1);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (dst && skb_dst(skb) == dst)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;sk_tx_queue_set(sk, queue_index);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;skb_set_queue_mapping(skb, queue_index);
</span><span class='line'>&#9;return netdev_get_tx_queue(dev, queue_index);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>2. 下面是其中的一种网卡类型调用函数alloc_etherdev时，</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dev = alloc_etherdev(sizeof(struct ether1_priv));</span></code></pre></td></tr></table></div></figure>


<p>其实该函数是一个宏定义：其中第二参数表示的就是队列的数量，这里在Linux2.6.37内核中找到的一种硬件网卡的实现，可用的队列是1个。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1)</span></code></pre></td></tr></table></div></figure>


<p>下面是alloc_etherdev_mq函数的定义实现。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct net_device *alloc_etherdev_mq(int sizeof_priv, unsigned int queue_count)
</span><span class='line'>{
</span><span class='line'>&#9;return alloc_netdev_mq(sizeof_priv, "eth%d", ether_setup, queue_count);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>3.</h5>

<p>几乎所有的设备都会使用队列调度出口的流量，而内核可以使用对了规则的算法安排那个帧进行发送，使其以最优效率的次序进行传输。这里检查这个队列中是否有enqueue函数，如果有则说明设备会使用这个队列，否则需另外处理。关于enqueue函数的设置，我找到dev_open->dev_activate中调用了qdisc_create_dflt来设置，需要注意的是，这里并不是将传进来的skb直接发送，而是先入队，然后调度队列，具体发送哪个数据包由enqueue和dequeue函数决定，这体现了设备的排队规则</p>

<p>Enqueue 把一个元素添加的队列</p>

<p>Dequeue 从队列中提取一个元素</p>

<p>Requeue 把一个原先已经提取的元素放回到队列，可以由于传输失败。</p>

<p>if (q->enqueue)为真的话，表明这个设备有队列，可以进行相关的流控。调用__dev_xmit_skb函数进行处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,
</span><span class='line'>&#9;&#9;&#9;&#9; struct net_device *dev,
</span><span class='line'>&#9;&#9;&#9;&#9; struct netdev_queue *txq)
</span><span class='line'>{
</span><span class='line'>&#9;spinlock_t *root_lock = qdisc_lock(q);
</span><span class='line'>&#9;bool contended = qdisc_is_running(q);
</span><span class='line'>&#9;int rc;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Heuristic to force contended enqueues to serialize on a
</span><span class='line'>&#9; * separate lock before trying to get qdisc main lock.
</span><span class='line'>&#9; * This permits __QDISC_STATE_RUNNING owner to get the lock more often
</span><span class='line'>&#9; * and dequeue packets faster.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (unlikely(contended))
</span><span class='line'>&#9;&#9;spin_lock(&q-&gt;busylock);
</span><span class='line'>
</span><span class='line'>&#9;spin_lock(root_lock);
</span><span class='line'>&#9;if (unlikely(test_bit(__QDISC_STATE_DEACTIVATED, &q-&gt;state))) {
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;rc = NET_XMIT_DROP;
</span><span class='line'>&#9;} else if ((q-&gt;flags & TCQ_F_CAN_BYPASS) && !qdisc_qlen(q) &&
</span><span class='line'>&#9;&#9; qdisc_run_begin(q)) {
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * This is a work-conserving queue; there are no old skbs
</span><span class='line'>&#9;&#9; * waiting to be sent out; and the qdisc is not running -
</span><span class='line'>&#9;&#9; * xmit the skb directly.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (!(dev-&gt;priv_flags & IFF_XMIT_DST_RELEASE))
</span><span class='line'>&#9;&#9;&#9;skb_dst_force(skb);
</span><span class='line'>&#9;&#9;__qdisc_update_bstats(q, skb-&gt;len);
</span><span class='line'>&#9;&#9;if (sch_direct_xmit(skb, q, dev, txq, root_lock)) {
</span><span class='line'>&#9;&#9;&#9;if (unlikely(contended)) {
</span><span class='line'>&#9;&#9;&#9;&#9;spin_unlock(&q-&gt;busylock);
</span><span class='line'>&#9;&#9;&#9;&#9;contended = false;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;__qdisc_run(q);
</span><span class='line'>&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;qdisc_run_end(q);
</span><span class='line'>
</span><span class='line'>&#9;&#9;rc = NET_XMIT_SUCCESS;
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;skb_dst_force(skb);
</span><span class='line'>&#9;&#9;rc = qdisc_enqueue_root(skb, q);
</span><span class='line'>&#9;&#9;if (qdisc_run_begin(q)) {
</span><span class='line'>&#9;&#9;&#9;if (unlikely(contended)) {
</span><span class='line'>&#9;&#9;&#9;&#9;spin_unlock(&q-&gt;busylock);
</span><span class='line'>&#9;&#9;&#9;&#9;contended = false;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;__qdisc_run(q);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;spin_unlock(root_lock);
</span><span class='line'>&#9;if (unlikely(contended))
</span><span class='line'>&#9;&#9;spin_unlock(&q-&gt;busylock);
</span><span class='line'>&#9;return rc;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>_dev_xmit_skb函数主要做两件事情：<br/>
 （1） 如果流控对象为空的，试图直接发送数据包。<br/>
 （2） 如果流控对象不空，将数据包加入流控对象，并运行流控对象。</p>

<p>当设备进入调度队列准备传输时，qdisc_run函数就会选出下一个要传输的帧，而该函数会间接的调用相关联的队列规则dequeue函数，从对了中取出数据进行传输。</p>

<p>有两个时机将会调用qdisc_run()：<br/>
  1.<code>__dev_xmit_skb()</code><br/>
  2.软中断服务线程NET_TX_SOFTIRQ</p>

<p>其实，真正的工作有qdisc_restart函数实现。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __qdisc_run(struct Qdisc *q)
</span><span class='line'>{
</span><span class='line'>&#9;unsigned long start_time = jiffies;
</span><span class='line'>
</span><span class='line'>&#9;while (qdisc_restart(q)) { //返回值大于0，说明流控对象非空。
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * Postpone processing if
</span><span class='line'>&#9;&#9; * 1. another process needs the CPU;
</span><span class='line'>&#9;&#9; * 2. we've been doing it for too long.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (need_resched() || jiffies != start_time) { //已经不允许继续运行本流控对象。
</span><span class='line'>&#9;&#9;&#9;__netif_schedule(q); //将本队列加入软中断的output_queue链表中。
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;qdisc_run_end(q);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果发现本队列运行的时间太长了，将会停止队列的运行，并将队列加入output_queue链表头。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int qdisc_restart(struct Qdisc *q)
</span><span class='line'>{
</span><span class='line'>&#9;struct netdev_queue *txq;
</span><span class='line'>&#9;struct net_device *dev;
</span><span class='line'>&#9;spinlock_t *root_lock;
</span><span class='line'>&#9;struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>&#9;/* Dequeue packet */
</span><span class='line'>&#9;skb = dequeue_skb(q);//一开始就调用dequeue函数。
</span><span class='line'>&#9;if (unlikely(!skb))
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;WARN_ON_ONCE(skb_dst_is_noref(skb));
</span><span class='line'>&#9;root_lock = qdisc_lock(q);
</span><span class='line'>&#9;dev = qdisc_dev(q);
</span><span class='line'>&#9;txq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));
</span><span class='line'>
</span><span class='line'>&#9;return sch_direct_xmit(skb, q, dev, txq, root_lock);//用于发送数据包
</span><span class='line'>}
</span><span class='line'>* Returns to the caller:
</span><span class='line'> *                0 - queue is empty or throttled.
</span><span class='line'> *                &gt;0 - queue is not empty.
</span><span class='line'> */
</span><span class='line'>int sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,
</span><span class='line'>&#9;&#9; struct net_device *dev, struct netdev_queue *txq,
</span><span class='line'>&#9;&#9; spinlock_t *root_lock)
</span><span class='line'>{
</span><span class='line'>&#9;int ret = NETDEV_TX_BUSY;
</span><span class='line'>
</span><span class='line'>&#9;/* And release qdisc */
</span><span class='line'>&#9;spin_unlock(root_lock);
</span><span class='line'>
</span><span class='line'>&#9;HARD_TX_LOCK(dev, txq, smp_processor_id());
</span><span class='line'>&#9;if (!netif_tx_queue_stopped(txq) && !netif_tx_queue_frozen(txq)) //设备没有被停止，且发送队列没有被冻结
</span><span class='line'>&#9;&#9;ret = dev_hard_start_xmit(skb, dev, txq); //发送数据包
</span><span class='line'>
</span><span class='line'>&#9;HARD_TX_UNLOCK(dev, txq);
</span><span class='line'>
</span><span class='line'>&#9;spin_lock(root_lock);
</span><span class='line'>
</span><span class='line'>&#9;if (dev_xmit_complete(ret)) {
</span><span class='line'>&#9;&#9;/* Driver sent out skb successfully or skb was consumed */
</span><span class='line'>&#9;&#9;//发送成功，返回新的队列的长度
</span><span class='line'>&#9;&#9;ret = qdisc_qlen(q);
</span><span class='line'>&#9;} else if (ret == NETDEV_TX_LOCKED) {
</span><span class='line'>&#9;&#9;/* Driver try lock failed */
</span><span class='line'>&#9;&#9;ret = handle_dev_cpu_collision(skb, txq, q);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;/* Driver returned NETDEV_TX_BUSY - requeue skb */
</span><span class='line'>&#9;&#9;if (unlikely (ret != NETDEV_TX_BUSY && net_ratelimit()))
</span><span class='line'>&#9;&#9;&#9;printk(KERN_WARNING "BUG %s code %d qlen %d\n",
</span><span class='line'>&#9;&#9;&#9; dev-&gt;name, ret, q-&gt;q.qlen);
</span><span class='line'>&#9;&#9; //设备繁忙，重新调度发送（利用softirq）
</span><span class='line'>&#9;&#9;ret = dev_requeue_skb(skb, q);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (ret && (netif_tx_queue_stopped(txq) ||
</span><span class='line'>&#9;&#9; netif_tx_queue_frozen(txq)))
</span><span class='line'>&#9;&#9;ret = 0;
</span><span class='line'>
</span><span class='line'>&#9;return ret;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>4. 我们看一下下面的发送函数。</h5>

<p> 从此函数可以看出，当驱动使用发送队列的时候会循环从队列中取出包发送, 而不使用队列的时候只发送一次，如果没发送成功就直接丢弃</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct netdev_queue *txq)
</span><span class='line'>{
</span><span class='line'>&#9;const struct net_device_ops *ops = dev-&gt;netdev_ops;//驱动程序的函数集
</span><span class='line'>&#9;int rc = NETDEV_TX_OK;
</span><span class='line'>
</span><span class='line'>&#9;if (likely(!skb-&gt;next)) {
</span><span class='line'>&#9;&#9;if (!list_empty(&ptype_all))
</span><span class='line'>&#9;&#9;&#9;dev_queue_xmit_nit(skb, dev);//如果dev_add_pack加入的是ETH_P_ALL，那么就会复制一份给你的回调函数。
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * If device doesnt need skb-&gt;dst, release it right now while
</span><span class='line'>&#9;&#9; * its hot in this cpu cache
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (dev-&gt;priv_flags & IFF_XMIT_DST_RELEASE)
</span><span class='line'>&#9;&#9;&#9;skb_dst_drop(skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb_orphan_try(skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (vlan_tx_tag_present(skb) &&
</span><span class='line'>&#9;&#9; !(dev-&gt;features & NETIF_F_HW_VLAN_TX)) {
</span><span class='line'>&#9;&#9;&#9;skb = __vlan_put_tag(skb, vlan_tx_tag_get(skb));
</span><span class='line'>&#9;&#9;&#9;if (unlikely(!skb))
</span><span class='line'>&#9;&#9;&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;skb-&gt;vlan_tci = 0;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (netif_needs_gso(dev, skb)) {
</span><span class='line'>&#9;&#9;&#9;if (unlikely(dev_gso_segment(skb)))
</span><span class='line'>&#9;&#9;&#9;&#9;goto out_kfree_skb;
</span><span class='line'>&#9;&#9;&#9;if (skb-&gt;next)
</span><span class='line'>&#9;&#9;&#9;&#9;goto gso;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;if (skb_needs_linearize(skb, dev) &&
</span><span class='line'>&#9;&#9;&#9; __skb_linearize(skb))
</span><span class='line'>&#9;&#9;&#9;&#9;goto out_kfree_skb;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* If packet is not checksummed and device does not
</span><span class='line'>&#9;&#9;&#9; * support checksumming for this protocol, complete
</span><span class='line'>&#9;&#9;&#9; * checksumming here.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;if (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {
</span><span class='line'>&#9;&#9;&#9;&#9;skb_set_transport_header(skb, skb-&gt;csum_start -
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; skb_headroom(skb));
</span><span class='line'>&#9;&#9;&#9;&#9;if (!dev_can_checksum(dev, skb) &&
</span><span class='line'>&#9;&#9;&#9;&#9; skb_checksum_help(skb))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto out_kfree_skb;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;rc = ops-&gt;ndo_start_xmit(skb, dev);//调用网卡的驱动程序发送数据。不同的网络设备有不同的发送函数
</span><span class='line'>&#9;&#9;trace_net_dev_xmit(skb, rc);
</span><span class='line'>&#9;&#9;if (rc == NETDEV_TX_OK)
</span><span class='line'>&#9;&#9;&#9;txq_trans_update(txq);
</span><span class='line'>&#9;&#9;return rc;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>gso:
</span><span class='line'>&#9;do {
</span><span class='line'>&#9;&#9;struct sk_buff *nskb = skb-&gt;next;
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb-&gt;next = nskb-&gt;next;
</span><span class='line'>&#9;&#9;nskb-&gt;next = NULL;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * If device doesnt need nskb-&gt;dst, release it right now while
</span><span class='line'>&#9;&#9; * its hot in this cpu cache
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (dev-&gt;priv_flags & IFF_XMIT_DST_RELEASE)
</span><span class='line'>&#9;&#9;&#9;skb_dst_drop(nskb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;rc = ops-&gt;ndo_start_xmit(nskb, dev); //调用网卡的驱动程序发送数据。不同的网络设备有不同的发送函数
</span><span class='line'>&#9;&#9;trace_net_dev_xmit(nskb, rc);
</span><span class='line'>&#9;&#9;if (unlikely(rc != NETDEV_TX_OK)) {
</span><span class='line'>&#9;&#9;&#9;if (rc & ~NETDEV_TX_MASK)
</span><span class='line'>&#9;&#9;&#9;&#9;goto out_kfree_gso_skb;
</span><span class='line'>&#9;&#9;&#9;nskb-&gt;next = skb-&gt;next;
</span><span class='line'>&#9;&#9;&#9;skb-&gt;next = nskb;
</span><span class='line'>&#9;&#9;&#9;return rc;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;txq_trans_update(txq);
</span><span class='line'>&#9;&#9;if (unlikely(netif_tx_queue_stopped(txq) && skb-&gt;next))
</span><span class='line'>&#9;&#9;&#9;return NETDEV_TX_BUSY;
</span><span class='line'>&#9;} while (skb-&gt;next);
</span><span class='line'>
</span><span class='line'>out_kfree_gso_skb:
</span><span class='line'>&#9;if (likely(skb-&gt;next == NULL))
</span><span class='line'>&#9;&#9;skb-&gt;destructor = DEV_GSO_CB(skb)-&gt;destructor;
</span><span class='line'>out_kfree_skb:
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>out:
</span><span class='line'>&#9;return rc;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>5.下面看一下dev_queue_xmit_nit函数。</h5>

<p>对于通过socket(AF_PACKET,SOCK_RAW,htons(ETH_P_ALL))创建的原始套接口，不但可以接受从外部输入的数据包，而且对于由于本地输出的数据包，如果满足条件，也可以能接受。</p>

<p>该函数就是用来接收由于本地输出的数据包，在链路层的输出过程中，会调用此函数，将满足条件的数据包输入到RAW套接口，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void dev_queue_xmit_nit(struct sk_buff *skb, struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct packet_type *ptype;
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_NET_CLS_ACT
</span><span class='line'>&#9;if (!(skb-&gt;tstamp.tv64 && (G_TC_FROM(skb-&gt;tc_verd) & AT_INGRESS)))
</span><span class='line'>&#9;&#9;net_timestamp_set(skb);-----------------（1）
</span><span class='line'>#else
</span><span class='line'>&#9;net_timestamp_set(skb);
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;list_for_each_entry_rcu(ptype, &ptype_all, list) {-----------------（2）
</span><span class='line'>&#9;&#9;/* Never send packets back to the socket
</span><span class='line'>&#9;&#9; * they originated from - MvS (miquels@drinkel.ow.org)
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if ((ptype-&gt;dev == dev || !ptype-&gt;dev) &&
</span><span class='line'>&#9;&#9; (ptype-&gt;af_packet_priv == NULL ||
</span><span class='line'>&#9;&#9; (struct sock *)ptype-&gt;af_packet_priv != skb-&gt;sk)) {-----------------（3）
</span><span class='line'>&#9;&#9;&#9;struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC); -----------------（4）
</span><span class='line'>&#9;&#9;&#9;if (!skb2)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* skb-&gt;nh should be correctly
</span><span class='line'>&#9;&#9;&#9; set by sender, so that the second statement is
</span><span class='line'>&#9;&#9;&#9; just protection against buggy protocols.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;skb_reset_mac_header(skb2);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (skb_network_header(skb2) &lt; skb2-&gt;data ||
</span><span class='line'>&#9;&#9;&#9; skb2-&gt;network_header &gt; skb2-&gt;tail) {
</span><span class='line'>&#9;&#9;&#9;&#9;if (net_ratelimit())
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;printk(KERN_CRIT "protocol %04x is "
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; "buggy, dev %s\n",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; ntohs(skb2-&gt;protocol),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; dev-&gt;name);
</span><span class='line'>&#9;&#9;&#9;&#9;skb_reset_network_header(skb2); -----------------（5）
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;skb2-&gt;transport_header = skb2-&gt;network_header;
</span><span class='line'>&#9;&#9;&#9;skb2-&gt;pkt_type = PACKET_OUTGOING;
</span><span class='line'>&#9;&#9;&#9;ptype-&gt;func(skb2, skb-&gt;dev, ptype, skb-&gt;dev); -----------------（6）
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>说明：<br/>
（1） 记录该数据包输入的时间戳<br/>
（2） 遍历ptype_all链表，查找所有符合输入条件的原始套接口，并循环将数据包输入到满足条件的套接口<br/>
（3） 数据包的输出设备与套接口的输入设备相符或者套接口不指定输入设备，并且该数据包不是有当前用于比较的套接口输出，此时该套接口满足条件，数据包可以输入<br/>
（4） 由于该数据包是额外输入到这个原始套接口的，因此需要克隆一个数据包<br/>
（5） 校验数据包是否有效<br/>
（6） 将数据包输入原始套接口</p>

<h5>6. 对于lookback设备来说处理有些不同。它的hard_start_xmit函数是loopback_xmit</h5>

<p>在net/lookback.c文件中，定义的struct net_device_ops loopback_ops结构体</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const struct net_device_ops loopback_ops = {
</span><span class='line'>&#9;.ndo_init = loopback_dev_init,
</span><span class='line'>&#9;.ndo_start_xmit= loopback_xmit,
</span><span class='line'>&#9;.ndo_get_stats64 = loopback_get_stats64,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>从这里可以看到起发送函数为loopback_xmit函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static netdev_tx_t loopback_xmit(struct sk_buff *skb,
</span><span class='line'>&#9;&#9;&#9;&#9; struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct pcpu_lstats *lb_stats;
</span><span class='line'>&#9;int len;
</span><span class='line'>
</span><span class='line'>&#9;skb_orphan(skb);
</span><span class='line'>
</span><span class='line'>&#9;skb-&gt;protocol = eth_type_trans(skb, dev);
</span><span class='line'>
</span><span class='line'>&#9;/* it's OK to use per_cpu_ptr() because BHs are off */
</span><span class='line'>&#9;lb_stats = this_cpu_ptr(dev-&gt;lstats);
</span><span class='line'>
</span><span class='line'>&#9;len = skb-&gt;len;
</span><span class='line'>&#9;if (likely(netif_rx(skb) == NET_RX_SUCCESS)) {//直接调用了netif_rx进行了接收处理
</span><span class='line'>&#9;&#9;u64_stats_update_begin(&lb_stats-&gt;syncp);
</span><span class='line'>&#9;&#9;lb_stats-&gt;bytes += len;
</span><span class='line'>&#9;&#9;lb_stats-&gt;packets++;
</span><span class='line'>&#9;&#9;u64_stats_update_end(&lb_stats-&gt;syncp);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;return NETDEV_TX_OK;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>7. 已经有了dev_queue_xmit函数，为什么还需要软中断来发送呢？</h5>

<p>dev_queue_xmit是对skb做些最后的处理并且第一次尝试发送,软中断是将前者发送失败或者没发完的包发送出去。</p>

<p>主要参考文献：</p>

<p>Linux发送函数dev_queue_xmit分析  <a href="http://shaojiashuai123456.iteye.com/blog/842236">http://shaojiashuai123456.iteye.com/blog/842236</a></p>

<p>TC流量控制实现分析（初步）  <a href="http://blog.csdn.net/wwwlkk/article/details/5929308">http://blog.csdn.net/wwwlkk/article/details/5929308</a></p>

<p>Linux内核源码剖析 TCP/IP实现</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/25/kernel-net-rtable/">路由表 rtable</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-25T17:46:00+08:00'><span class='date'>2015-08-25</span> <span class='time'>17:46:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/qy532846454/article/details/6423496">http://blog.csdn.net/qy532846454/article/details/6423496</a></p>

<p><a href="http://blog.csdn.net/qy532846454/article/details/6726171">http://blog.csdn.net/qy532846454/article/details/6726171</a></p>

<p><a href="http://blog.csdn.net/qy532846454/article/details/7568994">http://blog.csdn.net/qy532846454/article/details/7568994</a></p>

<hr />

<h4>路由表</h4>

<p>在内核中存在路由表fib_table_hash和路由缓存表rt_hash_table。路由缓存表主要是为了加速路由的查找，每次路由查询都会先查找路由缓存，再查找路由表。这和cache是一个道理，缓存存储最近使用过的路由项，容量小，查找快速；路由表存储所有路由项，容量大，查找慢。</p>

<p>首先，应该先了解路由表的意义，下面是route命令查看到的路由表：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Destination    Netmask        Gateway         Flags  Interface  Metric
</span><span class='line'>169.254.0.0    255.255.0.0      *               U      eth0       1
</span><span class='line'>192.168.123.0  255.255.255.0    *               U      eth0       1
</span><span class='line'>default        0.0.0.0       192.168.123.254    UG     eth0       1</span></code></pre></td></tr></table></div></figure>


<p>一条路由其实就是告知主机要到达一个目的地址，下一跳应该走哪里。比如发往192.168.22.3报文通过查路由表，会得到下一跳为192.168.123.254，再将其发送出去。在路由表项中，还有一个很重要的属性-scope，它代表了到目的网络的距离。</p>

<p>路由scope可取值：RT_SCOPE_UNIVERSE, RT_SCOPE_LINK, RT_SCOPE_HOST</p>

<p>在报文的转发过程中，显然是每次转发都要使到达目的网络的距离要越来越小或不变，否则根本到达不了目的网络。上面提到的scope很好的实现这个功能，在查找路由表中，表项的scope一定是更小或相等的scope(比如RT_SCOPE_LINK，则表项scope只能为RT_SCOPE_LINK或RT_SCOPE_HOST)。</p>

<h4>路由缓存</h4>

<p>路由缓存用于加速路由的查找，当收到报文或发送报文时，首先会查询路由缓存，在内核中被组织成hash表，就是rt_hash_table。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct rt_hash_bucket          *rt_hash_table __read_mostly;      [net/ipv4/route.c]</span></code></pre></td></tr></table></div></figure>


<p>通过ip_route_input()进行查询，首先是缓存操作时，通过[src_ip, dst_ip, iif,rt_genid]计算出hash值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(daddr, saddr, iif, rt_genid(net));</span></code></pre></td></tr></table></div></figure>


<p>此时rt_hash_table[hash].chain就是要操作的缓存表项的链表，比如遍历该链表</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (rth = rt_hash_table[hash].chain; rth; rth = rth-&gt;u.dst.rt_next)</span></code></pre></td></tr></table></div></figure>


<p>因此，在缓存中查找一个表项，首先计算出hash值，取出这组表项，然后遍历链表，找出指定的表项，这里需要完全匹配[src_ip, dst_ip, iif, tos, mark, net]，实际上struct rtable中有专门的属性用于缓存的查找键值 – struct flowi。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Cache lookup keys */
</span><span class='line'>struct flowi                fl;</span></code></pre></td></tr></table></div></figure>


<p>当找到表项后会更新表项的最后访问时间，并取出dst</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dst_use(&rth-&gt;u.dst, jiffies);
</span><span class='line'>skb_dst_set(skb, &rth-&gt;u.dst);</span></code></pre></td></tr></table></div></figure>


<p>路由缓存的创建</p>

<p>inet_init() -> ip_init() -> ip_rt_init()</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rt_hash_table = (struct rt_hash_bucket *)
</span><span class='line'>&#9;alloc_large_system_hash("IP route cache",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;sizeof(struct rt_hash_bucket),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;rhash_entries,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;(totalram_pages &gt;= 128 * 1024) ?
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;15 : 17,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;0,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&rt_hash_log,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&rt_hash_mask,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;rhash_entries ? 0 : 512 * 1024);</span></code></pre></td></tr></table></div></figure>


<p>其中rt_hash_mask表示表的大小，rt_hash_log = log(rt_hash_mask)，创建后的结构如图所示：</p>

<p><img src="/images/kernel/2015-08-25-1.png" alt="" /></p>

<h4>路由缓存插入条目</h4>

<p>函数rt_intern_hash()</p>

<p>要插入的条目是rt，相应散列值是hash，首先通过hash值找到对应的bucket</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rthp = &rt_hash_table[hash].chain;</span></code></pre></td></tr></table></div></figure>


<p>然后对bucket进行一遍查询，这次查询的目的有两个：如果是超时的条目，则直接删除；如果是与rt相同键值的条目，则删除并将rt插入头部返回。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while ((rth = *rthp) != NULL) {
</span><span class='line'>&#9;if (rt_is_expired(rth)) {     // 超时的条目
</span><span class='line'>&#9;&#9;*rthp = rth-&gt;u.dst.rt_next;
</span><span class='line'>&#9;&#9;rt_free(rth);
</span><span class='line'>&#9;&#9;continue;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (compare_keys(&rth-&gt;fl, &rt-&gt;fl) && compare_netns(rth, rt)) { //重复的条目
</span><span class='line'>&#9;&#9;*rthp = rth-&gt;u.dst.rt_next;
</span><span class='line'>&#9;&#9;rcu_assign_pointer(rth-&gt;u.dst.rt_next, rt_hash_table[hash].chain);
</span><span class='line'>&#9;&#9;rcu_assign_pointer(rt_hash_table[hash].chain, rth);
</span><span class='line'>&#9;&#9;……
</span><span class='line'>&#9;}
</span><span class='line'>&#9;……
</span><span class='line'>&#9;rthp = &rth-&gt;u.dst.rt_next;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在扫描一遍后，如rt还未存在，则将其插入头部</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rt-&gt;u.dst.rt_next = rt_hash_table[hash].chain;
</span><span class='line'>rcu_assign_pointer(rt_hash_table[hash].chain, rt);</span></code></pre></td></tr></table></div></figure>


<p>如果新插入rt满足一定条件，还要与ARP邻居表进行绑定</p>

<p>Hint：缓存的每个bucket是没有头结点的，单向链表，它所使用的插入和删除操作是值得学习的，简单实用。</p>

<h4>路由缓存删除条目</h4>

<p>rt_del()</p>

<p>要删除的条目是rt，相应散列值是hash，首先通过hash值找到对应的bucket，然后遍历，如果条目超时，或找到rt，则删除它。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rthp = &rt_hash_table[hash].chain;
</span><span class='line'>spin_lock_bh(rt_hash_lock_addr(hash));
</span><span class='line'>ip_rt_put(rt);
</span><span class='line'>while ((aux = *rthp) != NULL) {
</span><span class='line'>&#9;if (aux == rt || rt_is_expired(aux)) {
</span><span class='line'>&#9;&#9;*rthp = aux-&gt;u.dst.rt_next;
</span><span class='line'>&#9;&#9;rt_free(aux);
</span><span class='line'>&#9;&#9;continue;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;rthp = &aux-&gt;u.dst.rt_next;
</span><span class='line'>}
</span><span class='line'>spin_unlock_bh(rt_hash_lock_addr(hash));</span></code></pre></td></tr></table></div></figure>


<h4>路由表的创建</h4>

<p>inet_init() -> ip_init() -> ip_fib_init() -> fib_net_init() -> ip_fib_net_init()[net/ipv4/fib_frontend.c]</p>

<p>首先为路由表分配空间，这里的每个表项hlist_head实际都会链接一个单独的路由表，FIB_TABLE_HASHSZ表示了分配多少个路由表，一般情况下至少有两个 –　LOCAL和MAIN。注意这里仅仅是表头的空间分配，还没有真正分配路由表空间。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>net-&gt;ipv4.fib_table_hash = kzalloc(
</span><span class='line'>&#9;&#9;sizeof(struct hlist_head)*FIB_TABLE_HASHSZ, GFP_KERNEL);</span></code></pre></td></tr></table></div></figure>


<p>ip_fib_net_init() -> fib4_rules_init()，这里真正分配了路由表空间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>local_table = fib_hash_table(RT_TABLE_LOCAL);
</span><span class='line'>main_table  = fib_hash_table(RT_TABLE_MAIN);</span></code></pre></td></tr></table></div></figure>


<p>然后将local和main表链入之前的fib_table_hash中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hlist_add_head_rcu(&local_table-&gt;tb_hlist,
</span><span class='line'>&#9;&#9;&net-&gt;ipv4.fib_table_hash[TABLE_LOCAL_INDEX]);
</span><span class='line'>
</span><span class='line'>hlist_add_head_rcu(&main_table-&gt;tb_hlist,
</span><span class='line'>&#9;&#9;&net-&gt;ipv4.fib_table_hash[TABLE_MAIN_INDEX]);</span></code></pre></td></tr></table></div></figure>


<p>最终生成结构如图，LOCAL表位于fib_table_hash[0]，MAIN表位于fib_table_hash[1]；两张表通过结构tb_hlist链入链表，而tb_id则标识了功能，255是LOCAL表，254是MAIN表。</p>

<p>关于这里的struct fn_hash，它表示了不同子网掩码长度的hash表[即fn_zone]，对于ipv4，从0~32共33个。而fn_hash的实现则是fib_table的最后一个参数unsigned char tb_data[0]。</p>

<p><img src="/images/kernel/2015-08-25-2.png" alt="" /></p>

<p>注意到这里fn_zone还只是空指针，我们还只完成了路由表初始化的一部分。在启动阶段还会调用inet_rtm_newroute() -> fib_table_insert() -> fn_new_zone() [fib_hash.c]来创建fn_zone结构，前面已经讲过，fn_zone一共有33个，其中掩码长度为0[/0]表示为默认路由，fn_zone可以理解为相同掩码的地址集合。</p>

<p>首先为fn_zone分配空间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct fn_zone *fz = kzalloc(sizeof(struct fn_zone), GFP_KERNEL);</span></code></pre></td></tr></table></div></figure>


<p>传入参数z代表掩码长度， z = 0的掩码用于默认路由，一般只有一个，所以fz_divisor只需设为1；其它设为16；这里要提到fz_divisor的作用，fz->fz_hash并不是个单链表，而是一个哈希表，而哈希表的大小就是fz_divisor。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (z) {
</span><span class='line'>&#9;fz-&gt;fz_divisor = 16;
</span><span class='line'>} else {
</span><span class='line'>&#9;fz-&gt;fz_divisor = 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>fz_hashmask实际是用于求余数的，当算出hash值，再hash &amp; fz_hashmask就得出了在哈希表的位置；而fz_hash就是下一层的哈希表了，前面已经提过路由表被多组分层了，这里fz_hash就是根据fz_divisor大小来创建的；fz_order就是子网掩码长度；fz_mask就是子网掩码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fz-&gt;fz_hashmask = (fz-&gt;fz_divisor - 1);
</span><span class='line'>fz-&gt;fz_hash = fz_hash_alloc(fz-&gt;fz_divisor);
</span><span class='line'>fz-&gt;fz_order = z;
</span><span class='line'>fz-&gt;fz_mask = inet_make_mask(z);</span></code></pre></td></tr></table></div></figure>


<p>从子网长度大于新添加fz的fn_zone中挑选一个不为空的fn_zones[i]，将新创建的fz设成fn_zones[i].next；然后将fz根据掩码长度添加到fn_zones[]中相应位置；fn_zone_list始终指向掩码长度最长的fn_zone。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (i=z+1; i&lt;=32; i++)
</span><span class='line'>&#9;if (table-&gt;fn_zones[i])
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>if (i&gt;32) {
</span><span class='line'>&#9;fz-&gt;fz_next = table-&gt;fn_zone_list;
</span><span class='line'>&#9;table-&gt;fn_zone_list = fz;
</span><span class='line'>} else {
</span><span class='line'>&#9;fz-&gt;fz_next = table-&gt;fn_zones[i]-&gt;fz_next;
</span><span class='line'>&#9;table-&gt;fn_zones[i]-&gt;fz_next = fz;
</span><span class='line'>}
</span><span class='line'>table-&gt;fn_zones[z] = fz;</span></code></pre></td></tr></table></div></figure>


<p>这里的fn_hash是数组与链表的结合体，看下fn_hash定义</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct fn_hash {
</span><span class='line'>&#9;struct fn_zone *fn_zones[33];
</span><span class='line'>&#9;struct fn_zone *fn_zone_list;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>fn_hash包含33数组元素，每个元素存放一定掩码长度的fn_zone，其中fn_zone[i]存储掩码长度为i。而fn_zone通过内部属性fz_next又彼此串连起来，形成单向链表，其中fn_zone_list可以看作链表头，而这里链表的组织顺序是倒序的，即从掩码长到短。</p>

<p><img src="/images/kernel/2015-08-25-3.png" alt="" /></p>

<p>到这里，fz_hash所分配的哈希表还没有插入内容，这部分为fib_insert_node()完成。</p>

<p>inet_rtm_newroute() -> fib_table_insert() -> fib_insert_node() [net/ipv4/fib_hash.c]</p>

<p>这里f是fib_node，可以理解为具有相同网络地址的路由项集合。根据fn_key(网络地址)和fz(掩码长度)来计算hash值，决定将f插入fz_hash的哪个项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct hlist_head *head = &fz-&gt;fz_hash[fn_hash(f-&gt;fn_key, fz)];
</span><span class='line'>hlist_add_head(&f-&gt;fn_hash, head);</span></code></pre></td></tr></table></div></figure>


<p>如何fib_node还不存在，则会创建它，这里的kmem_cache_zalloc()其实就是内存分配</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>new_f = kmem_cache_zalloc(fn_hash_kmem, GFP_KERNEL);
</span><span class='line'>if (new_f == NULL)
</span><span class='line'>&#9;goto out;
</span><span class='line'>INIT_HLIST_NODE(&new_f-&gt;fn_hash);
</span><span class='line'>INIT_LIST_HEAD(&new_f-&gt;fn_alias);
</span><span class='line'>new_f-&gt;fn_key = key;
</span><span class='line'>f = new_f;</span></code></pre></td></tr></table></div></figure>


<p>路由表最后一层是fib_info，具体的路由信息都存储在此，它由fib_create_info()创建。</p>

<p>首先为fib_info分配空间，由于fib_info的最后一个属性是struct fib_nh fib_nh[0]，因此大小是fib_info + nhs * fib_nh，这里的fib_nh代表了下一跳(next hop)的信息，nhs代表了下一跳的数目，一般情况下nhs=1，除非配置了支持多路径。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fi = kzalloc(sizeof(*fi)+nhs*sizeof(struct fib_nh), GFP_KERNEL);</span></code></pre></td></tr></table></div></figure>


<p>设置fi的相关属性</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fi-&gt;fib_net = hold_net(net);
</span><span class='line'>fi-&gt;fib_protocol = cfg-&gt;fc_protocol;
</span><span class='line'>fi-&gt;fib_flags = cfg-&gt;fc_flags;
</span><span class='line'>fi-&gt;fib_priority = cfg-&gt;fc_priority;
</span><span class='line'>fi-&gt;fib_prefsrc = cfg-&gt;fc_prefsrc;
</span><span class='line'>fi-&gt;fib_nhs = nhs;</span></code></pre></td></tr></table></div></figure>


<p>使fi后面所有的nh->nh_parent指向fi，设置后如图所示</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>change_nexthops(fi) {
</span><span class='line'>&#9;nexthop_nh-&gt;nh_parent = fi;
</span><span class='line'>} endfor_nexthops(fi)</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/kernel/2015-08-25-4.png" alt="" /></p>

<p>设置fib_nh的属性，这里仅展示了单一路径的情况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct fib_nh *nh = fi-&gt;fib_nh;
</span><span class='line'>nh-&gt;nh_oif = cfg-&gt;fc_oif;
</span><span class='line'>nh-&gt;nh_gw = cfg-&gt;fc_gw;
</span><span class='line'>nh-&gt;nh_flags = cfg-&gt;fc_flags;</span></code></pre></td></tr></table></div></figure>


<p>然后，再根据cfg->fc_scope值来设置nh的其余属性。如果scope是RT_SCOPE_HOST，则设置下一跳scope为RT_SCOPE_NOWHERE</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (cfg-&gt;fc_scope == RT_SCOPE_HOST) {
</span><span class='line'>&#9;struct fib_nh *nh = fi-&gt;fib_nh;
</span><span class='line'>&#9;nh-&gt;nh_scope = RT_SCOPE_NOWHERE;
</span><span class='line'>&#9;nh-&gt;nh_dev = dev_get_by_index(net, fi-&gt;fib_nh-&gt;nh_oif);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果scope是RT_SCOPE_LINK或RT_SCOPE_UNIVERSE，则设置下跳</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>change_nexthops(fi) {
</span><span class='line'>&#9;if ((err = fib_check_nh(cfg, fi, nexthop_nh)) != 0)
</span><span class='line'>&#9;&#9;goto failure;
</span><span class='line'>} endfor_nexthops(fi)</span></code></pre></td></tr></table></div></figure>


<p>最后，将fi链入链表中，这里要注意的是所有的fib_info(只要创建了的)都会加入fib_info_hash中，如果路由项使用了优先地址属性，还会加入fib_info_laddrhash中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hlist_add_head(&fi-&gt;fib_hash,
</span><span class='line'>&#9;&#9;&fib_info_hash[fib_info_hashfn(fi)]);
</span><span class='line'>
</span><span class='line'>if (fi-&gt;fib_prefsrc) {
</span><span class='line'>&#9;struct hlist_head *head;
</span><span class='line'>&#9;head = &fib_info_laddrhash[fib_laddr_hashfn(fi-&gt;fib_prefsrc)];
</span><span class='line'>&#9;hlist_add_head(&fi-&gt;fib_lhash, head);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>无论fib_info在路由表中位于哪个掩码、哪个网段结构下，都与fib_info_hash和fib_info_laddrhash无关，这两个哈希表与路由表独立，主要是用于加速路由信息fib_info的查找。哈希表的大小为fib_hash_size，当超过这个限制时，fib_hash_size * 2(如果哈希函数够好，每个bucket都有一个fib_info)。fib_info在哈希表的图示如下：</p>

<p><img src="/images/kernel/2015-08-25-5.png" alt="" /></p>

<p>由于路由表信息也可能要以设备dev为键值搜索，因此还存在fib_info_devhash哈希表，用于存储nh的设置dev->ifindex。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>change_nexthops(fi) {
</span><span class='line'>&#9;hash = fib_devindex_hashfn(nexthop_nh-&gt;nh_dev-&gt;ifindex);
</span><span class='line'>&#9;head = &fib_info_devhash[hash];
</span><span class='line'>&#9;hlist_add_head(&nexthop_nh-&gt;nh_hash, head);
</span><span class='line'>} endfor_nexthops(fi)</span></code></pre></td></tr></table></div></figure>


<p>上面讲过了路由表各个部分的创建，现在来看下它们是如何一起工作的，在fib_table_insert()[net/ipv4/fib_hash.c]完成整个的路由表创建过程。下面来看下fib_table_insert()函数：</p>

<p>从fn_zones中取出掩码长度为fc_dst_len的项，如果该项不存在，则创建它[fn_zone的创建前面已经讲过]。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fz = table-&gt;fn_zones[cfg-&gt;fc_dst_len];
</span><span class='line'>if (!fz && !(fz = fn_new_zone(table, cfg-&gt;fc_dst_len)))
</span><span class='line'>&#9;return -ENOBUFS;</span></code></pre></td></tr></table></div></figure>


<p>然后创建fib_info结构，[前面已经讲过]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fi = fib_create_info(cfg);</span></code></pre></td></tr></table></div></figure>


<p>然后在掩码长度相同项里查找指定网络地址key(如145.222.33.0/24)，查找的结果如图所示</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>f = fib_find_node(fz, key);</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/kernel/2015-08-25-6.png" alt="" /></p>

<p>如果不存在该网络地址项，则创建相应的fib_node，并加入到链表fz_hash中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!f) {
</span><span class='line'>&#9;new_f = kmem_cache_zalloc(fn_hash_kmem, GFP_KERNEL);
</span><span class='line'>&#9;if (new_f == NULL)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'> 
</span><span class='line'>&#9;INIT_HLIST_NODE(&new_f-&gt;fn_hash);
</span><span class='line'>&#9;INIT_LIST_HEAD(&new_f-&gt;fn_alias);
</span><span class='line'>&#9;new_f-&gt;fn_key = key;
</span><span class='line'>&#9;f = new_f;
</span><span class='line'>}
</span><span class='line'>……
</span><span class='line'>fib_insert_node(fz, new_f);</span></code></pre></td></tr></table></div></figure>


<p>如果存在该网络地址项，则在fib_node的属性fn_alias中以tos和fi->fib_priority作为键值查找。一个fib_node可以有多个fib_alias相对应，这些fib_alias以链表形式存在，并按tos并从大到小的顺序排列。因此，fib_find_alias查找到的是第一个fib_alias->tos不大于tos的fib_alias项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fa = fib_find_alias(&f-&gt;fn_alias, tos, fi-&gt;fib_priority);</span></code></pre></td></tr></table></div></figure>


<p>如果查找到的fa与与要插入的路由项完全相同，则按照设置的标置位进行操作，NLM_F_REPLACE则替换掉旧的，NLM_F_APPEND添加在后面。</p>

<p>设置要插入的fib_alias的属性，包括最重要的fib_alias->fa_info设置为fi</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>new_fa-&gt;fa_info = fi;
</span><span class='line'>new_fa-&gt;fa_tos = tos;
</span><span class='line'>new_fa-&gt;fa_type = cfg-&gt;fc_type;
</span><span class='line'>new_fa-&gt;fa_scope = cfg-&gt;fc_scope;
</span><span class='line'>new_fa-&gt;fa_state = 0;</span></code></pre></td></tr></table></div></figure>


<p>如果没有要插入路由的网络地址项fib_node，则之前已经创建了新的，现在将它插入到路由表中fib_insert_node()；然后将new_fa链入到fib_node->fn_alias中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (new_f)
</span><span class='line'>&#9;fib_insert_node(fz, new_f);
</span><span class='line'>
</span><span class='line'>list_add_tail(&new_fa-&gt;fa_list,
</span><span class='line'>&#9;&#9;&#9;(fa ? &fa-&gt;fa_list : &f-&gt;fn_alias));</span></code></pre></td></tr></table></div></figure>


<p>最后，由于新插入的路由表项，会发出通告，告知所以加入RTNLGRP_IPV4_ROUTE组的成员，这个功能可以在linux中使用”ip route monitor”来测试。最终的路由表如图所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rtmsg_fib(RTM_NEWROUTE, key, new_fa, cfg-&gt;fc_dst_len, tb-&gt;tb_id, &cfg-&gt;fc_nlinfo, 0);</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/kernel/2015-08-25-7.png" alt="" /></p>

<p>至此，就完成了路由表项的插入，加上之前的路由表的初始化，整个路由表的创建过程就讲解完了，小小总结一下：</p>

<p>路由表的查找效率是第一位的，因此内核在实现时使用了多级索引来进行加速</p>

<p>第一级：fn_zone　按不同掩码长度分类(如/5和/24)</p>

<p>第二级：fib_node  按不同网络地址分类(如124.44.33.0/24)</p>

<p>第三级：fib_info     下一跳路由信息</p>

<hr />

<p>路由可以分为两部分：路由缓存(rt_hash_table)和路由表()</p>

<p>路由缓存顾名思义就是加速路由查找的，路由缓存的插入是由内核控制的，而非人为的插入，与之相对比的是路由表是人为插入的，而非内核插入的。在内核中，路由缓存组织成rt_hash_table的结构。</p>

<p>下面是一段IP层协议的代码段[net/ipv4/route.c]，传入IP层的协议在查找路由时先在路由缓存中查找，如果已存在，则skb_dst_set(skb, &amp;rth->u.dst)并返回；否则在路由表中查询。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(daddr, saddr, iif, rt_genid(net));  
</span><span class='line'>  
</span><span class='line'>rcu_read_lock();  
</span><span class='line'>for (rth = rcu_dereference(rt_hash_table[hash].chain); rth;  
</span><span class='line'>&#9; rth = rcu_dereference(rth-&gt;u.dst.rt_next)) {  
</span><span class='line'>&#9;if (((rth-&gt;fl.fl4_dst ^ daddr) |  
</span><span class='line'>&#9;&#9; (rth-&gt;fl.fl4_src ^ saddr) |  
</span><span class='line'>&#9;&#9; (rth-&gt;fl.iif ^ iif) |  
</span><span class='line'>&#9;&#9; rth-&gt;fl.oif |  
</span><span class='line'>&#9;&#9; (rth-&gt;fl.fl4_tos ^ tos)) == 0 &&  
</span><span class='line'>&#9;&#9;rth-&gt;fl.mark == skb-&gt;mark &&  
</span><span class='line'>&#9;&#9;net_eq(dev_net(rth-&gt;u.dst.dev), net) &&  
</span><span class='line'>&#9;&#9;!rt_is_expired(rth)) {  
</span><span class='line'>&#9;&#9;dst_use(&rth-&gt;u.dst, jiffies);  
</span><span class='line'>&#9;&#9;RT_CACHE_STAT_INC(in_hit);  
</span><span class='line'>&#9;&#9;rcu_read_unlock();  
</span><span class='line'>&#9;&#9;skb_dst_set(skb, &rth-&gt;u.dst);  
</span><span class='line'>&#9;&#9;return 0;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;RT_CACHE_STAT_INC(in_hlist_search);  
</span><span class='line'>}  
</span><span class='line'>rcu_read_unlock();  </span></code></pre></td></tr></table></div></figure>


<p>在ip_route_input()中查询完陆由缓存后会处理组播地址，如果是组播地址，则下面判断会成功：ipv4_is_multicast(daddr)。</p>

<p>然后执行ip_route_input_mc()，它的主要作用就是生成路由缓存项rth，并插入缓存。rth的生成与初始化只给出了input函数的，其它略去了，可以看出组播报文会通过ip_local_deliver()继续向上传递。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rth-&gt;u.dst.input= ip_local_deliver;  
</span><span class='line'>hash = rt_hash(daddr, saddr, dev-&gt;ifindex, rt_genid(dev_net(dev)));  
</span><span class='line'>return rt_intern_hash(hash, rth, NULL, skb, dev-&gt;ifindex);  </span></code></pre></td></tr></table></div></figure>


<p>路由表又可以分为两个：RT_TABLE_LOCAL和RT_TABLE_MAIN<br/>
  RT_TABLE_LOCAL存储目的地址是本机的路由表项，这些目的地址就是为各个网卡配置的IP地址；<br/>
  RT_TABLE_MAIN存储到其它主机的路由表项；</p>

<p>显然，RT_TABLE_MAIN路由表只有当主机作为路由器时才有作用，一般主机该表是空的，因为主机不具有转发数据包的功能。RT_TABLE_LOCAL对主机就足够了，为各个网卡配置的IP地址都会加入RT_TABLE_LOCAL中，如为eth1配置了1.2.3.4的地址，则RT_TABLE_LOCAL中会存在1.2.3.4的路由项。只有本地的网卡地址会被加入，比如lo、eth1。IP模块在初始化时ip_init() -> ip_rt_init() - > ip_fib_init()会注册notifier机制，当为网卡地址配置时会执行fib_netdev_notifier和fib_inetaddr_notifier，使更改反映到RT_TABLE_LOCAL中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>register_netdevice_notifier(&fib_netdev_notifier);  
</span><span class='line'>register_inetaddr_notifier(&fib_inetaddr_notifier);  </span></code></pre></td></tr></table></div></figure>


<p>而当在路由缓存中没有查找到缓存项时，会进行路由表查询，还是以IP层协议中的代码段为例[net/ipv4/route.c]，fib_lookup()会在MAIN和LOCAL两张表中进行查找。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ((err = fib_lookup(net, &fl, &res)) != 0) {  
</span><span class='line'>&#9;if (!IN_DEV_FORWARD(in_dev))  
</span><span class='line'>&#9;&#9;goto e_hostunreach;  
</span><span class='line'>&#9;goto no_route;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>如果主机配置成了支持转发，则无论在路由表中找到与否，都会生成这次查询的一个缓存，包括源IP、目的IP、接收的网卡，插入路由缓存中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(daddr, saddr, fl.iif, rt_genid(net));  
</span><span class='line'>err = rt_intern_hash(hash, rth, NULL, skb, fl.iif);  </span></code></pre></td></tr></table></div></figure>


<p>不同的是，如果在路由表中查询失败，即数据包不是发往本机，也不能被本机转发，则会设置插入路由缓存的缓存项u.dst.input=ip_error，而u.dst.input即为IP层处理完后向上传递的函数，而ip_error()会丢弃数据包，被发送相应的ICMP错误报文。不在路由表中的路由项也要插入路由缓存，这可以看作路由学习功能，下次就可以直接在路由缓存中找到。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rth-&gt;u.dst.input= ip_error;  
</span><span class='line'>rth-&gt;u.dst.error= -err;  
</span><span class='line'>rth-&gt;rt_flags    &= ~RTCF_LOCAL;  </span></code></pre></td></tr></table></div></figure>


<p>但如果主机不支持转发，即没有路由功能，则只有在找到时才会添加路由缓存项，都不会生成路由缓存项。这是因为在LOCAL表中没有找到，表明数据包不是发往本机的，此时缓存这样的路由项对于主机的数据包传输没有一点意义。它只需要知道哪些数据包是发给它的，其余的一律不管！</p>

<p>路由查询整合起来，就是由ip_route_input()引入，然后依次进行路由缓存和路由表查询，并对路由缓存进行更新。路由缓存在每个数据包到来时都可能发生更新，但路由表则不一样，只能通过RTM机制更新，LOCAL表是在网卡配置时更新的，MAIN表则是由人工插入的(inet_rtm_newroute)。</p>

<p>ip_route_input()<br/>
  - 路由缓存查询<br/>
  - 路由表查询：ip_route_input_slow() -> fib_lookup()</p>

<hr />

<p>这次将以更实际的例子来分析过程中路由表的使用情况，注意下文都是对路由缓存表的描述，因为路由表在配置完网卡地址后就不会再改变了(除非人为的去改动)，测试环境如下图：</p>

<p><img src="/images/kernel/2015-08-25-11.jpg" alt="" /></p>

<p>两台主机Host1与Host2，分别配置了IP地址192.168.1.1与192.168.1.2，两台主机间用网线直连。在两台主机上分别执行如下操作：<br/>
  1. 在Host1上ping主机Host2<br/>
  2. 在Host2上ping主机Host1</p>

<p>很简单常的两台主机互ping的例子，下面来分析这过程中路由表的变化，准备说是路由缓存的变化。首先，路由缓存会存在几个条目？答案不是2条而是3条，这点很关键，具体可以通过/proc/net/rt_cache来查看路由缓存表，下图是执行上述操作后得到的结果：</p>

<p><img src="/images/kernel/2015-08-25-12.jpg" alt="" /></p>

<p> brcm0.1是Host主机上的网卡设备，等同于常用的eth0，lo是环路设备。对结果稍加分析，可以发现，条目1和条目2是完全一样的，除了计数的Use稍有差别，存在这种情况的原因是缓存表是以Hash表的形式存储的，尽管两者内容相同，在实际插入时使用的键值是不同的，下面以Host2主机的路由缓存表为视角，针对互ping的过程进行逐一分析。</p>

<p>假设brcm0.1设备的index = 2</p>

<p>步骤0：初始时陆由缓存为空</p>

<p>步骤1：主机Host1 ping 主机Host2</p>

<p>Host2收到来自Host1的echo报文(dst = 192.168.1.2, src = 192.168.1.1)<br/>
在报文进入IP层后会查询路由表，以确定报文的接收方式，相应调用流程：<br/>
ip_route_input() -> ip_route_input_slow()<br/>
在ip_route_input()中查询路由缓存，使用的键值是[192.168.1.2, 192.168.1.1, 2, id]，由于缓存表为空，查询失败，继续走ip_route_input_slow()来创建并插入新的缓存项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(daddr, saddr, iif, rt_genid(net));  </span></code></pre></td></tr></table></div></figure>


<p>在ip_route_input_slow()中查询路由表，因为发往本机，在会LOCAL表中匹配192.168.1.2条目，查询结果res.type==RTN_LOCAL。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ((err = fib_lookup(net, &fl, &res)) != 0) {  
</span><span class='line'> if (!IN_DEV_FORWARD(in_dev))  
</span><span class='line'>  goto e_hostunreach;  
</span><span class='line'> goto no_route;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>然后根据res.type跳转到local_input代码段，创建新的路由缓存项，并插入陆由缓存。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rth = dst_alloc(&ipv4_dst_ops);  
</span><span class='line'>……  
</span><span class='line'>rth-&gt;u.dst.dev = net-&gt;loopback_dev;  
</span><span class='line'>rth-&gt;rt_dst = daddr;  
</span><span class='line'>rth-&gt;rt_src = saddr;  
</span><span class='line'>rth-&gt;rt_gateway = daddr;  
</span><span class='line'>rth-&gt;rt_spec_dst = spec_dst; (spec_dst=daddr)  
</span><span class='line'>……  
</span><span class='line'>hash = rt_hash(daddr, saddr, fl.iif, rt_genid(net));  
</span><span class='line'>err = rt_intern_hash(hash, rth, NULL, skb, fl.iif);  </span></code></pre></td></tr></table></div></figure>


<p>因此插入的第一条缓存信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;Key = [dst = 192.168.1.2  src = 192.168.1.1 idx = 2 id = id]
</span><span class='line'>&#9;Value = [Iface = lo dst = 192.168.1.2 src = 192.168.1.1 idx = 2 id = id ……]</span></code></pre></td></tr></table></div></figure>


<p>步骤2：
主机Host2 发送echo reply报文给主机 Host1 (dst = 192.168.1.1 src = 192.168.1.2)<br/>
步骤2是紧接着步骤1的，Host2在收到echo报文后会立即回复echo reply报文，相应调用流程：<br/>
icmp_reply() -> ip_route_output_key() -> ip_route_output_flow() -> <strong>ip_route_output_key() -> ip_route_output_slow() -> ip_mkroute_output() -> </strong>mkroute_output()<br/>
在icmp_reply()中生成稍后路由查找中的关键数据flowi，可以看作查找的键值，由于是回复已收到的报文，因此目的与源IP地址者是已知的，下面结构中daddr=192.168.1.1，saddr=192.168.1.2。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct flowi fl = { .nl_u = { .ip4_u =  
</span><span class='line'>  { .daddr = daddr,  
</span><span class='line'>  .saddr = rt-&gt;rt_spec_dst,  
</span><span class='line'>  .tos = RT_TOS(ip_hdr(skb)-&gt;tos) } },  
</span><span class='line'>  .proto = IPPROTO_ICMP };  </span></code></pre></td></tr></table></div></figure>


<p>在__ip_route_output_key()时会查询路由缓存表，查询的键值是[192.168.1.1, 192.168.1.2, 0, id]，由于此时路由缓存中只有一条刚刚插入的从192.168.1.1->192.168.1.2的缓存项，因而查询失败，继续走ip_route_output_slow()来创建并插入新的缓存项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(flp-&gt;fl4_dst, flp-&gt;fl4_src, flp-&gt;oif, rt_genid(net));  </span></code></pre></td></tr></table></div></figure>


<p>在ip_route_input_slow()中查询路由表，因为在同一网段，在会MAIN表中匹配192.168.1.0/24条目，查询结果res.type==RTN_UNICAST。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (fib_lookup(net, &fl, &res)) {  
</span><span class='line'>…..  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>然后调用__mkroute_output()来生成新的路由缓存，信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rth-&gt;u.dst.dev = dev_out;  
</span><span class='line'>rth-&gt;rt_dst = fl-&gt;fl4_dst;  
</span><span class='line'>rth-&gt;rt_src = fl-&gt;fl4_src;  
</span><span class='line'>rth-&gt;rt_gateway = fl-&gt;fl4_dst;  
</span><span class='line'>rth-&gt;rt_spec_dst= fl-&gt;fl4_src;  
</span><span class='line'>rth-&gt;fl.oif = oldflp-&gt;oif; (oldflp-&gt;oif为0)  </span></code></pre></td></tr></table></div></figure>


<p>插入路由缓存表时使用的键值是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(oldflp-&gt;fl4_dst, oldflp-&gt;fl4_src, oldflp-&gt;oif, rt_genid(dev_net(dev_out)));  </span></code></pre></td></tr></table></div></figure>


<p>这条语句很关键，缓存的存储形式是hash表，除了生成缓存信息外，还要有相应的键值，这句的hash就是产生的键值，可以看到，它是由(dst, src, oif, id)四元组生成的，dst和src很好理解，id对于net来说是定值，oif则是关键，注意这里用的是oldflp->oif(它的值为0)，尽管路由缓存对应的出接口设备是dev_out。所以，第二条缓存信息的如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;Key = [dst = 192.168.1.1  src = 192.168.1.2 idx = 0 id = id]
</span><span class='line'>&#9;Value = [Iface = brcm0.1  dst = 192.168.1.1 src = 192.168.1.2 idx = 2 id = id ……]</span></code></pre></td></tr></table></div></figure>


<p>步骤3：</p>

<p>主机Host2 ping 主机Host1  <br/>
Host2向Host1发送echo报文(dst = 192.168.1.1, src = 192.168.1.2)<br/>
Host2主动发送echo报文，使用SOCK_RAW与IPPROTO_ICMP组合的套接字，相应调用流程：<br/>
raw_sendmsg() -> ip_route_output_flow() -> <strong>ip_route_output_key() -> ip_route_output_slow() -> ip_mkroute_output() -> </strong>mkroute_output()<br/>
在raw_sendmsg()中生成稍后路由查找中的关键数据flowi，可以看作查找的键值，由于是主动发送的报文，源IP地址者还是未知的，因为主机可能是多接口的，在查询完路由表后才能得到要走的设备接口和相应的源IP地址。下面结构中daddr=192.168.1.1，saddr=0。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct flowi fl = { .oif = ipc.oif,  
</span><span class='line'>  .mark = sk-&gt;sk_mark,  
</span><span class='line'>  .nl_u = { .ip4_u =  
</span><span class='line'>&#9;{ .daddr = daddr,  
</span><span class='line'>   .saddr = saddr,  
</span><span class='line'>   .tos = tos } },  
</span><span class='line'>  .proto = inet-&gt;hdrincl ? IPPROTO_RAW :  
</span><span class='line'>&#9;&#9;sk-&gt;sk_protocol,  
</span><span class='line'> };  </span></code></pre></td></tr></table></div></figure>


<p>在__ip_route_output_key()时会查询路由缓存表，查询的键值是[192.168.1.1, 0, 0, id]，尽管此时路由缓存中刚刚插入了192.168.1.2->192.168.1.1的条目，但由于两者的键值不同，因而查询依旧失败，继续走ip_route_output_slow()来创建并插入新的缓存项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hash = rt_hash(flp-&gt;fl4_dst, flp-&gt;fl4_src, flp-&gt;oif, rt_genid(net));  </span></code></pre></td></tr></table></div></figure>


<p>与Host2回复Host1的echo报文相比，除了进入函数不同(前者为icmp_reply，后者为raw_sendmsg)，后续调用流程是完全相同的，导致最终路由缓存不同(准确说是键值)是因为初始时flowi不同。<br/>
此处，raw_sendmsg()中，flowi的初始值：dst = 192.168.1.1, src = 0, oif = 0<br/>
对比icmp_reply()中，flowi的初始值：dst = 192.168.1.1, src = 192.168.1.2, oif = 0<br/>
在上述调用流程中，在__ip_route_output_key()中查找路由缓存，尽管此时路由缓存有从192.168.1.2到192.168.1.1的缓存项，但它的键值与此次查找的键值[192.168.1.1, 192.168.1.2, 0]，从下表可以明显看出：</p>

<p><img src="/images/kernel/2015-08-25-13.jpg" alt="" /></p>

<p>由于查找失败，生成新的路由缓存项并插入路由缓存表，注意在ip_route_output_slow()中查找完路由表后，设置了缓存的src。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!fl.fl4_src)  
</span><span class='line'>&#9;fl.fl4_src = FIB_RES_PREFSRC(res);  </span></code></pre></td></tr></table></div></figure>


<p> 因此插入的第三条缓存信息如下，它与第二条缓存完成相同，区别在于键值不同：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;Key = [dst = 192.168.1.1  src = 0 idx = 0 id = id]
</span><span class='line'>&#9;Value = [Iface = brcm0.1  dst = 192.168.1.1 src = 192.168.1.2 idx = 2 id = id ……]</span></code></pre></td></tr></table></div></figure>


<p>最终，路由缓存表如下：</p>

<p><img src="/images/kernel/2015-08-25-14.jpg" alt="" /></p>

<p> 第三条缓存条目键值使用src=0, idx=0的原因是当主机要发送报文给192.168.1.1的主机时，直到IP层路由查询前，它都无法知道该使用的接口地址(如果没有绑定的话)，而路由缓存的查找发生在路由查询之前，所以src=0,idx=0才能保证后续报文使用该条目。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/08/25/kernel-net-ifconfig/">ifconfig statistics</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-25T14:27:00+08:00'><span class='date'>2015-08-25</span> <span class='time'>14:27:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://jaseywang.me/2014/08/16/ifconfig-%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%97%E6%AE%B5errors-dropped-overruns/">http://jaseywang.me/2014/08/16/ifconfig-%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%97%E6%AE%B5errors-dropped-overruns/</a></p>

<p><a href="http://unix.stackexchange.com/questions/184604/whats-the-difference-between-errors-dropped-overruns-and-frame-fiel">http://unix.stackexchange.com/questions/184604/whats-the-difference-between-errors-dropped-overruns-and-frame-fiel</a></p>

<p>RX errors: 表示总的收包的错误数量，这包括 too-long-frames 错误，Ring Buffer 溢出错误，crc 校验错误，帧同步错误，fifo overruns 以及 missed pkg 等等。</p>

<p>RX dropped: 表示数据包已经进入了 Ring Buffer，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃。</p>

<p>RX overruns: 表示了 fifo 的 overruns，这是由于 Ring Buffer(aka Driver Queue) 传输的 IO 大于 kernel 能够处理的 IO 导致的，而 Ring Buffer 则是指在发起 IRQ 请求之前的那块 buffer。很明显，overruns 的增大意味着数据包没到 Ring Buffer 就被网卡物理层给丢弃了，而 CPU 无法即使的处理中断是造成 Ring Buffer 满的原因之一，上面那台有问题的机器就是因为 interruprs 分布的不均匀(都压在 core0)，没有做 affinity 而造成的丢包。</p>

<p>RX frame: 表示 misaligned 的 frames，接收到的位长度不是8的倍数，不是字节。it means frames with a length not divisible by 8. Because of that length is not a valid frame and it is simply discarded.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/7">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/5">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(39)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>22</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>13</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(52)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~haproxy/?opendiv=tools'>haproxy</a><a href='##' onmousedown=showDiv('tools~haproxy') id='aexp_tools~haproxy'><span class='exp_style' id='exp_tools~haproxy'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~haproxy')) document.getElementById('aexp_tools~haproxy').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(51)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~cgroup/?opendiv=system'>cgroup</a><a href='##' onmousedown=showDiv('system~cgroup') id='aexp_system~cgroup'><span class='exp_style' id='exp_system~cgroup'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~cgroup')) document.getElementById('aexp_system~cgroup').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~kvm/?opendiv=system'>kvm</a><a href='##' onmousedown=showDiv('system~kvm') id='aexp_system~kvm'><span class='exp_style' id='exp_system~kvm'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~kvm')) document.getElementById('aexp_system~kvm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~namespace/?opendiv=system'>namespace</a><a href='##' onmousedown=showDiv('system~namespace') id='aexp_system~namespace'><span class='exp_style' id='exp_system~namespace'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~namespace')) document.getElementById('aexp_system~namespace').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(156)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~fs/?opendiv=kernel'>fs</a><a href='##' onmousedown=showDiv('kernel~fs') id='aexp_kernel~fs'><span class='exp_style' id='exp_kernel~fs'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~fs')) document.getElementById('aexp_kernel~fs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>33</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>74</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>19</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(20)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(66)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~perf/?opendiv=debug'>perf</a><a href='##' onmousedown=showDiv('debug~perf') id='aexp_debug~perf'><span class='exp_style' id='exp_debug~perf'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~perf')) document.getElementById('aexp_debug~perf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(26)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(199)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~11/?opendiv=2015'>2015-11</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2015~10/?opendiv=2015'>2015-10</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2015~09/?opendiv=2015'>2015-09</a><span class='right_span'>18</span></li>
<li><a href='/blog/cats/2015~08/?opendiv=2015'>2015-08</a><span class='right_span'>25</span></li>
<li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>31</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/17/kernel-net-ixgbe/">ixgbe</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/17/kernel-net-cubic/">cubic</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/17/kernel-net-iptables/">iptables</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/17/command-curl/">curl命令</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/17/command-alias/">alias命令</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
	<li>
		<a href=http://smilejay.com/ target=_blank>smilejay</a>
	</li>
	<li>
		<a href=http://blog.chinaunix.net/uid/10167808.html target=_blank>godbach</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
