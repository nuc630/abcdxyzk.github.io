
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/12/kernel-net-socket-wakeup/">Socket层实现系列 — 睡眠驱动的同步等待</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-12T17:16:00+08:00'><span class='date'>2015-06-12</span> <span class='time'>17:16:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/zhangskd/article/details/45770323">http://blog.csdn.net/zhangskd/article/details/45770323</a></p>

<p>主要内容：Socket的同步等待机制，connect和accept等待的实现。</p>

<p>内核版本：3.15.2</p>

<h4>概述</h4>

<p>socket上定义了几个IO事件：状态改变事件、有数据可读事件、有发送缓存可写事件、有IO错误事件。对于这些事件，socket中分别定义了相应的事件处理函数，也称回调函数。</p>

<p>Socket I/O事件的处理过程中，要使用到sock上的两个队列：等待队列和异步通知队列，这两个队列中都保存着等待该Socket I/O事件的进程。</p>

<p>Q：为什么要使用两个队列，等待队列和异步通知队列有什么区别呢？<br/>
A：等待队列上的进程会睡眠，直到Socket I/O事件的发生，然后在事件处理函数中被唤醒。异步通知队列上的进程则不需要睡眠，Socket I/O事件发时，事件处理函数会给它们发送到信号，这些进程事先注册的信号处理函数就能够被执行。</p>

<h4>等待队列</h4>

<p>Socket层使用等待队列来进行阻塞等待，在等待期间，阻塞在此socket上的进程会睡眠。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sock {
</span><span class='line'>&#9;...
</span><span class='line'>&#9;struct socket_wq __rcu *sk_wq; /* socket的等待队列和异步通知队列 */
</span><span class='line'>&#9;...
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct socket_wq {
</span><span class='line'>&#9;/* Note: wait MUST be first field of socket_wq */
</span><span class='line'>&#9;wait_queue_head_t wait; /* 等待队列头 */
</span><span class='line'>&#9;struct fasync_struct *fasync_list; /* 异步通知队列 */
</span><span class='line'>&#9;struct rcu_head *rcu;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h6>(1)  socket的等待队列头</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __wait_queue_head {
</span><span class='line'>&#9;spinlock_t lock;
</span><span class='line'>&#9;struct list_head task_list;
</span><span class='line'>};
</span><span class='line'>typedef struct __wait_queue_head wait_queue_head_t;</span></code></pre></td></tr></table></div></figure>


<h5>(2) 进程的等待任务</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __wait_queue {
</span><span class='line'>&#9;unsigned int flags;
</span><span class='line'>#define WQ_FLAG_EXCLUSIVE 0x01
</span><span class='line'>&#9;void *private; /* 指向当前的进程控制块 */
</span><span class='line'>&#9;wait_queue_func_t func; /* 唤醒函数 */
</span><span class='line'>&#9;struct list_head task_list; /* 用于链接入等待队列 */
</span><span class='line'>};
</span><span class='line'>typedef struct __wait_queue wait_queue_t;
</span><span class='line'>typedef int (*wait_queue_func_t) (wait_queue_t *wait, unsigned mode, int flags, void *key);
</span><span class='line'>int default_wake_function(wait_queue_t *wait, unsigned mode, int flags, void *key);</span></code></pre></td></tr></table></div></figure>


<h5>(3) 初始化等待任务</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)
</span><span class='line'>
</span><span class='line'>#define DEFINE_WAIT_FUNC(name, function)    \
</span><span class='line'>&#9;wait_queue_t name = {    \
</span><span class='line'>&#9;&#9;.private = current,    \
</span><span class='line'>&#9;&#9;.func = function,    \
</span><span class='line'>&#9;&#9;.task_list = LIST_HEAD_INIT((name).task_list),    \
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>int autoremove_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key)
</span><span class='line'>{
</span><span class='line'>&#9;int ret = default_wake_function(wait, mode, sync, key); /* 默认的唤醒函数 */
</span><span class='line'>
</span><span class='line'>&#9;if (ret)
</span><span class='line'>&#9;&#9;list_del_init(&wait-&gt;task_list); /* 从等待队列中删除 */
</span><span class='line'>
</span><span class='line'>&#9;return ret;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, void *key)
</span><span class='line'>{
</span><span class='line'>&#9;return try_to_wake_up(curr-&gt;private, mode, wake_flags);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>try_to_wake_up()通过把进程的状态设置为TASK_RUNNING，并把进程插入CPU运行队列，来唤醒睡眠的进程。</p>

<h5>(4) 把等待任务插入到等待队列中</h5>

<p>获取sock的等待队列。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline wait_queue_head_t *sk_sleep(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;BUILD_BUG_ON(offsetof(struct socket_wq, wait) != 0);
</span><span class='line'>&#9;return &rcu_dereference_raw(sk-&gt;sk_wq)-&gt;wait;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>把等待任务加入到等待队列中，同时设置当前进程的状态，TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state)
</span><span class='line'>{
</span><span class='line'>&#9;unsigned long flags;
</span><span class='line'>&#9;wait-&gt;flags &= ~WQ_FLAG_EXCLUSIVE; /* 可以同时唤醒多个等待进程 */
</span><span class='line'>
</span><span class='line'>&#9;spin_lock_irqsave(&q-&gt;lock, flags);
</span><span class='line'>
</span><span class='line'>&#9;if (list_empty(&wait-&gt;task_list))
</span><span class='line'>&#9;&#9;__add_wait_queue(q, wait); /* 把等待任务加入到等待队列的头部，会最先被唤醒 */
</span><span class='line'>
</span><span class='line'>&#9;set_current_state(state); /* 设置进程的状态 */
</span><span class='line'>
</span><span class='line'>&#9;spin_unlock_irqrestore(&q-&gt;lock, flags);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>prepare_to_wait()和prepare_to_wait_exclusive()都是用来把等待任务加入到等待队列中，不同之处在于使用prepare_to_wait_exclusive()时，会在等待任务中添加WQ_FLAG_EXCLUSIVE标志，表示一次只能唤醒一个等待任务，目的是为了避免惊群现象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void prepare_to_wait_exclusive(wait_queue_head_t *q, wait_queue_t *wait, int state)
</span><span class='line'>{
</span><span class='line'>&#9;unsigned long flags;
</span><span class='line'>
</span><span class='line'>&#9;/* 这个标志表示一次只唤醒一个等待任务，避免惊群现象 */
</span><span class='line'>&#9;wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;
</span><span class='line'>
</span><span class='line'>&#9;spin_lock_irqsave(&q-&gt;lock, flags);
</span><span class='line'>
</span><span class='line'>&#9;if (list_empty(&wait-&gt;task_list))
</span><span class='line'>&#9;&#9;__add_wait_queue_tail(q, wait); /* 把此等待任务加入到等待队列尾部 */
</span><span class='line'>
</span><span class='line'>&#9;set_current_state(state); /* 设置当前进程的状态 */
</span><span class='line'>
</span><span class='line'>&#9;spin_unlock_irqrestore(&q-&gt;lock, flags);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static inline void __add_wait_queue_tail(wait_queue_head_t *head, wait_queue_t *new)
</span><span class='line'>{
</span><span class='line'>&#9;list_add_tail(&new-&gt;task_list, &head-&gt;task_list);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>#define set_current_state(state_value)    \
</span><span class='line'>&#9;set_mb(current-&gt;state, (state_value))</span></code></pre></td></tr></table></div></figure>


<h5>(5) 删除等待任务</h5>

<p>从等待队列中删除等待任务，同时把等待进程的状态置为可运行状态，即TASK_RUNNING。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * finish_wait - clean up after waiting in a queue
</span><span class='line'> * @q: waitqueue waited on，等待队列头
</span><span class='line'> * @wait: wait descriptor，等待任务
</span><span class='line'> *
</span><span class='line'> * Sets current thread back to running state and removes the wait
</span><span class='line'> * descriptor from the given waitqueue if still queued.
</span><span class='line'> */
</span><span class='line'>void finish_wait(wait_queue_head_t *q, wait_queue_t *wait)
</span><span class='line'>{
</span><span class='line'>&#9;unsigned long flags;
</span><span class='line'>&#9;__set_current_state(TASK_RUNNING);
</span><span class='line'>
</span><span class='line'>&#9;if (! list_empty_careful(&wait-&gt;task_list)) {
</span><span class='line'>&#9;&#9;spin_lock_irqsave(&q-&gt;lock, flags);
</span><span class='line'>
</span><span class='line'>&#9;&#9;list_del_init(&wait-&gt;task_list); /* 从等待队列中删除 */
</span><span class='line'>
</span><span class='line'>&#9;&#9;spin_unlock_irqrestore(&q-&gt;lock, flags);
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>connect等待</h4>

<h5>(1) 睡眠</h5>

<p>connect()的超时时间为sk->sk_sndtimeo，在sock_init_data()中初始化为MAX_SCHEDULE_TIMEOUT，表示无限等待，可以通过SO_SNDTIMEO选项来修改。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static long inet_wait_for_connect(struct sock *sk, long timeo, int writebias)
</span><span class='line'>{
</span><span class='line'>&#9;DEFINE_WAIT(wait);  /* 初始化等待任务 */
</span><span class='line'>
</span><span class='line'>&#9;/* 把等待任务加入到socket的等待队列头部，把进程的状态设为TASK_INTERRUPTIBLE */
</span><span class='line'>&#9;prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
</span><span class='line'>&#9;sk-&gt;sk_write_pending += writebias;
</span><span class='line'>
</span><span class='line'>&#9;/* Basic assumption: if someone sets sk-&gt;sk_err, he _must_ change state of the socket
</span><span class='line'>&#9; * from TCP_SYN_*. Connect() does not allow to get error notifications without closing
</span><span class='line'>&#9; * the socket.
</span><span class='line'>&#9; */
</span><span class='line'>
</span><span class='line'>&#9;/* 完成三次握手后，状态就会变为TCP_ESTABLISHED，从而退出循环 */
</span><span class='line'>&#9;while ((1 &lt;&lt; sk-&gt;sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
</span><span class='line'>&#9;&#9;release_sock(sk); /* 等下要睡觉了，先释放锁 */
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* 进入睡眠，直到超时或收到信号，或者被I/O事件处理函数唤醒。
</span><span class='line'>&#9;&#9; * 1. 如果是收到信号退出的，timeo为剩余的jiffies。
</span><span class='line'>&#9;&#9; * 2. 如果使用了SO_SNDTIMEO选项，超时退出后，timeo为0。
</span><span class='line'>&#9;&#9; * 3. 如果没有使用SO_SNDTIMEO选项，timeo为无穷大，即MAX_SCHEDULE_TIMEOUT，
</span><span class='line'>&#9;&#9; *      那么返回值也是这个，而超时时间不定。为了无限阻塞，需要上面的while循环。
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;timeo = schedule_timeout(timeo);
</span><span class='line'>
</span><span class='line'>&#9;&#9;lock_sock(sk); /* 被唤醒后重新上锁 */
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* 如果进程有待处理的信号，或者睡眠超时了，退出循环，之后会返回错误码 */
</span><span class='line'>&#9;&#9;if (signal_pending(current) || !timeo)
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* 继续睡眠吧 */
</span><span class='line'>&#9;&#9;prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/* 等待结束时，把等待进程从等待队列中删除，把当前进程的状态设为TASK_RUNNING */
</span><span class='line'>&#9;finish_wait(sk_sleep(sk), &wait);
</span><span class='line'>&#9;sk-&gt;sk_write_pending -= writebias;
</span><span class='line'>&#9;return timeo;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>(2) 唤醒</h5>

<p>三次握手中，当客户端收到SYNACK、发出ACK后，连接就成功建立了。此时连接的状态从TCP_SYN_SENT或TCP_SYN_RECV变为TCP_ESTABLISHED，sock的状态发生变化，会调用sock_def_wakeup()来处理连接状态变化事件，唤醒进程，connect()就能成功返回了。</p>

<p>sock_def_wakeup()的函数调用路径如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_v4_rcv
</span><span class='line'>&#9;tcp_v4_do_rcv
</span><span class='line'>&#9;&#9;tcp_rcv_state_process
</span><span class='line'>&#9;&#9;&#9;tcp_rcv_synsent_state_process
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_finish_connect
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;sock_def_wakeup
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;wake_up_interruptible_all
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;__wake_up
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;__wake_up_common</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;...
</span><span class='line'>&#9;tcp_set_state(sk, TCP_ESTABLISHED); /* 在这里设置为连接已建立的状态 */
</span><span class='line'>&#9;...
</span><span class='line'>&#9;if (! sock_flag(sk, SOCK_DEAD)) {
</span><span class='line'>&#9;&#9;sk-&gt;sk_state_change(sk); /* 指向sock_def_wakeup，会唤醒调用connect()的进程，完成连接的建立 */
</span><span class='line'>&#9;&#9;sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT); /* 如果使用了异步通知，则发送SIGIO通知进程可写 */
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>accept等待</h4>

<p>(1) 睡眠</p>

<p>accept()超时时间为sk->sk_rcvtimeo，在sock_init_data()中初始化为MAX_SCHEDULE_TIMEOUT，表示无限等待。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Wait for an incoming connection, avoid race conditions.
</span><span class='line'> * This must be called with the socket locked.
</span><span class='line'> */
</span><span class='line'>static int inet_csk_wait_for_connect(struct sock *sk, long timeo)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>&#9;DEFINE_WAIT(wait); /* 初始化等待任务 */
</span><span class='line'>&#9;int err;
</span><span class='line'>
</span><span class='line'>&#9;for (; ;) {
</span><span class='line'>&#9;&#9;/* 把等待任务加入到socket的等待队列中，把进程状态设置为TASK_INTERRUPTIBLE */
</span><span class='line'>&#9;&#9;prepare_to_wait_exclusive(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
</span><span class='line'>
</span><span class='line'>&#9;&#9;release_sock(sk); /* 等下可能要睡觉了，先释放 */
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (reqsk_queue_empty(&icsk-&gt;icsk_accept_queue)) /* 如果全连接队列为空 */
</span><span class='line'>&#9;&#9;&#9;timeo = schedule_timeout(timeo); /* 进入睡眠直到超时或收到信号，或被IO事件处理函数唤醒 */
</span><span class='line'>
</span><span class='line'>&#9;&#9;lock_sock(sk); /* 醒来后重新上锁 */
</span><span class='line'>&#9;&#9;err = 0;
</span><span class='line'>&#9;&#9;/* 全连接队列不为空时，说明有新的连接建立了，成功返回 */
</span><span class='line'>&#9;&#9;if (! reqsk_queue_empty(&icsk-&gt;icsk_accept_queue))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;err = -EINVAL;
</span><span class='line'>&#9;&#9;if (sk-&gt;sk_state != TCP_LISTEN) /* 如果sock不处于监听状态了，退出，返回错误码 */
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;err = sock_intr_errno(timeo);
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* 如果进程有待处理的信号，退出，返回错误码。
</span><span class='line'>&#9;&#9; * 因为timeo默认为MAX_SCHEDULE_TIMEOUT，所以err默认为-ERESTARTSYS。
</span><span class='line'>&#9;&#9; * 接下来会重新调用此函数，所以accept()依然阻塞。
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (signal_pending(current))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;err = -EAGAIN;
</span><span class='line'>&#9;&#9;if (! timeo) /* 如果等待超时，即超过用户设置的sk-&gt;sk_rcvtimeo，退出 */
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/* 从等待队列中删除等待任务，把等待进程的状态设为TASK_RUNNING */
</span><span class='line'>&#9;finish_wait(sk_sleep(sk), &wait);
</span><span class='line'>&#9;return err;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>(2) 唤醒</h5>

<p>三次握手中，当服务器端接收到ACK完成连接建立的时候，会把新的连接链入全连接队列中，然后唤醒监听socket上的等待进程，accept()就能成功返回了。</p>

<p>三次握手时，当收到客户端的ACK后，经过如下调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_v4_rcv
</span><span class='line'>&#9;tcp_v4_do_rcv
</span><span class='line'>&#9;&#9;tcp_child_process
</span><span class='line'>&#9;&#9;&#9;sock_def_readable
</span><span class='line'>&#9;&#9;&#9;&#9;wake_up_interruptible_sync_poll
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;__wake_up_sync_key
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;__wake_up_common</span></code></pre></td></tr></table></div></figure>


<p>最终调用我们给等待任务注册的唤醒函数。</p>

<p>我们来看下accept()是如何避免惊群现象的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void __wake_up_common(wait_queue_head_t *q, unsigned int mode, int nr_exclusive,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9; int wake_flags, void *key)
</span><span class='line'>{
</span><span class='line'>&#9;wait_queue_t *curr, *next;
</span><span class='line'>
</span><span class='line'>&#9;list_for_each_entry_safe(curr, next, &q-&gt;task_list, task_list) {
</span><span class='line'>&#9;&#9;unsigned flags = curr-&gt;flags;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (curr-&gt;func(curr, mode, wake_flags, key) && (flags & WQ_FLAG_EXCLUSIVE)
</span><span class='line'>&#9;&#9;&#9;!--nr_exclusive)
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>初始化等待任务时，flags |= WQ_FLAG_EXCLUSIVE。传入的nr_exclusive为1，表示只允许唤醒一个等待任务。</p>

<p>所以这里只会唤醒一个等待的进程，不会导致惊群现象。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/12/kernel-net-socket-signal/">Socket层实现系列 — 信号驱动的异步等待</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-12T17:13:00+08:00'><span class='date'>2015-06-12</span> <span class='time'>17:13:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/zhangskd/article/details/45932775">http://blog.csdn.net/zhangskd/article/details/45932775</a></p>

<p>主要内容：Socket的异步通知机制。</p>

<p>内核版本：3.15.2</p>

<h4>概述</h4>

<p>socket上定义了几个IO事件：状态改变事件、有数据可读事件、有发送缓存可写事件、有IO错误事件。对于这些事件，socket中分别定义了相应的事件处理函数，也称回调函数。</p>

<p>Socket I/O事件的处理过程中，要使用到sock上的两个队列：等待队列和异步通知队列，这两个队列中都保存着等待该Socket I/O事件的进程。</p>

<p>Q：为什么要使用两个队列，等待队列和异步通知队列有什么区别呢？<br/>
A：等待队列上的进程会睡眠，直到Socket I/O事件的发生，然后在事件处理函数中被唤醒。异步通知队列上的进程则不需要睡眠，Socket I/O事件发时，事件处理函数会给它们发送到信号，这些进程事先注册的信号处理函数就能够被执行。</p>

<h4>异步通知队列</h4>

<p>Socket层使用异步通知队列来实现异步等待，此时等待Socket I/O事件的进程不用睡眠。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sock {
</span><span class='line'>&#9;...
</span><span class='line'>&#9;struct socket_wq __rcu *sk_wq; /* socket的等待队列和异步通知队列 */
</span><span class='line'>&#9;...
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct socket_wq {
</span><span class='line'>&#9;/* Note: wait MUST be first field of socket_wq */
</span><span class='line'>&#9;wait_queue_head_t wait; /* 等待队列头 */
</span><span class='line'>&#9;struct fasync_struct *fasync_list; /* 异步通知队列 */
</span><span class='line'>&#9;struct rcu_head *rcu;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct fasync_struct {
</span><span class='line'>&#9;spinlock_t fa_lock;
</span><span class='line'>&#9;int magic;
</span><span class='line'>&#9;int fa_fd; /* 文件描述符 */
</span><span class='line'>&#9;struct fasync_struct *fa_next; /* 用于链入单向链表 */
</span><span class='line'>&#9;struct file *fa_file; /* fa_file-&gt;f_owner记录接收信号的进程 */
</span><span class='line'>&#9;struct rcu_head fa_rcu;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>通过之前的blog《linux的异步通知机制》，我们知道为了能处理协议栈发出的SIGIO信号，</p>

<p>用户程序需要做的事情有：<br/>
1. 通过signal()指定SIGIO的处理函数。<br/>
2. 设置sockfd的拥有者为本进程，如此一来本进程才能收到协议栈发出的SIGIO信号。<br/>
3. 设置sockfd支持异步通知，即设置O_ASYNC标志。</p>

<p>对应的用户程序函数调用大概如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>signal(SIGIO, my_handler); /* set new SIGIO handler */
</span><span class='line'>fcntl(sockfd, F_SETOWN, getpid()); /* set sockfd's owner process */
</span><span class='line'>oflags = fcntl(sockfd, F_GETFL); /* get old sockfd flags */
</span><span class='line'>fcntl(sockfd, F_SETFL, oflags | O_ASYNC); /* set new sockfd flags */</span></code></pre></td></tr></table></div></figure>


<p>下文关注的是内核层面的一些工作：<br/>
1. 如何把进程加入Socket的异步通知队列，或者把进程从Socket的异步通知队列中删除。<br/>
2. 协议栈何时发送信号给Socket异步通知队列上的进程。</p>

<h4>插入和删除</h4>

<p>首先来看下fcntl()的系统调用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SYSCALL_DEFINE3(fcntl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)
</span><span class='line'>{
</span><span class='line'>&#9;struct fd f = fdget_raw(fd);
</span><span class='line'>&#9;long err = -EBADF; /* Bad file number */
</span><span class='line'>
</span><span class='line'>&#9;if (! f.file)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;/* File is opened with O_PATH, almost nothing can be done with it */
</span><span class='line'>&#9;if (unlikely(f.file-&gt;f_mode & FMODE_PATH)) {
</span><span class='line'>&#9;&#9;if (! check_fcntl_cmd(cmd))
</span><span class='line'>&#9;&#9;&#9;goto out1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;err = security_file_fcntl(f.file, cmd, arg);
</span><span class='line'>&#9;if (! err)
</span><span class='line'>&#9;&#9;err = do_fcntl(fd, cmd, arg, f.file); /* 实际的处理函数 */
</span><span class='line'>
</span><span class='line'>out1:
</span><span class='line'>&#9;fdput(f);
</span><span class='line'>out:
</span><span class='line'>&#9;return err;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static long do_fcntl(int fd, unsigned int cmd, unsigned long arg, struct fil *filp)
</span><span class='line'>{
</span><span class='line'>&#9;long err = -EINVAL;
</span><span class='line'>
</span><span class='line'>&#9;switch(cmd) {
</span><span class='line'>&#9;...
</span><span class='line'>&#9;case F_SETFL: /* 在这里设置O_ASYNC标志 */
</span><span class='line'>&#9;&#9;err = setfl(fd, filp, arg);
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;...
</span><span class='line'>&#9;case F_SETOWN: /* 在这里设置所有者进程 */
</span><span class='line'>&#9;&#9;err = f_setown(filp, arg, 1);
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;....
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;return err;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int setfl(int fd, struct file *filp, unsigned long arg)
</span><span class='line'>{
</span><span class='line'>&#9;...
</span><span class='line'>&#9;/* -&gt;fasync() is responsible for setting the FASYNC bit. */
</span><span class='line'>&#9;if (((arg ^ filp-&gt;f_flags) & FASYNC) && filp-&gt;f_op-&gt;fasync) {
</span><span class='line'>&#9;&#9;error = filp-&gt;f_op-&gt;fasync(fd, filp, (arg & FASYNC) != 0);
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (error &lt; 0)
</span><span class='line'>&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;&#9;if (error &gt; 0)
</span><span class='line'>&#9;&#9;&#9;error = 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Socket文件的操作函数集为socket_file_ops。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const struct file_operations socket_file_ops = {
</span><span class='line'>&#9;...
</span><span class='line'>&#9;.fasync = sock_fasync,
</span><span class='line'>&#9;...
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Update the socket async list. */
</span><span class='line'>static int sock_fasync(int fd, struct file *filp, int on)
</span><span class='line'>{
</span><span class='line'>&#9;struct socket *sock = filp-&gt;private_data;
</span><span class='line'>&#9;struct sock *sk = sock-&gt;sk;
</span><span class='line'>&#9;struct socket_wq *wq; /* Socket的等待队列和异步通知队列 */
</span><span class='line'>
</span><span class='line'>&#9;if (sk == NULL)
</span><span class='line'>&#9;&#9;return -EINVAL;
</span><span class='line'>
</span><span class='line'>&#9;lock_sock(sk);
</span><span class='line'>&#9;wq = rcu_dereference_protected(sock-&gt;wq, sock_owned_by_user(sk));
</span><span class='line'>
</span><span class='line'>&#9;fasync_helper(fd, filp, on, &wq-&gt;fasync_list); /* 使用此函数来插入或删除 */
</span><span class='line'>
</span><span class='line'>&#9;/* 设置或取消SOCK_FASYNC标志 */
</span><span class='line'>&#9;if (! wq-&gt;fasync_list)
</span><span class='line'>&#9;&#9;sock_reset_flag(sk, SOCK_FASYNC);
</span><span class='line'>&#9;else
</span><span class='line'>&#9;&#9;sock_set_flag(sk, SOCK_FASYNC);
</span><span class='line'>
</span><span class='line'>&#9;release_sock(sk);
</span><span class='line'>
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>和设备驱动一样，最终调用fasync_helper()来把进程插入异步通知队列，或者把进程从异步通知队列中删除。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * fasync_helper() is used by almost all character device drivers to set up the fasync
</span><span class='line'> * queue, and for regular files by the file lease code. It returns negative on error, 0 if
</span><span class='line'> * it did no changes and positive if it added / deleted the entry.
</span><span class='line'> */
</span><span class='line'>
</span><span class='line'>int fasync_helper(int fd, struct file *filp, int on, struct fasync_struct **fapp)
</span><span class='line'>{
</span><span class='line'>&#9;if (! on)
</span><span class='line'>&#9;&#9;return fasync_remove_entry(filp, fapp); /* 插入 */
</span><span class='line'>
</span><span class='line'>&#9;return fasync_add_entry(fd, filp, fapp); /* 删除 */
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>发送信号</h4>

<p>当Socket I/O事件触发时，协议栈会调用sk_wake_async()来进行异步通知。</p>

<p>函数的处理方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum {
</span><span class='line'>&#9;SOCK_WAKE_IO, /* 直接发送SIGIO信号 */
</span><span class='line'>&#9;SOCK_WAKE_WAITD, /* 检测应用程序是否通过recv()类调用来等待接收数据，如果没有才发送SIGIO信号 */
</span><span class='line'>&#9;SOCK_WAKE_SPACE, /* 检测sock的发送队列是否曾经到达上限，如果有的话发送SIGIO信号 */
</span><span class='line'>&#9;SOCK_WAKE_URG, /* 直接发送SIGURG信号 */
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>通告的IO类型，常用的有：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define __SI_POLL 0
</span><span class='line'>#define POLL_IN (__SI_POLL | 1) /* data input available, 有接收数据可读 */
</span><span class='line'>#define POLL_OUT (__SI_POLL | 2) /* output buffers available, 有输出缓存可写 */
</span><span class='line'>#define POLL_MSG (__SI_POLL | 3) /* input message available, 有输入消息可读 */
</span><span class='line'>#define POLL_ERR (__SI_POLL | 4) /* i/0 error, I/O错误 */
</span><span class='line'>#define POLL_PRI (__SI_POLL | 5) /* high priority input available, 有紧急数据可读 */
</span><span class='line'>#define POLL_HUP (__SI_POLL | 6) /* device disconnected, 设备关闭或文件关闭，无法继续读写 */</span></code></pre></td></tr></table></div></figure>


<p>how为函数的处理方式，band为通告的IO类型。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void sk_wake_async(struct sock *sk, int how, int band)
</span><span class='line'>{
</span><span class='line'>&#9;if (sock_flag(sk, SOCK_FASYNC)) /* sock需要支持异步通知 */
</span><span class='line'>&#9;&#9;sock_wake_async(sk-&gt;sk_socket, how, band);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int sock_wake_async(struct socket *sock, int how, int band)
</span><span class='line'>{
</span><span class='line'>&#9;struct socket_wq *wq;
</span><span class='line'>
</span><span class='line'>&#9;if (! sock)
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;wq = rcu_dereference(sock-&gt;wq); /* socket的等待队列和异步通知队列 */
</span><span class='line'>
</span><span class='line'>&#9;if (! wq || !wq-&gt;fasync_list) { /* 如果有队列没有实例 */
</span><span class='line'>&#9;&#9;rcu_read_unlock();
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;switch(how) {
</span><span class='line'>&#9;/* 检测应用程序是否通过recv()类调用来等待接收数据，如果没有才发送SIGIO信号 */
</span><span class='line'>&#9;case SOCK_WAKE_WAITD:
</span><span class='line'>&#9;&#9;if (test_bit(SOCK_ASYNC_WAITDATA, &sock-&gt;flags))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;goto call_kill;
</span><span class='line'>
</span><span class='line'>&#9;/* 检测sock的发送队列是否曾经到达上限，如果有的话发送SIGIO信号 */
</span><span class='line'>&#9;case SOCK_WAKE_SPACE:
</span><span class='line'>&#9;&#9;if (! test_and_clear_bit(SOCK_ASYNC_NOSPACE, &sock-&gt;flags))
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;/* fall_through */
</span><span class='line'>
</span><span class='line'>&#9;case SOCK_WAKE_IO: /* 直接发送SIGIO信号 */
</span><span class='line'>call_kill:
</span><span class='line'>&#9;&#9;&#9;/* 发送SIGIO信号给异步通知队列上的进程，告知IO消息 */
</span><span class='line'>&#9;&#9;&#9;kill_fasync(&wq-&gt;fasync_list, SIGIO, band);
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;case SOCK_WAKE_URG:
</span><span class='line'>&#9;&#9;&#9;/* 发送SIGURG信号给异步通知队列上的进程 */
</span><span class='line'>&#9;&#9;&#9;kill_fasync(&wq-&gt;fasync_list, SIGURG, band);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>和设备驱动一样，最终调用kill_fasync()来发送信号给用户进程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void kill_fasync(struct fasync_struct **fp, int sig, int band)
</span><span class='line'>{
</span><span class='line'>&#9;/* First a quick test without locking: usually the list is empty. */
</span><span class='line'>&#9;if (*f) {
</span><span class='line'>&#9;&#9;rcu_read_lock();
</span><span class='line'>&#9;&#9;kill_fasync_rcu(rcu_dereference(*fp), sig, band);
</span><span class='line'>&#9;&#9;rcu_read_unlock();
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void kill_fasync_rcu(struct fasync_struct *fa, int sig, int band)
</span><span class='line'>{
</span><span class='line'>&#9;while (fa) {
</span><span class='line'>&#9;&#9;struct fown_struct *fown;
</span><span class='line'>&#9;&#9;unsigned long flags;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (fa-&gt;magic != FASYNC_MAGIC) {
</span><span class='line'>&#9;&#9;&#9;printk(KERN_ERR "kill_fasync: bad magic number in fasync_struct!\n");
</span><span class='line'>&#9;&#9;&#9;return;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;spin_lock_irqsave(&fa-&gt;fa_lock, flags);
</span><span class='line'>&#9;&#9;if (fa-&gt;fa_file) {
</span><span class='line'>&#9;&#9;&#9;fown = &fa-&gt;file-&gt;f_owner; /* 持有文件的进程 */
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* Don't send SIGURG to processes which have not set a queued signum:
</span><span class='line'>&#9;&#9;&#9; * SIGURG has its own default signalling mechanism. */
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (! (sig == SIGURG && fown-&gt;signum == 0))
</span><span class='line'>&#9;&#9;&#9;&#9;send_sigio(fown, fa-&gt;fa_fd, band); /* 发送信号给持有文件的进程 */
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;spin_unlock_irqrestore(&fa-&gt;fa_lock, flags);
</span><span class='line'>
</span><span class='line'>&#9;&#9;fa = rcu_dereference(fa-&gt;fa_next); /* 指向下一个异步通知结构体 */
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/12/kernel-net-sock-socket/">socket和sock的一些分析</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-12T16:55:00+08:00'><span class='date'>2015-06-12</span> <span class='time'>16:55:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/wolongzhumeng/article/details/8900414">http://blog.csdn.net/wolongzhumeng/article/details/8900414</a></p>

<p>1、每一个打开的文件、socket等等都用一个file数据结构代表，这样文件和socket就通过inode->u(union)中的各个成员来区别：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct inode {
</span><span class='line'>&#9;.....................
</span><span class='line'>&#9;union {
</span><span class='line'>&#9;&#9;struct ext2_inode_info ext2_i;
</span><span class='line'>&#9;&#9;struct ext3_inode_info ext3_i;
</span><span class='line'>&#9;&#9;struct socket socket_i;
</span><span class='line'>&#9;&#9;.....................
</span><span class='line'>&#9;} u;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>2、每个socket数据结构都有一个sock数据结构成员，sock是对socket的扩充，两者一一对应，socket->sk指向对应的sock，sock->socket 指向对应的socket；</p>

<p>3、socket和sock是同一事物的两个侧面，为什么不把两个数据结构合并成一个呢？这是因为socket是inode结构中的一部分，即把inode结
构内部的一个union用作socket结构。由于插口操作的特殊性，这个数据结构中需要有大量的结构成分，如果把这些成分全部放到socket
结构中，则inode结构中的这个union就会变得很大，从而inode结构也会变得很大，而对于其他文件系统这个union是不需要这么大的，
所以会造成巨大浪费，系统中使用inode结构的数量要远远超过使用socket的数量，故解决的办法就是把插口分成两部分，把与文件系
统关系密切的放在socket结构中，把与通信关系密切的放在另一个单独结构sock中；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct socket
</span><span class='line'>{
</span><span class='line'>&#9;socket_state state;      // 该state用来表明该socket的当前状态
</span><span class='line'>&#9;typedef enum {
</span><span class='line'>&#9;&#9;SS_FREE = 0,         /* not allocated */
</span><span class='line'>&#9;&#9;SS_UNCONNECTED,      /* unconnected to any socket */
</span><span class='line'>&#9;&#9;SS_CONNECTING,       /* in process of connecting */
</span><span class='line'>&#9;&#9;SS_CONNECTED,        /* connected to socket */
</span><span class='line'>&#9;&#9;SS_DISCONNECTING     /* in process of disconnecting */
</span><span class='line'>&#9;} socket_state;
</span><span class='line'>&#9;unsigned long flags;     //该成员可能的值如下，该标志用来设置socket是否正在忙碌
</span><span class='line'>&#9;#define SOCK_ASYNC_NOSPACE 0
</span><span class='line'>&#9;#define SOCK_ASYNC_WAITDATA 1
</span><span class='line'>&#9;#define SOCK_NOSPACE 2
</span><span class='line'>&#9;struct proto_ops *ops;   //依据协议邦定到该socket上的特定的协议族的操作函数指针，例如IPv4 TCP就是inet_stream_ops
</span><span class='line'>&#9;struct inode *inode;     //表明该socket所属的inode
</span><span class='line'>&#9;struct fasync_struct *fasync_list; //异步唤醒队列
</span><span class='line'>&#9;struct file *file;       //file回指指针
</span><span class='line'>&#9;struct sock *sk;         //sock指针
</span><span class='line'>&#9;wait_queue_head_t wait;  //sock的等待队列，在TCP需要等待时就sleep在这个队列上
</span><span class='line'>&#9;short type;              //表示该socket在特定协议族下的类型例如SOCK_STREAM,
</span><span class='line'>&#9;unsigned char passcred;  //在TCP分析中无须考虑
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct sock {
</span><span class='line'>&#9;/* socket用来对进入的包进行匹配的5大因素 */
</span><span class='line'>&#9;__u32 daddr;        // dip，Foreign IPv4 addr
</span><span class='line'>&#9;__u32 rcv_saddr;    // 记录套接字所绑定的地址 Bound local IPv4 addr
</span><span class='line'>&#9;__u16 dport;        // dport
</span><span class='line'>&#9;unsigned short num; /* 套接字所在的端口号, 端口号小于1024的为特权端口, 只有特权用户才能绑定,当用户指定的端
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9; * 口号为零时, 系统将提供一个未分配的用户端口，如果对于raw socket的话，该num又可以用来
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9; * 保存socket(int family, int type, int protocol)中的protocol，而不是端口号了；在bind时候，会首先
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9; * 将邦定的源端口号赋予该成员，最终sport成员从该成员出获取源端口号__tcp_v4_hash主要就
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9; * 是利用了该成员来hash从而排出hash链
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9; */
</span><span class='line'>&#9;int bound_dev_if;   // Bound device index if != 0
</span><span class='line'>
</span><span class='line'>&#9;/* 主hash链，系统已分配的端口用tcp_hashinfo.__tcp_bhash来索引, 索引槽结构为tcp_bind_hashbucket, 端口绑定结构用tcp_bind_bucket描述,
</span><span class='line'>&#9;它包含指向绑定到该端口套接字的指针(owners), 套接字的sk-&gt;prev指针指向该绑定结构 */
</span><span class='line'>&#9;struct sock *next;
</span><span class='line'>&#9;struct sock **pprev;
</span><span class='line'>&#9;/* sk-&gt;bind_next和sk-&gt;bind_pprev用来描述绑定到同一端口的套接字，例如http服务器 */
</span><span class='line'>&#9;struct sock *bind_next;
</span><span class='line'>&#9;struct sock **bind_pprev;
</span><span class='line'>&#9;struct sock *prev;
</span><span class='line'>
</span><span class='line'>&#9;volatile unsigned char state, zapped; // Connection state，zapped在TCP分析中无须考虑
</span><span class='line'>&#9;__u16 sport;                   // 源端口，见num
</span><span class='line'>
</span><span class='line'>&#9;unsigned short family;         // 协议族，例如PF_INET
</span><span class='line'>&#9;unsigned char reuse;           // 地址是否可重用，只有RAW才使用
</span><span class='line'>&#9;unsigned char shutdown;        // 判断该socket连接在某方向或者双向方向上都已经关闭
</span><span class='line'>&#9;#define SHUTDOWN_MASK 3
</span><span class='line'>&#9;#define RCV_SHUTDOWN 1
</span><span class='line'>&#9;#define SEND_SHUTDOWN 2
</span><span class='line'>&#9;atomic_t refcnt;               // 引用计数
</span><span class='line'>&#9;socket_lock_t lock;            // 锁标志， 每个socket都有一个自旋锁，该锁在用户上下文和软中断处理时提供了同步机制
</span><span class='line'>&#9;typedef struct {
</span><span class='line'>&#9;&#9;spinlock_t slock;
</span><span class='line'>&#9;&#9;unsigned int users;
</span><span class='line'>&#9;&#9;wait_queue_head_t wq;
</span><span class='line'>&#9;} socket_lock_t;
</span><span class='line'>&#9;wait_queue_head_t *sleep;      // Sock所属线程的自身休眠等待队列
</span><span class='line'>&#9;struct dst_entry *dst_cache;   // 目的地的路由缓存
</span><span class='line'>&#9;rwlock_t dst_lock;             // 为该socket赋dst_entry值时的锁
</span><span class='line'>
</span><span class='line'>&#9;/* sock的收发都是要占用内存的，即发送缓冲区和接收缓冲区。 系统对这些内存的使用是有限制的。 通常，每个sock都会从配额里
</span><span class='line'>&#9;&#9;预先分配一些，这就是forward_alloc， 具体分配时：
</span><span class='line'>&#9;&#9;1）比如收到一个skb，则要计算到rmem_alloc中，并从forward_alloc中扣除。 接收处理完成后（如用户态读取），则释放skb，并利
</span><span class='line'>&#9;&#9;&#9;用tcp_rfree()把该skb的内存反还给forward_alloc。
</span><span class='line'>&#9;&#9;2）发送一个skb，也要暂时放到发送缓冲区，这也要计算到wmem_queued中，并从forward_alloc中扣除。真正发送完成后，也释放
</span><span class='line'>&#9;&#9;&#9;skb，并反还forward_alloc。 当从forward_alloc中扣除的时候，有可能forward_alloc不够，此时就要调用tcp_mem_schedule()来增
</span><span class='line'>&#9;&#9;&#9;加forward_alloc，当然，不是随便想加就可以加的，系统对整个TCP的内存使用有总的限制，即sysctl_tcp_mem[3]。也对每个sock
</span><span class='line'>&#9;&#9;&#9;的内存使用分别有限制，即sysctl_tcp_rmem[3]和sysctl_tcp_wmem[3]。只有满足这些限制（有一定的灵活性），forward_alloc才
</span><span class='line'>&#9;&#9;&#9;能增加。 当发现内存紧张的时候，还会调用tcp_mem_reclaim()来回收forward_alloc预先分配的配额。
</span><span class='line'>&#9;*/
</span><span class='line'>&#9;int rcvbuf;                    // 接受缓冲区的大小（按字节）
</span><span class='line'>&#9;int sndbuf;                    // 发送缓冲区的大小（按字节）
</span><span class='line'>&#9;atomic_t rmem_alloc;           // 接受队列中存放的数据的字节数
</span><span class='line'>&#9;atomic_t wmem_alloc;           // 发送队列中存放的数据的字节数
</span><span class='line'>&#9;int wmem_queued;               // 所有已经发送的数据的总字节数
</span><span class='line'>&#9;int forward_alloc;             // 预分配剩余字节数
</span><span class='line'>
</span><span class='line'>&#9;struct sk_buff_head receive_queue; // 接受队列
</span><span class='line'>&#9;struct sk_buff_head write_queue;   // 发送队列
</span><span class='line'>&#9;atomic_t omem_alloc;               // 在TCP分析中无须考虑 * "o" is "option" or "other" */
</span><span class='line'>
</span><span class='line'>&#9;__u32 saddr; /* 指真正的发送地址，这里需要注意的是，rcv_saddr是记录套接字所绑定的地址，其可能是广播或者
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;多播，对于我们要发送的包来说，只能使用接口的IP地址，而不能使用广播或者多播地址 */
</span><span class='line'>&#9;unsigned int allocation;       // 分配该sock之skb时选择的模式，GFP_ATOMIC还是GFP_KERNEL等等
</span><span class='line'>
</span><span class='line'>&#9;volatile char dead,            // tcp_close.tcp_listen_stop.inet_sock_release调用sock_orphan将该值置1，表示该socket已经和进程分开，变成孤儿
</span><span class='line'>&#9;&#9;&#9;&#9;done,              // 用于判断该socket是否已经收到 fin，如果收到则将该成员置1
</span><span class='line'>&#9;&#9;&#9;&#9;urginline,         // 如果该值被设置为1，表示将紧急数据放于普通数据流中一起处理，而不在另外处理
</span><span class='line'>&#9;&#9;&#9;&#9;keepopen,          // 是否启动保活定时器
</span><span class='line'>&#9;&#9;&#9;&#9;linger,            // lingertime一起，指明了close()后保留的时间
</span><span class='line'>&#9;&#9;&#9;&#9;destroy,           // 在TCP分析中无须考虑
</span><span class='line'>&#9;&#9;&#9;&#9;no_check,          // 是否对发出的skb做校验和，仅对UDP有效
</span><span class='line'>&#9;&#9;&#9;&#9;broadcast,         // 是否允许广播，仅对UPD有效
</span><span class='line'>&#9;&#9;&#9;&#9;bsdism;            // 在TCP分析中无须考虑
</span><span class='line'>&#9;unsigned char debug;           // 在TCP分析中无须考虑
</span><span class='line'>&#9;unsigned char rcvtstamp;       // 是否将收到skb的时间戳发送给app
</span><span class='line'>&#9;unsigned char use_write_queue; // 在init中该值被初始化为1，该值一直没有变化
</span><span class='line'>&#9;unsigned char userlocks;       // 包括如下几种值的组合，从而改变收包等操作的执行顺序
</span><span class='line'>&#9;#define SOCK_SNDBUF_LOCK 1
</span><span class='line'>&#9;#define SOCK_RCVBUF_LOCK 2
</span><span class='line'>&#9;#define SOCK_BINDADDR_LOCK 4
</span><span class='line'>&#9;#define SOCK_BINDPORT_LOCK 8
</span><span class='line'>&#9;int route_caps;                // 指示本sock用到的路由的信息
</span><span class='line'>&#9;int proc;                      // 保存用户线程的pid
</span><span class='line'>&#9;unsigned long lingertime;      // lingertime一起，指明了close()后保留的时间
</span><span class='line'>&#9;int hashent;                   // 存放4元的hash值
</span><span class='line'>&#9;struct sock *pair;             // 在TCP分析中无须考虑
</span><span class='line'>
</span><span class='line'>&#9;/* 一个进程也许会锁住socket导致该socket不能被改变。特别是这点意味着其甚至不能被驱动中断所改变，例如，
</span><span class='line'>&#9;&#9;到达的报会被堵塞，导致我们无法获取新的数据或者任何的状态改变。所以在这里，当socket被锁住的时候，中
</span><span class='line'>&#9;&#9;断处理可以将包往下面的backlog中添加*/
</span><span class='line'>&#9;struct {
</span><span class='line'>&#9;&#9;struct sk_buff *head;
</span><span class='line'>&#9;&#9;struct sk_buff *tail;
</span><span class='line'>&#9;} backlog;
</span><span class='line'>
</span><span class='line'>&#9;rwlock_t callback_lock;          // sock相关函数内部操作的保护锁
</span><span class='line'>&#9;struct sk_buff_head error_queue; // 错误报文的队列，很少使用
</span><span class='line'>&#9;struct proto *prot;              // 例如指向tcp_prot
</span><span class='line'>
</span><span class='line'>&#9;union {       // 私有TCP相关数据保存
</span><span class='line'>&#9;&#9;struct tcp_opt af_tcp;
</span><span class='line'>&#9;&#9;.............
</span><span class='line'>&#9;} tp_pinfo;
</span><span class='line'>
</span><span class='line'>&#9;int err,      // 保存各种错误，例如ECONNRESET Connection reset by peer，从而会影响到后续流程的处理
</span><span class='line'>&#9;&#9;err_soft; // 保存各种软错误，例如EPROTO Protocol error，从而会影响到后续流程的处理
</span><span class='line'>&#9;unsigned short ack_backlog;       // 当前已经accept的数目
</span><span class='line'>&#9;unsigned short max_ack_backlog;   // 当前listen sock能保留多少个待处理TCP连接.
</span><span class='line'>&#9;__u32 priority;                   /* Packet queueing priority，Used to set the TOS field. Packets with a higher priority may be processed first, depending on the device’s queueing discipline. See SO_PRIORITY */
</span><span class='line'>&#9;unsigned short type;              // 例如SOCK_STREAM，SOCK_DGRAM或者SOCK_RAW等
</span><span class='line'>&#9;unsigned char localroute;         // Route locally only if set – set by SO_DONTROUTE option.
</span><span class='line'>&#9;unsigned char protocol;           // socket(int family, int type, int protocol)中的protocol
</span><span class='line'>&#9;struct ucred peercred;            // 在TCP分析中无须考虑
</span><span class='line'>&#9;int rcvlowat;                     /* 声明在开始发送 数据 (SO_SNDLOWAT) 或正在接收数据的用户 (SO_RCVLOWAT) 传递数据之
</span><span class='line'>&#9;前缓冲区内的最小字节数. 在 Linux 中这两个值是不可改变的, 固定为 1 字节. */
</span><span class='line'>&#9;long rcvtimeo;                    // 接收时的超时设定, 并在超时时报错
</span><span class='line'>&#9;long sndtimeo;                    // 发送时的超时设定, 并在超时时报错
</span><span class='line'>
</span><span class='line'>&#9;union {       // 私有inet相关数据保存
</span><span class='line'>&#9;&#9;struct inet_opt af_inet;
</span><span class='line'>&#9;&#9;.................
</span><span class='line'>&#9;} protinfo;
</span><span class='line'>
</span><span class='line'>&#9;/* the timer is used for SO_KEEPALIVE (i.e. sending occasional keepalive probes to a remote site – by default, set to 2 hours in
</span><span class='line'>&#9;stamp is simply the time that the last packet was received. */
</span><span class='line'>&#9;struct timer_list timer;
</span><span class='line'>&#9;struct timeval stamp;
</span><span class='line'>&#9;struct socket *socket; // 对应的socket
</span><span class='line'>&#9;void *user_data;       // 私有数据，在TCP分析中无须考虑
</span><span class='line'>
</span><span class='line'>&#9;/* The state_change operation is called whenever the status of the socket is changed. Similarly, data_ready is called
</span><span class='line'>&#9;&#9;when data have been received, write_space when free memory available for writing has increased and error_report
</span><span class='line'>&#9;&#9;when an error occurs, backlog_rcv when socket locked, putting skb to backlog, destruct for release this sock*/
</span><span class='line'>&#9;void (*state_change)(struct sock *sk);
</span><span class='line'>&#9;void (*data_ready)(struct sock *sk,int bytes);
</span><span class='line'>&#9;void (*write_space)(struct sock *sk);
</span><span class='line'>&#9;void (*error_report)(struct sock *sk);
</span><span class='line'>&#9;int (*backlog_rcv) (struct sock *sk, struct sk_buff *skb);
</span><span class='line'>&#9;void (*destruct)(struct sock *sk);
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>struct inet_opt
</span><span class='line'>{
</span><span class='line'>&#9;int ttl;                    // IP的TTL设置
</span><span class='line'>&#9;int tos;                    // IP的TOS设置
</span><span class='line'>&#9;unsigned cmsg_flags;        // 该标志用来决定是否向应用层打印相关信息，包括如下可能的值
</span><span class='line'>&#9;#define IP_CMSG_PKTINFO 1
</span><span class='line'>&#9;#define IP_CMSG_TTL 2
</span><span class='line'>&#9;#define IP_CMSG_TOS 4
</span><span class='line'>&#9;#define IP_CMSG_RECVOPTS 8
</span><span class='line'>&#9;#define IP_CMSG_RETOPTS 16
</span><span class='line'>&#9;struct ip_options *opt;     // IP选项，包括安全和处理限制、记录路径、时间戳、宽松的源站选路、严格的源站选路
</span><span class='line'>&#9;unsigned char hdrincl;      // 用于RAW
</span><span class='line'>&#9;__u8 mc_ttl;                // 多播TTL
</span><span class='line'>&#9;__u8 mc_loop;               // 多播回环
</span><span class='line'>&#9;unsigned recverr : 1,       // 是否允许传递扩展的可靠的错误信息.
</span><span class='line'>&#9;freebind : 1;               // 是否允许socket被绑定
</span><span class='line'>&#9;__u16 id;                   // 用于禁止分片的IP包的ID计数
</span><span class='line'>&#9;__u8 pmtudisc;              // 路径MTU发现
</span><span class='line'>&#9;int mc_index;               // 多播设备索引
</span><span class='line'>&#9;__u32 mc_addr;              // 自己的多播地址
</span><span class='line'>&#9;struct ip_mc_socklist *mc_list; // 多播组
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct tcp_opt {
</span><span class='line'>&#9;int tcp_header_len;         // tcp首部长度（包括选项）
</span><span class='line'>&#9;__u32 pred_flags; /* 首部预测标志，在syn_rcv、syn_sent、更新窗口或其他恰当的时候，设置pred_flags（主要
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;是创建出不符合快速路径的条件，一般值为0x??10 &lt;&lt; 16 + snd_wnd）?所对应的值不确定，
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;在连接完毕之后，根据pred_flags以及其他因素来确定是否走快速路径。*/
</span><span class='line'>
</span><span class='line'>&#9;__u32 rcv_nxt;              // 期望接受到的下一个tcp包的seq
</span><span class='line'>&#9;__u32 snd_nxt;              // 要发送的下一个tcp包的seq
</span><span class='line'>&#9;__u32 snd_una;              // 表示最近一个尚未确认的但是已经发送过的报文的seq
</span><span class='line'>&#9;__u32 snd_sml;              // 最近发送的小包的最后一个字节数，主要用于Nagle算法
</span><span class='line'>&#9;__u32 rcv_tstamp;           // 最近收到的ACK的时间，用于保活
</span><span class='line'>&#9;__u32 lsndtime;             // 最近发送的数据包的时间，用于窗口restart
</span><span class='line'>
</span><span class='line'>&#9;/* 经受时延的确认的控制 */
</span><span class='line'>&#9;struct {
</span><span class='line'>&#9;&#9;__u8 pending;           /* 正处于ACK延时状态，包括如下几种状态 ACK is pending */
</span><span class='line'>&#9;&#9;enum tcp_ack_state_t
</span><span class='line'>&#9;&#9;{
</span><span class='line'>&#9;&#9;&#9;TCP_ACK_SCHED = 1,
</span><span class='line'>&#9;&#9;&#9;TCP_ACK_TIMER = 2,
</span><span class='line'>&#9;&#9;&#9;TCP_ACK_PUSHED= 4
</span><span class='line'>&#9;&#9;};
</span><span class='line'>&#9;&#9;__u8 quick;            /* 快速恢复算法时，用于决定是否需要重传的收到的重复ACK的最大数目 Scheduled number of quick acks */
</span><span class='line'>&#9;&#9;__u8 pingpong;         /* 当前该TCP会话处于交互状态（非延时ACK状态）The session is interactive */
</span><span class='line'>&#9;&#9;__u8 blocked;          /* 当前socket被锁住了，这时候延时的ACK不再等待，而是立即发送 Delayed ACK was blocked by socket lock*/]
</span><span class='line'>&#9;&#9;/*Adaptive Time-Out (ATO) is the time that must elapse before an acknowledgment is considered lost. RFC 2637*/
</span><span class='line'>&#9;&#9;__u32 ato;             /* 软件时钟的预测嘀嗒数目 Predicted tick of soft clock */
</span><span class='line'>&#9;&#9;unsigned long timeout; /* 当前延时确认的定时器时间 Currently scheduled timeout */
</span><span class='line'>&#9;&#9;__u32 lrcvtime;        /* 最后收到的数据报的时间戳 timestamp of last received data packet*/
</span><span class='line'>&#9;&#9;__u16 last_seg_size;   /* 最后收到的数据报的大小 Size of last incoming segment */
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9;1. tp-&gt;advmss：The MSS advertised by the host. This is initialised in the function tcp_advertise_mss, from the routing table's destination cache(dst-&gt;advmss).
</span><span class='line'>Given that the cached entry is calculated from the MTU (maximum transfer unit) of the next hop, this will have a value of 1460 over Ethernet.
</span><span class='line'>
</span><span class='line'>&#9;&#9;2. tp-&gt;ack.rcv_mss：A lower-bound estimate of the peer's MSS. This is initiated in tcp_initialize_rcv mss, and updated whenever a segment is received by
</span><span class='line'>tcp measure rcv mss.
</span><span class='line'>
</span><span class='line'>&#9;&#9;3. tp-&gt;mss_cache：The current effective sending MSS, which is calculated in the function tcp_sync_mss. When the socket is created, it is initialised to 536 by
</span><span class='line'>tcp_v4_init_sock. Note that these are the only functions that alter the value of tp-&gt;mss cache.
</span><span class='line'>
</span><span class='line'>&#9;&#9;4. tp-&gt;mss clamp：An upper-bound value of the MSS of the connection. This is negotiated at connect(), such that it is the minimum of the MSS values advertised
</span><span class='line'>by the two hosts.We will never see a segment larger than this.
</span><span class='line'>*/
</span><span class='line'>&#9;&#9;__u16 rcv_mss;    /* 属于点到点的mss，用于延时确认 MSS used for delayed ACK decisions */
</span><span class='line'>&#9;} ack;
</span><span class='line'>
</span><span class='line'>&#9;__u16 mss_cache;      // 当前提供的有效mss， /* Cached effective mss, not including SACKS */
</span><span class='line'>&#9;__u16 mss_clamp;      // 最大mss，连接建立时协商的mss或者用户通过ioctl指定的mss的两者之中最大值
</span><span class='line'>&#9;/* Maximal mss, negotiated at connection setup */
</span><span class='line'>&#9;__u16 advmss;         /* MTU包括路径MTU，这里的advmss是本机告知周围网关的我自身的mss */
</span><span class='line'>
</span><span class='line'>&#9;/* 用于直接拷贝给应用层的数据，当用户正在读取该套接字时, TCP包将被排入套接字的预备队列(tcp_prequeue ())，将其
</span><span class='line'>&#9;传递到该用户线程上下文中进行处理. */
</span><span class='line'>&#9;struct {
</span><span class='line'>&#9;&#9;struct sk_buff_head prequeue; // 当前预备队列
</span><span class='line'>&#9;&#9;struct task_struct *task;     // 当前线程
</span><span class='line'>&#9;&#9;struct iovec *iov;            // 用户空间接受数据的地址
</span><span class='line'>&#9;&#9;int memory;                   // 当前预备队列中的包总字节数目
</span><span class='line'>&#9;&#9;int len;                      // 用户进程从预备队列中读取的数据字节数
</span><span class='line'>&#9;} ucopy;
</span><span class='line'>
</span><span class='line'>&#9;__u32 snd_wl1;        // 收到对方返回的skb，记下该包的seq号，用于判断窗口是否需要更新 /* Sequence for window update */
</span><span class='line'>&#9;__u32 snd_wnd;        // 记录对方提供的窗口大小 /* The window we expect to receive */
</span><span class='line'>&#9;__u32 max_window;     // 对方曾经提供的最大窗口 /* Maximal window ever seen from peer */
</span><span class='line'>&#9;__u32 pmtu_cookie;    // 将发送mss和当前的pmtu/exthdr设置同步 /* Last pmtu seen by socket */
</span><span class='line'>&#9;__u16 ext_header_len; // 网络层协议选项长度 /* Network protocol overhead (IP/IPv6 options) */
</span><span class='line'>&#9;__u8 ca_state;        // 快速重传状态机 /* State of fast-retransmit machine */
</span><span class='line'>&#9;enum tcp_ca_state
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;TCP_CA_Open = 0,
</span><span class='line'>&#9;&#9;TCP_CA_Disorder = 1,
</span><span class='line'>&#9;&#9;TCP_CA_CWR = 2,
</span><span class='line'>&#9;&#9;TCP_CA_Recovery = 3,
</span><span class='line'>&#9;&#9;TCP_CA_Loss = 4
</span><span class='line'>&#9;};
</span><span class='line'>&#9;/* RFC 1122指出，TCP实现必须包括Karn和Jacobson实现计算重传超时（retransmission timeout：RTO）的算法 */
</span><span class='line'>&#9;__u8 retransmits; // 某个还没有被确认的发送TCP包重传的次数 /* Number of unrecovered RTO timeouts. */
</span><span class='line'>
</span><span class='line'>&#9;/* 当收到下面数量的重复ack时，快速重传开始，而无需等待重传定时器超时 */
</span><span class='line'>&#9;__u8 reordering; /* Packet reordering metric. */
</span><span class='line'>
</span><span class='line'>&#9;/* 当我们发出一个tcp包之后，并不立刻释放掉该包，而是等待其对应的ack到来，如果这时候ack来了，那么我们将从
</span><span class='line'>&#9;write_queue队列中释放掉该包，同时将该事件的标志记录在tp-&gt;queue_shrunk中，如果原来进程由于write_queue中没
</span><span class='line'>&#9;有足够的空间继续发送数据而休眠的话，那么此时将会唤醒其对应的sock，从而进程可以继续发送数据 */
</span><span class='line'>&#9;__u8 queue_shrunk; /* Write queue has been shrunk recently.*/
</span><span class='line'>&#9;__u8 defer_accept; // 请参考附录1 /* User waits for some data after accept() */
</span><span class='line'>
</span><span class='line'>&#9;/* 往返时间测量 RTT，有关RTT的侧量这里不再详细讨论measurement ：Round-Trip Time (RTT) is the estimated round-trip time for an Acknowledgment to be received for a
</span><span class='line'>given transmitted packet. When the network link is a local network, this delay will be minimal (if not zero). When the network link is
</span><span class='line'>the Internet, this delay could be substantial and vary widely. RTT is adaptive. */
</span><span class='line'>&#9;__u8 backoff;         /* backoff */
</span><span class='line'>&#9;__u32 srtt;           /* smothed round trip time &lt;&lt; 3 */
</span><span class='line'>&#9;__u32 mdev;           /* medium deviation */
</span><span class='line'>&#9;__u32 mdev_max;       /* maximal mdev for the last rtt period */
</span><span class='line'>&#9;__u32 rttvar;         /* smoothed mdev_max */
</span><span class='line'>&#9;__u32 rtt_seq;        /* sequence number to update rttvar */
</span><span class='line'>&#9;__u32 rto;            /* 重传超时时间 retransmit timeout */
</span><span class='line'>
</span><span class='line'>&#9;__u32 packets_out;    /* 已经发出去的数目 Packets which are "in flight" */
</span><span class='line'>&#9;__u32 left_out;       /* 发出去已经被确认的数目 Packets which leaved network */
</span><span class='line'>&#9;__u32 retrans_out;    /* 重传的发出去的包数目 Retransmitted packets out */
</span><span class='line'>
</span><span class='line'>&#9;// 慢启动和拥塞控制 Slow start and congestion control (see also Nagle, and Karn & Partridge)
</span><span class='line'>&#9;__u32 snd_ssthresh;   // 拥塞控制时的慢启动门限 /* Slow start size threshold */
</span><span class='line'>&#9;__u32 snd_cwnd;       // 当前采用的拥塞窗口 /* Sending congestion window */
</span><span class='line'>&#9;__u16 snd_cwnd_cnt;   // 线形增加的拥塞窗口计数器 /* Linear increase counter */
</span><span class='line'>&#9;__u16 snd_cwnd_clamp; // 拥塞窗口的最大值（一般为对方通告的窗口大小） /* Do not allow snd_cwnd to grow above this */
</span><span class='line'>&#9;__u32 snd_cwnd_used;  // 慢启动，每发出去一个包，snd_cwnd_used++
</span><span class='line'>&#9;__u32 snd_cwnd_stamp; // 该参数可以保证在重传模式下不会改变拥塞窗口的大小 */
</span><span class='line'>
</span><span class='line'>&#9;/* 重传定时器和延时确认定时器 Two commonly used timers in both sender and receiver paths. */
</span><span class='line'>&#9;unsigned long timeout;// 用于重传
</span><span class='line'>&#9;struct timer_list retransmit_timer;     /* Resend (no ack) */
</span><span class='line'>&#9;struct timer_list delack_timer;         /* Ack delay */
</span><span class='line'>&#9;struct sk_buff_head out_of_order_queue; // 乱序的TCP报都存放在该队列中 /* Out of order segments go here */
</span><span class='line'>
</span><span class='line'>&#9;struct tcp_func *af_specific;           // ipv4/ipv6 相关特定处理函数 /* Operations which are AF_INET{4,6} specific */
</span><span class='line'>&#9;struct tcp_func ipv4_specific = {
</span><span class='line'>&#9;&#9;ip_queue_xmit,
</span><span class='line'>&#9;&#9;tcp_v4_send_check,
</span><span class='line'>&#9;&#9;tcp_v4_rebuild_header,
</span><span class='line'>&#9;&#9;tcp_v4_conn_request,
</span><span class='line'>&#9;&#9;tcp_v4_syn_recv_sock,
</span><span class='line'>&#9;&#9;tcp_v4_remember_stamp,
</span><span class='line'>&#9;&#9;sizeof(struct iphdr),
</span><span class='line'>
</span><span class='line'>&#9;&#9;ip_setsockopt,
</span><span class='line'>&#9;&#9;ip_getsockopt,
</span><span class='line'>&#9;&#9;v4_addr2sockaddr,
</span><span class='line'>&#9;&#9;sizeof(struct sockaddr_in)
</span><span class='line'>&#9;};
</span><span class='line'>&#9;struct sk_buff *send_head;  // 最先要发送的TCP报文 /* Front of stuff to transmit */
</span><span class='line'>&#9;struct page *sndmsg_page;   // sendmsg所使用的缓冲内存页面 /* Cached page for sendmsg */
</span><span class='line'>&#9;u32 sndmsg_off;             // sendmsg所使用的缓冲偏移 /* Cached offset for sendmsg */
</span><span class='line'>
</span><span class='line'>&#9;__u32 rcv_wnd;              // 当前接受窗口 /* Current receiver window */
</span><span class='line'>&#9;__u32 rcv_wup;              // 对方窗口最后一次更新时的rcv_nxt /* rcv_nxt on last window update sent */
</span><span class='line'>&#9;__u32 write_seq;            // tcp发送总数据字节量+1 /* Tail(+1) of data held in tcp send buffer */
</span><span class='line'>&#9;__u32 pushed_seq;           // 上次发送带PSH标志的TCP包的seq /* Last pushed seq, required to talk to windows */
</span><span class='line'>&#9;__u32 copied_seq;           // 尚未读取的数据第一个字节位置 /* Head of yet unread data */
</span><span class='line'>
</span><span class='line'>&#9;// Options received (usually on last packet, some only on SYN packets).
</span><span class='line'>&#9;char tstamp_ok,        /* syn包上的时间戳 TIMESTAMP seen on SYN packet */
</span><span class='line'>&#9;wscale_ok,             /* SACK选项处理Kind=5不再详细叙说 Wscale seen on SYN packet */
</span><span class='line'>&#9;sack_ok;               /* SACK选项处理Kind=5不再详细叙说 SACK seen on SYN packet */
</span><span class='line'>&#9;char saw_tstamp;       /* 最后一个TCP包的时间戳 Saw TIMESTAMP on last packet */
</span><span class='line'>&#9;__u8 snd_wscale;       /* 接受窗口扩大因子 Window scaling received from sender */
</span><span class='line'>&#9;__u8 rcv_wscale;       /* 发送窗口扩大因子 Window scaling to send to receiver */
</span><span class='line'>&#9;__u8 nonagle;          /* 是否允许Nagle算法 Disable Nagle algorithm? */
</span><span class='line'>&#9;__u8 keepalive_probes; /* 保活探测的数量 num of allowed keep alive probes */
</span><span class='line'>
</span><span class='line'>&#9;/* PAWS：防止回绕的序号，不再详细叙说 PAWS/RTTM data */
</span><span class='line'>&#9;__u32 rcv_tsval;       /* Time stamp value */
</span><span class='line'>&#9;__u32 rcv_tsecr;       /* Time stamp echo reply */
</span><span class='line'>&#9;__u32 ts_recent;       /* Time stamp to echo next */
</span><span class='line'>&#9;long ts_recent_stamp;  /* Time we stored ts_recent (for aging) */
</span><span class='line'>
</span><span class='line'>&#9;/* SACK选项处理Kind=5不再详细叙说 SACKs data1 */
</span><span class='line'>&#9;__u16 user_mss;        /* 用户通过ioctl指定的mssmss requested by user in ioctl */
</span><span class='line'>&#9;__u8 dsack;            /* D-SACK is scheduled */
</span><span class='line'>&#9;__u8 eff_sacks;        /* Size of SACK array to send with next packet */
</span><span class='line'>&#9;struct tcp_sack_block duplicate_sack[1]; /* D-SACK block */
</span><span class='line'>&#9;struct tcp_sack_block selective_acks[4]; /* The SACKS themselves*/
</span><span class='line'>
</span><span class='line'>&#9;/* 通告窗口(advertised window，tp-&gt;tcv_wnd)，window_clamp是最大的通告窗口，说白了就是
</span><span class='line'>&#9;应用程序的缓冲区真实大小。rcv_ssthresh是更为严格的window_clamp，主要用于慢启动期间
</span><span class='line'>&#9;预测连接的行为 */
</span><span class='line'>&#9;__u32 window_clamp;   /* Maximal window to advertise */
</span><span class='line'>&#9;__u32 rcv_ssthresh;   /* Current window clamp */
</span><span class='line'>
</span><span class='line'>&#9;__u8 probes_out;      /* 用于零窗口探测 unanswered 0 window probes */
</span><span class='line'>&#9;__u8 num_sacks;       /* Number of SACK blocks */
</span><span class='line'>
</span><span class='line'>&#9;__u8 syn_retries;     /* syn重试次数 num of allowed syn retries */
</span><span class='line'>&#9;__u8 ecn_flags;       /* 显式拥塞通知状态位，不再详叙 ECN status bits. */
</span><span class='line'>&#9;__u16 prior_ssthresh; /* 在经过重传后恢复时的ssthresh保存值 ssthresh saved at recovery start */
</span><span class='line'>
</span><span class='line'>&#9;/* SACK选项处理Kind=5不再详细叙说 SACKs data2 */
</span><span class='line'>&#9;__u32 lost_out;       /* Lost packets */
</span><span class='line'>&#9;__u32 sacked_out;     /* SACK'd packets */
</span><span class='line'>&#9;__u32 fackets_out;    /* FACK'd packets */
</span><span class='line'>&#9;__u32 high_seq;       /* snd_nxt at onset of congestion */
</span><span class='line'>
</span><span class='line'>&#9;__u32 retrans_stamp;  // 上次重传的时间，其也会记住第一个syn的时间戳
</span><span class='line'>&#9;__u32 undo_marker;    /* 开始跟踪重传的标示符 tracking retrans started here. */
</span><span class='line'>&#9;int undo_retrans;     /* 用于Undo冗余的重传 number of undoable retransmissions. */
</span><span class='line'>&#9;__u32 urg_seq;        /* 紧急指针的seq Seq of received urgent pointer */
</span><span class='line'>&#9;__u16 urg_data;       /* 紧急指针的相关控制标志保存 Saved octet of OOB data and control flags */
</span><span class='line'>&#9;__u8 pending;         /* 确定定时器的事件 Scheduled timer event，包括如下四种情况 */
</span><span class='line'>&#9;#define TCP_TIME_RETRANS 1  /* Retransmit timer */
</span><span class='line'>&#9;#define TCP_TIME_DACK 2     /* Delayed ack timer */
</span><span class='line'>&#9;#define TCP_TIME_PROBE0 3   /* Zero window probe timer */
</span><span class='line'>&#9;#define TCP_TIME_KEEPOPEN 4 /* Keepalive timer */
</span><span class='line'>
</span><span class='line'>&#9;__u8 urg_mode;        /* 是否处于紧急模式 In urgent mode */
</span><span class='line'>&#9;__u32 snd_up;         /* 紧急指针位置 Urgent pointer */
</span><span class='line'>
</span><span class='line'>&#9;/* The syn_wait_lock is necessary only to avoid tcp_get_info having to grab the main lock sock while browsing the listening hash
</span><span class='line'>&#9; * (otherwise it's deadlock prone). This lock is acquired in read mode only from tcp_get_info() and it's acquired in write mode _only_ from
</span><span class='line'>&#9; * code that is actively changing the syn_wait_queue. All readers that are holding the master sock lock don't need to grab this lock in read
</span><span class='line'>&#9; * mode too as the syn_wait_queue writes are always protected from the main sock lock.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;rwlock_t syn_wait_lock;
</span><span class='line'>&#9;struct tcp_listen_opt *listen_opt;
</span><span class='line'>
</span><span class='line'>&#9;/* 服务器段listening socket的已经建立的子socket FIFO队列 FIFO of established children */
</span><span class='line'>&#9;struct open_request *accept_queue;
</span><span class='line'>&#9;struct open_request *accept_queue_tail;
</span><span class='line'>
</span><span class='line'>&#9;int write_pending;             /* 是否有对socket的写请求 A write to socket waits to start. */
</span><span class='line'>&#9;unsigned int keepalive_time;   /* 保活定时器启动的时间阀值 time before keep alive takes place */
</span><span class='line'>&#9;unsigned int keepalive_intvl;  /* 保活探测时间间隔 time interval between keep alive probes */
</span><span class='line'>&#9;int linger2;                   // lingertime一起，指明了close()后保留的时间
</span><span class='line'>&#9;int frto_counter;              /* 开始重传后的新的ack数目 Number of new acks after RTO */
</span><span class='line'>&#9;__u32 frto_highmark;           /* 重传发生时的要发送的下一个tcp包的seq snd_nxt when RTO occurred */
</span><span class='line'>
</span><span class='line'>&#9;unsigned long last_synq_overflow; // 用于syn_cookie处理
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>/*
附录1：
The first option we&rsquo;ll consider is TCP_DEFER_ACCEPT. (This is what it&rsquo;s called in Linux; other OSs offer the same option but use different names.)
To understand the idea of the TCP_DEFER_ACCEPT option, it is necessary to picture a typical process of the HTTP client-server interaction. Consider
how the TCP establishes a connection with the goal of transferring data. On a network, information travels in discrete units called IP packets (or IP
datagrams). A packet always has a header that carries service information, used for internal protocol handling, and it may also carry payload data. A
typical example of service information is a set of so-called flags, which mark the packets as having special meaning to a TCP/IP stack, such as
acknowledgement of successful packet receiving. Often, it&rsquo;s possible to carry payload in the “marked” packet, but sometimes, internal logic forces a
TCP/IP stack to send out packets with just a header. These packets often introduce unwanted delays and increased overhead and result in overall
performance degradation.</p>

<p>The server has now created a socket and is waiting for a connection. The connection procedure in TCP/IP is a so-called “three-way handshake.” First,
a client sends a TCP packet with a SYN flag set and no payload (a SYN packet). The server replies by sending a packet with SYN/ACK flags set (a
SYN/ACK packet) to acknowledge receipt of the initial packet. The client then sends an ACK packet to acknowledge receipt of the second packet and to
finalize the connection procedure. After receiving the SYN/ACK, the packet server wakes up a receiver process while waiting for data. When the three-way
handshake is completed, the client starts to send “useful” data to be transferred to the server. Usually, an HTTP request is quite small and fits into a single
packet. But in this case, at least four packets will be sent in both directions, adding considerable delay times. Note also that the receiver has already been
waiting for the information—since before the data was ever sent.</p>

<p>To alleviate these problems, Linux (along with some other OSs) includes a TCP_DEFER_ACCEPT option in its TCP implementation. Set on a server-side
listening socket, it instructs the kernel not to wait for the final ACK packet and not to initiate the process until the first packet of real data has arrived. After
sending the SYN/ACK, the server will then wait for a data packet from a client. Now, only three packets will be sent over the network, and the connection
establishment delay will be significantly reduced, which is typical for HTTP.</p>

<p>This feature, called an “accept filter” , is used in different ways, although in all cases, the effect is the same as TCP_DEFER_ACCEPT—the server
will not wait for the final ACK packet, waiting only for a packet carrying a payload. More information about this option and its significance for a high-performance
Web server is available in the Apache documentation.
*/</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/09/kernel-net-listen/">socket监听连接 sys_listen</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-09T17:50:00+08:00'><span class='date'>2015-06-09</span> <span class='time'>17:50:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/justlinux2010/article/details/8597498">http://blog.csdn.net/justlinux2010/article/details/8597498</a></p>

<p>listen()函数仅在TCP服务器端调用，它做两个事情：将套接字转换到LISTEN状态和设置套接上的最大连接队列。listen()对应的内核实现为sys_listen()，下面开始对其实现作具体的分析。</p>

<h4>一、sys_listen()函数</h4>

<p>sys_listen()的源码实现及分析如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 
</span><span class='line'> *  Perform a listen. Basically, we allow the protocol to do anything 
</span><span class='line'> *  necessary for a listen, and if that works, we mark the socket as 
</span><span class='line'> *  ready for listening. 
</span><span class='line'> */  
</span><span class='line'>
</span><span class='line'>SYSCALL_DEFINE2(listen, int, fd, int, backlog)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct socket *sock;  
</span><span class='line'>&#9;int err, fput_needed;  
</span><span class='line'>&#9;int somaxconn;  
</span><span class='line'>  
</span><span class='line'>&#9;sock = sockfd_lookup_light(fd, &err, &fput_needed);  
</span><span class='line'>&#9;if (sock) {  
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * sysctl_somaxconn存储的是服务器监听时，允许每个套接字连接队列长度  
</span><span class='line'>&#9;&#9; * 的最大值，默认值是SOMAXCONN，即128，在sysctl_core_net_init()函数中初始化。 
</span><span class='line'>&#9;&#9; * 在proc文件系统中可以通过修改/proc/sys/net/core/somaxconn文件来修改这个值。 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;  
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * 如果指定的最大连接数超过系统限制，则使用系统当前允许的连接队列 
</span><span class='line'>&#9;&#9; * 中连接的最大数。 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;if ((unsigned)backlog &gt; somaxconn)  
</span><span class='line'>&#9;&#9;&#9;backlog = somaxconn;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;err = security_socket_listen(sock, backlog);  
</span><span class='line'>&#9;&#9;if (!err)  
</span><span class='line'>&#9;&#9;&#9;/* 
</span><span class='line'>&#9;&#9;&#9; * 如果是TCP套接字，sock-&gt;ops指向的是inet_stream_ops， 
</span><span class='line'>&#9;&#9;&#9; * sock-&gt;ops是在inet_create()函数中初始化，所以listen接口 
</span><span class='line'>&#9;&#9;&#9; * 调用的是inet_listen()函数。 
</span><span class='line'>&#9;&#9;&#9; */  
</span><span class='line'>&#9;&#9;&#9;err = sock-&gt;ops-&gt;listen(sock, backlog);  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;fput_light(sock-&gt;file, fput_needed);  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;return err;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>sys_listen()的代码流程图如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;sys_listen()
</span><span class='line'>&#9;&#9;|
</span><span class='line'>&#9;&#9;|---&gt; sockfd_lookup_light()
</span><span class='line'>&#9;&#9;|
</span><span class='line'>&#9;&#9;|---&gt; 确定最大连接队列
</span><span class='line'>&#9;&#9;|
</span><span class='line'>&#9;&#9; ---&gt; inet_listen()</span></code></pre></td></tr></table></div></figure>


<p>sys_listen()的代码流程和sys_bind()很像，都是先调用sockfd_lookup_light()获取描述符对应的socket实例，然后通过调用sock->ops中的操作接口来完成真正的操作。接下来看这段代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ((unsigned)backlog &gt; somaxconn)  
</span><span class='line'>&#9;&#9;&#9;backlog = somaxconn;  </span></code></pre></td></tr></table></div></figure>


<p>这里可以看出，如果指定的最大连接队列数超过系统限制，会使用系统中设置的最大连接队列数。所以，如果想扩大套接字的连接队列，只调整listen()的backlog参数是没用的，还要修改系统的设置才行。</p>

<h4>二、inet_listen()函数</h4>

<p>inet_listen()的源码实现及分析如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 
</span><span class='line'> *  Move a socket into listening state. 
</span><span class='line'> */  
</span><span class='line'>/* 
</span><span class='line'> * inet_listen()函数为listen系统调用套接字层的实现。 
</span><span class='line'> */  
</span><span class='line'>int inet_listen(struct socket *sock, int backlog)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct sock *sk = sock-&gt;sk;  
</span><span class='line'>&#9;unsigned char old_state;  
</span><span class='line'>&#9;int err;  
</span><span class='line'>  
</span><span class='line'>&#9;lock_sock(sk);  
</span><span class='line'>  
</span><span class='line'>&#9;err = -EINVAL;  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 检测调用listen的套接字的当前状态和类型。如果套接字状态 
</span><span class='line'>&#9; * 不是SS_UNCONNECTED，或套接字类型不是SOCK_STREAM，则不 
</span><span class='line'>&#9; * 允许进行监听操作，返回相应错误码 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (sock-&gt;state != SS_UNCONNECTED || sock-&gt;type != SOCK_STREAM)  
</span><span class='line'>&#9;&#9;goto out;  
</span><span class='line'>  
</span><span class='line'>&#9;old_state = sk-&gt;sk_state;  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 检查进行listen调用的传输控制块的状态。如果该传输控制块不在 
</span><span class='line'>&#9; * 在TCPF_CLOSE或TCPF_LISTEN状态，则不能进行监听操作，返回 
</span><span class='line'>&#9; * 相应错误码 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (!((1 &lt;&lt; old_state) & (TCPF_CLOSE | TCPF_LISTEN)))  
</span><span class='line'>&#9;&#9;goto out;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Really, if the socket is already in listen state 
</span><span class='line'>&#9; * we can only allow the backlog to be adjusted. 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 如果传输控制块不在LISTEN状态，则调用inet_csk_listen_start() 
</span><span class='line'>&#9; * 进行监听操作。最后，无论是否在LISTEN状态都需要设置传输控制块 
</span><span class='line'>&#9; * 的连接队列长度的上限。从这里可以看出，可以通过调用listen() 
</span><span class='line'>&#9; * 来修改最大连接队列的长度。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (old_state != TCP_LISTEN) {  
</span><span class='line'>&#9;&#9;err = inet_csk_listen_start(sk, backlog);  
</span><span class='line'>&#9;&#9;if (err)  
</span><span class='line'>&#9;&#9;&#9;goto out;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;sk-&gt;sk_max_ack_backlog = backlog;  
</span><span class='line'>&#9;err = 0;  
</span><span class='line'>  
</span><span class='line'>out:  
</span><span class='line'>&#9;release_sock(sk);  
</span><span class='line'>&#9;return err;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>inet_listen()首先检查套接字的状态及类型，如果状态和类型不适合进行listen操作，则返回EINVAL错误。如果套接字的当前状态不是LISTEN状态，则调用inet_csk_listen_start()来分配管理接收队列的内存，并且将套接字状态转换为LISTEN状态。如果套接字状态已经是LISTEN状态，则只修改套接字中sk_max_ack_backlog成员，即连接队列的上限。从这里可以看出，可以通过调用listen()来修改连接队列的上限。但是这里有一个问题，假设套接的当前状态是LISTEN状态，连接队列的长度是100，这时调用listen()来将连接队列的长度修改为1024（假设已修改/proc/sys/net/core/somaxconn文件提高系统限制），但从代码看来并没有调用inet_csk_listen_start()来重新分配管理连接队列的内存，管理连接队列的内存没有变化，是不是会没有效果呢？其实不然，inet_csk_listen_start()中分配的内存除了listen_sock管理结构外，用作半连接队列的哈希表槽位。哈希表中可以容纳的元素个数和listen()中的backlog参数有关（和系统设置有关，还会对齐到2的整数次幂），和哈希表的槽位个数是没有关系的，参见reqsk_queue_alloc()函数。</p>

<p>下面来看这行代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sk-&gt;sk_max_ack_backlog = backlog;  </span></code></pre></td></tr></table></div></figure>


<p>其中sk_max_ack_backlog存储的是套接字的连接队列的上限，即accept队列的上限，但是这个上限值并不意味着连接队列中只能有sk_max_ack_backlog指定的数量。还有一个地方需要说明的是，《Unix网络编程》中讲到listen()时，说第二个参数的值是半连接队列和连接队列的个数之和，但是在linux中不是这样的，简单地说，listen()的第二个参数既是半连接队列的长度，也是连接队列的长度，并不是两者的和。这样说不太准确，后面会专门写一篇关于listen()的第二个参数backlog的分析。</p>

<h4>三、inet_csk_listen_start()函数</h4>

<p>inet_csk_listen_start()的源码实现及分析如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 
</span><span class='line'> * 使TCP传输控制块进入监听状态，实现监听状态:为管理连接 
</span><span class='line'> * 请求块的散列表分配存储空间，接着使TCP传输控制块的状态 
</span><span class='line'> * 迁移到LISTEN状态，然后将传输控制块添加到监听散列表中。 
</span><span class='line'> * @nr_table_entries:允许连接的队列长度上限，通过此值 
</span><span class='line'> *                   合理计算出存储连接请求块的散列表大小 
</span><span class='line'> */  
</span><span class='line'>int inet_csk_listen_start(struct sock *sk, const int nr_table_entries)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct inet_sock *inet = inet_sk(sk);  
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 为管理连接请求块的散列表分配存储空间，如果分配失败则返回 
</span><span class='line'>&#9; * 相应错误码 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;int rc = reqsk_queue_alloc(&icsk-&gt;icsk_accept_queue, nr_table_entries);  
</span><span class='line'>  
</span><span class='line'>&#9;if (rc != 0)  
</span><span class='line'>&#9;&#9;return rc;  
</span><span class='line'>  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 初始化连接队列长度上限，清除当前已建立连接数 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;sk-&gt;sk_max_ack_backlog = 0;  
</span><span class='line'>&#9;sk-&gt;sk_ack_backlog = 0;  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 初始化传输控制块中与延时发送ACK段有关的控制数据结构icsk_ack 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;inet_csk_delack_init(sk);  
</span><span class='line'>  
</span><span class='line'>&#9;/* There is race window here: we announce ourselves listening, 
</span><span class='line'>&#9; * but this transition is still not validated by get_port(). 
</span><span class='line'>&#9; * It is OK, because this socket enters to hash table only 
</span><span class='line'>&#9; * after validation is complete. 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 设置传输控制块状态为监听状态 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;sk-&gt;sk_state = TCP_LISTEN;  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 调用的是inet_csk_get_port()，如果没有绑定端口，则进行绑定 
</span><span class='line'>&#9; * 端口操作；如果已经绑定了端口，则对绑定的端口进行校验。绑定 
</span><span class='line'>&#9; * 或校验端口成功后，根据端口号在传输控制块中设置网络字节序的 
</span><span class='line'>&#9; * 端口号成员，然后再清除缓存在传输控制块中的目的路由缓存，最后 
</span><span class='line'>&#9; * 调用hash接口inet_hash()将该传输控制块添加到监听散列表listening_hash 
</span><span class='line'>&#9; * 中，完成监听 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (!sk-&gt;sk_prot-&gt;get_port(sk, inet-&gt;num)) {  
</span><span class='line'>&#9;&#9;inet-&gt;sport = htons(inet-&gt;num);  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;sk_dst_reset(sk);  
</span><span class='line'>&#9;&#9;sk-&gt;sk_prot-&gt;hash(sk);  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;return 0;  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 如果绑定或校验端口失败，则说明监听失败，设置传输控制块状态 
</span><span class='line'>&#9; * 为TCP_CLOSE状态 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;sk-&gt;sk_state = TCP_CLOSE;  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 释放之前分配的inet_bind_bucket实例 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;__reqsk_queue_destroy(&icsk-&gt;icsk_accept_queue);  
</span><span class='line'>&#9;return -EADDRINUSE;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>inet_csk_listen_start()首先调用reqsk_queue_alloc()来分配管理连接队的内存，如果分配成功，则开始初始化sock结构中与连接队列相关的成员，并将套接字的状态设置为LISTEN状态。在上述工作完成后，该函数还要检查当前套接字是否已经绑定本地协议地址，如果没有绑定，则内核会自动为套接字分配一个可用端口，当前这种情况一般不会发生，如果发生那就是你的服务器程序忘记调用bind()了。</p>

<h4>四、reqsk_queue_alloc()函数</h4>

<p>reqsk_queue_alloc()的源码实现及分析如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 
</span><span class='line'> * 用来分配连接请求块散列表，然后将其连接到所在传输控制块的请求 
</span><span class='line'> * 块容器中。 
</span><span class='line'> */  
</span><span class='line'>int reqsk_queue_alloc(struct request_sock_queue *queue,  
</span><span class='line'>&#9;&#9;&#9;  unsigned int nr_table_entries)  
</span><span class='line'>{  
</span><span class='line'>&#9;size_t lopt_size = sizeof(struct listen_sock);  
</span><span class='line'>&#9;struct listen_sock *lopt;  
</span><span class='line'>  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 取用户设定的连接队列长度最大值参数nr_table_entries和系统最多 
</span><span class='line'>&#9; * 可同时存在未完成三次握手SYN请求数sysctl_max_syn_backlog两者的 
</span><span class='line'>&#9; * 最小值，他们都用来控制连接队列的长度，只是前者针对某传输控制 
</span><span class='line'>&#9; * 块，而后者控制的是全局的 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;nr_table_entries = min_t(u32, nr_table_entries, sysctl_max_syn_backlog);  
</span><span class='line'>&#9;nr_table_entries = max_t(u32, nr_table_entries, 8);  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 调用roundup_pow_of_two以确保nr_table_entries的值为2的n次方 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;nr_table_entries = roundup_pow_of_two(nr_table_entries + 1);  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 计算用来保存SYN请求连接的listen_sock结构的大小 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;lopt_size += nr_table_entries * sizeof(struct request_sock *);  
</span><span class='line'>&#9;if (lopt_size &gt; PAGE_SIZE)  
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * 如果用于保存SYN请求连接的listen_sock结构大于一个页面， 
</span><span class='line'>&#9;&#9; * 则调用__vmalloc()从高位内存中分配虚拟内存，并且清零 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;lopt = __vmalloc(lopt_size,  
</span><span class='line'>&#9;&#9;&#9;GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO,  
</span><span class='line'>&#9;&#9;&#9;PAGE_KERNEL);  
</span><span class='line'>&#9;else  
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * 如果小于一个页面，则在常规内存中分配内存并清零。kzalloc() 
</span><span class='line'>&#9;&#9; * 封装了kmalloc()及memset() 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;lopt = kzalloc(lopt_size, GFP_KERNEL);  
</span><span class='line'>&#9;if (lopt == NULL)  
</span><span class='line'>&#9;&#9;return -ENOMEM;  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 从nr_table_entries = max_t(u32, nr_table_entries, 8);中可以看出 
</span><span class='line'>&#9; * nr_table_entries最小值为8，所以这里从3开始 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;for (lopt-&gt;max_qlen_log = 3;  
</span><span class='line'>&#9;&#9; (1 &lt;&lt; lopt-&gt;max_qlen_log) &lt; nr_table_entries;  
</span><span class='line'>&#9;&#9; lopt-&gt;max_qlen_log++);  
</span><span class='line'>  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 初始化listen_sock结构中的一些成员，如用于生成连接请求块 
</span><span class='line'>&#9; * 散列表的hash_rnd等 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;get_random_bytes(&lopt-&gt;hash_rnd, sizeof(lopt-&gt;hash_rnd));  
</span><span class='line'>&#9;rwlock_init(&queue-&gt;syn_wait_lock);  
</span><span class='line'>&#9;queue-&gt;rskq_accept_head = NULL;  
</span><span class='line'>&#9;lopt-&gt;nr_table_entries = nr_table_entries;  
</span><span class='line'>  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 将散列表连接到所在传输控制块的请求块容器中 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;write_lock_bh(&queue-&gt;syn_wait_lock);  
</span><span class='line'>&#9;queue-&gt;listen_opt = lopt;  
</span><span class='line'>&#9;write_unlock_bh(&queue-&gt;syn_wait_lock);  
</span><span class='line'>  
</span><span class='line'>&#9;return 0;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>从上面的代码中可以看到半连接队列长度的计算过程，nr_table_entries的值存储的就是计算的结果，这个值是基于listen()的第二个参数的值计算得到的。半连接队列的上限值的以2为底的对数存储在lopt的max_qlen_log成员中，对数的计算是通过下面的代码完成的，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (lopt-&gt;max_qlen_log = 3;  
</span><span class='line'>&#9;&#9; (1 &lt;&lt; lopt-&gt;max_qlen_log) &lt; nr_table_entries;  
</span><span class='line'>&#9;&#9; lopt-&gt;max_qlen_log++);  </span></code></pre></td></tr></table></div></figure>


<h4>五、结束语</h4>

<p>在listen()系统调用中，第二个参数backlog对服务器的程序影响是很大的，而且不同的系统对这个参数的使用可能有所不同。前面我们也提到了，《Unix网络编程》中对第二参数backlog的描述是连接队列和半连接队列的长度之和不超过backlog，但是在Linux中并不是这样，限于篇幅，后面会单独写一篇关于backlog参数的分析文章来详细介绍。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/09/kernel-net-socket/">socket创建过程 sys_socket</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-09T17:45:00+08:00'><span class='date'>2015-06-09</span> <span class='time'>17:45:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://m.blog.chinaunix.net/uid-26905027-id-4031796.html">http://m.blog.chinaunix.net/uid-26905027-id-4031796.html</a></p>

<p>对于网络编程程序员来说sockfd = socket(AF_INET, SOCKET_DGRM, 0);这行代码是最熟悉不过，但这行代码的背后是&hellip;&hellip;</p>

<ol>
<li><p>socket这个api是库函数，我们直接调用就可以了，调用之后，产生0x80号软中断，linux系统由用户态切换到内核态，接着执行系统调用函数，在内核态执行相应的服务例程，针对socket这个函数，服务例程是sys_socket函数。至于这个过程是怎么实现的，在这里不阐述。下面我们分析sys_socket函数，看socket是怎么创建的。</p></li>
<li><p>在分析sys_socket函数之前，我们先看一下sock_init初始化过程</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int __init sock_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Initialize sock SLAB cache.
</span><span class='line'>&#9; */
</span><span class='line'>
</span><span class='line'>&#9;sk_init(); 
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Initialize skbuff SLAB cache
</span><span class='line'>&#9; */
</span><span class='line'>&#9;skb_init();
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Initialize the protocols module.
</span><span class='line'>&#9; */
</span><span class='line'>
</span><span class='line'>&#9;init_inodecache();   //在这里创建了名为sock_inode_cache的cache
</span><span class='line'>&#9;register_filesystem(&sock_fs_type);
</span><span class='line'>&#9;sock_mnt = kern_mount(&sock_fs_type);
</span><span class='line'>
</span><span class='line'>&#9;/* The real protocol initialization is performed in later initcalls.
</span><span class='line'>&#9; */
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_NETFILTER
</span><span class='line'>&#9;netfilter_init();
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct socket_alloc {
</span><span class='line'>&#9;struct socket socket;
</span><span class='line'>&#9;struct inode vfs_inode;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static int init_inodecache(void)
</span><span class='line'>{
</span><span class='line'>&#9;sock_inode_cachep = kmem_cache_create("sock_inode_cache",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;sizeof(struct socket_alloc),    //在这里创建了名为sock_inode_cache，大小为sizeof(struct socket_alloc)的slab高速缓存  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;//猜测创建slab高速缓存，而不是普通内存，那么操作socket结构就快了
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;0,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;(SLAB_HWCACHE_ALIGN |
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;SLAB_RECLAIM_ACCOUNT |
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;SLAB_MEM_SPREAD),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;init_once,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;NULL);
</span><span class='line'>&#9;if (sock_inode_cachep == NULL)
</span><span class='line'>&#9;&#9;return -ENOMEM;
</span><span class='line'>&#9;return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static struct vfsmount *sock_mnt __read_mostly;
</span><span class='line'>
</span><span class='line'>static struct file_system_type sock_fs_type = {    
</span><span class='line'>&#9;.name =        "sockfs",
</span><span class='line'>&#9;.get_sb =    sockfs_get_sb,
</span><span class='line'>&#9;.kill_sb =    kill_anon_super,
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>register_filesystem(&sock_fs_type);   //在这里注册了名为sockfs的VFS
</span><span class='line'>sock_mnt = kern_mount(&sock_fs_type);  //并在这里得到struct vfsmount 结构的sock_mnt变量，这个变量是全局变量，在创建socket的时候会用到
</span><span class='line'>
</span><span class='line'>static struct super_operations sockfs_ops = {
</span><span class='line'>&#9;.alloc_inode =    sock_alloc_inode,      //这里就是最终创建struct socket_alloc结构的函数
</span><span class='line'>&#9;.destroy_inode =sock_destroy_inode,
</span><span class='line'>&#9;.statfs =    simple_statfs,
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static int sockfs_get_sb(struct file_system_type *fs_type,
</span><span class='line'>&#9;&#9;int flags, const char *dev_name, void *data,
</span><span class='line'>&#9;&#9;struct vfsmount *mnt)
</span><span class='line'>{
</span><span class='line'>&#9;return get_sb_pseudo(fs_type, "socket:", &sockfs_ops, SOCKFS_MAGIC,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;mnt);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static struct inode *sock_alloc_inode(struct super_block *sb)
</span><span class='line'>{
</span><span class='line'>&#9;struct socket_alloc *ei;
</span><span class='line'>
</span><span class='line'>&#9;ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);  //在这里我们看到了memory allocate 操作
</span><span class='line'>&#9;if (!ei)
</span><span class='line'>&#9;&#9;return NULL;
</span><span class='line'>&#9;init_waitqueue_head(&ei-&gt;socket.wait);
</span><span class='line'>
</span><span class='line'>&#9;ei-&gt;socket.fasync_list = NULL;          //在这里对socket结构一些字段进行了初始化
</span><span class='line'>&#9;ei-&gt;socket.state = SS_UNCONNECTED;
</span><span class='line'>&#9;ei-&gt;socket.flags = 0;
</span><span class='line'>&#9;ei-&gt;socket.ops = NULL;
</span><span class='line'>&#9;ei-&gt;socket.sk = NULL;
</span><span class='line'>&#9;ei-&gt;socket.file = NULL;
</span><span class='line'>
</span><span class='line'>&#9;return &ei-&gt;vfs_inode;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>前面进行的这些初始化，为后面做好了准备，接着往下看吧：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>asmlinkage long sys_socket(int family, int type, int protocol)
</span><span class='line'>{
</span><span class='line'>&#9;int retval;
</span><span class='line'>&#9;struct socket *sock;
</span><span class='line'>
</span><span class='line'>&#9;retval = sock_create(family, type, protocol, &sock);  //在这个函数完成了socket的创建过程
</span><span class='line'>&#9;if (retval &lt; 0)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;retval = sock_map_fd(sock);  //把创建的socket和文件相关联，
</span><span class='line'>&#9;if (retval &lt; 0)
</span><span class='line'>&#9;&#9;goto out_release;
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>&#9;/* It may be already another descriptor 8) Not kernel problem. */
</span><span class='line'>&#9;return retval;
</span><span class='line'>
</span><span class='line'>out_release:
</span><span class='line'>&#9;sock_release(sock);
</span><span class='line'>&#9;return retval;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>sock_create函数是封装函数，实际调用的是__sock_create函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int __sock_create(int family, int type, int protocol,
</span><span class='line'>&#9;&#9;&#9;struct socket **res, int kern)
</span><span class='line'>{
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;struct socket *sock;
</span><span class='line'>&#9;const struct net_proto_family *pf;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Check protocol is in range
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (family &lt; 0 || family &gt;= NPROTO)
</span><span class='line'>&#9;&#9;return -EAFNOSUPPORT;
</span><span class='line'>&#9;if (type &lt; 0 || type &gt;= SOCK_MAX)
</span><span class='line'>&#9;&#9;return -EINVAL;
</span><span class='line'>
</span><span class='line'>&#9;/* Compatibility.
</span><span class='line'>&#9; * This uglymoron is moved from INET layer to here to avoid
</span><span class='line'>&#9; * deadlock in module load.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (family == PF_INET && type == SOCK_PACKET) {
</span><span class='line'>&#9;&#9;static int warned;
</span><span class='line'>&#9;&#9;if (!warned) {
</span><span class='line'>&#9;&#9;&#9;warned = 1;
</span><span class='line'>&#9;&#9;&#9;printk(KERN_INFO "%s uses obsolete (PF_INET,SOCK_PACKET)\n",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;current-&gt;comm);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;family = PF_PACKET;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;err = security_socket_create(family, type, protocol, kern);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;return err;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; *    Allocate the socket and allow the family to set things up. if
</span><span class='line'>&#9; *    the protocol is 0, the family is instructed to select an appropriate
</span><span class='line'>&#9; *    default.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;sock = sock_alloc();    //这个函数调用了初始化时注册的创建socket和inode节点的回调函数，完成了socket和inode节点的创建。在unix和类unix系统中把socket当做文件节点来处理，所以有inode节点
</span><span class='line'>&#9;&#9;&#9;&#9;//后面我们分析这个函数
</span><span class='line'>&#9;if (!sock) {
</span><span class='line'>&#9;&#9;if (net_ratelimit())
</span><span class='line'>&#9;&#9;&#9;printk(KERN_WARNING "socket: no more sockets\n");
</span><span class='line'>&#9;&#9;return -ENFILE;    /* Not exactly a match, but its the
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;closest posix thing */
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;sock-&gt;type = type;
</span><span class='line'>
</span><span class='line'>#if defined(CONFIG_KMOD)
</span><span class='line'>&#9;/* Attempt to load a protocol module if the find failed.
</span><span class='line'>&#9; *
</span><span class='line'>&#9; * 12/09/1996 Marcin: this makes REALLY only sense, if the user
</span><span class='line'>&#9; * requested real, full-featured networking support upon configuration.
</span><span class='line'>&#9; * Otherwise module support will
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (net_families[family] == NULL)
</span><span class='line'>&#9;&#9;request_module("net-pf-%d", family);
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;pf = rcu_dereference(net_families[family]);  //根据协议族family得到struct net_proto_family结构，这个net_families数组在inet_init函数中初始化，稍后我们看看这个初始化过程
</span><span class='line'>&#9;err = -EAFNOSUPPORT;
</span><span class='line'>&#9;if (!pf)
</span><span class='line'>&#9;&#9;goto out_release;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * We will call the -&gt;create function, that possibly is in a loadable
</span><span class='line'>&#9; * module, so we have to bump that loadable module refcnt first.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (!try_module_get(pf-&gt;owner))
</span><span class='line'>&#9;&#9;goto out_release;
</span><span class='line'>
</span><span class='line'>&#9;/* Now protected by module ref count */
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>
</span><span class='line'>&#9;err = pf-&gt;create(sock, protocol); //在这里创建了庞大的struct sock 结构，并进行了初始化。这个挂入的inet_create函数
</span><span class='line'>&#9;if (err &lt; 0)
</span><span class='line'>&#9;&#9;goto out_module_put;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Now to bump the refcnt of the [loadable] module that owns this
</span><span class='line'>&#9; * socket at sock_release time we decrement its refcnt.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (!try_module_get(sock-&gt;ops-&gt;owner))
</span><span class='line'>&#9;&#9;goto out_module_busy;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Now that we're done with the -&gt;create function, the [loadable]
</span><span class='line'>&#9; * module can have its refcnt decremented
</span><span class='line'>&#9; */
</span><span class='line'>&#9;module_put(pf-&gt;owner);
</span><span class='line'>&#9;err = security_socket_post_create(sock, family, type, protocol, kern);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto out_release;
</span><span class='line'>&#9;*res = sock;
</span><span class='line'>
</span><span class='line'>&#9;return 0;
</span><span class='line'>
</span><span class='line'>out_module_busy:
</span><span class='line'>&#9;err = -EAFNOSUPPORT;
</span><span class='line'>out_module_put:
</span><span class='line'>&#9;sock-&gt;ops = NULL;
</span><span class='line'>&#9;module_put(pf-&gt;owner);
</span><span class='line'>out_sock_release:
</span><span class='line'>&#9;sock_release(sock);
</span><span class='line'>&#9;return err;
</span><span class='line'>
</span><span class='line'>out_release:
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>&#9;goto out_sock_release;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码中看到_sock_create函数调用了回调函数完成了socket创建和初始化过程，下面我们看创建socket结构的过程：sock = sock_alloc();</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct socket *sock_alloc(void)
</span><span class='line'>{
</span><span class='line'>&#9;struct inode *inode;
</span><span class='line'>&#9;struct socket *sock;
</span><span class='line'>
</span><span class='line'>&#9;inode = new_inode(sock_mnt-&gt;mnt_sb); //在这里我们看到了sock_init函数中得到的全局变量sock_mnt，稍后看下new_inode函数
</span><span class='line'>&#9;if (!inode)
</span><span class='line'>&#9;&#9;return NULL;
</span><span class='line'>
</span><span class='line'>&#9;sock = SOCKET_I(inode); //得到了socket结构
</span><span class='line'>
</span><span class='line'>&#9;inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO;
</span><span class='line'>&#9;inode-&gt;i_uid = current-&gt;fsuid;
</span><span class='line'>&#9;inode-&gt;i_gid = current-&gt;fsgid;
</span><span class='line'>
</span><span class='line'>&#9;get_cpu_var(sockets_in_use)++;
</span><span class='line'>&#9;put_cpu_var(sockets_in_use);
</span><span class='line'>&#9;return sock;
</span><span class='line'>}
</span><span class='line'>struct inode *new_inode(struct super_block *sb)
</span><span class='line'>{
</span><span class='line'>&#9;static unsigned long last_ino;
</span><span class='line'>&#9;struct inode * inode;
</span><span class='line'>
</span><span class='line'>&#9;spin_lock_prefetch(&inode_lock);
</span><span class='line'>
</span><span class='line'>&#9;inode = alloc_inode(sb);  //接着看这个函数
</span><span class='line'>&#9;if (inode) {
</span><span class='line'>&#9;&#9;spin_lock(&inode_lock);
</span><span class='line'>&#9;&#9;inodes_stat.nr_inodes++;
</span><span class='line'>&#9;&#9;list_add(&inode-&gt;i_list, &inode_in_use);
</span><span class='line'>&#9;&#9;list_add(&inode-&gt;i_sb_list, &sb-&gt;s_inodes);
</span><span class='line'>&#9;&#9;inode-&gt;i_ino = ++last_ino;
</span><span class='line'>&#9;&#9;inode-&gt;i_state = 0;
</span><span class='line'>&#9;&#9;spin_unlock(&inode_lock);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return inode;
</span><span class='line'>}
</span><span class='line'>static struct inode *alloc_inode(struct super_block *sb)
</span><span class='line'>{
</span><span class='line'>&#9;static const struct address_space_operations empty_aops;
</span><span class='line'>&#9;static struct inode_operations empty_iops;
</span><span class='line'>&#9;static const struct file_operations empty_fops;
</span><span class='line'>&#9;struct inode *inode;
</span><span class='line'>
</span><span class='line'>&#9;if (sb-&gt;s_op-&gt;alloc_inode)      //在这里我们看到 if调节满足，因为在sock_init函数中我们挂入了sock_alloc_inode函数，之前我们也看到了sock_alloc_inode函数创建了sizeof(struct socket_alloc
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;//大小的slab高速缓存
</span><span class='line'>&#9;&#9;inode = sb-&gt;s_op-&gt;alloc_inode(sb); 
</span><span class='line'>&#9;else
</span><span class='line'>&#9;&#9;inode = (struct inode *) kmem_cache_alloc(inode_cachep, GFP_KERNEL);
</span><span class='line'>
</span><span class='line'>&#9;if (inode) {
</span><span class='line'>&#9;&#9;struct address_space * const mapping = &inode-&gt;i_data;
</span><span class='line'>
</span><span class='line'>&#9;&#9;inode-&gt;i_sb = sb;
</span><span class='line'>&#9;&#9;inode-&gt;i_blkbits = sb-&gt;s_blocksize_bits;
</span><span class='line'>&#9;&#9;inode-&gt;i_flags = 0;
</span><span class='line'>&#9;&#9;atomic_set(&inode-&gt;i_count, 1);
</span><span class='line'>&#9;&#9;inode-&gt;i_op = &empty_iops;
</span><span class='line'>&#9;&#9;inode-&gt;i_fop = &empty_fops;
</span><span class='line'>&#9;&#9;inode-&gt;i_nlink = 1;
</span><span class='line'>&#9;&#9;atomic_set(&inode-&gt;i_writecount, 0);
</span><span class='line'>&#9;&#9;inode-&gt;i_size = 0;
</span><span class='line'>&#9;&#9;inode-&gt;i_blocks = 0;
</span><span class='line'>&#9;&#9;inode-&gt;i_bytes = 0;
</span><span class='line'>&#9;&#9;inode-&gt;i_generation = 0;
</span><span class='line'>#ifdef CONFIG_QUOTA
</span><span class='line'>&#9;&#9;memset(&inode-&gt;i_dquot, 0, sizeof(inode-&gt;i_dquot));
</span><span class='line'>#endif
</span><span class='line'>&#9;&#9;inode-&gt;i_pipe = NULL;
</span><span class='line'>&#9;&#9;inode-&gt;i_bdev = NULL;
</span><span class='line'>&#9;&#9;inode-&gt;i_cdev = NULL;
</span><span class='line'>&#9;&#9;inode-&gt;i_rdev = 0;
</span><span class='line'>&#9;&#9;inode-&gt;dirtied_when = 0;
</span><span class='line'>&#9;&#9;if (security_inode_alloc(inode)) {
</span><span class='line'>&#9;&#9;&#9;if (inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode)
</span><span class='line'>&#9;&#9;&#9;&#9;inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode(inode);
</span><span class='line'>&#9;&#9;&#9;else
</span><span class='line'>&#9;&#9;&#9;&#9;kmem_cache_free(inode_cachep, (inode));
</span><span class='line'>&#9;&#9;&#9;return NULL;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;mapping-&gt;a_ops = &empty_aops;
</span><span class='line'>&#9;&#9;mapping-&gt;host = inode;
</span><span class='line'>&#9;&#9;mapping-&gt;flags = 0;
</span><span class='line'>&#9;&#9;mapping_set_gfp_mask(mapping, GFP_HIGHUSER);
</span><span class='line'>&#9;&#9;mapping-&gt;assoc_mapping = NULL;
</span><span class='line'>&#9;&#9;mapping-&gt;backing_dev_info = &default_backing_dev_info;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * If the block_device provides a backing_dev_info for client
</span><span class='line'>&#9;&#9; * inodes then use that.  Otherwise the inode share the bdev's
</span><span class='line'>&#9;&#9; * backing_dev_info.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (sb-&gt;s_bdev) {
</span><span class='line'>&#9;&#9;&#9;struct backing_dev_info *bdi;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;bdi = sb-&gt;s_bdev-&gt;bd_inode_backing_dev_info;
</span><span class='line'>&#9;&#9;&#9;if (!bdi)
</span><span class='line'>&#9;&#9;&#9;&#9;bdi = sb-&gt;s_bdev-&gt;bd_inode-&gt;i_mapping-&gt;backing_dev_info;
</span><span class='line'>&#9;&#9;&#9;mapping-&gt;backing_dev_info = bdi;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;inode-&gt;i_private = NULL;
</span><span class='line'>&#9;&#9;inode-&gt;i_mapping = mapping;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return inode;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的分析中我们就可以很好的理解得到socket结构的过程：根据inode 得到socket</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sock = SOCKET_I(inode);  
</span><span class='line'>static inline struct socket *SOCKET_I(struct inode *inode)
</span><span class='line'>{
</span><span class='line'>&#9;return &container_of(inode, struct socket_alloc, vfs_inode)-&gt;socket;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>现在创建socket结构的过程也就完成了，下面我们看看创建struct sock结构的过程</li>
</ol>


<p> 在inet_init函数中，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(void)sock_register(&inet_family_ops);
</span><span class='line'>
</span><span class='line'>static struct net_proto_family inet_family_ops = {
</span><span class='line'>&#9;.family = PF_INET,
</span><span class='line'>&#9;.create = inet_create,
</span><span class='line'>&#9;.owner    = THIS_MODULE,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>在这里我们看到了挂入的过程，net_families数组以family为下标，组成了各个协议创建函数，还记得执行create函数的地方吧？但在看这个函数以前先看看这里：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Upon startup we insert all the elements in inetsw_array[] into
</span><span class='line'> * the linked list inetsw.
</span><span class='line'> */
</span><span class='line'>static struct inet_protosw inetsw_array[] =
</span><span class='line'>{
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;.type = SOCK_STREAM,
</span><span class='line'>&#9;&#9;.protocol = IPPROTO_TCP,
</span><span class='line'>&#9;&#9;.prot = &tcp_prot,
</span><span class='line'>&#9;&#9;.ops = &inet_stream_ops,
</span><span class='line'>&#9;&#9;.capability = -1,
</span><span class='line'>&#9;&#9;.no_check = 0,
</span><span class='line'>&#9;&#9;.flags = INET_PROTOSW_PERMANENT |
</span><span class='line'>&#9;&#9;&#9;INET_PROTOSW_ICSK,
</span><span class='line'>&#9;},
</span><span class='line'>
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;.type = SOCK_DGRAM,
</span><span class='line'>&#9;&#9;.protocol = IPPROTO_UDP,
</span><span class='line'>&#9;&#9;.prot = &udp_prot,
</span><span class='line'>&#9;&#9;.ops = &inet_dgram_ops,
</span><span class='line'>&#9;&#9;.capability = -1,
</span><span class='line'>&#9;&#9;.no_check = UDP_CSUM_DEFAULT,
</span><span class='line'>&#9;&#9;.flags = INET_PROTOSW_PERMANENT,
</span><span class='line'>&#9;},
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;.type = SOCK_RAW,
</span><span class='line'>&#9;&#9;.protocol = IPPROTO_IP,    /* wild card */
</span><span class='line'>&#9;&#9;.prot = &raw_prot,
</span><span class='line'>&#9;&#9;.ops = &inet_sockraw_ops,
</span><span class='line'>&#9;&#9;.capability = CAP_NET_RAW,
</span><span class='line'>&#9;&#9;.no_check = UDP_CSUM_DEFAULT,
</span><span class='line'>&#9;&#9;.flags = INET_PROTOSW_REUSE,
</span><span class='line'>&#9;}
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>//下面的代码是在inet_init函数中执行的
</span><span class='line'>/* Register the socket-side information for inet_create. */
</span><span class='line'>&#9;for (r = &inetsw[0]; r &lt; &inetsw[SOCK_MAX]; ++r)
</span><span class='line'>&#9;&#9;INIT_LIST_HEAD(r);
</span><span class='line'>
</span><span class='line'>&#9;for (q = inetsw_array; q &lt; &inetsw_array[INETSW_ARRAY_LEN]; ++q)
</span><span class='line'>&#9;&#9;inet_register_protosw(q);</span></code></pre></td></tr></table></div></figure>


<p>我们来看看struct inet_protosw 这个结构</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* This is used to register socket interfaces for IP protocols. */
</span><span class='line'>struct inet_protosw {
</span><span class='line'>&#9;struct list_head list;
</span><span class='line'>
</span><span class='line'>&#9;/* These two fields form the lookup key. */
</span><span class='line'>&#9;unsigned short     type;     /* This is the 2nd argument to socket(2). */
</span><span class='line'>&#9;unsigned short     protocol; /* This is the L4 protocol number. */
</span><span class='line'>
</span><span class='line'>&#9;struct proto     *prot;
</span><span class='line'>&#9;const struct proto_ops *ops;
</span><span class='line'>
</span><span class='line'>&#9;int capability; /* Which (if any) capability do
</span><span class='line'>&#9;&#9;&#9; * we need to use this socket
</span><span class='line'>&#9;&#9;&#9; * interface?
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;char no_check; /* checksum on rcv/xmit/none? */
</span><span class='line'>&#9;unsigned char     flags; /* See INET_PROTOSW_* below. */
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> *    Create an inet socket. //从这个注释中我们可以看到，还可以创建其他类型的socket
</span><span class='line'> */
</span><span class='line'>
</span><span class='line'>static int inet_create(struct socket *sock, int protocol)
</span><span class='line'>{
</span><span class='line'>&#9;struct sock *sk;
</span><span class='line'>&#9;struct list_head *p;
</span><span class='line'>&#9;struct inet_protosw *answer;
</span><span class='line'>&#9;struct inet_sock *inet;
</span><span class='line'>&#9;struct proto *answer_prot;
</span><span class='line'>&#9;unsigned char answer_flags;
</span><span class='line'>&#9;char answer_no_check;
</span><span class='line'>&#9;int try_loading_module = 0;
</span><span class='line'>&#9;int err;
</span><span class='line'>
</span><span class='line'>&#9;sock-&gt;state = SS_UNCONNECTED;
</span><span class='line'>
</span><span class='line'>&#9;/* Look for the requested type/protocol pair. */
</span><span class='line'>&#9;answer = NULL;
</span><span class='line'>lookup_protocol:
</span><span class='line'>&#9;err = -ESOCKTNOSUPPORT;
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;list_for_each_rcu(p, &inetsw[sock-&gt;type]) {   //在这里我们遍历inetsw数组，根据是UDP，TCP，RAW类型得到了struct inet_protosw结构
</span><span class='line'>&#9;&#9;answer = list_entry(p, struct inet_protosw, list);
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Check the non-wild match. */
</span><span class='line'>&#9;&#9;if (protocol == answer-&gt;protocol) {
</span><span class='line'>&#9;&#9;&#9;if (protocol != IPPROTO_IP)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;/* Check for the two wild cases. */
</span><span class='line'>&#9;&#9;&#9;if (IPPROTO_IP == protocol) {
</span><span class='line'>&#9;&#9;&#9;&#9;protocol = answer-&gt;protocol;
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;if (IPPROTO_IP == answer-&gt;protocol)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;err = -EPROTONOSUPPORT;
</span><span class='line'>&#9;&#9;answer = NULL;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (unlikely(answer == NULL)) {
</span><span class='line'>&#9;&#9;if (try_loading_module &lt; 2) {
</span><span class='line'>&#9;&#9;&#9;rcu_read_unlock();
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * Be more specific, e.g. net-pf-2-proto-132-type-1
</span><span class='line'>&#9;&#9;&#9; * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM)
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;if (++try_loading_module == 1)
</span><span class='line'>&#9;&#9;&#9;&#9;request_module("net-pf-%d-proto-%d-type-%d",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;PF_INET, protocol, sock-&gt;type);
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * Fall back to generic, e.g. net-pf-2-proto-132
</span><span class='line'>&#9;&#9;&#9; * (net-pf-PF_INET-proto-IPPROTO_SCTP)
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;else
</span><span class='line'>&#9;&#9;&#9;&#9;request_module("net-pf-%d-proto-%d",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;PF_INET, protocol);
</span><span class='line'>&#9;&#9;&#9;goto lookup_protocol;
</span><span class='line'>&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;goto out_rcu_unlock;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;err = -EPERM;
</span><span class='line'>&#9;if (answer-&gt;capability &gt; 0 && !capable(answer-&gt;capability))
</span><span class='line'>&#9;&#9;goto out_rcu_unlock;
</span><span class='line'>
</span><span class='line'>&#9;sock-&gt;ops = answer-&gt;ops;    //对socket结构进行了初始化
</span><span class='line'>&#9;answer_prot = answer-&gt;prot;
</span><span class='line'>&#9;answer_no_check = answer-&gt;no_check;
</span><span class='line'>&#9;answer_flags = answer-&gt;flags;
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>
</span><span class='line'>&#9;BUG_TRAP(answer_prot-&gt;slab != NULL);
</span><span class='line'>
</span><span class='line'>&#9;err = -ENOBUFS;
</span><span class='line'>&#9;sk = sk_alloc(PF_INET, GFP_KERNEL, answer_prot, 1);   //这个函数创建了struct sock 这个庞然大物
</span><span class='line'>&#9;if (sk == NULL)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;err = 0;
</span><span class='line'>&#9;sk-&gt;sk_no_check = answer_no_check;
</span><span class='line'>&#9;if (INET_PROTOSW_REUSE & answer_flags)
</span><span class='line'>&#9;&#9;sk-&gt;sk_reuse = 1;
</span><span class='line'>
</span><span class='line'>&#9;inet = inet_sk(sk);
</span><span class='line'>&#9;inet-&gt;is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0;
</span><span class='line'>
</span><span class='line'>&#9;if (SOCK_RAW == sock-&gt;type) {
</span><span class='line'>&#9;&#9;inet-&gt;num = protocol;
</span><span class='line'>&#9;&#9;if (IPPROTO_RAW == protocol)
</span><span class='line'>&#9;&#9;&#9;inet-&gt;hdrincl = 1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (ipv4_config.no_pmtu_disc)
</span><span class='line'>&#9;&#9;inet-&gt;pmtudisc = IP_PMTUDISC_DONT;
</span><span class='line'>&#9;else
</span><span class='line'>&#9;&#9;inet-&gt;pmtudisc = IP_PMTUDISC_WANT;
</span><span class='line'>
</span><span class='line'>&#9;inet-&gt;id = 0;
</span><span class='line'>
</span><span class='line'>&#9;sock_init_data(sock, sk);  //在这里对struct sock里面重要的字段进行了初始化，包括接受队列，发送队列，以及长度等
</span><span class='line'>
</span><span class='line'>&#9;sk-&gt;sk_destruct     = inet_sock_destruct;   
</span><span class='line'>&#9;sk-&gt;sk_family     = PF_INET;
</span><span class='line'>&#9;sk-&gt;sk_protocol     = protocol;
</span><span class='line'>&#9;sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv;
</span><span class='line'>
</span><span class='line'>&#9;inet-&gt;uc_ttl    = -1;
</span><span class='line'>&#9;inet-&gt;mc_loop    = 1;
</span><span class='line'>&#9;inet-&gt;mc_ttl    = 1;
</span><span class='line'>&#9;inet-&gt;mc_index    = 0;
</span><span class='line'>&#9;inet-&gt;mc_list    = NULL;
</span><span class='line'>
</span><span class='line'>&#9;sk_refcnt_debug_inc(sk);
</span><span class='line'>
</span><span class='line'>&#9;if (inet-&gt;num) {    //我们看到当我们调用RAW类型的socket的时候，这个if条件就成立了
</span><span class='line'>&#9;&#9;/* It assumes that any protocol which allows
</span><span class='line'>&#9;&#9; * the user to assign a number at socket
</span><span class='line'>&#9;&#9; * creation time automatically
</span><span class='line'>&#9;&#9; * shares.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;inet-&gt;sport = htons(inet-&gt;num);
</span><span class='line'>&#9;&#9;/* Add to protocol hash chains. */
</span><span class='line'>&#9;&#9;sk-&gt;sk_prot-&gt;hash(sk);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (sk-&gt;sk_prot-&gt;init) {           //看L4层是否注册了初始化函数，我们看到UDP类型的socket为空，而TCP类型的socket注册了初始化函数
</span><span class='line'>&#9;&#9;err = sk-&gt;sk_prot-&gt;init(sk);
</span><span class='line'>&#9;&#9;if (err)
</span><span class='line'>&#9;&#9;&#9;sk_common_release(sk);
</span><span class='line'>&#9;}
</span><span class='line'>out:
</span><span class='line'>&#9;return err;
</span><span class='line'>out_rcu_unlock:
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>&#9;goto out;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void sock_init_data(struct socket *sock, struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;skb_queue_head_init(&sk-&gt;sk_receive_queue); //接受队列
</span><span class='line'>&#9;skb_queue_head_init(&sk-&gt;sk_write_queue);   //发送队列
</span><span class='line'>&#9;skb_queue_head_init(&sk-&gt;sk_error_queue);
</span><span class='line'>#ifdef CONFIG_NET_DMA
</span><span class='line'>&#9;skb_queue_head_init(&sk-&gt;sk_async_wait_queue);
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>&#9;sk-&gt;sk_send_head    =    NULL;
</span><span class='line'>
</span><span class='line'>&#9;init_timer(&sk-&gt;sk_timer);
</span><span class='line'>
</span><span class='line'>&#9;sk-&gt;sk_allocation    =    GFP_KERNEL;
</span><span class='line'>&#9;sk-&gt;sk_rcvbuf        =    sysctl_rmem_default;  //接受缓冲区大小
</span><span class='line'>&#9;sk-&gt;sk_sndbuf        =    sysctl_wmem_default;  //发送缓冲区大小
</span><span class='line'>&#9;sk-&gt;sk_state        =    TCP_CLOSE;   //被初始化为TCP_CLOSE，再下一篇绑定分析中我们会看到会检查这个状态
</span><span class='line'>&#9;sk-&gt;sk_socket        =    sock;
</span><span class='line'>
</span><span class='line'>&#9;sock_set_flag(sk, SOCK_ZAPPED);
</span><span class='line'>
</span><span class='line'>&#9;if(sock)
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;sk-&gt;sk_type    =    sock-&gt;type;
</span><span class='line'>&#9;&#9;sk-&gt;sk_sleep    =    &sock-&gt;wait;
</span><span class='line'>&#9;&#9;sock-&gt;sk    =    sk;
</span><span class='line'>&#9;} else
</span><span class='line'>&#9;&#9;sk-&gt;sk_sleep    =    NULL;
</span><span class='line'>
</span><span class='line'>&#9;rwlock_init(&sk-&gt;sk_dst_lock);
</span><span class='line'>&#9;rwlock_init(&sk-&gt;sk_callback_lock);
</span><span class='line'>&#9;lockdep_set_class(&sk-&gt;sk_callback_lock,
</span><span class='line'>&#9;&#9;&#9;af_callback_keys + sk-&gt;sk_family);
</span><span class='line'>
</span><span class='line'>&#9;sk-&gt;sk_state_change    =    sock_def_wakeup;
</span><span class='line'>&#9;sk-&gt;sk_data_ready    =    sock_def_readable;
</span><span class='line'>&#9;sk-&gt;sk_write_space    =    sock_def_write_space;
</span><span class='line'>&#9;sk-&gt;sk_error_report    =    sock_def_error_report;
</span><span class='line'>&#9;sk-&gt;sk_destruct        =    sock_def_destruct;
</span><span class='line'>
</span><span class='line'>&#9;sk-&gt;sk_sndmsg_page    =    NULL;
</span><span class='line'>&#9;sk-&gt;sk_sndmsg_off    =    0;
</span><span class='line'>
</span><span class='line'>&#9;sk-&gt;sk_peercred.pid     =    0;
</span><span class='line'>&#9;sk-&gt;sk_peercred.uid    =    -1;
</span><span class='line'>&#9;sk-&gt;sk_peercred.gid    =    -1;
</span><span class='line'>&#9;sk-&gt;sk_write_pending    =    0;
</span><span class='line'>&#9;sk-&gt;sk_rcvlowat        =    1;
</span><span class='line'>&#9;sk-&gt;sk_rcvtimeo        =    MAX_SCHEDULE_TIMEOUT;
</span><span class='line'>&#9;sk-&gt;sk_sndtimeo        =    MAX_SCHEDULE_TIMEOUT;
</span><span class='line'>
</span><span class='line'>&#9;sk-&gt;sk_stamp.tv_sec = -1L;
</span><span class='line'>&#9;sk-&gt;sk_stamp.tv_usec = -1L;
</span><span class='line'>
</span><span class='line'>&#9;atomic_set(&sk-&gt;sk_refcnt, 1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/23">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/21">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(40)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>23</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>13</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(54)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~graphviz,-codeviz/?opendiv=tools'>graphviz、codeviz</a><a href='##' onmousedown=showDiv('tools~graphviz、codeviz') id='aexp_tools~graphviz、codeviz'><span class='exp_style' id='exp_tools~graphviz、codeviz'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~graphviz、codeviz')) document.getElementById('aexp_tools~graphviz、codeviz').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~haproxy/?opendiv=tools'>haproxy</a><a href='##' onmousedown=showDiv('tools~haproxy') id='aexp_tools~haproxy'><span class='exp_style' id='exp_tools~haproxy'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~haproxy')) document.getElementById('aexp_tools~haproxy').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(54)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>17</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~cgroup/?opendiv=system'>cgroup</a><a href='##' onmousedown=showDiv('system~cgroup') id='aexp_system~cgroup'><span class='exp_style' id='exp_system~cgroup'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~cgroup')) document.getElementById('aexp_system~cgroup').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~kvm/?opendiv=system'>kvm</a><a href='##' onmousedown=showDiv('system~kvm') id='aexp_system~kvm'><span class='exp_style' id='exp_system~kvm'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~kvm')) document.getElementById('aexp_system~kvm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~namespace/?opendiv=system'>namespace</a><a href='##' onmousedown=showDiv('system~namespace') id='aexp_system~namespace'><span class='exp_style' id='exp_system~namespace'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~namespace')) document.getElementById('aexp_system~namespace').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(163)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~fs/?opendiv=kernel'>fs</a><a href='##' onmousedown=showDiv('kernel~fs') id='aexp_kernel~fs'><span class='exp_style' id='exp_kernel~fs'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~fs')) document.getElementById('aexp_kernel~fs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>33</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>80</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>19</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(22)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(70)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>17</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~perf/?opendiv=debug'>perf</a><a href='##' onmousedown=showDiv('debug~perf') id='aexp_debug~perf'><span class='exp_style' id='exp_debug~perf'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~perf')) document.getElementById('aexp_debug~perf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(27)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>20</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2016/'>2016</a><a href='##' onmousedown=showDiv('2016')><span class='exp_style' id='exp_2016'>[+]</span></a><span class='right_span'>(12)</span></li>
<div id='2016' class='catsub'><li><a href='/blog/cats/2016~03/?opendiv=2016'>2016-03</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2016~02/?opendiv=2016'>2016-02</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2016~01/?opendiv=2016'>2016-01</a><span class='right_span'>6</span></li>
</div><li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(207)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~12/?opendiv=2015'>2015-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2015~11/?opendiv=2015'>2015-11</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2015~10/?opendiv=2015'>2015-10</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2015~09/?opendiv=2015'>2015-09</a><span class='right_span'>18</span></li>
<li><a href='/blog/cats/2015~08/?opendiv=2015'>2015-08</a><span class='right_span'>25</span></li>
<li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>31</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/03/21/graphviz-codeviz/">用Graphviz + CodeViz生成C/C++函数调用图(call graph)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/21/command-sed/">sed命令</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/21/command-awk/">awk命令</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/09/kernel-net-bonding-source/">bonding的源代码分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/09/kernel-net-bonding/">七种网卡绑定模式详解</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
	<li>
		<a href=http://smilejay.com/ target=_blank>smilejay</a>
	</li>
	<li>
		<a href=http://blog.chinaunix.net/uid/10167808.html target=_blank>godbach</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
