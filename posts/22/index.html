
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/02/kernel-mm-alloc-numa/">Linux-2.6.32 NUMA架构之内存和调度</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-02T15:32:00+08:00'><span class='date'>2015-06-02</span> <span class='time'>15:32:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.chinaunix.net/uid-7295895-id-3076420.html">http://blog.chinaunix.net/uid-7295895-id-3076420.html</a></p>

<p>Linux-2.6.32 NUMA架构之内存和调度</p>

<p>  本文将以XLP832通过ICI互连形成的NUMA架构进行分析，主要包括内存管理和调度两方面，参考内核版本2.6.32.9；NUMA架构常见配置选项有：CONFIG_SMP, CONFIG_NUMA, CONFIG_NEED_MULTIPLE_NODES, CONFIG_NODES_SHIFT, CONFIG_SPARSEMEM, CONFIG_CGROUPS, CONFIG_CPUSETS, CONFIG_MIGRATION等。</p>

<p>本文试图从原理上介绍，尽量避免涉及代码的实现细节。</p>

<h3>1 NUMA架构简介</h3>

<p>NUMA(Non Uniform Memory Access)即非一致内存访问架构，市面上主要有X86_64(JASPER)和MIPS64(XLP)体系。</p>

<h4>1.1 概念</h4>

<p>NUMA具有多个节点(Node)，每个节点可以拥有多个CPU(每个CPU可以具有多个核或线程)，节点内使用共有的内存控制器，因此节点的所有内存对于本节点的所有CPU都是等同的，而对于其它节点中的所有CPU都是不同的。节点可分为本地节点(Local Node)、邻居节点(Neighbour Node)和远端节点(Remote Node)三种类型。</p>

<p>本地节点：对于某个节点中的所有CPU，此节点称为本地节点；<br/>
邻居节点：与本地节点相邻的节点称为邻居节点；<br/>
远端节点：非本地节点或邻居节点的节点，称为远端节点。</p>

<p>邻居节点和远端节点，称作非本地节点(Off Node)。</p>

<p>CPU访问不同类型节点内存的速度是不相同的：本地节点>邻居节点>远端节点。访问本地节点的速度最快，访问远端节点的速度最慢，即访问速度与节点的距离有关，距离越远访问速度越慢，此距离称作Node Distance。</p>

<p>常用的NUMA系统中：硬件设计已保证系统中所有的Cache是一致的(Cache Coherent, ccNUMA)；不同类型节点间的Cache同步时间不一样，会导致资源竞争不公平，对于某些特殊的应用，可以考虑使用FIFO Spinlock保证公平性。</p>

<h4>1.2 关键信息</h4>

<p>1) 物理内存区域与Node号之间的映射关系；<br/>
2) 各Node之间的Node Distance；<br/>
3) 逻辑CPU号与Node号之间的映射关系。</p>

<h3>2 XLP832 NUMA初始化</h3>

<p>首先需要完成1.2节中描述的3个关键信息的初始化。</p>

<h4>2.1 CPU和Node的关系</h4>

<p>start_kernel()->setup_arch()->prom_init():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#ifdef CONFIG_NUMA
</span><span class='line'>&#9;build_node_cpu_map();
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>build_node_cpu_map()函数工作：</p>

<p>a) 确定CPU与Node的相互关系，做法很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define cpu_to_node(cpu)       (cpu &gt;&gt; 5)
</span><span class='line'>#define cpumask_of_node    (NODE_CPU_MASK(node)) /* node0:0~31; node1: 32~63 */</span></code></pre></td></tr></table></div></figure>


<p>说明：XLP832每个节点有1个物理CPU，每个物理CPU有8个核，每个核有4个超线程，因此每个节点对应32个逻辑CPU，按节点依次展开。另外，实际物理存在的CPU数目是通过DTB传递给内核的；numa_node_id()可以获取当前CPU所处的Node号。</p>

<p>b) 设置每个物理存在的节点的在线状态，具体是通过node_set_online()函数来设置全局变量</p>

<p>nodemask_t node_states[];</p>

<p>这样，类似于CPU号，Node号也就具有如下功能宏：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for_each_node(node);
</span><span class='line'>for_each_online_node(node);</span></code></pre></td></tr></table></div></figure>


<p>详细可参考include/linux/nodemask.h</p>

<h4>2.2 Node Distance确立</h4>

<p>作用：建立buddy时用，可以依此来构建zonelist，以及zone relaim(zone_reclaim_mode)使用，详见后面的4.2.2节。</p>

<h4>2.3 内存区域与Node的关系</h4>

<p>start_kernel()->setup_arch()->arch_mem_init->bootmem_init()->nlm_numa_bootmem_init():</p>

<p>nlm_get_dram_mapping();</p>

<p>XLP832上电后的默认memory-mapped物理地址空间分布：</p>

<p><img src="/images/kernel/2015-06-02-30.jpg" alt="" /></p>

<p>  其中PCIE配置空间映射地址范围为[0x1800_0000, 0x1BFF_FFFF]，由寄存器ECFG_BASE和ECFG_LIMIT指定(注：但这2个寄存器本身是处于PCIE配置空间之中的)。</p>

<p>PCIE配置空间：<br/>
  PCIE配置空间与memory-mapped物理地址的映射方式：</p>

<p><img src="/images/kernel/2015-06-02-31.jpg" alt="" /></p>

<p>XLP832实现了所有设备都位于虚拟总线0上，每个节点有8个设备，按节点依次排开。</p>

<p>DRAM映射寄存器组：<br/>
  每个节点都独立实现有几组不同类型的DRAM(每组有8个相同类型的)寄存器可以配置DRAM空间映射到物理地址空间中的基址和大小，以及所属的节点信息(这些寄存器的值事先会由bootloader设好)；这组寄存器位于虚拟总线0的设备0/8/16/24(依次对应每个节点的第一个设备号)的Function0(每个设备最多可定义8个Function，每个Function有着独立的PCIE 4KB的配置空间)的PCIE配置空间中(这个配置空间实现的是DRAM/Bridge控制器)。</p>

<p>本小节涉及到的3组不同类型的寄存器(注：按索引对应即DRAM_BAR<n>,DRAM_LIMIT<n>和 DRAM_NODE_TRANSLATION<n>描述一个内存区域属性)：</p>

<p>第一组(DRAM空间映射物理空间基址)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DRAM_BAR0: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x54
</span><span class='line'>DRAM_BAR1: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x55
</span><span class='line'>DRAM_BAR2: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x56
</span><span class='line'>DRAM_BAR3: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x57
</span><span class='line'>DRAM_BAR4: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x58
</span><span class='line'>DRAM_BAR5: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x59
</span><span class='line'>DRAM_BAR6: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x5A
</span><span class='line'>DRAM_BAR7: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x5B</span></code></pre></td></tr></table></div></figure>


<p>第二组(DRAM空间映射物理空间长度)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DRAM_LIMIT0: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x5C
</span><span class='line'>DRAM_LIMIT1: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x5D
</span><span class='line'>DRAM_LIMIT2: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x5E
</span><span class='line'>DRAM_LIMIT3: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x5F
</span><span class='line'>DRAM_LIMIT4: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x60
</span><span class='line'>DRAM_LIMIT5: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x61
</span><span class='line'>DRAM_LIMIT6: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x62
</span><span class='line'>DRAM_LIMIT7: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x63</span></code></pre></td></tr></table></div></figure>


<p>第三组(节点相关)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DRAM_NODE_TRANSLATION0: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x64
</span><span class='line'>DRAM_NODE_TRANSLATION1: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x65
</span><span class='line'>DRAM_NODE_TRANSLATION2: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x66
</span><span class='line'>DRAM_NODE_TRANSLATION3: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x67
</span><span class='line'>DRAM_NODE_TRANSLATION4: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x68
</span><span class='line'>DRAM_NODE_TRANSLATION5: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x69
</span><span class='line'>DRAM_NODE_TRANSLATION6: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x6A
</span><span class='line'>DRAM_NODE_TRANSLATION7: PCIe Bus 0, Device 0/8/16/24, Function 0, Register 0x6B</span></code></pre></td></tr></table></div></figure>


<p>根据上述的PCIE配置空间memory-mapped映射方式便可直接获取寄存器中的值，就可以建立各个节点中的所有内存区域(最多8个区域)信息。关于这些寄存器的使用可以参考“XLP® Processor Family Programming Reference Manual”的“Chapter 7 Memory and I/O Subsystem”。</p>

<h3>3 Bootmem初始化</h3>

<p>bootmem_init()->…->init_bootmem_node()->init_bootmem_core():</p>

<p><img src="/images/kernel/2015-06-02-32.jpg" alt="" /></p>

<p>每个节点拥有各自的bootmem管理(code&amp;data之前可以为空闲页面)。</p>

<h3>4 Buddy初始化</h3>

<p>初始化流程最后会设置全局struct node_active_region early_node_map[]用于初始化Buddy系统，for_each_online_node()遍历所有在线节点调用free_area_init_node()初始化，主要初始化每个zone的大小和所涉及页面的struct page结构(flags中初始化有所属zone和node信息，由set_page_links()函数设置)等。</p>

<h4>4.1 NUMA带来的变化</h4>

<p>1) pglist_data</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct pglist_data {
</span><span class='line'>&#9;struct zone node_zones[MAX_NR_ZONES];
</span><span class='line'>&#9;struct zonelist node_zonelists[MAX_ZONELISTS];
</span><span class='line'>&#9;int nr_zones;
</span><span class='line'>&#9;struct bootmem_data *bdata;
</span><span class='line'>&#9;unsigned long node_start_pfn;
</span><span class='line'>&#9;unsigned long node_present_pages; /* total number of physical pages */
</span><span class='line'>&#9;unsigned long node_spanned_pages; /* total size of physical pagerange, including holes */
</span><span class='line'>&#9;int node_id;
</span><span class='line'>&#9;wait_queue_head_t kswapd_wait;
</span><span class='line'>&#9;struct task_struct *kswapd;
</span><span class='line'>&#9;int kswapd_max_order;
</span><span class='line'>} pg_data_t;</span></code></pre></td></tr></table></div></figure>


<p>a)上节的bootmem结构的描述信息存放在NODE_DATA(node)-> bdata中；NODE_DATA(i)宏返回节点i的struct pglist_data结构，需要在架构相关的mmzone.h中实现；<br/>
b) #define MAX_ZONELISTS 2，请参考后面的“zonelist初始化”。</p>

<p>2) zone</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct zone {
</span><span class='line'>#ifdef CONFIG_NUMA
</span><span class='line'>&#9;int node;
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * zone reclaim becomes active if more unmapped pages exist.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;unsigned long        min_unmapped_pages;
</span><span class='line'>&#9;unsigned long        min_slab_pages;
</span><span class='line'>&#9;struct per_cpu_pageset   *pageset[NR_CPUS];
</span><span class='line'>#else
</span><span class='line'>&#9;… …
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>a)最终调用kmalloc_node()为pageset成员在每个CPU的对应的内存节点分配内存；<br/>
b)min_unmapped_pages 对应/proc/sys/vm/min_unmapped_ratio，默认值为1；<br/>
  min_slab_pages对应/proc/sys/vm/min_slab_ratio，默认值为5；<br/>
  作用：当剩余可回收的非文件映射和SLAB页面超过这2个值时，才激活当前zone回收；</p>

<p>c) 增加了zone对应的节点号。</p>

<h4>4.2 zonelist初始化</h4>

<p>  本节讲述zonelist的构建方式，实现位于start_kernel()->build_all_zonelists()中，zonelist的组织方式非常关键(这一点与以前的2.6.21内核版本不一样，2.6.32组织得更清晰)。</p>

<h5>4.2.1 zonelist order</h5>

<p>NUMA系统中存在多个节点，每个节点对应一个struct pglist_data结构，此结构中可以包含多个zone，如：ZONE_DMA, ZONE_NORMAL，这样就产生几种排列顺序，以2个节点2个zone为例(zone从高到低排列, ZONE_DMA0表示节点0的ZONE_DMA，其它类似)：</p>

<p>a) Legacy方式<br/>
<img src="/images/kernel/2015-06-02-33.jpg" alt="" /><br/>
  每个节点只排列自己的zone；</p>

<p>b)Node方式<br/>
<img src="/images/kernel/2015-06-02-34.jpg" alt="" /><br/>
  按节点顺序依次排列，先排列本地节点的所有zone，再排列其它节点的所有zone。</p>

<p>c) Zone方式<br/>
<img src="/images/kernel/2015-06-02-35.jpg" alt="" /><br/>
  按zone类型从高到低依次排列各节点的同相类型zone。</p>

<p>可通过启动参数“numa_zonelist_order”来配置zonelist order，内核定义了3种配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define ZONELIST_ORDER_DEFAULT  0 /* 智能选择Node或Zone方式 */
</span><span class='line'>#define ZONELIST_ORDER_NODE     1 /* 对应Node方式 */
</span><span class='line'>#define ZONELIST_ORDER_ZONE     2 /* 对应Zone方式 */</span></code></pre></td></tr></table></div></figure>


<p>默认配置为ZONELIST_ORDER_DEFAULT，由内核通过一个算法来判断选择Node或Zone方式，算法思想：</p>

<p>a) alloc_pages()分配内存是按照ZONE从高到低的顺序进行的，例如上节“Node方式”的图示中，从ZONE_NORMAL0中分配内存时，ZONE_NORMAL0中无内存时将落入较低的ZONE_DMA0中分配，这样当ZONE_DMA0比较小的时候，很容易将ZONE_DMA0中的内存耗光，这样是很不理智的，因为还有更好的分配方式即从ZONE_NORMAL1中分配；</p>

<p>b) 内核会检测各ZONE的页面数来选择Zone组织方式，当ZONE_DMA很小时，选择ZONELIST_ORDER_DEFAULT时，内核将倾向于选择ZONELIST_ORDER_ZONE方式，否则选择ZONELIST_ORDER_NODE方式。</p>

<p>另外，可以通过/proc/sys/vm/numa_zonelist_order动态改变zonelist order的分配方式。</p>

<h5>4.2.2 Node Distance</h5>

<p>上节中的例子是以2个节点为例，如果有>2个节点存在，就需要考虑不同节点间的距离来安排节点，例如以4个节点2个ZONE为例，各节点的布局(如4个XLP832物理CPU级联)值如下：</p>

<p><img src="/images/kernel/2015-06-02-36.jpg" alt="" /></p>

<p>上图中，Node0和Node2的Node Distance为25，Node1和Node3的Node Distance为25，其它的Node Distance为15。</p>

<h6>4.2.2.1 优先进行Zone Reclaim</h6>

<p>另外，当Node Distance超过20的时候，内核会在某个zone分配内存不足的时候，提前激活本zone的内存回收工作，由全局变量zone_reclaim_mode控制，build_zonelists()中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * If another node is sufficiently far away then it is better
</span><span class='line'> * to reclaim pages in a zone before going off node.
</span><span class='line'> */
</span><span class='line'>if (distance &gt; RECLAIM_DISTANCE)
</span><span class='line'>&#9;zone_reclaim_mode = 1;</span></code></pre></td></tr></table></div></figure>


<p>通过/proc/sys/vm/zone_reclaim_mode可以动态调整zone_reclaim_mode的值来控制回收模式，含义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define RECLAIM_OFF    0
</span><span class='line'>#define RECLAIM_ZONE  (1&lt;&lt;0)     /* Run shrink_inactive_list on the zone */
</span><span class='line'>#define RECLAIM_WRITE (1&lt;&lt;1)     /* Writeout pages during reclaim */
</span><span class='line'>#define RECLAIM_SWAP  (1&lt;&lt;2)     /* Swap pages out during reclaim */</span></code></pre></td></tr></table></div></figure>


<h6>4.2.2.2 影响zonelist方式</h6>

<p>采用Node方式组织的zonelist为：</p>

<p><img src="/images/kernel/2015-06-02-37.jpg" alt="" /></p>

<p>  即各节点按照与本节点的Node Distance距离大小来排序，以达到更优的内存分配。</p>

<h5>4.2.3 zonelist[2]</h5>

<p>配置NUMA后，每个节点将关联2个zonelist：<br/>
  1) zonelist[0]中存放以Node方式或Zone方式组织的zonelist，包括所有节点的zone；<br/>
  2) zonelist[1]中只存放本节点的zone即Legacy方式；</p>

<p>zonelist[1]用来实现仅从节点自身zone中的内存分配(参考<code>__GFP_THISNODE</code>标志)。</p>

<h3>5 SLAB初始化</h3>

<p>配置NUMA后对SLAB(本文不涉及SLOB或SLUB)的初始化影响不大，只是在分配一些变量采用类似Buddy系统的per_cpu_pageset(单面页缓存)在CPU本地节点进行内存分配。</p>

<h4>5.1 NUMA带来的变化</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct kmem_cache {
</span><span class='line'>&#9;struct array_cache *array[NR_CPUS];
</span><span class='line'>&#9;… …
</span><span class='line'>&#9;struct kmem_list3 *nodelists[MAX_NUMNODES];
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct kmem_list3 {
</span><span class='line'>&#9;… …
</span><span class='line'>&#9;struct array_cache *shared;    /* shared per node */
</span><span class='line'>&#9;struct array_cache **alien;    /* on other nodes */
</span><span class='line'>&#9;… …
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct slab {
</span><span class='line'>&#9;… …
</span><span class='line'>&#9;unsigned short nodeid;
</span><span class='line'>&#9;… …
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>上面的4种类型的指针变量在SLAB初始化完毕后将改用kmalloc_node()分配的内存。具体实现请参考enable_cpucache()，此函数最终调用alloc_arraycache()和alloc_kmemlist()来分配这些变量代表的空间。</p>

<p>  nodelists[MAX_NUMNODES]存放的是所有节点对应的相关数据，本文称作SLAB节点。每个节点拥有各自的数据；</p>

<p>注：有些非NUMA系统比如非连续内存系统可能根据不同的内存区域定义多个节点(实际上Node Distance都是0即物理内存访问速度相同)，所以这些变量并没有采用CONFIG_NUMA宏来控制，本文暂称为NUMA带来的变化。</p>

<h4>5.2 SLAB缓存</h4>

<p>配置NUMA后，SLAB将有三种类型的缓存：本地缓存(当前CPU的缓存)，共享缓存(节点内的缓存)和外部缓存(节点间的缓存)。</p>

<p>SLAB系统分配对象时，先从本地缓存中查找，如果本地缓存为空，则将共享缓存中的缓存搬运本地缓存中，重新从本地缓存中分配；如果共享缓存为空，则从SLAB中进行分配；如果SLAB中已经无空闲对象，则分配新的SLAB后重新分配本地缓存。</p>

<p>SLAB系统释放对象时，先不归还给SLAB (简化分配流程，也可充分利用CPU Cache)，如果是同节点的SLAB对象先放入本地缓存中，如果本地缓存溢出(满)，则转移一部分(以batch为单位)至共享缓存中；如果是跨节点释放，则先放入外部缓存中，如果外部缓存溢出，则转移一部分至共享缓存中，以供后续分配时使用；如果共享缓存溢出，则调用free_block()函数释放溢出的缓存对象。</p>

<p>关于这三种类型缓存的大小以及参数设置，不在本文的讨论范围。</p>

<p>本地缓存<br/>
  kmem_cache-> array[] 中缓存每个CPU的SLAB cached objects；</p>

<p>共享缓存<br/>
  kmem_list3[]->shared(如果存在shared缓存)中缓存与当前CPU同节点的所有CPU (如XLP832 NUMA系统中的Node0包含为CPU0~CPU31) 本地缓存溢出的缓存，详细实现请参考cache_flusharray()；另外，大对象SLAB不存在共享缓存。</p>

<p>外部缓存<br/>
  kmem_list3[]->alien中存放其它节点的SLAB cached objects，当在某个节点上分配的SLAB 的object在另外一个节点上被释放的时候(即slab->nodeid与numa_node_id()当前节点不相等时)，将加入到对象所在节点的alien缓存中(如果不存在此alien缓存，此对象不会被缓存，而是直接释放给此对象所属SLAB)，否则加入本地缓存或共享缓存(本地缓存溢出且存在shared缓存时)；当alien缓存满的时候，会调用cache_free_alien()搬迁至shared缓存中(如果不存在shared缓存，直接释放给SLAB)；</p>

<p>slab->nodeid记录本SLAB内存块(若干个页面)所在的节点。</p>

<p>示例</p>

<p>例如2个节点，CPU0~31位于Node0，CPU32~CPU63位于Node1：</p>

<p>64个(依次对应于CPU0~CPU63)本地缓存<br/>
kmem_cache->array[0~31]:在Node0分配“array_cache结构+cached Objs指针”；<br/>
kmem_cache->array[32~63]:在Node1分配“array_cache结构+cached Objs指针”；</p>

<p>2个SLAB节点<br/>
kmem_cache->nodelists[0]:在Node0分配“kmem_list3结构”；<br/>
kmem_cache->nodelists[1]:在Node1分配“kmem_list3结构”；</p>

<p>SLAB节点0(CPU0~CPU31)共享缓存和外部缓存alien[1]<br/>
kmem_cache->nodelists[0]->shared:在Node0分配“array_cache结构+cached Objs指针”；<br/>
kmem_cache->nodelists[0]->alien:在Node0分配“节点数<em>sizeof(void</em>)”；<br/>
kmem_cache->nodelists[0]->alien[0]:置为NULL；<br/>
kmem_cache->nodelists[0]->alien[1]:在Node0分配“array_cache结构+cached Objs指针”；</p>

<p>SLAB节点1(CPU32~CPU63)共享缓存和外部缓存alien[0]<br/>
kmem_cache->nodelists[1]->shared:在Node1分配“array_cache结构+cached Objs指针”；<br/>
kmem_cache->nodelists[1]->alien:在Node1分配“节点数<em>sizeof(void</em>)”；<br/>
kmem_cache->nodelists[1]->alien[0]:在Node1分配“array_cache结构+cached Objs指针”；<br/>
kmem_cache->nodelists[1]->alien[1]:置为NULL；</p>

<p>另外，可以用内核启动参数“use_alien_caches”来控制是否开启alien缓存：默认值为1，当系统中的节点数目为1时，use_alien_caches初始化为0；use_alien_caches目的是用于某些多节点非连续内存(访问速度相同)的非NUMA系统。</p>

<p>由上可见，随着节点个数的增加，SLAB明显会开销越来越多的缓存，这也是SLUB涎生的一个重要原因。</p>

<h4>5.3 __GFP_THISNODE</h4>

<p>SLAB在某个节点创建新的SLAB时，都会置<code>__GFP_THISNODE</code>标记向Buddy系统提交页面申请，Buddy系统中看到此标记，选用申请节点的Legacy zonelist[1]，仅从申请节点的zone中分配内存，并且不会走内存不足流程，也不会重试或告警，这一点需要引起注意。</p>

<p>SLAB在申请页面的时候会置GFP_THISNODE标记后调用cache_grow()来增长SLAB；</p>

<p>GFP_THISNODE定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#ifdef CONFIG_NUMA
</span><span class='line'>#define GFP_THISNODE     (__GFP_THISNODE | __GFP_NOWARN | __GFP_NORETRY)</span></code></pre></td></tr></table></div></figure>


<h3>6 调度初始化</h3>

<p>配置NUMA后负载均衡会多一层NUMA调度域，根据需要在topology.h中定义，示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SD_NODE_INIT (struct sched_domain) {                 \
</span><span class='line'>&#9;.parent             = NULL,                              \
</span><span class='line'>&#9;.child              = NULL,                              \
</span><span class='line'>&#9;.groups             = NULL,                              \
</span><span class='line'>&#9;.min_interval       = 8,                                 \
</span><span class='line'>&#9;.max_interval       = 32,                                \
</span><span class='line'>&#9;.busy_factor        = 32,                                \
</span><span class='line'>&#9;.imbalance_pct      = 125,                               \
</span><span class='line'>&#9;.cache_nice_tries   = 1,                                 \
</span><span class='line'>&#9;.flags              = SD_LOAD_BALANCE | SD_BALANCE_EXEC, \
</span><span class='line'>&#9;.last_balance       = jiffies,                           \
</span><span class='line'>&#9;.balance_interval   = 1,                                 \
</span><span class='line'>&#9;.nr_balance_failed  = 0,                                 \
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  顺便提一下，2.6.32对于实时任务不走负载均衡流程，采用了全局优先级调度的思想，保证实时任务的及时运行；这样的做法同时也解决了低版本内核在处理同一个逻辑CPU上相同最高优先级实时任务的负载均衡的时延。</p>

<h3>7 NUMA内存分配</h3>

<p>Zonelist[2]组织方式在NUMA内存分配过程中起着至关重要的作用，它决定了整个页面在不同节点间的申请顺序和流程。</p>

<h4>7.1显式分配</h4>

<p>显式分配即指定节点的分配函数，此类基础分配函数主要有2个：Buddy系统的   alloc_pages_node()和SLAB系统的kmem_cache_alloc_node()，其它的函数都可以从这2个派生出来。</p>

<p>例如，kmalloc_node()最终调用kmem_cache_alloc_node()进行分配。</p>

<h5>7.1.1 Buddy显式分配</h5>

<p>alloc_pages_node(node, gfp_flags, order)分配流程：<br/>
  1) 如果node小于0，node取本地节点号(node = numa_node_id())；<br/>
  2) NODE_DATA(node)得到node对应的struct pglist_data结构，从而得到zonelist[2]；<br/>
  3) 如果gfp_flags含有<code>__GFP_THISNODE</code>标志，仅在此节点分配内存，使用node节点的Legacy zonelist[1]，否则使用其包含所有节点zone的zonelist[0] (见4.2.2.3节)；<br/>
  4) 遍历确定出来的zonelist结构中包含的每一个符合要求的zone，gfp_flags指定了本次分配中的最高的zone，如<code>__GFP_HIGHMEM</code>表示最高的zone为ZONE_HIGH；<br/>
  5) 分配结束。</p>

<h5>7.1.2 SLAB显式分配</h5>

<p>kmem_cache_alloc_node(cachep, gfp_flags, node)分配流程：<br/>
  1) 如果node值为-1，node取本地节点号(node = numa_node_id())；<br/>
  2) 如果node &lt; -1，则执行fall back行为，此行为与用户策略有关，有点类似隐式分配：<br/>
   a) 根据用户策略(包括CPUSET和内存策略)依次选取节点，根据gfp_flags选取合适的zonelist进行分配；<br/>
   b) 如果内存不足分配失败，则跳过内存策略直接进行隐式Buddy页面分配(仍受CPUSET的限定，关于CPUSET和内存策略后面会介绍)，最终构建成新的SLAB并完成本次分配；转5)；<br/>
  3) 如果node是正常节点号，则先在node节点上根据gfp_flags选取合适的zonelist进行分配；<br/>
  4) 如果3)中node节点内存不足分配失败，转2) a)执行fall back行为。<br/>
  5) 分配结束。</p>

<p>注：fall back行为指的是某个节点上内存不足时会落到此节点的zonelist[0]中定义的其它节点zone分配。</p>

<h5>7.1.3 设备驱动</h5>

<p>配置CONFIG_NUMA后，设备会关联一个NUMA节点信息，struct device结构中会多一个numa_node字段记录本设备所在的节点，这个结构嵌套在各种类型的驱动中，如struct net_device结构。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct device {
</span><span class='line'>&#9;… …
</span><span class='line'>&#9;#ifdef CONFIG_NUMA
</span><span class='line'>&#9;&#9;int          numa_node;    /* NUMA node this device is close to */
</span><span class='line'>&#9;#endif
</span><span class='line'>&#9;… …
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>附<code>__netdev_alloc_skb()</code>的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sk_buff *__netdev_alloc_skb(struct net_device *dev,
</span><span class='line'>&#9;&#9;unsigned int length, gfp_t gfp_mask)
</span><span class='line'>{
</span><span class='line'>&#9;int node = dev-&gt;dev.parent ? dev_to_node(dev-&gt;dev.parent) : -1;
</span><span class='line'>&#9;struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>&#9;skb = __alloc_skb(length + NET_SKB_PAD, gfp_mask, 0, node);
</span><span class='line'>&#9;if (likely(skb)) {
</span><span class='line'>&#9;&#9;skb_reserve(skb, NET_SKB_PAD);
</span><span class='line'>&#9;&#9;skb-&gt;dev = dev;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return skb;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>__alloc_skb()</code>最终调用kmem_cache_alloc_node()和kmalloc_node()在此node上分配内存。</p>

<h4>7.2 隐式分配和内存策略</h4>

<p>隐式分配即不指定节点的分配函数，此类基础分配函数主要有2个：Buddy系统的   alloc_pages()和SLAB系统的kmem_cache_alloc()，其它的函数都可以从这2个派生出来。</p>

<p>隐式分配涉及到NUMA内存策略(Memory Policy)，内核定义了四种内存策略。</p>

<p>注：隐式分配还涉及到CPUSET，本文后面会介绍。</p>

<h5>7.2.1 内存策略</h5>

<p>内核mm/mempolicy.c中实现了NUMA内存的四种内存分配策略：MPOL_DEFAULT, MPOL_PREFERRED, MPOL_INTERLEAVE和MPOL_BIND，内存策略会从父进程继承。</p>

<p>MPOL_DEFAULT：使用本地节点的zonelist；<br/>
MPOL_PREFERRED：使用指定节点的zonelist；<br/>
MPOL_BIND： 设置一个节点集合，只能从这个集合中节点的zone申请内存：</p>

<p>  1)无<code>__GFP_THISNODE</code>申请标记，使用本地节点的zonelist[0]；<br/>
  2)置有<code>__GFP_THISNODE</code>申请标记，如果本地节点：<br/>
   a)在集合中，使用本地节点的zonelist[1]；<br/>
   b)不在集合中，使用集合中最小节点号的zonelist[1]；</p>

<p>MPOL_INTERLEAVE：采用Round-Robin方式从设定的节点集合中选出某个节点，使用此节点的zonelist；</p>

<p>内核实现的内存策略，用struct mempolicy结构来描述：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct mempolicy {
</span><span class='line'>&#9;atomic_t refcnt;
</span><span class='line'>&#9;unsigned short mode;              /* See MPOL_* above */
</span><span class='line'>&#9;unsigned short flags;             /* See set_mempolicy() MPOL_F_* above */
</span><span class='line'>&#9;union {
</span><span class='line'>&#9;&#9;short         preferred_node; /* preferred */
</span><span class='line'>&#9;&#9;nodemask_t    nodes;          /* interleave/bind */
</span><span class='line'>&#9;&#9;/* undefined for default */
</span><span class='line'>&#9;} v;
</span><span class='line'>&#9;union {
</span><span class='line'>&#9;&#9;nodemask_t cpuset_mems_allowed;     /* relative to these nodes */
</span><span class='line'>&#9;&#9;nodemask_t user_nodemask;           /* nodemask passed by user */
</span><span class='line'>&#9;} w;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>成员mode表示使用四种分配策略中的哪一种，联合体v根据不同的分配策略记录相应的分配信息。</p>

<p>另外，MPOL_PREFERRED策略有一种特殊的模式，当其flags置上MPOL_F_LOCAL标志后，将等同于MPOL_DEFAULT策略，内核默认使用此种策略，见全局变量default_policy。</p>

<p>内存策略涉及的分配函数有2个：alloc_pages_current()和alloc_page_vma()，可以分别为不同任务以及任务的不同VMA设置内存策略。</p>

<h5>7.2.2 Buddy隐式分配</h5>

<p>以默认的NUMA内存策略为例讲解，alloc_pages(gfp_flags, order)分配流程：<br/>
  1) 得到本地节点对应的struct pglist_data结构，从而得到zonelist[2]；<br/>
  2) 如果gfp_flags含有<code>__GFP_THISNODE</code>标志，仅在此节点分配内存即使用本地节点的Legacy zonelist[1]，否则使用zonelist[0] (见4.2.2.3节)；<br/>
  3) 遍历确定出来的zonelist结构中包含的每一个符合要求的zone，gfp_flags指定了本次分配中的最高的zone，如<code>__GFP_HIGHMEM</code>表示最高的zone为ZONE_HIGH；<br/>
  4) 分配结束。</p>

<h5>7.2.3 SLAB隐式分配</h5>

<p>以默认的NUMA内存策略为例讲解，kmem_cache_alloc(cachep, gfp_flags)分配流程：<br/>
  1) 调用<code>____cache_alloc()</code>函数在本地节点local_node分配，此函数无fall back行为；<br/>
  2) 如果1)中本地节点内存不足分配失败，调用<code>____cache_alloc_node</code>(cachep, gfp_flags,local_node)再次尝试在本地节点分配，如果还失败此函数会进行fall back行为；<br/>
  3) 分配结束。</p>

<h4>7.3 小结</h4>

<p>上文提到的所有的内存分配函数都允许fall back行为，但有2种情况例外：<br/>
  1) <code>__GFP_THISNODE</code>分配标记限制了只能从某一个节点上分配内存；<br/>
  2) MPOL_BIND策略，限制了只能从一个节点集合中的节点上分配内存；<br/>
   (gfp_zone(gfp_flags) &lt; policy_zone的情况，MPOL_BIND不限制节点)。</p>

<p>注：还有一种情况，CPUSET限制的内存策略，后面会介绍。</p>

<h3>8 CPUSET</h3>

<p>CPUSET基于CGROUP的框架构建的子系统，有如下特点：<br/>
  1) 限定一组任务所允许使用的内存Node和CPU资源；<br/>
  2) CPUSET在内核各子系统中添加的检测代码很少，对内核没有性能影响；<br/>
  3) CPUSET的限定优先级高于内存策略(针对于Node)和绑定(针对于CPU)；<br/>
  4) 没有额外实现系统调用接口，只能通过/proc文件系统和用户交互。</p>

<p>本节只讲述CPUSET的使用方法和说明。</p>

<h4>8.1 创建CPUSET</h4>

<p>因为CPUSET只能使用/proc文件系统访问，所以第一步就要先mount cpuset文件系统，配置CONFIG_CGROUPS和CONFIG_CPUSETS后/proc/filesystems中将有这个文件系统。</p>

<p>CPUSET是分层次的，可以在cpuset文件系统根目录是最顶层的CPUSET，可以在其下创建CPUSET子项，创建方式很简单即创建一个新的目录。</p>

<p>mount命令：mount nodev –t cpuset /your_dir或mount nodev –t cgroup –o cpuset /your_dir</p>

<p>Mount成功后，进入mount目录，这个就是最顶层的CPUSET了(top_cpuset)，下面附一个演示例子：</p>

<p><img src="/images/kernel/2015-06-02-38.jpg" alt="" /></p>

<h4>8.2 CPUSET文件</h4>

<p>介绍几个重要的CPUSET文件：<br/>
1) tasks，实际上是CGROUPS文件，为此CPUSET包含的线程pid集合；<br/>
  echo 100 > tasks</p>

<p>2) cgroup.procs是CGROUPS文件，为此CPUSET包含的线程组tgid集合；<br/>
  echo 100 > cgroup.procs</p>

<p>3) cpus是CPUSET文件，表示此CPUSET允许的CPU；<br/>
  echo 0-8 > cpus</p>

<p>4) mems是CPUSET文件，表示此CPUSET允许的内存节点；
  echo 0-1 > mems  (对应于struct task_struct中的mems_allowed字段)</p>

<p>5) sched_load_balance，为CPUSET文件，设置cpus集合的CPU是否参与负载均衡；
  echo 0 > sched_load_balance (禁止负载均衡)；默认值为1表示开启负载均衡；</p>

<p>6) sched_relax_domain_level，为CPUSET文件，数值代表某个调度域级别，大于此级别的调度域层次将禁用闲时均衡和唤醒均衡，而其余级别的调度域都开启；
也可以通过启动参数“relax_domain_level”设置，其值含义：<br/>
  -1 : 无效果，此为默认值<br/>
   0 - 设置此值会禁用所有调度域的闲时均衡和唤醒均衡<br/>
   1 - 超线程域<br/>
   2 - 核域<br/>
   3 - 物理域<br/>
   4 - NUMA域<br/>
   5 - ALLNODES模式的NUMA域</p>

<p>7) mem_exclusive和mem_hardwall，为CPUSET文件，表示内存硬墙标记；默认为0，表示软墙；有关CPUSET的内存硬墙(HardWall)和内存软墙(SoftWall)，下文会介绍；</p>

<p>8) memory_spread_page和memory_spread_slab，为CPUSET文件，设定CPUSET中的任务PageCache和SLAB(创建时置有SLAB_MEM_SPREAD)以Round-Robin方式使用内存节点(类似于MPOL_INTERLEAVE)；默认为0，表示未开启；struct task_struct结构中增加成员cpuset_mem_spread_rotor记录下次使用的节点号；</p>

<p>9) memory_migrate，为CPUSET文件，表明开启此CPUSET的内存迁移，默认为0；</p>

<p>  当一个任务从一个CPUSET1(mems值为0)迁移至另一个CPUSET2(mems值为1)的时候，此任务在节点0上分配的页面内容将迁移至节点1上分配新的页面(将数据同步到新页面)，这样就避免了此任务的非本地节点的内存访问。</p>

<p><img src="/images/kernel/2015-06-02-39.jpg" alt="" /></p>

<p>上图为单Node，8个CPU的系统。</p>

<p>1) 顶层CPUSET包含了系统中的所有CPU以及Node，而且是只读的，不能更改；<br/>
2) 顶层CPUSET包含了系统中的所有任务，可以更改；<br/>
3) child为新创建的子CPUSET，子CPUSET的资源不能超过父CPUSET的资源；<br/>
4) 新创建的CPUSET的mems和cpus都是空的，使用前必须先初始化；<br/>
5) 添加任务：设置tasks和cgroup.procs文件；<br/>
6) 删除任务：将任务重新添加至其它CPUSET(如顶层)就可以从本CPUSET删除任务。</p>

<h4>8.3 利用CPUSET限定CPU和Node</h4>

<p>设置步骤：<br/>
1) 在某个父CPUSET中创建子CPUSET；<br/>
2) 在子CPUSET目录下，输入指定的Node号至mems文件；<br/>
3) 在子CPUSET目录下，输入指定的Node号至mems文件；<br/>
4) 在子CPUSET目录下，设定任务至tasks或group.procs文件；<br/>
5) 还可以设置memory_migrate为1，激活内存页面的迁移功能。</p>

<p>这样限定后，此CPUSET中所有的任务都将使用限定的CPU和Node，但毕竟系统中的任务并不能完全孤立，比如还是可能会全局共享Page Cache，动态库等资源，因此内核在某些情况下还是可以允许打破这个限制，如果不允许内核打破这个限制，需要设定CPUSET的内存硬墙标志即mem_exclusive或mem_hardwall置1即可；CPUSET默认是软墙。</p>

<p>硬软墙用于Buddy系统的页面分配，优先级高于内存策略，请参考内核函数：</p>

<p>cpuset_zone_allowed_hardwall()和cpuset_zone_allowed_softwall()</p>

<p>另外，当内核分不到内存将导致Oops的时候，CPUSET所有规则将被打破，毕竟一个系统的正常运行才是最重要的：<br/>
  1) <code>__GFP_THISNODE</code>标记分配内存的时候(通常是SLAB系统)；<br/>
  2) 中断中分配内存的时候；<br/>
  3) 任务置有TIF_MEMDIE标记即被内核OOM杀死的任务。</p>

<h4>8.4 利用CPUSET动态改变调度域结构</h4>

<p>利用sched_load_balance文件可以禁用掉某些CPU的负载均衡，同时重新构建调度域，此功能类似启动参数“isolcpus”的功能。</p>

<p>8个CPU的系统中，系统中存在一个物理域，现需要禁掉CPU4~CPU7的负载均衡，配置步骤为：<br/>
  1) “mkdir child”在顶层CPUSET中创建子CPUSET，记为child；<br/>
  2) “echo 0-3 > child/cpus ”(新建CPUSET的sched_load_balance默认是是打开的)；<br/>
  3) “echo 0 > sched_load_balance”关闭顶层CPUSET的负载均衡。</p>

<p>操作过程见下图：</p>

<p><img src="/images/kernel/2015-06-02-40.jpg" alt="" /></p>

<p>由图可见，CPU4~CPU7的调度域已经不存在了，具体效果是将CPU4~CPU7从负载均衡中隔离出来。</p>

<h3>9 NUMA杂项</h3>

<p>1) /sys/devices/system/node/中记录有系统中的所有内存节点信息；<br/>
2)任务额外关联一个/proc/<tid>/numa_smaps文件信息；<br/>
3) tmpfs可以指定在某个Node上创建；<br/>
4) libnuma库和其numactl小工具可以方便操作NUMA内存；<br/>
5) … …</p>

<h3>10 参考资料</h3>

<ol>
<li>www.kernel.org</li>
<li>ULK3</li>
<li>XLP® Processor Family Programming Reference Manual</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/02/kernel-mm-alloc/">Linux内存管理</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-02T15:05:00+08:00'><span class='date'>2015-06-02</span> <span class='time'>15:05:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/myarrow/article/details/8624687">http://blog.csdn.net/myarrow/article/details/8624687</a></p>

<p><a href="http://blog.csdn.net/myarrow/article/details/8682819">http://blog.csdn.net/myarrow/article/details/8682819</a></p>

<h4>1. Linux物理内存三级架构</h4>

<p><img src="/images/kernel/2015-06-02-20.png" alt="" /></p>

<p>对于内存管理，Linux采用了与具体体系架构不相关的设计模型，实现了良好的可伸缩性。它主要由内存节点node、内存区域zone和物理页框page三级架构组成。</p>

<h5>内存节点node</h5>

<p>  内存节点node是计算机系统中对物理内存的一种描述方法，一个总线主设备访问位于同一个节点中的任意内存单元所花的代价相同，而访问任意两个不同节点中的内存单元所花的代价不同。在一致存储结构(Uniform Memory Architecture，简称UMA)计算机系统中只有一个节点，而在非一致性存储结构(NUMA)计算机系统中有多个节点。Linux内核中使用数据结构pg_data_t来表示内存节点node。如常用的ARM架构为UMA架构。</p>

<h5>内存区域zone</h5>

<p>  内存区域位于同一个内存节点之内，由于各种原因它们的用途和使用方法并不一样。如基于IA32体系结构的个人计算机系统中，由于历史原因使得ISA设备只能使用最低16MB来进行DMA传输。又如，由于Linux内核采用</p>

<p> • 物理页框page</p>

<h4>2. Linux虚拟内存三级页表</h4>

<p>Linux虚拟内存三级管理由以下三级组成：<br/>
 • PGD: Page Global Directory (页目录)<br/>
 • PMD: Page Middle Directory (页目录)<br/>
 • PTE:  Page Table Entry     (页表项)</p>

<p>每一级有以下三个关键描述宏：<br/>
 • SHIFT<br/>
 • SIZE<br/>
 • MASK</p>

<p>如页的对应描述为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* PAGE_SHIFT determines the page size  asm/page.h */  
</span><span class='line'>#define PAGE_SHIFT      12  
</span><span class='line'>#define PAGE_SIZE       (_AC(1,UL) &lt;&lt; PAGE_SHIFT)  
</span><span class='line'>#define PAGE_MASK       (~(PAGE_SIZE-1))  </span></code></pre></td></tr></table></div></figure>


<p>数据结构定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* asm/page.h */  
</span><span class='line'>typedef unsigned long pteval_t;  
</span><span class='line'>
</span><span class='line'>typedef pteval_t pte_t;  
</span><span class='line'>typedef unsigned long pmd_t;  
</span><span class='line'>typedef unsigned long pgd_t[2];  
</span><span class='line'>typedef unsigned long pgprot_t;  
</span><span class='line'>
</span><span class='line'>#define pte_val(x)      (x)  
</span><span class='line'>#define pmd_val(x)      (x)  
</span><span class='line'>#define pgd_val(x)  ((x)[0])  
</span><span class='line'>#define pgprot_val(x)   (x)  
</span><span class='line'>
</span><span class='line'>#define __pte(x)        (x)  
</span><span class='line'>#define __pmd(x)        (x)  
</span><span class='line'>#define __pgprot(x)     (x)  </span></code></pre></td></tr></table></div></figure>


<h5>2.1 Page Directory (PGD and PMD)</h5>

<p>  每个进程有它自己的PGD( Page Global Directory)，它是一个物理页，并包含一个pgd_t数组。其定义见&lt;asm/page.h>。 进程的pgd_t数据见 task_struct -> mm_struct -> pgd_t * pgd;</p>

<p>  ARM架构的PGD和PMD的定义如下&lt;arch/arm/include/asm/pgtable.h>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define PTRS_PER_PTE  512    // PTE中可包含的指针&lt;u32&gt;数 (21-12=9bit)  
</span><span class='line'>#define PTRS_PER_PMD  1  
</span><span class='line'>#define PTRS_PER_PGD  2048   // PGD中可包含的指针&lt;u32&gt;数 (32-21=11bit)&lt;/p&gt;&lt;p&gt;#define PTE_HWTABLE_PTRS (PTRS_PER_PTE)  
</span><span class='line'>#define PTE_HWTABLE_OFF  (PTE_HWTABLE_PTRS * sizeof(pte_t))  
</span><span class='line'>#define PTE_HWTABLE_SIZE (PTRS_PER_PTE * sizeof(u32))
</span><span class='line'>/*  
</span><span class='line'> * PMD_SHIFT determines the size of the area a second-level page table can map  
</span><span class='line'> * PGDIR_SHIFT determines what a third-level page table entry can map  
</span><span class='line'> */  
</span><span class='line'>#define PMD_SHIFT  21  
</span><span class='line'>#define PGDIR_SHIFT  21</span></code></pre></td></tr></table></div></figure>


<p>虚拟地址SHIFT宏图：</p>

<p><img src="/images/kernel/2015-06-02-21.png" alt="" /></p>

<p>虚拟地址MASK和SIZE宏图：</p>

<p><img src="/images/kernel/2015-06-02-22.png" alt="" /></p>

<h5>2.2 Page Table Entry</h5>

<p>PTEs, PMDs和PGDs分别由pte_t, pmd_t 和pgd_t来描述。为了存储保护位，pgprot_t被定义，它拥有相关的flags并经常被存储在page table entry低位(lower bits)，其具体的存储方式依赖于CPU架构。</p>

<p>每个pte_t指向一个物理页的地址，并且所有的地址都是页对齐的。因此在32位地址中有PAGE_SHIFT(12)位是空闲的，它可以为PTE的状态位。</p>

<p>PTE的保护和状态位如下图所示：</p>

<p><img src="/images/kernel/2015-06-02-23.png" alt="" /></p>

<h5>2.3 如何通过3级页表访问物理内存</h5>

<p>为了通过PGD、PMD和PTE访问物理内存，其相关宏在asm/pgtable.h中定义。</p>

<p>• pgd_offset</p>

<p>根据当前虚拟地址和当前进程的mm_struct获取pgd项的宏定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* to find an entry in a page-table-directory */  
</span><span class='line'>#define pgd_index(addr)     ((addr) &gt;&gt; PGDIR_SHIFT)  //获得在pgd表中的索引  
</span><span class='line'>
</span><span class='line'>#define pgd_offset(mm, addr)    ((mm)-&gt;pgd + pgd_index(addr)) //获得pmd表的起始地址  
</span><span class='line'>
</span><span class='line'>/* to find an entry in a kernel page-table-directory */  
</span><span class='line'>#define pgd_offset_k(addr)  pgd_offset(&init_mm, addr)  </span></code></pre></td></tr></table></div></figure>


<p>• pmd_offset</p>

<p>根据通过pgd_offset获取的pgd 项和虚拟地址，获取相关的pmd项(即pte表的起始地址)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Find an entry in the second-level page table.. */  
</span><span class='line'>#define pmd_offset(dir, addr)   ((pmd_t *)(dir))   //即为pgd项的值  </span></code></pre></td></tr></table></div></figure>


<p>• pte_offset</p>

<p>  根据通过pmd_offset获取的pmd项和虚拟地址，获取相关的pte项(即物理页的起始地址)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#ifndef CONFIG_HIGHPTE  
</span><span class='line'>#define __pte_map(pmd)      pmd_page_vaddr(*(pmd))  
</span><span class='line'>#define __pte_unmap(pte)    do { } while (0)  
</span><span class='line'>#else  
</span><span class='line'>#define __pte_map(pmd)      (pte_t *)kmap_atomic(pmd_page(*(pmd)))  
</span><span class='line'>#define __pte_unmap(pte)    kunmap_atomic(pte)  
</span><span class='line'>#endif  
</span><span class='line'>
</span><span class='line'>#define pte_index(addr)     (((addr) &gt;&gt; PAGE_SHIFT) & (PTRS_PER_PTE - 1))  
</span><span class='line'>
</span><span class='line'>#define pte_offset_kernel(pmd,addr) (pmd_page_vaddr(*(pmd)) + pte_index(addr))  
</span><span class='line'>
</span><span class='line'>#define pte_offset_map(pmd,addr)    (__pte_map(pmd) + pte_index(addr))  
</span><span class='line'>#define pte_unmap(pte)          __pte_unmap(pte)  
</span><span class='line'>
</span><span class='line'>#define pte_pfn(pte)        (pte_val(pte) &gt;&gt; PAGE_SHIFT)  
</span><span class='line'>#define pfn_pte(pfn,prot)   __pte(__pfn_to_phys(pfn) | pgprot_val(prot))  
</span><span class='line'>
</span><span class='line'>#define pte_page(pte)       pfn_to_page(pte_pfn(pte))  
</span><span class='line'>#define mk_pte(page,prot)   pfn_pte(page_to_pfn(page), prot)  
</span><span class='line'>
</span><span class='line'>#define set_pte_ext(ptep,pte,ext) cpu_set_pte_ext(ptep,pte,ext)  
</span><span class='line'>#define pte_clear(mm,addr,ptep) set_pte_ext(ptep, __pte(0), 0)  </span></code></pre></td></tr></table></div></figure>


<p>其示意图如下图所示：</p>

<p><img src="/images/kernel/2015-06-02-24.png" alt="" /></p>

<h5>2.4 根据虚拟地址获取物理页的示例代码</h5>

<p>  根据虚拟地址获取物理页的示例代码详见&lt;mm/memory.c中的函数follow_page>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** 
</span><span class='line'> * follow_page - look up a page descriptor from a user-virtual address 
</span><span class='line'> * @vma: vm_area_struct mapping @address 
</span><span class='line'> * @address: virtual address to look up 
</span><span class='line'> * @flags: flags modifying lookup behaviour 
</span><span class='line'> * 
</span><span class='line'> * @flags can have FOLL_ flags set, defined in &lt;linux/mm.h&gt; 
</span><span class='line'> * 
</span><span class='line'> * Returns the mapped (struct page *), %NULL if no mapping exists, or 
</span><span class='line'> * an error pointer if there is a mapping to something not represented 
</span><span class='line'> * by a page descriptor (see also vm_normal_page()). 
</span><span class='line'> */  
</span><span class='line'>struct page *follow_page(struct vm_area_struct *vma, unsigned long address,  
</span><span class='line'>&#9;&#9;    unsigned int flags)  
</span><span class='line'>{  
</span><span class='line'>&#9;pgd_t *pgd;  
</span><span class='line'>&#9;pud_t *pud;  
</span><span class='line'>&#9;pmd_t *pmd;  
</span><span class='line'>&#9;pte_t *ptep, pte;  
</span><span class='line'>&#9;spinlock_t *ptl;  
</span><span class='line'>&#9;struct page *page;  
</span><span class='line'>&#9;struct mm_struct *mm = vma-&gt;vm_mm;  
</span><span class='line'>
</span><span class='line'>&#9;page = follow_huge_addr(mm, address, flags & FOLL_WRITE);  
</span><span class='line'>&#9;if (!IS_ERR(page)) {  
</span><span class='line'>&#9;&#9;BUG_ON(flags & FOLL_GET);  
</span><span class='line'>&#9;&#9;goto out;  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;page = NULL;  
</span><span class='line'>&#9;pgd = pgd_offset(mm, address);  
</span><span class='line'>&#9;if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))  
</span><span class='line'>&#9;&#9;goto no_page_table;  
</span><span class='line'>
</span><span class='line'>&#9;pud = pud_offset(pgd, address);  
</span><span class='line'>&#9;if (pud_none(*pud))  
</span><span class='line'>&#9;&#9;goto no_page_table;  
</span><span class='line'>&#9;if (pud_huge(*pud) && vma-&gt;vm_flags & VM_HUGETLB) {  
</span><span class='line'>&#9;&#9;BUG_ON(flags & FOLL_GET);  
</span><span class='line'>&#9;&#9;page = follow_huge_pud(mm, address, pud, flags & FOLL_WRITE);  
</span><span class='line'>&#9;&#9;goto out;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;if (unlikely(pud_bad(*pud)))  
</span><span class='line'>&#9;&#9;goto no_page_table;  
</span><span class='line'>
</span><span class='line'>&#9;pmd = pmd_offset(pud, address);  
</span><span class='line'>&#9;if (pmd_none(*pmd))  
</span><span class='line'>&#9;&#9;goto no_page_table;  
</span><span class='line'>&#9;if (pmd_huge(*pmd) && vma-&gt;vm_flags & VM_HUGETLB) {  
</span><span class='line'>&#9;&#9;BUG_ON(flags & FOLL_GET);  
</span><span class='line'>&#9;&#9;page = follow_huge_pmd(mm, address, pmd, flags & FOLL_WRITE);  
</span><span class='line'>&#9;&#9;goto out;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;if (pmd_trans_huge(*pmd)) {  
</span><span class='line'>&#9;&#9;if (flags & FOLL_SPLIT) {  
</span><span class='line'>&#9;&#9;    split_huge_page_pmd(mm, pmd);  
</span><span class='line'>&#9;&#9;    goto split_fallthrough;  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;&#9;spin_lock(&mm-&gt;page_table_lock);  
</span><span class='line'>&#9;&#9;if (likely(pmd_trans_huge(*pmd))) {  
</span><span class='line'>&#9;&#9;    if (unlikely(pmd_trans_splitting(*pmd))) {  
</span><span class='line'>&#9;&#9;        spin_unlock(&mm-&gt;page_table_lock);  
</span><span class='line'>&#9;&#9;        wait_split_huge_page(vma-&gt;anon_vma, pmd);  
</span><span class='line'>&#9;&#9;    } else {  
</span><span class='line'>&#9;&#9;        page = follow_trans_huge_pmd(mm, address,  
</span><span class='line'>&#9;&#9;                         pmd, flags);  
</span><span class='line'>&#9;&#9;        spin_unlock(&mm-&gt;page_table_lock);  
</span><span class='line'>&#9;&#9;        goto out;  
</span><span class='line'>&#9;&#9;    }  
</span><span class='line'>&#9;&#9;} else  
</span><span class='line'>&#9;&#9;    spin_unlock(&mm-&gt;page_table_lock);  
</span><span class='line'>&#9;&#9;/* fall through */  
</span><span class='line'>&#9;}  
</span><span class='line'>split_fallthrough:  
</span><span class='line'>&#9;if (unlikely(pmd_bad(*pmd)))  
</span><span class='line'>&#9;&#9;goto no_page_table;  
</span><span class='line'>
</span><span class='line'>&#9;ptep = pte_offset_map_lock(mm, pmd, address, &ptl);  
</span><span class='line'>
</span><span class='line'>&#9;pte = *ptep;  
</span><span class='line'>&#9;if (!pte_present(pte))  
</span><span class='line'>&#9;&#9;goto no_page;  
</span><span class='line'>&#9;if ((flags & FOLL_WRITE) && !pte_write(pte))  
</span><span class='line'>&#9;&#9;goto unlock;  
</span><span class='line'>
</span><span class='line'>&#9;page = vm_normal_page(vma, address, pte);  
</span><span class='line'>&#9;if (unlikely(!page)) {  
</span><span class='line'>&#9;&#9;if ((flags & FOLL_DUMP) ||  
</span><span class='line'>&#9;&#9;    !is_zero_pfn(pte_pfn(pte)))  
</span><span class='line'>&#9;&#9;    goto bad_page;  
</span><span class='line'>&#9;&#9;page = pte_page(pte);  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;if (flags & FOLL_GET)  
</span><span class='line'>&#9;&#9;get_page(page);  
</span><span class='line'>&#9;if (flags & FOLL_TOUCH) {  
</span><span class='line'>&#9;&#9;if ((flags & FOLL_WRITE) &&  
</span><span class='line'>&#9;&#9;    !pte_dirty(pte) && !PageDirty(page))  
</span><span class='line'>&#9;&#9;    set_page_dirty(page);  
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * pte_mkyoung() would be more correct here, but atomic care 
</span><span class='line'>&#9;&#9; * is needed to avoid losing the dirty bit: it is easier to use 
</span><span class='line'>&#9;&#9; * mark_page_accessed(). 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;mark_page_accessed(page);  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;if ((flags & FOLL_MLOCK) && (vma-&gt;vm_flags & VM_LOCKED)) {  
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * The preliminary mapping check is mainly to avoid the 
</span><span class='line'>&#9;&#9; * pointless overhead of lock_page on the ZERO_PAGE 
</span><span class='line'>&#9;&#9; * which might bounce very badly if there is contention. 
</span><span class='line'>&#9;&#9; * 
</span><span class='line'>&#9;&#9; * If the page is already locked, we don't need to 
</span><span class='line'>&#9;&#9; * handle it now - vmscan will handle it later if and 
</span><span class='line'>&#9;&#9; * when it attempts to reclaim the page. 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;if (page-&gt;mapping && trylock_page(page)) {  
</span><span class='line'>&#9;&#9;    lru_add_drain();  /* push cached pages to LRU */  
</span><span class='line'>&#9;&#9;    /* 
</span><span class='line'>&#9;&#9;     * Because we lock page here and migration is 
</span><span class='line'>&#9;&#9;     * blocked by the pte's page reference, we need 
</span><span class='line'>&#9;&#9;     * only check for file-cache page truncation. 
</span><span class='line'>&#9;&#9;     */  
</span><span class='line'>&#9;&#9;    if (page-&gt;mapping)  
</span><span class='line'>&#9;&#9;        mlock_vma_page(page);  
</span><span class='line'>&#9;&#9;    unlock_page(page);  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;}  
</span><span class='line'>unlock:  
</span><span class='line'>&#9;pte_unmap_unlock(ptep, ptl);  
</span><span class='line'>out:  
</span><span class='line'>&#9;return page;  
</span><span class='line'>
</span><span class='line'>bad_page:  
</span><span class='line'>&#9;pte_unmap_unlock(ptep, ptl);  
</span><span class='line'>&#9;return ERR_PTR(-EFAULT);  
</span><span class='line'>
</span><span class='line'>no_page:  
</span><span class='line'>&#9;pte_unmap_unlock(ptep, ptl);  
</span><span class='line'>&#9;if (!pte_none(pte))  
</span><span class='line'>&#9;&#9;return page;  
</span><span class='line'>
</span><span class='line'>no_page_table:  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * When core dumping an enormous anonymous area that nobody 
</span><span class='line'>&#9; * has touched so far, we don't want to allocate unnecessary pages or 
</span><span class='line'>&#9; * page tables.  Return error instead of NULL to skip handle_mm_fault, 
</span><span class='line'>&#9; * then get_dump_page() will return NULL to leave a hole in the dump. 
</span><span class='line'>&#9; * But we can only make this optimization where a hole would surely 
</span><span class='line'>&#9; * be zero-filled if handle_mm_fault() actually did handle it. 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if ((flags & FOLL_DUMP) &&  
</span><span class='line'>&#9;&#9;(!vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;fault))  
</span><span class='line'>&#9;&#9;return ERR_PTR(-EFAULT);  
</span><span class='line'>&#9;return page;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>1. First Fit分配器</h4>

<p>  First Fit分配器是最基本的内存分配器，它使用bitmap而不是空闲块列表来表示内存。在bitmap中，如果page对应位为1，则表示此page已经被分配，为0则表示此page没有被分配。为了分配小于一个page的内存块，First Fit分配器记录了最后被分配的PFN (Page Frame Number)和分配的结束地址在页内的偏移量。随后小的内存分配被Merge到一起并存储到同一页中。</p>

<p>  First Fit分配器不会造成严重的内存碎片，但其效率较低，由于内存经常通过线性地址进行search，而First Fit中的小块内存经常在物理内存的开始处，为了分配大块内存而不得不扫描前面大量的内存。</p>

<h4>2. Boot Memory分配器</h4>

<p>  物理内存分配器如何分配内存来初始化其自己呢？</p>

<p>  答案是：通过Boot Memory分配器来实现，而Boot Memory分配器则通过最基本的First Fit分配器来实现。</p>

<h5>2.1 Boot Map定义</h5>

<p>  Boot Map通过数据结构bootmem_data来定义，详见&lt;linux/bootmem.h>，其定义如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct bootmem_data {  
</span><span class='line'>&#9;unsigned long node_boot_start; // 描述的物理内存的起始地址  
</span><span class='line'>&#9;unsigned long node_low_pfn;    // 结束物理地址，即ZONE_NORMAL的结束  
</span><span class='line'>&#9;void *node_bootmem_map;        // 描述“使用或空闲的位图”的地址  
</span><span class='line'>&#9;unsigned long last_offset;     // 最后被分配的页内偏移量，即在llast_pos描述的物理页中，  
</span><span class='line'>&#9;&#9;                         // 从last_offset开始，没有被分配   
</span><span class='line'>&#9;unsigned long last_pos;        // 最后被分配的页的PFN  
</span><span class='line'>} bootmem_data_t;  </span></code></pre></td></tr></table></div></figure>


<p>所有bootmem_data被放于全局变量bdata_list中。</p>

<h5>2.2 Boot Memory分配器初始化</h5>

<p>  每一个CPU架构被要求提供setup_arch函数，它负责获取初始化boot memory分配器的必要参数。不同的CPU架构通过不同的函数来实现，如ARM通过bootmem_init来实现。它负责获取以下参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>• min_low_pfn： 系统中可获得的最小的PFN，装载kernel image结束之后的第一页，在mm/bootmem.c中定义
</span><span class='line'>• max_low_pfn：低端内存(ZONE_NORMAL)中可获得的最大PFN
</span><span class='line'>• highstart_pfn：高端内存(ZONE_HIGHMEM)的起始PFN
</span><span class='line'>• highend_pfn：高端内存(ZONE_HIGHMEM)的结束PFN
</span><span class='line'>• max_pfn：系统中可获得的最大的PFN， 在mm/bootmem.c中定义</span></code></pre></td></tr></table></div></figure>


<p>PFN是在物理内存map的偏移量，以page为单位。Kernel可直接访问ZONE_NORMAL，其偏移量为：PAGE_OFFSET。</p>

<p>通过以上5个参数明确了可用物理内存之后，调用init_bootmem->init_bootmem_core来初始化contig_page_data。它主要完成以下两件事：<br/>
  1) 将把与此node对应pgdat_data_t插入到pgdat_list中<br/>
  2) 初始化bootmem_data_t的中参数，并分配表示页分配状态的bitmap，其大小为: (end_pfn-start_pfn+7)/8</p>

<p>bitmap的物理地址为：bootmem_data_t->node_boot_start<br/>
bitmap的虚拟地直为：bootmem_data_t->node_bootmem_map</p>

<h5>2.3 分配内存</h5>

<p> • reserve_bootmem：用于预留物理页面。但用于通用的内存分配是低率的，它主要用于各种驱动(如：Video Codec)预留内存。</p>

<p>常用的内存分配函数如下(in UMA架构，我们常的ARM架构为UMA架构)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>• alloc_bootmem
</span><span class='line'>• alloc_bootmem_low
</span><span class='line'>• alloc_bootmem_pages
</span><span class='line'>• alloc_bootmem_low_pages</span></code></pre></td></tr></table></div></figure>


<p>其调用关系如下图所示：</p>

<h6>2.3.1 <code>__alloc_bootmem</code></h6>

<p><code>__alloc_bootmem()</code> 需要以下参数：<br/>
 • pgdat 用于分配内存块的节点，在UMA架构中，它被忽略，因为它总是为：contig_page_data<br/>
 • size  指定请求分配的内存大小，以字节为单位<br/>
 • align 请求以多少字节对齐，地于小块内存分配，一般以SMP_CACHE_BYTES对齐，如在X86上，与L1硬件cache对齐<br/>
 • goal  偏好的分配内存的起始地址,</p>

<h6>2.3.2 __alloc_bootmem_core</h6>

<p>它从goal指定的地址开始，线性地扫描内存，以寻找可以满足内存分配要求的内存块。它的另外一项功能是决定是否需要把新分配的内存块与以前已经分配的内存块merge到一起。</p>

<p>分配内存常用函数定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#ifdef CONFIG_NO_BOOTMEM  
</span><span class='line'>/* We are using top down, so it is safe to use 0 here */  
</span><span class='line'>#define BOOTMEM_LOW_LIMIT 0  
</span><span class='line'>#else  
</span><span class='line'>#define BOOTMEM_LOW_LIMIT __pa(MAX_DMA_ADDRESS)  
</span><span class='line'>#endif  
</span><span class='line'>
</span><span class='line'>#define alloc_bootmem(x) \  
</span><span class='line'>&#9;__alloc_bootmem(x, SMP_CACHE_BYTES, BOOTMEM_LOW_LIMIT)  
</span><span class='line'>#define alloc_bootmem_align(x, align) \  
</span><span class='line'>&#9;__alloc_bootmem(x, align, BOOTMEM_LOW_LIMIT)  
</span><span class='line'>#define alloc_bootmem_nopanic(x) \  
</span><span class='line'>&#9;__alloc_bootmem_nopanic(x, SMP_CACHE_BYTES, BOOTMEM_LOW_LIMIT)  
</span><span class='line'>#define alloc_bootmem_pages(x) \  
</span><span class='line'>&#9;__alloc_bootmem(x, PAGE_SIZE, BOOTMEM_LOW_LIMIT)  
</span><span class='line'>#define alloc_bootmem_pages_nopanic(x) \  
</span><span class='line'>&#9;__alloc_bootmem_nopanic(x, PAGE_SIZE, BOOTMEM_LOW_LIMIT)  
</span><span class='line'>#define alloc_bootmem_node(pgdat, x) \  
</span><span class='line'>&#9;__alloc_bootmem_node(pgdat, x, SMP_CACHE_BYTES, BOOTMEM_LOW_LIMIT)  
</span><span class='line'>#define alloc_bootmem_node_nopanic(pgdat, x) \  
</span><span class='line'>&#9;__alloc_bootmem_node_nopanic(pgdat, x, SMP_CACHE_BYTES, BOOTMEM_LOW_LIMIT)  
</span><span class='line'>#define alloc_bootmem_pages_node(pgdat, x) \  
</span><span class='line'>&#9;__alloc_bootmem_node(pgdat, x, PAGE_SIZE, BOOTMEM_LOW_LIMIT)  
</span><span class='line'>#define alloc_bootmem_pages_node_nopanic(pgdat, x) \  
</span><span class='line'>&#9;__alloc_bootmem_node_nopanic(pgdat, x, PAGE_SIZE, BOOTMEM_LOW_LIMIT)  
</span><span class='line'>
</span><span class='line'>#define alloc_bootmem_low(x) \  
</span><span class='line'>&#9;__alloc_bootmem_low(x, SMP_CACHE_BYTES, 0)  
</span><span class='line'>#define alloc_bootmem_low_pages(x) \  
</span><span class='line'>&#9;__alloc_bootmem_low(x, PAGE_SIZE, 0)  
</span><span class='line'>#define alloc_bootmem_low_pages_node(pgdat, x) \  
</span><span class='line'>&#9;__alloc_bootmem_low_node(pgdat, x, PAGE_SIZE, 0)  </span></code></pre></td></tr></table></div></figure>


<h5>2.4 释放内存</h5>

<p>调用free_bootmem来释放内存。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __init free_bootmem(unsigned long addr, unsigned long size)  
</span><span class='line'>{  
</span><span class='line'>&#9;unsigned long start, end;  
</span><span class='line'>
</span><span class='line'>&#9;kmemleak_free_part(__va(addr), size);  
</span><span class='line'>
</span><span class='line'>&#9;start = PFN_UP(addr);  
</span><span class='line'>&#9;end = PFN_DOWN(addr + size);  
</span><span class='line'>
</span><span class='line'>&#9;mark_bootmem(start, end, 0, 0);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/02/kernel-mm-smp-numa/">SMP、NUMA体系结构</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-02T14:34:00+08:00'><span class='date'>2015-06-02</span> <span class='time'>14:34:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html">http://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html</a></p>

<p>blog.csdn.net/skymanwu/article/details/7551670</p>

<p>  从系统架构来看，目前的商用服务器大体可以分为三类，即对称多处理器结构 (SMP ： Symmetric Multi-Processor) ，非一致存储访问结构 (NUMA ： Non-Uniform Memory Access) ，以及海量并行处理结构 (MPP ： Massive Parallel Processing) 。它们的特征分别描述如下：</p>

<h4>1. SMP(Symmetric Multi-Processor)</h4>

<p>  SMP (Symmetric Multi Processing),对称多处理系统内有许多紧耦合多处理器，在这样的系统中，所有的CPU共享全部资源，如总线，内存和I/O系统等，操作系统或管理数据库的复本只有一个，这种系统有一个最大的特点就是共享所有资源。多个CPU之间没有区别，平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的进程。如果两个处理器同时请求访问一个资源（例如同一段内存地址），由硬件、软件的锁机制去解决资源争用问题。Access to RAM is serialized; this and cache coherency issues causes performance to lag slightly behind the number of additional processors in the system.</p>

<p><img src="/images/kernel/2015-06-02-10.gif" alt="" /></p>

<p>  所谓对称多处理器结构，是指服务器中多个 CPU 对称工作，无主次或从属关系。各 CPU 共享相同的物理内存，每个 CPU 访问内存中的任何地址所需时间是相同的，因此 SMP 也被称为一致存储器访问结构 (UMA ： Uniform Memory Access) 。对 SMP 服务器进行扩展的方式包括增加内存、使用更快的 CPU 、增加 CPU 、扩充 I/O( 槽口数与总线数 ) 以及添加更多的外部设备 ( 通常是磁盘存储 ) 。</p>

<p>  SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I/O 等 ) 都是共享的。也正是由于这种特征，导致了 SMP 服务器的主要问题，那就是它的扩展能力非常有限。对于 SMP 服务器而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU 。</p>

<p><img src="/images/kernel/2015-06-02-11.gif" alt="" /></p>

<h4>2. NUMA(Non-Uniform Memory Access)</h4>

<p>  由于 SMP 在扩展能力上的限制，人们开始探究如何进行有效地扩展从而构建大型系统的技术， NUMA 就是这种努力下的结果之一。利用 NUMA 技术，可以把几十个 CPU( 甚至上百个 CPU) 组合在一个服务器内。其 CPU 模块结构如图 2 所示：</p>

<p><img src="/images/kernel/2015-06-02-12.gif" alt="" /><br/>
图 2.NUMA 服务器 CPU 模块结构</p>

<p>  NUMA 服务器的基本特征是具有多个 CPU 模块，每个 CPU 模块由多个 CPU( 如 4 个 ) 组成，并且具有独立的本地内存、 I/O 槽口等。由于其节点之间可以通过互联模块 ( 如称为 Crossbar Switch) 进行连接和信息交互，因此每个 CPU 可以访问整个系统的内存 ( 这是 NUMA 系统与 MPP 系统的重要差别 ) 。显然，访问本地内存的速度将远远高于访问远地内存 ( 系统内其它节点的内存 ) 的速度，这也是非一致存储访问 NUMA 的由来。由于这个特点，为了更好地发挥系统性能，开发应用程序时需要尽量减少不同 CPU 模块之间的信息交互。</p>

<p>  利用 NUMA 技术，可以较好地解决原来 SMP 系统的扩展问题，在一个物理服务器内可以支持上百个 CPU 。比较典型的 NUMA 服务器的例子包括 HP 的 Superdome 、 SUN15K 、 IBMp690 等。</p>

<p>  但 NUMA 技术同样有一定缺陷，由于访问远地内存的延时远远超过本地内存，因此当 CPU 数量增加时，系统性能无法线性增加。如 HP 公司发布 Superdome 服务器时，曾公布了它与 HP 其它 UNIX 服务器的相对性能值，结果发现， 64 路 CPU 的 Superdome (NUMA 结构 ) 的相对性能值是 20 ，而 8 路 N4000( 共享的 SMP 结构 ) 的相对性能值是 6.3 。从这个结果可以看到， 8 倍数量的 CPU 换来的只是 3 倍性能的提升。</p>

<hr />

<p><img src="/images/kernel/2015-06-02-13.png" alt="" /></p>

<p><img src="/images/kernel/2015-06-02-14.jpg" alt="" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/02/kernel-sched-user-to-kernel/">用户态到内核态切换</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-02T14:16:00+08:00'><span class='date'>2015-06-02</span> <span class='time'>14:16:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.cnblogs.com/justcxtoworld/p/3155741.html">http://www.cnblogs.com/justcxtoworld/p/3155741.html</a></p>

<p>本文将主要研究在X86体系下Linux系统中用户态到内核态切换条件，及切换过程中内核栈和任务状态段TSS在中断机制/任务切换中的作用及相关寄存器的变化。</p>

<h4>一、用户态到内核态切换途径：</h4>

<p> 1：系统调用        2：中断 　　3：异常</p>

<p>对应代码，在3.3内核中，可以在/arch/x86/kernel/entry_32.S文件中查看。</p>

<h4>二、内核栈</h4>

<p>内核栈：Linux中每个进程有两个栈，分别用于用户态和内核态的进程执行，其中的内核栈就是用于内核态的堆栈，它和进程的task_struct结构，更具体的是thread_info结构一起放在两个连续的页框大小的空间内。</p>

<p>在内核源代码中使用C语言定义了一个联合结构方便地表示一个进程的thread_info和内核栈：</p>

<p>此结构在3.3内核版本中的定义在include/linux/sched.h文件的第2106行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2016  union thread_union {
</span><span class='line'>2017          struct thread_info thread_info;
</span><span class='line'>2018          unsigned long stack[THREAD_SIZE/sizeof(long)];
</span><span class='line'>2019     };        </span></code></pre></td></tr></table></div></figure>


<p>其中thread_info结构的定义如下：</p>

<p>3.3内核 /arch/x86/include/asm/thread_info.h文件第26行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 26 　　struct thread_info {
</span><span class='line'> 27         struct task_struct      *task;          /* main task structure */
</span><span class='line'> 28         struct exec_domain      *exec_domain;   /* execution domain */
</span><span class='line'> 29         __u32                   flags;          /* low level flags */
</span><span class='line'> 30         __u32                   status;         /* thread synchronous flags */
</span><span class='line'> 31         __u32                   cpu;            /* current CPU */
</span><span class='line'> 32         int                     preempt_count;  /* 0 =&gt; preemptable,
</span><span class='line'> 33                                                    &lt;0 =&gt; BUG */
</span><span class='line'> 34         mm_segment_t            addr_limit;
</span><span class='line'> 35         struct restart_block    restart_block;
</span><span class='line'> 36         void __user             *sysenter_return;
</span><span class='line'> 37 #ifdef CONFIG_X86_32
</span><span class='line'> 38         unsigned long           previous_esp;   /* ESP of the previous stack in
</span><span class='line'> 39                                                    case of nested (IRQ) stacks
</span><span class='line'> 40                                                 */
</span><span class='line'> 41         __u8                    supervisor_stack[0];
</span><span class='line'> 42 #endif
</span><span class='line'> 43         unsigned int            sig_on_uaccess_error:1;
</span><span class='line'> 44         unsigned int            uaccess_err:1;  /* uaccess failed */
</span><span class='line'> 45 };</span></code></pre></td></tr></table></div></figure>


<p>它们的结构图大致如下：</p>

<p><img src="/images/kernel/2015-06-02.png" alt="" /></p>

<p>  esp寄存器是CPU栈指针，存放内核栈栈顶地址。在X86体系中，栈开始于末端，并朝内存区开始的方向增长。从用户态刚切换到内核态时，进程的内核栈总是空的，此时esp指向这个栈的顶端。</p>

<p>  在X86中调用int指令型系统调用后会把用户栈的%esp的值及相关寄存器压入内核栈中，系统调用通过iret指令返回，在返回之前会从内核栈弹出用户栈的%esp和寄存器的状态，然后进行恢复。所以在进入内核态之前要保存进程的上下文，中断结束后恢复进程上下文，那靠的就是内核栈。</p>

<p>  这里有个细节问题，就是要想在内核栈保存用户态的esp,eip等寄存器的值，首先得知道内核栈的栈指针，那在进入内核态之前，通过什么才能获得内核栈的栈指针呢？答案是：TSS</p>

<h4>三、TSS</h4>

<p>X86体系结构中包括了一个特殊的段类型：任务状态段（TSS），用它来存放硬件上下文。TSS反映了CPU上的当前进程的特权级。</p>

<p>linux为每一个cpu提供一个tss段，并且在tr寄存器中保存该段。</p>

<p>在从用户态切换到内核态时，可以通过获取TSS段中的esp0来获取当前进程的内核栈 栈顶指针，从而可以保存用户态的cs,esp,eip等上下文。</p>

<p>注：linux中之所以为每一个cpu提供一个tss段，而不是为每个进程提供一个tss段，主要原因是tr寄存器永远指向它，在任务切换的适合不必切换tr寄存器，从而减小开销。</p>

<p>下面我们看下在X86体系中Linux内核对TSS的具体实现：</p>

<p>内核代码中TSS结构的定义：</p>

<p>3.3内核中：/arch/x86/include/asm/processor.h文件的第248行处：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>248   struct tss_struct {
</span><span class='line'>249         /*
</span><span class='line'>250          * The hardware state:
</span><span class='line'>251          */
</span><span class='line'>252         struct x86_hw_tss       x86_tss;
</span><span class='line'>253 
</span><span class='line'>254         /*
</span><span class='line'>255          * The extra 1 is there because the CPU will access an
</span><span class='line'>256          * additional byte beyond the end of the IO permission
</span><span class='line'>257          * bitmap. The extra byte must be all 1 bits, and must
</span><span class='line'>258          * be within the limit.
</span><span class='line'>259          */
</span><span class='line'>260         unsigned long           io_bitmap[IO_BITMAP_LONGS + 1];
</span><span class='line'>261 
</span><span class='line'>262         /*
</span><span class='line'>263          * .. and then another 0x100 bytes for the emergency kernel stack:
</span><span class='line'>264          */
</span><span class='line'>265         unsigned long           stack[64];
</span><span class='line'>266 
</span><span class='line'>267 } ____cacheline_aligned;    </span></code></pre></td></tr></table></div></figure>


<p>其中主要的内容是：<br/>
  硬件状态结构:     x86_hw_tss<br/>
  IO权位图: 　　　　io_bitmap<br/>
  备用内核栈: 　　  stack</p>

<p>其中硬件状态结构：其中在32位X86系统中x86_hw_tss的具体定义如下：</p>

<p>/arch/x86/include/asm/processor.h文件中第190行处：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>190#ifdef CONFIG_X86_32
</span><span class='line'>191 /* This is the TSS defined by the hardware. */
</span><span class='line'>192 struct x86_hw_tss {
</span><span class='line'>193         unsigned short          back_link, __blh;
</span><span class='line'>194         unsigned long           sp0;　　            //当前进程的内核栈顶指针
</span><span class='line'>195         unsigned short          ss0, __ss0h;       //当前进程的内核栈段描述符
</span><span class='line'>196         unsigned long           sp1;
</span><span class='line'>197         /* ss1 caches MSR_IA32_SYSENTER_CS: */
</span><span class='line'>198         unsigned short          ss1, __ss1h;
</span><span class='line'>199         unsigned long           sp2;
</span><span class='line'>200         unsigned short          ss2, __ss2h;
</span><span class='line'>201         unsigned long           __cr3;
</span><span class='line'>202         unsigned long           ip;
</span><span class='line'>203         unsigned long           flags;
</span><span class='line'>204         unsigned long           ax;
</span><span class='line'>205         unsigned long           cx;
</span><span class='line'>206         unsigned long           dx;
</span><span class='line'>207         unsigned long           bx;
</span><span class='line'>208         unsigned long           sp;      　　　　　　//当前进程用户态栈顶指针
</span><span class='line'>209         unsigned long           bp;
</span><span class='line'>210         unsigned long           si;
</span><span class='line'>211         unsigned long           di;
</span><span class='line'>212         unsigned short          es, __esh;
</span><span class='line'>213         unsigned short          cs, __csh;
</span><span class='line'>214         unsigned short          ss, __ssh;
</span><span class='line'>215         unsigned short          ds, __dsh;
</span><span class='line'>216         unsigned short          fs, __fsh;
</span><span class='line'>217         unsigned short          gs, __gsh;
</span><span class='line'>218         unsigned short          ldt, __ldth;
</span><span class='line'>219         unsigned short          trace;
</span><span class='line'>220         unsigned short          io_bitmap_base;
</span><span class='line'>221 
</span><span class='line'>222 } __attribute__((packed));</span></code></pre></td></tr></table></div></figure>


<p>linux的tss段中只使用esp0和iomap等字段，并且不用它的其他字段来保存寄存器，在一个用户进程被中断进入内核态的时候，从tss中的硬件状态结构中取出esp0（即内核栈栈顶指针），然后切到esp0，其它的寄存器则保存在esp0指的内核栈上而不保存在tss中。</p>

<p>每个CPU定义一个TSS段的具体实现代码：</p>

<p>3.3内核中/arch/x86/kernel/init_task.c第35行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 35  * per-CPU TSS segments. Threads are completely 'soft' on Linux,
</span><span class='line'> 36  * no more per-task TSS's. The TSS size is kept cacheline-aligned
</span><span class='line'> 37  * so they are allowed to end up in the .data..cacheline_aligned
</span><span class='line'> 38  * section. Since TSS's are completely CPU-local, we want them
</span><span class='line'> 39  * on exact cacheline boundaries, to eliminate cacheline ping-pong.
</span><span class='line'> 40  */
</span><span class='line'>
</span><span class='line'> 41 DEFINE_PER_CPU_SHARED_ALIGNED(struct tss_struct, init_tss) = INIT_TSS;</span></code></pre></td></tr></table></div></figure>


<p>INIT_TSS的定义如下:</p>

<p>3.3内核中 /arch/x86/include/asm/processor.h文件的第879行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>879 #define INIT_TSS  {                                                       \
</span><span class='line'>880         .x86_tss = {                                                      \
</span><span class='line'>881                 .sp0            = sizeof(init_stack) + (long)&init_stack, \
</span><span class='line'>882                 .ss0            = __KERNEL_DS,                            \
</span><span class='line'>883                 .ss1            = __KERNEL_CS,                            \
</span><span class='line'>884                 .io_bitmap_base = INVALID_IO_BITMAP_OFFSET,               \
</span><span class='line'>885          },                                                               \
</span><span class='line'>886         .io_bitmap              = { [0 ... IO_BITMAP_LONGS] = ~0 },       \
</span><span class='line'>887 }</span></code></pre></td></tr></table></div></figure>


<p>其中init_stack是宏定义，指向内核栈：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>61 #define init_stack              (init_thread_union.stack)</span></code></pre></td></tr></table></div></figure>


<p>这里可以看到分别把内核栈栈顶指针、内核代码段、内核数据段赋值给TSS中的相应项。从而进程从用户态切换到内核态时，可以从TSS段中获取内核栈栈顶指针，进而保存进程上下文到内核栈中。</p>

<h4>总结、有了上面的一些准备，现总结在进程从用户态到内核态切换过程中，Linux主要做的事：</h4>

<p>  1：读取tr寄存器，访问TSS段<br/>
  2：从TSS段中的sp0获取进程内核栈的栈顶指针<br/>
  3：由控制单元在内核栈中保存当前eflags,cs,ss,eip,esp寄存器的值。<br/>
  4：由SAVE_ALL保存其寄存器的值到内核栈<br/>
  5：把内核代码选择符写入CS寄存器，内核栈指针写入ESP寄存器，把内核入口点的线性地址写入EIP寄存器</p>

<p>此时，CPU已经切换到内核态，根据EIP中的值开始执行内核入口点的第一条指令。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/06/02/kernel-sched-switch/">进程切换过程分析</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-02T14:10:00+08:00'><span class='date'>2015-06-02</span> <span class='time'>14:10:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/nkguohao/article/details/9187381">http://blog.csdn.net/nkguohao/article/details/9187381</a></p>

<p>参考《深入理解Linux内核（第三版）》</p>

<h4>进程切换</h4>

<p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换，任务切换或上下文切换。下面几节描述在Linux中进行进程切换的主要内容。</p>

<h4>硬件上下文</h4>

<p>尽管每个进程可以拥有属于自己的地址空间，但所有进程必须共享CPU寄存器。因此要恢复一个进程的执行之前，内核必须确保每个寄存器装入了挂起进程时的值。</p>

<p>进程恢复执行前必须装入寄存器的一组数据称为硬件上下文。硬件上下文是进程可执行上下文的一个子集，因为可执行上下文包含进程执行时需要的所有信息。在Linux中，进程硬件上下文的一部分存在TSS段，而剩余部分存放在内核态的堆栈中。</p>

<p>在下面的描述中，我们假定用prev局部变量表示切换出的进程的描述符，next表示切换进的进程的描述符。因此，我们把进程切换定义为这样的行为：保存prev硬件上下文，用next硬件上下文代替prev。因为进程切换经常发生，因此减少和装入硬件上下文所花费的时间是非常重要的。</p>

<p>早期的Linux版本利用80x86体系结构所提供的硬件支持，并通过far jmp指令跳到进程TSS描述符的选择符来执行进程切换。当执行这条指令时，CPU通过自动保存原来的硬件上下文，装入新的硬件上下文来执行硬件上下文切换。但是基于以下原因，Linux2.6使用软件执行进程切换：</p>

<p>  通过一组mov指令逐步执行切换，这样能较好地控制所装入数据的合法性，尤其是，这使检查ds和es段寄存器的值成为可能，这些值有可能被恶意用户伪造。当用单独的farjmp指令时，不可能进行这类检查。</p>

<p>  旧方法和新方法所需时间大致相同。然而，尽管当前的切换代码还有改进的余地，却不能对硬件上下文切换进行优化。</p>

<p>进程切换只发生在内核态。在执行进程切换之前，用户态进程所使用的所有寄存器内容已保存在内核态堆栈上，这也包括ss和esp这对寄存器的内容。</p>

<h4>任务状态段</h4>

<p>80x86体系结构包括一个特殊的段类型，叫任务状态段（Task State Segment, TSS）来存放硬件上下文。尽管Linux并不使用硬件上下文切换，但是强制它为系统中每个不同的CPU创建一个TSS。这样做的两个主要理由为：<br/>
  当80x86的一个CPU从用户态切换到内核态时，它就从TSS中获取内核态堆栈的地址。<br/>
  当用户态进程试图通过in或out指令访问一个I/O端口时，CPU需要访问存放在TSS中的I/O许可图以检查该进程是否有访问端口的权力。</p>

<p>更确切地说，当进程在用户态下执行in或out指令时，控制单元执行下列操作：<br/>
  它检查eflags寄存器中的2位IOPL字段。如果该字段值为3，控制单元就执行I/O指令。否则，执行下一个检查。<br/>
  访问tr寄存器以确定当前的TSS和相应的I/O许可权位图。<br/>
  检查I/O指令中指定的I/O端口在I/O许可权位图中对应的位。如果该位清0，这条I/O指令就执行，否则控制单元产生一个”Generalprotetion”异常。</p>

<p>tss_struct结构描述TSS的格式。正如第二章(《深入理解Linux内核（第三版）》)所提到的，init_tss数组为系统上每个不同的CPU存放一个TSS。在每次进程切换时，内核都更新TSS的某些字段以便相应的CPU控制单元可以安全地检索到它需要的信息。因此，TSS反映了CPU上的当前进程的特权级，但不必为没有在运行的进程保留TSS。</p>

<p>每个TSS有它自己8字节的任务状态段描述符。这个描述符包括指向TSS起始地址的32位Base字段，20位Limit字段。TSSD的S标志被清0，以表示相应的TSS是系统段的事实。</p>

<p>Type字段置为11或9以表示这个段实际上是TSS。在Intel的原始设计中，系统中的每个进程都应当指向自己的TSS；Type字段的第二个有效位叫做Busy位；如果进程正由CPU执行，则该位置为1，否则置为0。在Linux的设计中，每个CPU只有一个TSS，因此，Busy位总置为1。</p>

<p>由linux创建的TSSD存放在全局描述符表中。GDT的基地址存放在每个CPU的gdtr寄存器中。每个CPU的tr寄存器包含相应TSS的TSSD选择符，也包括了两个隐藏了非编程字段；TSSD的Base字段和Limit字段。这样，处理器就能直接对TSS寻址而不用从GDT中检索TSS的地址。</p>

<h4>Thread字段</h4>

<p>在每次进程切换时，被替换进程的硬件上下文必须保存在别处。不能像Intel原始设计那样把它保存在TSS中，因为Linux为每个处理器而不是为每个进程使用TSS。</p>

<p>因此，每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。随后我们会看到，这个数据结构包含的字段涉及大部分CPU寄存器，但不包括诸如exa、ebx等等这些通用寄存器，它们的值保留在内核堆栈中。</p>

<h4>执行进程切换</h4>

<p>进程切换可能只发生在精心定义的点：schedule()函数（《深入理解Linux内核（第三版）》第七章有详细讨论）。这里，我们仅关注内核如何执行一个进程切换。</p>

<p>从本质上说，每个进程切换由两步组成：<br/>
  切换页全局目录以安装一个新的地址空间；将在第九章（《深入理解Linux内核（第三版）》）描述这一步。<br/>
  切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包含CPU寄存器。</p>

<p>我们又一次假定prev指向被替换进程的描述符，而next指向被激活进程的描述符。prev和next是schedule()函数的局部变量。</p>

<h4>switch_to宏</h4>

<p>进程切换的第二步由switch_to宏执行。它是内核中与硬件关系最密切的例程之一，要理解它到低做了些什么我们必须下些功夫。</p>

<p>首先，该宏有三个参数，它们是prev,next和last。你可能很容易猜到prev和next的作用：它们仅是局部变量prev和next的占位符，即它们是输入参数，分别表示被替换进程和新进程描述符的地址在内存中的位置。</p>

<p>那第三个参数last呢？在任何进程切换中，涉及到三个进程而不是两个。假设内核决定暂停进程A而激活里程B。在schedule()函数中，prev指向A的描述符而next指向B的描述符。switch_to宏一但使A暂停，A的执行流就冻结。</p>

<p>随后，当内核想再次此激活A，就必须暂停另一个进程C，于是就要用prev指向C而next指向A来执行另一个swithch_to宏。当A恢复它的执行流时，就会找到它原来的内核栈，于是prev局部变量还是指向A的描述符而next指向B的描述符。此时，代表进程A执行的内核就失去了对C的任何引用。但是，事实表明这个引用对于完成进程切换是很有用的。</p>

<p>switch_to宏的最后一个参数是输出参数，它表示宏把进程C的描述符地址写在内存的什么位置了。在进程切换之前，宏把第一个输入参数prev表示的变量的内容存入CPU的eax寄存器。在完成进程切换，A已经恢复执行时，宏把CPU的eax寄存器的内容写入由第三个输出参数&mdash;&mdash;-last所指示的A在内存中的位置。因为CPU寄存器不会在切换点发生变化，所以C的描述符地址也存在内存的这个位置。在schedule()执行过程中，参数last指向A的局部变量prev，所以prev被C的地址覆盖。</p>

<p>图3-7显示了进程A，B，C内核堆栈的内容以及eax寄存器的内容。必须注意的是：图中显示的是在被eax寄存器的内容覆盖以前的prev局部变量的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define switch_to(prev, next, last)                 \
</span><span class='line'>32do {                                  \
</span><span class='line'>33  /*                              \
</span><span class='line'>34   * Context-switching clobbers all registers, so we clobber  \
</span><span class='line'>35   * them explicitly, via unused output variables.        \
</span><span class='line'>36   * (EAX and EBP is not listed because EBP is saved/restored \
</span><span class='line'>37   * explicitly for wchan access and EAX is the return value of   \
</span><span class='line'>38   * __switch_to())                       \
</span><span class='line'>39   */                             \
</span><span class='line'>40  unsigned long ebx, ecx, edx, esi, edi;              \
</span><span class='line'>41                                  \
</span><span class='line'>42  asm volatile("pushfl\n\t"       /* save    flags */ \
</span><span class='line'>43           "pushl %%ebp\n\t"      /* save    EBP   */ \
</span><span class='line'>44           "movl %%esp,%[prev_sp]\n\t"    /* save    ESP   */ \
</span><span class='line'>45           "movl %[next_sp],%%esp\n\t"    /* restore ESP   */ \
</span><span class='line'>46           "movl $1f,%[prev_ip]\n\t"  /* save    EIP   */ \
</span><span class='line'>47           "pushl %[next_ip]\n\t" /* restore EIP   */ \
</span><span class='line'>48           __switch_canary                    \
</span><span class='line'>49           "jmp __switch_to\n"    /* regparm call  */ \
</span><span class='line'>50           "1:\t"                     \
</span><span class='line'>51           "popl %%ebp\n\t"       /* restore EBP   */ \
</span><span class='line'>52           "popfl\n"          /* restore flags */ \
</span><span class='line'>53                                  \
</span><span class='line'>54           /* output parameters */                \
</span><span class='line'>55           : [prev_sp] "=m" (prev-&gt;thread.sp),     \
</span><span class='line'>56             [prev_ip] "=m" (prev-&gt;thread.ip),     \
</span><span class='line'>57             "=a" (last),                 \
</span><span class='line'>58                                  \
</span><span class='line'>59             /* clobbered output registers: */        \
</span><span class='line'>60             "=b" (ebx), "=c" (ecx), "=d" (edx),      \
</span><span class='line'>61             "=S" (esi), "=D" (edi)               \
</span><span class='line'>62                                      \
</span><span class='line'>63             __switch_canary_oparam               \
</span><span class='line'>64                                  \
</span><span class='line'>65             /* input parameters: */              \
</span><span class='line'>66           : [next_sp]  "m" (next-&gt;thread.sp),     \
</span><span class='line'>67             [next_ip]  "m" (next-&gt;thread.ip),     \
</span><span class='line'>68                                      \
</span><span class='line'>69             /* regparm parameters for __switch_to(): */  \
</span><span class='line'>70             [prev]     "a" (prev),               \
</span><span class='line'>71             [next]     "d" (next)                \
</span><span class='line'>72                                  \
</span><span class='line'>73             __switch_canary_iparam               \
</span><span class='line'>74                                  \
</span><span class='line'>75           : /* reloaded segment registers */         \
</span><span class='line'>76          "memory");                  \
</span><span class='line'>77} while (0)
</span><span class='line'>78</span></code></pre></td></tr></table></div></figure>


<p>由于switch_to宏采用扩展的内联汇编语言编码，所以可读性比较差：实际上这段代码通过特殊位置记数法使用寄存器，而实际使用的通用寄存器由编译器自由选择。我们将采用标准汇编语言而不是麻烦的内联汇编语言来描述switch_to宏在80x86微处理器上所完成的典型工作。</p>

<p>  在eax和edx寄存器中分别保存prev和next的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>movl prev ,%eax
</span><span class='line'>movl next ,%edx</span></code></pre></td></tr></table></div></figure>


<p>  把eflags和ebp寄存器的内容保存在prev内核栈中。必須保存它们的原因是编译器认为在switch_to结束之前它们的值应当保持不变。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pushf1
</span><span class='line'>push %ebp</span></code></pre></td></tr></table></div></figure>


<p>  把esp的内容保存到prev->thread.esp中以使该字段指向prev内核栈的栈顶：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>movl %esp, 484(%eax)</span></code></pre></td></tr></table></div></figure>


<p>  把next->thread.esp装入esp.此时，内核开始在next的内核栈上操作，因此这条指令实际上完成了从prev到next的切换。由于进程描述符的地址和内核栈的地址紧挨着，所以改变内核栈意味着改变进程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>movl 484(%edx),%esp</span></code></pre></td></tr></table></div></figure>


<p>  把标记为1的地址存入prev->thread.eip。当被替换的进程重新恢复执行时，进程执行被标记为1的那条指令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>movl $lf, 480(%eax)</span></code></pre></td></tr></table></div></figure>


<p>  宏把next->thread.eip的值压入next的内核栈。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>push1 480(%edx)</span></code></pre></td></tr></table></div></figure>


<p>  跳到<code>__switch_to()</code> 函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>jmp __switch_to</span></code></pre></td></tr></table></div></figure>


<p>  这里被进程B替换的进程A再次获得CPU；它执行一些保存eflags和ebp寄存器内容的指令，这两条指令的第一条指令被标记为1。</p>

<p>  拷贝eax寄存器的内容到switch_to宏的第三个参数lash标识的内存区域中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>movl  %eax, last</span></code></pre></td></tr></table></div></figure>


<p>正如以前讨论的，eax寄存器指向刚被替换的进程描述符。</p>

<h4><code>__switch_to()</code>函数</h4>

<p><code>__switch_to()</code>函数执行大多数开始于switch_to()宏的进程切换。这个函数作用于prev_p和next_p参数，这两个参数表示前一个进程和新进程。这个函数的调用不同于一般函数的调用，因为<code>__switch_to()</code>从eax和edx取参数prev_p和next_p，而不像大多数函数一样从栈中取参数。为了强迫函数从寄存器取它的参数，内核利用<code>__attribute__</code>和regparm关键字，这两个关键字是C语言非标准的扩展名，由gcc编译程序实现。在include/asm-i386/system.h头文件中，<code>__switch_to()</code>函数的声明如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__switch_to(structtask_struct *prev_p,struct tast_struct *next_p)__attribute_(regparm(2));</span></code></pre></td></tr></table></div></figure>


<p>函数执行的步骤如下：<br/>
  1、执行由<code>__unlazy_fpu()</code>宏产生的代码，以有选择地保存prev_p进程的FPU、MMX及XMM寄存器的内容。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__unlazy_fpu(prev_p);</span></code></pre></td></tr></table></div></figure>


<p>  2、执行smp_processor_id()宏获得本地(local)CPU的下标，即执行代码的CPU。该宏从当前进程的thread_info结构的cpu字段获得下标将它保存到cpu局部变量。</p>

<p>  3、把next_p->thread.esp0装入对应于本地CPU的TSS的esp0字段；将在通过sysenter指令发生系统调用一节看到，以后任何由sysenter汇编指令产生的从用户态到内核态的特权级转换将把这个地址拷贝到esp寄存器中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>init_tss[cpu].esp0= next_p-&gt;thread.esp0;</span></code></pre></td></tr></table></div></figure>


<p>  4、把next_p进程使用的线程局部存储段装入本地CPU的全局描述符表；三个段选择符保存在进程描述符内的tls_array数组中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cpu_gdt_table[cpu][6]= next_p-&gt;thread.tls_array[0];
</span><span class='line'>cpu_gdt_table[cpu][7]= next_p-&gt;thread.tls_array[1];
</span><span class='line'>cpu_gdt_table[cpu][8]= next_p-&gt;thread.tls_array[2];</span></code></pre></td></tr></table></div></figure>


<p>  5、把fs和gs段寄存器的内容分别存放在prev_p->thread.fs和prev_p->thread.gs中，对应的汇编语言指令是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>movl%fs,40(%esi)
</span><span class='line'>movl%gs,44(%esi)</span></code></pre></td></tr></table></div></figure>


<p>  6、如果fs或gs段寄存器已经被prev_p或next_p进程中的任意一个使用，则将next_p进程的thread_struct描述符中保存的值装入这些寄存器中。这一步在逻辑上补充了前一步中执行的操作。主要的汇编语言指令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>movl40(%ebx),%fs
</span><span class='line'>movl44(%edb),%gs</span></code></pre></td></tr></table></div></figure>


<p>  7、ebx寄存器指向next_p->thread结构。代码实际上更复杂，因为当它检测到一个无效的段寄存器值时，CPU可能产生一个异常。</p>

<p>  8、用next_p->thread.debugreg数组的内容装载dr0,&hellip;,dr7中的6个调试寄存器。只有在next_p被挂起时正在使用调试寄存器，这种操作才能进行。这些寄存器不需要被保存，因为只有当一个调试器想要监控prev时prev_p->thread.debugreg才会修改。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(next_p-&gt;thread.debugreg[7]){
</span><span class='line'>loaddebug(&next_p-&gt;thread,0);
</span><span class='line'>loaddebug(&next_p-&gt;thread,1);
</span><span class='line'>loaddebug(&next_p-&gt;thread,2);
</span><span class='line'>loaddebug(&next_p-&gt;thread,3);
</span><span class='line'>loaddebug(&next_p-&gt;thread,6);
</span><span class='line'>loaddebug(&next_p-&gt;thread,7);</span></code></pre></td></tr></table></div></figure>


<p>  8、如果必要，更新TSS中的I/O位图。当next_p或prev_p有其自己的定制I/O权限位图时必须这么做：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(prev_p-&gt;thread.io_bitmap_ptr|| next_p-&gt;thread.io_bitmap_ptr )
</span><span class='line'>handle_io_bitmap(&next_p-&gt;thread,&init_tss[cpu]);</span></code></pre></td></tr></table></div></figure>


<p>因为进程很修改I/O权限位图，所以该位图在“懒”模式中被处理；当且仅当一个进程在当前时间片内实际访问I/O端口时，真实位图才被拷贝到本地CPU的TSS中。进程的定制I/O权限位图被保存在thread_info结构的io_bitmap_ptr字段指向的缓冲区中。handle_io_bitmap()函数为next_p进程设置本地CPU使用的TSS的in_bitmap字段如下：<br/>
  (a)如果next_p进程不拥有自己的I/O权限位图，则TSS的io_bitmap字段被设为0x8000.<br/>
  (b) 如果next_p进程拥有自己的I/O权限位图，则TSS的io_bitmap字段被设为0x9000。</p>

<p>TSS的io_bitmap字段应当包含一个在TSS中的偏移量，其中存放实际位图。无论何时用户态进程试图访问一个I/O端口，0x8000和0x9000指向TSS界限之外并将因此引起”Generalprotection”异常。do_general_protection()异常处理程序将检查保存在io_bitmap字段的值：如果是0x8000，函数发送一个SIGSEGV信号给用户态进程；如果是0x9000，函数把进程位图拷贝拷贝到本地CPU的TSS中，把io_bitmap字段为实际位图的偏移(104)，并强制再一次执行有缺陷的汇编指令。</p>

<p>  9、终止。
<code>__switch_to()</code>函数通过使用下列声明结束：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>return prev_p;</span></code></pre></td></tr></table></div></figure>


<p>  由编译器产生的相应汇编语言指令是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>movl %edl,%eax
</span><span class='line'>ret</span></code></pre></td></tr></table></div></figure>


<p>  prev_p参数被拷贝到eax，因为缺省情况下任何C函数的返回值被传递给eax寄存器。注意eax的值因此在调用<code>__switch_to()</code>的过程中被保护起来；这非常重要，因为调用switch_to宏时会假定eax总是用来存放被替换的进程描述符的地址。</p>

<p>  汇编语言指令ret把栈顶保存的返回地址装入eip程序计数器。不过，通过简单地跳转到<code>__switch_to()</code>函数来调用该函数。因此，ret汇编指令在栈中找到标号为1的指令的地址，其中标号为1的地址是由switch_to()宏推入栈中的。如果因为next_p第一次执行而以前从未被挂起，<code>__switch_to()</code>就找到ret_from_fork()函数的起始地址。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/23">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/21">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(40)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>23</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>13</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(52)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~haproxy/?opendiv=tools'>haproxy</a><a href='##' onmousedown=showDiv('tools~haproxy') id='aexp_tools~haproxy'><span class='exp_style' id='exp_tools~haproxy'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~haproxy')) document.getElementById('aexp_tools~haproxy').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(51)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~cgroup/?opendiv=system'>cgroup</a><a href='##' onmousedown=showDiv('system~cgroup') id='aexp_system~cgroup'><span class='exp_style' id='exp_system~cgroup'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~cgroup')) document.getElementById('aexp_system~cgroup').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~kvm/?opendiv=system'>kvm</a><a href='##' onmousedown=showDiv('system~kvm') id='aexp_system~kvm'><span class='exp_style' id='exp_system~kvm'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~kvm')) document.getElementById('aexp_system~kvm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~namespace/?opendiv=system'>namespace</a><a href='##' onmousedown=showDiv('system~namespace') id='aexp_system~namespace'><span class='exp_style' id='exp_system~namespace'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~namespace')) document.getElementById('aexp_system~namespace').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(158)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~fs/?opendiv=kernel'>fs</a><a href='##' onmousedown=showDiv('kernel~fs') id='aexp_kernel~fs'><span class='exp_style' id='exp_kernel~fs'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~fs')) document.getElementById('aexp_kernel~fs').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>33</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>76</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>19</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(22)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(68)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>18</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~perf/?opendiv=debug'>perf</a><a href='##' onmousedown=showDiv('debug~perf') id='aexp_debug~perf'><span class='exp_style' id='exp_debug~perf'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~perf')) document.getElementById('aexp_debug~perf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(27)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>20</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(207)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~12/?opendiv=2015'>2015-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2015~11/?opendiv=2015'>2015-11</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2015~10/?opendiv=2015'>2015-10</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2015~09/?opendiv=2015'>2015-09</a><span class='right_span'>18</span></li>
<li><a href='/blog/cats/2015~08/?opendiv=2015'>2015-08</a><span class='right_span'>25</span></li>
<li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>31</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/27/kernel-net-test-tool/">Web压力测试工具</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/27/alg-mul2_add2/">乘2加1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/08/kernel-net-cwnd-test/">TCP拥塞控制窗口有效性验证机制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/08/android-base-adjust/">Android 系统基本</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/26/lang-c-flock/">c 文件锁flock</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
	<li>
		<a href=http://smilejay.com/ target=_blank>smilejay</a>
	</li>
	<li>
		<a href=http://blog.chinaunix.net/uid/10167808.html target=_blank>godbach</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
