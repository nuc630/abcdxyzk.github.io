
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>学习中......</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2014/04/09/alg-suffix/">[大牛的]后缀数组总结</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-04-09T17:57:00+08:00'><span class='date'>2014-04-09</span> <span class='time'>17:57:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h5>双关键字的基数排序</h5>

<p>先对关键字2进行排序，然后再对关键字1进行稳定排序。 后缀数组中用到了这点。</p>

<hr />

<p><a href="http://hi.baidu.com/ahnkftravhdhkyr">大牛在这里</a></p>

<p>  后缀数组是处理字符串的有力工具。后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能而时间复杂度也并不逊色，而且它比后缀树所占用的内存空间小很多。可以说，后缀数组比后缀树要更为实用。自从拜读了罗穗骞大牛的WC2009论文《后缀数组——处理字符串的有力工具》后，经过若干星期的努力（中间有因某些原因而缓下来），终于把论文上面的练习题全部完成了，现在写写自己对后缀数组的理解和感悟。在看本笔记时，请不要忘记了，这是笔记，而教材是《后缀数组——处理字符串的有力工具》。</p>

<h4>一：后缀数组的实现</h4>

<ol>
<li>定义：Suffix Array数组（SA数组）用于保存从小到大排好序之后的后缀。RANK名次数组用来保存后缀S[i..n]在所有后缀中是第几小的后缀。简单来说，SA数组表示的是“排第几的是谁”，RANK数组表示的是“你的排名是多少”。</li>
<li>求SA数组以及RANK数组的方法：详细的请转到罗穗骞大牛的论文，我的学习笔记重点不是要介绍这个。</li>
<li>对DA（倍增算法）的一些个人理解：由于我只学习了倍增算法，所以我只能谈谈我对它的理解。DC3算法我没有去研究&hellip;.</li>
</ol>


<p>DA算法我是根据罗穗骞的模板写的，根据自己的理解做了些许的小优化。我们现在来看看罗穗骞大牛的模板：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int wa[maxn],wb[maxn],wv[maxn],ws[maxn];
</span><span class='line'>int cmp(int *r,int a,int b,int l)
</span><span class='line'>{return r[a]==r[b]&&r[a+l]==r[b+l];}
</span><span class='line'>void da(int *r,int *sa,int n,int m)
</span><span class='line'>{
</span><span class='line'>    int i,j,p,*x=wa,*y=wb,*t;
</span><span class='line'>    for(i=0;i&lt;m;i++) ws[i]=0;
</span><span class='line'>    for(i=0;i&lt;n;i++) ws[x[i]=r[i]]++;
</span><span class='line'>    for(i=1;i&lt;m;i++) ws[i]+=ws[i-1];
</span><span class='line'>    for(i=n-1;i&gt;=0;i--) sa[--ws[x[i]]]=i;
</span><span class='line'>    for(j=1,p=1;p&lt;n;j*=2,m=p)
</span><span class='line'>    {
</span><span class='line'>        for(p=0,i=n-j;i&lt;n;i++) y[p++]=i;
</span><span class='line'>        for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j;
</span><span class='line'>        for(i=0;i&lt;n;i++) wv[i]=x[y[i]];
</span><span class='line'>        for(i=0;i&lt;m;i++) ws[i]=0;
</span><span class='line'>        for(i=0;i&lt;n;i++) ws[wv[i]]++;
</span><span class='line'>        for(i=1;i&lt;m;i++) ws[i]+=ws[i-1];
</span><span class='line'>        for(i=n-1;i&gt;=0;i--) sa[--ws[wv[i]]]=y[i];
</span><span class='line'>        for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
</span><span class='line'>        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;
</span><span class='line'>    }
</span><span class='line'>    return;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其实，我个人认为，对于这个算法以及代码，无需过分深入地理解，只需记忆即可，理解只是为了帮助记忆罢了。先解释变量：n为字符串长度，m为字符的取值范围，r为字符串。后面的j为每次排序时子串的长度。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for(i=0;i&lt;m;i++) ws[i]=0;
</span><span class='line'>for(i=0;i&lt;n;i++) ws[x[i]=r[i]]++;
</span><span class='line'>for(i=1;i&lt;m;i++) ws[i]+=ws[i-1];
</span><span class='line'>for(i=n-1;i&gt;=0;i--) sa[--ws[x[i]]]=i;</span></code></pre></td></tr></table></div></figure>


<p>这四行代码，进行的是对R中长度为1的子串进行基数排序。x数组在后面需要用到，所以先复制r数组的值。特别需要注意的是，第四行的for语句，初始化语句为i=n-1，如果写得不太熟练，很容易习惯性地写成i=0，我一开始就是。理解这是基数排序的最好方法，找个例子，自己推推&hellip;.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for(p=0,i=n-j;i&lt;n;i++) y[p++]=i;
</span><span class='line'>for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j;</span></code></pre></td></tr></table></div></figure>


<p>这两行代码，利用了上一次基数排序的结果，对待排序的子串的第二关键字进行了一次高效地基数排序。我们可以结合下面的图来理解：</p>

<p>不难发现，除了第一次基数排序以外，之后的每次双关键字排序，设此次排序子串长度为j，则从第n-j位开始的子串，其第二关键字均为0，所以得到第一个for语句：for(p=0,i=n-j;i&lt;n;i++) y[p++]=i;使用pascal的朋友们注意了，这里之所以是n-j位，是因为c++的字符串是从第0位开始表示的。这里，p暂时成为了一个计数变量。第二个语句的意义，分析上图也不难理解，这里留给朋友们你们自行思考啦。（不如说我懒&hellip;）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for(i=0;i&lt;n;i++) wv[i]=x[y[i]];
</span><span class='line'>for(i=0;i&lt;m;i++) ws[i]=0;
</span><span class='line'>for(i=0;i&lt;n;i++) ws[wv[i]]++;
</span><span class='line'>for(i=1;i&lt;m;i++) ws[i]+=ws[i-1];
</span><span class='line'>for(i=n-1;i&gt;=0;i--) sa[--ws[wv[i]]]=y[i];</span></code></pre></td></tr></table></div></figure>


<p>与一开始的4个for语句意义相同，基数排序。至于为什么wv[i]=x[y[i]]，这个我想了蛮久没想通&hellip;硬记算了- -哪位朋友理解的希望能告诉我一声&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
</span><span class='line'>    x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;</span></code></pre></td></tr></table></div></figure>


<p>这个for语句中的初始化语句里，完成了x数组和y数组的交换，用了指针的交换节约时间，简化代码。这里需要注意的是p和i的初始值都是1，不是0.其实如果记得后面的语句，不难看出它们的初始值不能为0，因为后面有i-1和p-1嘛。这个for语句的意义要结合cmp函数来理解。反正，你知道这里p的值表示的是此时关键字不同的串的数量就对了。当 p=n 的时候，说明所有串都已经排好序了（它们的排名都唯一确定）。所以，一开始的循环语句中，循环条件是（p&lt;n）。</p>

<p>另外，在使用倍增算法前，需要保证r数组的值均大于0。然后要在原字符串后添加一个0号字符，具体原因参见罗穗骞的论文。这时候，若原串的长度为n，则实际要进行后缀数组构建的r数组的长度应该为n+1.所以调用da函数时，对应的n应为n+1.</p>

<h4>二、后缀数组的应用&ndash;height数组</h4>

<p>在介绍后缀数组的应用前，先介绍后缀数组的一个重要附属数组：height数组。
1、height 数组：定义height[i]=suffix(sa[i-1])和suffix(sa[i])的最长公
共前缀，也就是排名相邻的两个后缀的最长公共前缀。
height数组是应用后缀数组解题是的核心，基本上使用后缀数组解决的题目都是依赖height数组完成的。</p>

<p>2、height数组的求法：具体的求法参见罗穗骞的论文。对于height数组的求法，我并没有去深刻理解，单纯地记忆了而已&hellip;有兴趣的朋友可以去钻研钻研再和我交流交流
这里给出代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int rank[maxn],height[maxn];
</span><span class='line'>void calheight(int *r,int *sa,int n)
</span><span class='line'>{
</span><span class='line'>    int i,j,k=0;
</span><span class='line'>    for(i=1;i&lt;=n;i++) rank[sa[i]]=i;
</span><span class='line'>    for(i=0;i&lt;n;height[rank[i++]]=k)
</span><span class='line'>    for(k?k--:0,j=sa[rank[i]-1];r[i+k]==r[j+k];k++);
</span><span class='line'>    return;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>3、一些注意事项：height数组的值应该是从height[1]开始的，而且height[1]应该是等于0的。原因是，因为我们在字符串后面添加了一个0号字符，所以它必然是最小的一个后缀。而字符串中的其他字符都应该是大于0的（前面有提到，使用倍增算法前需要确保这点），所以排名第二的字符串和0号字符的公共前缀（即height[1]）应当为0.在调用calheight函数时，要注意height数组的范围应该是[1..n]。所以调用时应该是calheight(r,sa,n)而不是calheight(r,sa,n+1)。要理解清楚这里的n的含义是什么。</p>

<p>calheight过程中，对rank数组求值的for语句的初始语句是i=1 而不是i=0 的原因，和上面说的类似，因为sa[0]总是等于那个已经失去作用的0号字符，所以没必要求出其rank值。当然你错写成for (i=0 ..)，也不会有什么问题。</p>

<h4>三、后缀数组解题总结：</h4>

<h5>1、求单个子串的不重复子串个数。SPOJ 694、SPOJ 705.</h5>

<p>  这个问题是一个特殊求值问题。要认识到这样一个事实：一个字符串中的所有子串都必然是它的后缀的前缀。（这句话稍微有点绕&hellip;）对于每一个sa[i]后缀，它的起始位置sa[i]，那么它最多能得到该后缀长度个子串（n-sa[i]个），而其中有height[i]个是与前一个后缀相同的，所以它能产生的实际后缀个数便是n-sa[i]-height[i]。遍历一次所有的后缀，将它产生的后缀数加起来便是答案。<br/>
代码及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/68f919f849748668024f56fb.html">http://hi.baidu.com/fhnstephen/blog/item/68f919f849748668024f56fb.html</a></p>

<h5>2、后缀的最长公共前缀。（记为lcp（x，y））</h5>

<p>这是height数组的最基本性质之一。具体的可以参看罗穗骞的论文。后缀i和后缀j的最长公共前缀的长度为它们在sa数组中所在排位之间的height值中的最小值。这个描述可能有点乱，正规的说，令x=rank[i],y=rank[j]，x&lt;y,那么lcp(i,j)=min(height[x+1],height[x+2]&hellip;height[y])。lcp(i,i)=n-sa[i]。解决这个问题，用RMQ的ST算法即可（我只会这个，或者用最近公共祖先那个转化的做法）。</p>

<h5>3、最长重复子串（可重叠）</h5>

<p>  要看到，任何一个重复子串，都必然是某两个后缀的最长公共前缀。因为，两个后缀的公共前缀，它出现在这两个后缀中，并且起始位置时不同的，所以这个公共前缀必然重复出现两次以上（可重叠）。而任何两个后缀的最长公共前缀为某一段height值中的最小值，所以最大为height值中的最大值（即某个lcp(sa[i],sa[i+1]））。所以只要算出height数组，然后输出最大值就可以了。<br/>
一道题目和代码：<a href="http://hi.baidu.com/fhnstephen/blog/item/4ed09dffdec0a78eb801a0ba.html">http://hi.baidu.com/fhnstephen/blog/item/4ed09dffdec0a78eb801a0ba.html</a></p>

<h5>4、最长重复不重叠子串 PKU1743</h5>

<p>  这个问题和3的唯一区别在于能否重叠。加上不能重叠这个限制后，直接求解比较困难，所以我们选择二分枚举答案，将问题转换为判定性问题。假设当时枚举的长度为k，那么要怎样判断是否存在长度为k的重复不重叠子串呢？</p>

<p>  首先，根据height数组，将后缀分成若干组，使得每组后缀中，后缀之间的height值不小于k。这样分组之后，不难看出，如果某组后缀数量大于1，那么它们之中存在一个公共前缀，其长度为它们之间的height值的最小值。而我们分组之后，每组后缀之间height值的最小值大于等于k。所以，后缀数大于1的分组中，有可能存在满足题目限制条件的长度不小于k的子串。只要判断满足题目限制条件成立，那么说明存在长度至少为k的合法子串。</p>

<p>  对于本题，限制条件是不重叠，判断的方法是，一组后缀中，起始位置最大的后缀的起始位置减去起始位置最小的后缀的起始位置>=k。满足这个条件的话，那么这两个后缀的公共前缀不但出现两次，而且出现两次的起始位置间隔大于等于k，所以不会重叠。</p>

<p>深刻理解这种height分组方法以及判断重叠与否的方法，在后面的问题中起到举足轻重的作用。<br/>
练习及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/85a25b208263794293580759.html">http://hi.baidu.com/fhnstephen/blog/item/85a25b208263794293580759.html</a></p>

<h5>5、最长的出现k次的重复（可重叠）子串。 PKU3261</h5>

<p>  使用后缀数组解题时，遇到“最长”，除了特殊情况外（如问题3），一般需要二分答案，利用height值进行分组。本题的限制条件为出现k次。只需判断，有没有哪一组后缀数量不少于k就可以了。相信有了我前面问题的分析作为基础，这个应该不难理解。注意理解“不少于k次”而不是“等于k次”的原因。如果理解不了，可以找个具体的例子来分析分析。<br/>
题目及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/be7d15133ccbe7f0c2ce79bb.html">http://hi.baidu.com/fhnstephen/blog/item/be7d15133ccbe7f0c2ce79bb.html</a></p>

<h5>6、最长回文子串 ural1297</h5>

<p>  这个问题没有很直接的方法可以解决，但可以采用枚举的方法。具体的就是枚举回文子串的中心所在位置i。注意要分回文子串的长度为奇数还是偶数两种情况分析。然后，我们要做的，是要求出以i为中心的回文子串最长为多长。利用后缀数组，可以设计出这样一种求法：求i往后的后缀与i往前的前缀的最长公共前缀。我这里的表述有些问题，不过不影响理解。</p>

<p>  要快速地求这个最长前缀，可以将原串反写之后接在原串后面。在使用后缀数组的题目中，连接两个（n个）字符串时，中间要用不可能会出现在原串中，不一样的非0号的字符将它们隔开。这样可以做到不影响后缀数组的性质。然后，问题就可以转化为求两个后缀的最长公共前缀了。具体的细节，留给大家自己思考&hellip;（懒&hellip;原谅我吧，都打这么多字了..一个多小时了啊TOT ）<br/>
题目及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/68342f1d5f9e3cf81ad576ef.html">http://hi.baidu.com/fhnstephen/blog/item/68342f1d5f9e3cf81ad576ef.html</a></p>

<h5>7、求一个串最多由哪个串复制若干次得到 PKU2406</h5>

<p>  具体的问题描述请参考PKU2406.这个问题可以用KMP解决，而且效率比后缀数组好。
利用后缀数组直接解决本题也很困难（主要是，就算二分答案，也难以解决转变而成的判定性问题。上题也是），但可以同过枚举模板串的长度k（模板串指被复制的那个串）将问题变成一个后缀数组可以解决的判定性问题。首先判断k能否被n整除，然后只要看lcp(1,k+1)（实际在用c写程序时是lcp(0,k)）是否为n-k就可以了。</p>

<p>  为什么这样就行了呢？这要充分考虑到后缀的性质。当lcp（1，k+1）=n-k时，后缀k+1是后缀1（即整个字符串）的一个前缀。（因为后缀k+1的长度为n-k）那么，后缀1的前k个字符必然和后缀k+1的前k个字符对应相同。而后缀1的第k+1..2k个字符，又相当于后缀k+1的前k个字符，所以与后缀1的前k个字符对应相同，且和后缀k的k+1..2k又对应相同。依次类推，只要lcp(1,k+1)=n-k,那么s[1..k]就可以通过自复制n/k次得到整个字符串。找出k的最小值，就可以得到n/k的最大值了。<br/>
题目及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/5d79f2efe1c3623127979124.html">http://hi.baidu.com/fhnstephen/blog/item/5d79f2efe1c3623127979124.html</a></p>

<h5>8、求两个字符串的最长公共子串。Pku2774、Ural1517</h5>

<p>  首先区分好“最长公共子串”和“最长公共子序列”。前者的子串是连续的，后者是可以不连续的。</p>

<p>  对于两个字符串的问题，一般情况下均将它们连起来，构造height数组。然后，最长公共子串问题等价于后缀的最长公共前缀问题。只不过，并非所有的lcp值都能作为问题的答案。只有当两个后缀分属两个字符串时，它们的lcp值才能作为答案。与问题3一样，本题的答案必然是某个height值，因为lcp值是某段height值中的最小值。当区间长度为1时，lcp值等于某个height值。所以，本题只要扫描一遍后缀，找出后缀分属两个字符串的height值中的最大值就可以了。判断方法这里就不说明了，留给大家自己思考&hellip;<br/>
题目及题解：<br/>
<a href="http://hi.baidu.com/fhnstephen/blog/item/8666a400cd949d7b3812bb44.html  ">http://hi.baidu.com/fhnstephen/blog/item/8666a400cd949d7b3812bb44.html  </a>
<a href="http://hi.baidu.com/fhnstephen/blog/item/b5c7585600cadfc8b645aebe.html">http://hi.baidu.com/fhnstephen/blog/item/b5c7585600cadfc8b645aebe.html</a></p>

<h5>9、重复次数最多的重复子串 SPOJ 687，Pku3693</h5>

<p>  难度比较大的一个问题，主要是罗穗骞的论文里的题解写得有点含糊不清。题目的具体含义可以去参考Pku3693.</p>

<p>  又是一题难以通过二分枚举答案解决的问题（因为要求的是重复次数），所以选择朴素枚举的方法。先枚举重复子串的长度k，再利用后缀数组来求长度为k的子串最多重复出现多少次。注意到一点，假如一个字符串它重复出现2次（这里不讨论一次的情况，因为那是必然的），那么它必然包含s[0],s[k],s[2<em>k]&hellip;之中的相邻的两个。所以，我们可以枚举一个数i，然后判断从i</em>k这个位置起的长度为k的字符串能重复出现多少次。判断方法和8中的相似，lcp(i<em>k,(i+1)</em>k)/k+1。但是，仅仅这样会忽略点一些特殊情况，即重复子串的起点不在[i<em>k]位置上时的情况。这种情况应该怎么求解呢？<br/>
看下面这个例子：<br/>
aabababc<br/>
当k=2，i=1时，枚举到2的位置，此时的重复子串为ba(注意第一位是0),lcp(2，4)=3，所以ba重复出现了2次。但实际上，起始位置为1的字符串ab出现次数更多，为3次。我们注意到，这种情况下，lcp(2,4)=3，3不是2的整数倍。说明当前重复子串在最后没有多重复出现一次，而重复出现了部分（这里是多重复出现了一个b）。如果我这样说你没有看懂，那么更具体地：<br/>
sa[2]=bababc<br/>
sa[4]=babc<br/>
lcp=bab<br/>
现在注意到了吧，ba重复出现了两次之后，出现了一个b，而a没有出现。那么，不难想到，可以将枚举的位置往前挪一位，这样这个最后的b就能和前面的一个a构成一个重复子串了，而假如前挪的一位正好是a，那么答案可以多1。所以，我们需要求出a=lcp(i</em>k,(i+1)*k)%n，然后向前挪k-a位，再用同样的方法求其重复出现的长度。这里，令b=k-a,只需要lcp(b,b+k)>=k就可以了。实际上，lcp(b,b+k)>=k时，lcp(b,b+k)必然大于等于之前求得的lcp值，而此时答案的长度只加1。没有理解的朋友细细体会下上图吧。<br/>
题目及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/870da9ee3651404379f0555f.html">http://hi.baidu.com/fhnstephen/blog/item/870da9ee3651404379f0555f.html</a></p>

<h5>10.多个串的公共子串问题 PKU3294</h5>

<p>首先将串连接起来，然后构造height数组，然后怎么办呢？<br/>
对，二分答案再判断是否可行就行了。可行条件很直观：有一组后缀，有超过题目要求的个数个不同的字符串中的后缀存在。即，假如题目要求要出现在至少k个串中，那么就得有一组后缀，在不同字符串中的后缀数大于等于k。<br/>
题目及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/49c3b7dec79ec5e377c638f1.html">http://hi.baidu.com/fhnstephen/blog/item/49c3b7dec79ec5e377c638f1.html</a></p>

<h5>11、出现或反转后出现所有字符串中的最长子串 PKU1226</h5>

<p><a href="http://hi.baidu.com/fhnstephen/blog/item/7fead5020a16d2da267fb5c0.html">http://hi.baidu.com/fhnstephen/blog/item/7fead5020a16d2da267fb5c0.html</a></p>

<h5>12、不重叠地至少两次出现在所有字符串中的最长子串</h5>

<p>spoj220 <a href="http://hi.baidu.com/fhnstephen/blog/item/1dffe1dda1c98754cdbf1a35.html">http://hi.baidu.com/fhnstephen/blog/item/1dffe1dda1c98754cdbf1a35.html</a></p>

<p>之所以把两题一起说，因为它们大同小异，方法在前面的题目均出现过。对于多个串，连起来；反转后出现，将每个字符串反写后和原串都连起来，将反写后的串和原串看成同一个串；求最长，二分答案后height分组；出现在所有字符串中（反写后的也行），判断方法和10一样，k=n而已；不重叠见问题4，只不过这里对于每个字符串都要进行检验而已。</p>

<h5>13、两个字符串的重复子串个数。 Pku3415</h5>

<p>我个人觉得颇有难度的一个问题。具体的题目描述参看Pku3415。<br/>
大家可以移步到这：<a href="http://hi.baidu.com/fhnstephen/blog/item/bf06d001de30fc034afb51c1.html">http://hi.baidu.com/fhnstephen/blog/item/bf06d001de30fc034afb51c1.html</a></p>

<h5>14、最后的总结</h5>

<p>用后缀数组解题有着一定的规律可循，这是后缀的性质所决定的，具体归纳如下：<br/>
1、N个字符串的问题（N>1）<br/>
方法：将它们连接起来，中间用不会出现在原串中的，互不相同的，非0号字符分隔开。</p>

<p>2、无限制条件下的最长公共子串（重复子串算是后缀们的最长公共前缀）<br/>
方法：height的最大值。这里的无限制条件是对子串无限制条件。最多只能是两个串的最长公共子串，才可以直接是height的最大值。</p>

<p>3、特殊条件下的最长子串<br/>
方法：二分答案，再根据height数组进行分组，根据条件完成判定性问题。三个或以上的字符串的公共子串问题也需要二分答案。设此时要验证的串长度为len，特殊条件有：<br/>
3.1、出现在k个串中<br/>
条件：属于不同字符串的后缀个数不小于k。（在一组后缀中，下面省略）<br/>
3.2、不重叠<br/>
条件：出现在同一字符串中的后缀中，出现位置的最大值减最小值大于等于len。<br/>
3.3、可重叠出现k次<br/>
条件：出现在同一字符串中的后缀个数大于等于k。若对于每个字符串都需要满足，需要逐个字符串进行判断。</p>

<p>4、特殊计数<br/>
方法：根据后缀的性质，和题目的要求，通过自己的思考，看看用后缀数组能否实现。一般和“子串”有关的题目，用后缀数组应该是可以解决的。</p>

<p>5、重复问题<br/>
知道一点：lcp(i,i+k)可以判断，以i为起点，长度为k的一个字符串，它向后自复制的长度为多少，再根据具体题目具体分析，得出算法即可。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2014/03/28/debug-memory-prefetch/">memory prefetch浅析</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-03-28T17:40:00+08:00'><span class='date'>2014-03-28</span> <span class='time'>17:40:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文地址： <a href="http://www.searchtb.com/2014/03/memory-prefetch%e6%b5%85%e6%9e%90.html">http://www.searchtb.com/2014/03/memory-prefetch%e6%b5%85%e6%9e%90.html</a>  , 感谢原作者分享。</p>

<p>  最近在用vtune分析程序性能瓶颈时，发现一些内存访问的地方竟然成了cpu热点。经过仔细分析，发现这些热点主要是对大数组非连续位置的访问的引起的。比较消耗cpu的原因应该是 cache不命中。因为像这样局部性很差的内存访问逻辑，对cache是很不友好的。于是想到了prefetch……</p>

<p>  x86（以及其他很多体系结构）的CPU提供了prefetch系列指令，用于将指定地址的内存预取到cache。如”prefetcht0 (%rax)”将以$rax所保存的值为地址的内存所在的cache line（大小一般是64byte）载入每一级cache。</p>

<p>在适当位置加了prefetch之后，程序里相应的cpu热点果然得以消除，程序性能得到提升。</p>

<h4>现象</h4>

<p>在此也写一段测试程序，体验一下 prefetch的功效，并做一些简单的分析。（注，分析硬件的行为实在是一件痛苦的事情。对于软件来说，源代码摆在那里，一是一、二是二，很多问题都是 确定的。而硬件不仅看不到它的具体实现，也鲜有文档。并且相比操作系统为软件提供的虚拟而单纯的运行环境，硬件环境复杂多变，有时候实在让人难以琢磨。所 以以下分析实在难免存在谬误。不妥之处还请包涵。）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;xmmintrin.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;sys/mman.h&gt;
</span><span class='line'>#include &lt;sys/time.h&gt;
</span><span class='line'>#include &lt;sys/types.h&gt;
</span><span class='line'>#include &lt;sys/stat.h&gt;
</span><span class='line'>#include &lt;fcntl.h&gt;
</span><span class='line'>#include &lt;math.h&gt;
</span><span class='line'>void usage()
</span><span class='line'>{
</span><span class='line'>    printf("usage: BIN file step prefetch\n");
</span><span class='line'>    exit(1);
</span><span class='line'>}
</span><span class='line'>inline int calcu(int input)
</span><span class='line'>{
</span><span class='line'>#ifdef EMPTYCALC
</span><span class='line'>    return input;
</span><span class='line'>#endif
</span><span class='line'>    int val = (input % 99) * (input / 98);
</span><span class='line'>    val = val ? val : 1;
</span><span class='line'>#ifdef HEAVYCALC
</span><span class='line'>    double d = (double)input / (double)val;
</span><span class='line'>    return (int)pow(d, 1999.9);
</span><span class='line'>#endif
</span><span class='line'>    double n = sqrt(sqrt((double)(unsigned)input * 1.3));
</span><span class='line'>    double m = sqrt(sqrt((double)(unsigned)val * 0.9));
</span><span class='line'>    return (int)((double)input * (double)val * m / (n ? n : 1.1));
</span><span class='line'>}
</span><span class='line'>int run_withprefetch(const int *array, int size, int step, int prefetch)
</span><span class='line'>{
</span><span class='line'>    int result = 0;
</span><span class='line'>    printf("run with prefetch(%d)...\n", prefetch);
</span><span class='line'>    for (int i = 0; i &lt; step; i++) {
</span><span class='line'>        for (int j = i; j &lt; size; j += step) {
</span><span class='line'>            int k = j + step * prefetch;
</span><span class='line'>            if (k  &lt; size) {
</span><span class='line'>                _mm_prefetch(&array[k], _MM_HINT_T0);
</span><span class='line'>                //const int *addr = &array[k];
</span><span class='line'>                //__asm__ __volatile__ ("mov (%0), %%eax"::"r"(addr):"eax");
</span><span class='line'>                //__asm__ __volatile__ ("mov %0, %%eax"::"r"(k):"eax");
</span><span class='line'>            }
</span><span class='line'>            result += calcu(array[j]);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return result;
</span><span class='line'>}
</span><span class='line'>int run(const int *array, int size, int step)
</span><span class='line'>{
</span><span class='line'>    int result = 0;
</span><span class='line'>    printf("run...\n");
</span><span class='line'>    for (int i = 0; i &lt; step; i++) {
</span><span class='line'>        for (int j = i; j &lt; size; j += step) {
</span><span class='line'>            //asm volatile("lfence");
</span><span class='line'>            result += calcu(array[j]);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return result;
</span><span class='line'>}
</span><span class='line'>int main(int argc, const char *argv[])
</span><span class='line'>{
</span><span class='line'>    if (argc != 4) {
</span><span class='line'>        usage();
</span><span class='line'>    }
</span><span class='line'>    int step = atoi(argv[2]);
</span><span class='line'>    int prefetch = atoi(argv[3]);
</span><span class='line'>    int fd = open(argv[1], O_RDONLY);
</span><span class='line'>    if (fd == -1) {
</span><span class='line'>        usage();
</span><span class='line'>    }
</span><span class='line'>    struct stat st;
</span><span class='line'>    int ret = fstat(fd, &st);
</span><span class='line'>    if (ret != 0) {
</span><span class='line'>        usage();
</span><span class='line'>    }
</span><span class='line'>    int array_size = st.st_size / sizeof(int);
</span><span class='line'>    printf("array size: %d, step: %d. ", array_size, step);
</span><span class='line'>    const int *array = (const int *)mmap(NULL, st.st_size, PROT_READ, MAP_POPULATE|MAP_SHARED, fd, 0);
</span><span class='line'>    if (array == MAP_FAILED) {
</span><span class='line'>        usage();
</span><span class='line'>    }
</span><span class='line'>    struct timeval tv1, tv2;
</span><span class='line'>    gettimeofday(&tv1, NULL);
</span><span class='line'>    int result = 0;
</span><span class='line'>    if (prefetch == 0) {
</span><span class='line'>        result = run(array, array_size, step);
</span><span class='line'>    }
</span><span class='line'>    else if (prefetch &gt; 0) {
</span><span class='line'>        result = run_withprefetch(array, array_size, step, prefetch);
</span><span class='line'>    }
</span><span class='line'>    gettimeofday(&tv2, NULL);
</span><span class='line'>    tv2.tv_sec -= tv1.tv_sec;
</span><span class='line'>    tv2.tv_usec -= tv1.tv_usec;
</span><span class='line'>    if (tv2.tv_usec &lt; 0) {
</span><span class='line'>        tv2.tv_usec += 1000000;
</span><span class='line'>        tv2.tv_sec--;
</span><span class='line'>    }
</span><span class='line'>    printf("time cost: %d.%06d, ", tv2.tv_sec, tv2.tv_usec);
</span><span class='line'>    printf("result: %d\n", result);
</span><span class='line'>    return result;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>程序mmap一个大文件（由file参数指定）作为大数组，对数组中的每一个元素进行一定的变换逻辑（calc函数，通过宏定义选择三种不同复杂度的逻辑）、然后加和。</p>

<p>对于数组元素的访问支持顺序访问和跳跃访问（step参数，跳跃间隙）、支持预取（prefetch参数，预取提前量）。</p>

<p>（注意，程序最终产生的result的值只跟选择的计算逻辑和输入文件的内容相关，跟读内存的顺序无关。所以，后续不管给程序加了什么稀奇古怪的读内存逻辑，最终的result都是一致的。这就确保了我们所加的各种读内存逻辑没有引入BUG。）</p>

<p>一些测试结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ll -h test.tar.gz 
</span><span class='line'>-rw-rw-r-- 1 xiangy xiangy 1.8G Jun 27 09:37 test.tar.gz
</span><span class='line'>$ g++ -O2 prefetch.cpp -DHEAVYCALC -o prefetch.heavy
</span><span class='line'>$ g++ -O2 prefetch.cpp -DEMPTYCALC -o prefetch.empty
</span><span class='line'>$ g++ -O2 prefetch.cpp -o prefetch.normal
</span><span class='line'>$ ./prefetch.normal 
</span><span class='line'>usage: BIN file step prefetch</span></code></pre></td></tr></table></div></figure>


<p>（选择不同复杂度的计算逻辑，编译成以不同后缀命名的可执行文件。）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-1]$ ./prefetch.empty test.tar.gz 1024 0
</span><span class='line'>array size: 468787200, step: 1024. run...
</span><span class='line'>time cost: 23.980005, result: 692002678</span></code></pre></td></tr></table></div></figure>


<p>（空计算＋跳读内存。预期内存访问基本上都是cache miss，而计算逻辑基本上又不花时间，所以最终花费的时间主要就是读内存时间。记住这个值，下面的case经常需要参考它。）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-2]$ ./prefetch.normal test.tar.gz 1 0
</span><span class='line'>array size: 468787200, step: 1. run...
</span><span class='line'>time cost: 22.846302, result: 1309150882
</span><span class='line'>[case-3]$ ./prefetch.normal test.tar.gz 1024 0
</span><span class='line'>array size: 468787200, step: 1024. run...
</span><span class='line'>time cost: 66.041256, result: 1309150882
</span><span class='line'>[case-4]$ ./prefetch.normal test.tar.gz 1024 4
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(4)...
</span><span class='line'>time cost: 28.247350, result: 1309150882</span></code></pre></td></tr></table></div></figure>


<p>（以上是普通计算的运行情况。case-2顺序读内存预期基本上都是cache hit的，最终花费的时间主要是执行计算逻辑的时间；case-3跳读内存时间花费大量增加；case-4加了预取之后，时间花费基本上恢复到case-2的水平。)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-5]$ ./prefetch.heavy test.tar.gz 1 0
</span><span class='line'>array size: 468787200, step: 1. run...
</span><span class='line'>time cost: 47.386533, result: 1625037789
</span><span class='line'>[case-6]$ ./prefetch.heavy test.tar.gz 1024 0
</span><span class='line'>array size: 468787200, step: 1024. run...
</span><span class='line'>time cost: 107.783801, result: 1625037789
</span><span class='line'>[case-7]$ ./prefetch.heavy test.tar.gz 1024 4
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(4)...
</span><span class='line'>time cost: 51.492479, result: 1625037789</span></code></pre></td></tr></table></div></figure>


<p>（以上是复杂计算的运行情况。跟前面的表现基本一致，跳读带来了大量的时间增长，而预取又基本恢复到顺序读时的水平。)</p>

<p>如果读内存开销很小、或者计算开销很小，prefetch也有用么？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-8]$ ./prefetch.empty test.tar.gz 1024 4
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(4)...
</span><span class='line'>time cost: 24.253892, result: 692002678</span></code></pre></td></tr></table></div></figure>


<p>（空计算＋跳读内存，预取效果跟不加预取时差不多。）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-9]$ ./prefetch.normal test.tar.gz 1 4
</span><span class='line'>array size: 468787200, step: 1. run with prefetch(4)...
</span><span class='line'>time cost: 22.896790, result: 1309150882</span></code></pre></td></tr></table></div></figure>


<p>（普通计算＋顺序读内存＋预取，效果跟不加预取时也差不多。）</p>

<p>可见当读内存存在一定开销、且开销小于或相当于计算开销时，通过适当的prefetch能够将跳读内存开销隐藏掉，基本上达到顺序读内存的效果。</p>

<p>反过来如果计算开销不大、或者读内存本身没什么开销，单纯想通过prefetch来提升读内存的速度，效果并不明显。</p>

<h4>prefetch原理</h4>

<p>为什么prefetch能达到这样的效果呢？简单来说，prefetch将原本串行工作的计算过程和读内存过程并行化了。如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>load-1                            load-1  
</span><span class='line'>calc-1                   =&gt;       calc-1    load-2  
</span><span class='line'>          load-2                            calc-2    load-3  
</span><span class='line'>          calc-2                                      calc-3  </span></code></pre></td></tr></table></div></figure>


<p>但是实际上却又并非如此简单。</p>

<p>在一个程序中，组成程序本身的指令虽然是有顺序的，但是CPU在执行指令的时候并不一定按部就班一条一条的去执行，指令之间有很多并行性可以去挖掘。（这就是所谓的ILP，Instruction Level Parallelism，指令级并行。）</p>

<p>两条指令想要并行执行需要满足三个条件：</p>

<p>1、指令之间没有数据依赖<br/>
如：a = b * 3; c = d + 5;， 就没有依赖；<br/>
如：a = b * 3; c = a + 5; ，“写后读”依赖。第二条指令需要a的值作为输入，而a的值依赖于第一条指令的计算结果；<br/>
如：a = b * 3; a = d + 5; ，“写后写”依赖。不过虽然第二条指令一定要在第一条指令修改a的值之后才能修改a的值（确保最终a的值是d + 5的结果），但是其实两条指令是可以并行执行的，最后将结果commit到a的时候再串行就OK了；<br/>
如：a = b * 3; b = d + 5;， “读后写”依赖。同样，虽然第二条指令一定不能在第一条指令读取b的值之前就将b的值修改（确保第一条指令读到的是旧值），但是只要确保第一条指令先拿到 b的旧值、或者直接跟生成b的旧值的那条指令关联上，之后两条指令还是可以并行执行的；</p>

<p>2、CPU功能部件充足<br/>
CPU中用来执行具体操作的功能部件是有限的，假设CPU只有一个乘法器。<br/>
如：a = b * 3; c = d + 5; ，一个使用乘法器、另一个使用加法器，互不影响就可以并行；<br/>
如：a = b * 3; c = d * 5; ，两条指令都需要使用这个仅有的乘法器，就只能串行了（当然也未必是第一条指令先占用乘法器，因为可能它所依赖的b的值尚未ready、而第二条指令所需要的d已经OK）；</p>

<p>3、CPU已经看到这两条指令<br/>
程序执行的指令序列可能无穷无尽（考虑 到有循环），CPU为了挖掘并行性不可能一下子分析所有指令，一定会有个限度。在经典的流水线算法－－tomasulo算法－－中，这个限度就是 RS（reservation station，保留站）的数目。CPU取指部件按指令顺序将指令放入RS，并设置它们的依赖关系（RS提供了这样的支持）。存在于RS中的指令当输入已 经ready、且需要的功能部件有空余时，便会开始执行。</p>

<p>遇到分支指令时指令序列如何确定呢？分支指令在执行完成之前根本就不知道程序要往哪里走。解决办法就是分支预测，根据一些统计信息猜测程序的走向。然后无视这些分支，就跟没有分支时一样去执行。如果分支预测错了，再回滚回来，按正确的序列重新执行。</p>

<p>回到我们的例子，每个loop有一个 load过程＋一个calc过程，calc过程依赖于load过程。但是下一次loop的load并不依赖于上一loop的calc过程，并且load和 calc使用不同的CPU功能部件，所以这两个过程是可以并行的。（for循环在经历很多次loop之后才会退出，每次分支的走向都是一样的，可以近似认 为分支预测一定成功。）</p>

<p>prefetch加与不加，前两个并行条件都是不会变的：prefetch既不会改变指令之间的依赖关系、也不会多占用或少占用CPU功能部件。但是为什么加上prefetch会有效果呢？</p>

<p>区别只在于第三个并行条件。试想当程序 执行到第N次loop时（loop-N），由于calc过程复杂，指令很多，RS一直被占满。直到计算进入尾声，loop-(N+1)的指令才进入RS， 这时CPU才知道要去load loop-(N+1)的input。而这些input在cache中不能命中，需要经历漫长的读内存过程，导致loop-(N+1)的calc指令卡在 RS中得不到执行。相当于load和calc过程被串行化了。</p>

<p>加了prefetch之后 呢？loop-(N+X)的prefetch指令排在loop-N的计算指令之前，早早的就能进入RS。这些load指令是计算的源头，其本身并没有依赖 别的数据，所以一旦内存通道空闲下来prefetch就可以开始工作了。于是load与calc才正真并行起来。</p>

<p>如下面示意：</p>

<p>case-2，顺序读内存，cache全命中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>calc-11
</span><span class='line'>calc-12
</span><span class='line'>calc-13    calc-21
</span><span class='line'>           calc-22
</span><span class='line'>           calc-23    calc-31
</span><span class='line'>                      calc-32
</span><span class='line'>                      calc-33    calc-41
</span><span class='line'>                                 calc-42
</span><span class='line'>                                 calc-43    calc-51
</span><span class='line'>                                            calc-52
</span><span class='line'>                                            calc-53</span></code></pre></td></tr></table></div></figure>


<p>（每个loop约花费2个单位时间。）</p>

<p>case-3，跳读内存，cache全不命中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>load-11
</span><span class='line'>load-12
</span><span class='line'>calc-11
</span><span class='line'>calc-12
</span><span class='line'>calc-13    load-21
</span><span class='line'>           load-22
</span><span class='line'>           calc-21
</span><span class='line'>           calc-22 
</span><span class='line'>           calc-23    load-31
</span><span class='line'>                      load-32
</span><span class='line'>                      calc-31
</span><span class='line'>                      calc-32
</span><span class='line'>                      calc-33</span></code></pre></td></tr></table></div></figure>


<p>（每个loop约花费4个单位时间。注，假设CPU执行到calc-N3的时候才看到有load-(N+1)1。）</p>

<p>case-4，跳读内存，加预取：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>load-11
</span><span class='line'>load-12
</span><span class='line'>calc-11    prefetch-21
</span><span class='line'>calc-12    prefetch-22
</span><span class='line'>calc-13    calc-21    prefetch-31
</span><span class='line'>           calc-22    prefetch-32
</span><span class='line'>           calc-23    calc-31    prefetch-41
</span><span class='line'>                      calc-32    prefetch-42
</span><span class='line'>                      calc-33    calc-41    prefetch-51
</span><span class='line'>                                 calc-42    prefetch-52
</span><span class='line'>                                 calc-43    calc-51
</span><span class='line'>                                            calc-52
</span><span class='line'>                                            calc-53</span></code></pre></td></tr></table></div></figure>


<p>（每个loop约花费2个单位时间。注，在calc-N1之前prefetch-(N+X)1就已经发起了。）</p>

<p>通过prefetch，使这些既耗时又 被后续指令依赖的load指令提前进入CPU的视野，让CPU可以利用可能空闲的内存带宽，提前完成读操作。另一方面，使用prefetch预取内存之 后，跟依赖于它的那些计算指令拉开了距离，使得计算指令不必等到马上就得使用load的输入时才临时抱佛脚。拉开相关依赖指令的距离正是编译器优化代码的 一种常用手段，通常通过指令重排调整无关指令的顺序来实现。</p>

<p>到这里prefetch的大致逻辑已经理清楚了，但是仔细想一下其实问题还很多……</p>

<h4>例子引出的问题</h4>

<p>第一个问题，为什么case-3（读内 存＋普通计算）的执行时间（66.041256）要比case-1（单纯的读内存）时间（23.980005）＋case-2（单纯的计算）时间 （22.846302）更长呢？按理说，就算load指令和calc指令完全串行，case-3的执行时间最多也就等于1、2之合吧。</p>

<p>这个问题应该可以用内存多通道来解释。 现在CPU访问内存的通道一般会有两个或以上。在case-1中，单纯的读内存其实并不代表串行的读内存。多个内存通道是可以让多个load指令并行工作 的，以充分利用内存带宽。而在case-3中，由于引入了一堆计算指令，导致RS被装满，CPU无法同时看到当前loop和下一个loop的load请 求，也就无法将两次load并行化。所以，更准确来说，case-3耗时这么长的原因并不是load与calc无法并行，而是load与load无法并 行。loop-N的calc过程跟loop-(N+1)的load过程是并行的，但是在loop-(N+1) load完成并进行calc之前，loop-(N+2)的load指令还未进入CPU的视野，所以无法与loop-(N+1)的load并行。</p>

<p>如何证实这一点呢？</p>

<p>我们在case-1中加一个lfence指令试试看。lfence是x86提供的内存屏障指令，作用是确保load操作的顺序：lfence之前的load操作必须先于lfence之后的load操作。如此便打破了load的并行性（如果真如刚才所说，并行性存在的话）。</p>

<p>修改run函数如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int run(const int *array, int size, int step)
</span><span class='line'>{
</span><span class='line'>    int result = 0;
</span><span class='line'>    printf("run...\n");
</span><span class='line'>    for (int i = 0; i &lt; step; i++) {
</span><span class='line'>        for (int j = i; j &lt; size; j += step) {
</span><span class='line'>            asm volatile("lfence");
</span><span class='line'>            result += calcu(array[j]);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return result;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>再次运行case-1：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-1.1]$ g++ -O2 prefetch.cpp -DEMPTYCALC
</span><span class='line'>[case-1.1]$ ./a.out test.tar.gz 1024 0
</span><span class='line'>array size: 468787200, step: 1024. run...
</span><span class='line'>time cost: 63.999864, result: 692002678</span></code></pre></td></tr></table></div></figure>


<p>（强制让load不能并行之后，case-1.1的耗时直接变成了case-3的水平。说明在原本的case-1中load是存在很大的并行度的。）</p>

<p>再以加lfence的代码运行一下case-6（未加prefetch、复杂计算）看看，如果在复杂计算＋跳读内存的情况下，读内存的并行性已经很少的话，加了lfence之后的耗时应该跟加之前差不多：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-6.1]$ g++ -O2 prefetch.cpp -DHEAVYCALC
</span><span class='line'>[case-6.1]$ ./a.out test.tar.gz 1024 0
</span><span class='line'>array size: 468787200, step: 1024. run...
</span><span class='line'>time cost: 114.787379, result: 1625037789</span></code></pre></td></tr></table></div></figure>


<p>（果然如此。）</p>

<p>还可以同时运行两个程序来看看是什么情 况。两个程序同时运行时，由于kernel load balance的作用，它们会尽量运行在不同的CPU上、且尽量不共享cache。那么，如果两个进程都总是能cache hit，则运行时间应该跟单个进程运行时差不多；反之如果总是cache miss，则两个进程会争抢内存带宽，运行时间会有所增加。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-2.2]$ ./prefetch.normal test.tar.gz 1 0 | ./prefetch.normal test.tar.gz 1 0
</span><span class='line'>array size: 468787200, step: 1. run...
</span><span class='line'>time cost: 22.964594, result: 1309150882</span></code></pre></td></tr></table></div></figure>


<p>（两个顺序读内存的普通计算一起运行，因为总是cache hit，所以跟单个运行的时间差不多。）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-1.2]$ ./a.out test.tar.gz 1024 0 | ./a.out test.tar.gz 1024 0
</span><span class='line'>array size: 468787200, step: 1024. run...
</span><span class='line'>time cost: 63.973557, result: 692002678</span></code></pre></td></tr></table></div></figure>


<p>（两个加了lfence的进程一起运行，由于进程内的内存访问已经串行化了，两个进程可以各自使用一个内存通道，所以运行时间跟单个进程运行时差不多。）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-1.3]$ ./prefetch.empty test.tar.gz 1024 0
</span><span class='line'>array size: 468787200, step: 1024. run...
</span><span class='line'>time cost: 24.083044, result: 692002678
</span><span class='line'>[case-1.4]$ ./prefetch.empty test.tar.gz 1024 0 | ./prefetch.empty test.tar.gz 1024 0
</span><span class='line'>array size: 468787200, step: 1024. run...
</span><span class='line'>time cost: 37.948864, result: 692002678</span></code></pre></td></tr></table></div></figure>


<p>（而用之前没加过lfence的程序再试一下，两个进程同时运行时，由于争抢内存带宽，运行时间就会受影响。）</p>

<h4>prefetch提前量</h4>

<p>还有一个问题也可以用内存多通道来解释，即prefetch提前量问题。先就之前的程序继续看几个case：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ for x in 1 2 4 8 16 32; do ./prefetch.normal test.tar.gz 1024 $x; done
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(1)...
</span><span class='line'>time cost: 36.262511, result: 1309150882
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(2)...
</span><span class='line'>time cost: 29.902517, result: 1309150882
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(4)...
</span><span class='line'>time cost: 28.052798, result: 1309150882
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(8)...
</span><span class='line'>time cost: 26.040215, result: 1309150882
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(16)...
</span><span class='line'>time cost: 26.198825, result: 1309150882
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(32)...
</span><span class='line'>time cost: 25.910506, result: 1309150882</span></code></pre></td></tr></table></div></figure>


<p>prefetch提前量从1增大到32。从结果看，当提前量小的时候，prefetch效果不明显。为什么呢？</p>

<p>假设提前量为1，那么loop-N会为 loop-(N+1)进行预取。但是从前面普通计算的数据可以看出，就一个loop而言，load的时间是多于calc时间的（从总量上说，load并行 之后才与calc时间相当，那么单独的load就应该比calc耗时长）。所以当执行到loop-(N+1)的时候，prefetch应该尚未完成。</p>

<p>再假设提前量为4，loop-N会为 loop-(N+4)做预取，loop-(N+1)为loop-(N+5)预取。而在进入loop-(N+1)时，loop-(N+4)的预取尚未完成， 而此时发起的loop-(N+5)的预取就能与之并行。可见增大提前量能更好的利用内存带宽。（虽然说以N为提前量就可以充分利用N个内存通道，但是机器 上还有kernel和其他进程也在使用内存，未必就能让你独占内存带宽。所以使用大于N的提前量更能充分利用空余的内存带宽。）</p>

<p>当然提前量肯定不能太大，否则等真正用到数据的时候，预取好的数据可能已经被从cache中挤出去了。</p>

<h4>用mov代替prefetch？</h4>

<p>prefetch指令可以用来预取，难道不用prefetch就不行了么？</p>

<p>我们将之前的run_withprefetch函数修改一下，把prefetch替换成简单的load操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int run_withprefetch(const int *array, int size, int step, int prefetch)
</span><span class='line'>{
</span><span class='line'>    int result = 0;
</span><span class='line'>    printf("run with prefetch(%d)...\n", prefetch);
</span><span class='line'>    for (int i = 0; i &lt; step; i++) {
</span><span class='line'>        for (int j = i; j &lt; size; j += step) {
</span><span class='line'>            int k = j + step * prefetch;
</span><span class='line'>            if (k  &lt; size) {
</span><span class='line'>                const int *addr = &array[k];
</span><span class='line'>                asm volatile("mov (%0), %%eax"::"r"(addr):"eax");
</span><span class='line'>            }
</span><span class='line'>            result += calcu(array[j]);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return result;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>重跑case-4：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-4.1]$ g++ -O2 prefetch.cpp
</span><span class='line'>[case-4.1]$ ./a.out test.tar.gz 1024 4
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(4)...
</span><span class='line'>time cost: 37.312423, result: 1309150882</span></code></pre></td></tr></table></div></figure>


<p>确实比不加prefetch的情况case-3（66.041256）要好很多，但还是比不上原来的case-4（28.247350）。</p>

<p>那么prefetch比直接movload好在哪里呢？<br/>
1、使用mov也同样能达到让load操作提前进入CPU视野的目的<br/>
2、使用mov访问过的内存同样会被cache住<br/>
3、仅仅是因为mov操作多占用了一个寄存器么？把代码改成这样看看（使用原来的prefetch但是多占用一个寄存器）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (k  &lt; size) {
</span><span class='line'>    _mm_prefetch(&array[k], _MM_HINT_T0);
</span><span class='line'>    __asm__ __volatile__ ("mov %0, %%eax"::"r"(k):"eax");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>[case-4.2]$ g++ -O2 prefetch.cpp
</span><span class='line'>[case-4.2]$ ./a.out test.tar.gz 1024 4
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(4)...
</span><span class='line'>time cost: 28.051848, result: 1309150882</span></code></pre></td></tr></table></div></figure>


<p>可见仅仅多占用一个寄存器，貌似并没有什么影响。（在tomasulo算法中，这里实际上并没有多占用寄存器，而是多占用了RS。）</p>

<p>前面提到了tomasulo算法，提到了RS，这里面还有个东西叫ROB（reorder buffer，指令重排缓存）。前面还提到过对于“写后写”依赖指令，在执行过程中是可以并行的，只要保证最后写回的顺序不变就行了。ROB就能完成这个功能。</p>

<p>CPU取指令之后除了将其放入RS（让 其可以乱序执行），还要按顺序将其放入ROB。执行完成后的指令最终在ROB中排队，然后按顺序提交（将结果写回寄存器或内存）。ROB还有另一个很重要 的作用，就是分支预测失败时的回滚。分支指令也跟其他指令一样要在ROB中排队。如果分支指令执行完以后发现分支预测错了，则将ROB里排在这条分支之后 的指令及其结果都清理掉就行了。因为ROB是按指令顺序排队的，由于分支预测出错而被错误执行的那些指令一定都排在分支指令之后。</p>

<p>回到我们的例子，”mov (addr), %eax”这条指令会一直占着ROB，直到load完成。这将导致后续的指令结果一直得不到提交，尚未被CPU取走的指令又会因为无法获得ROB而不能被 取走。这又回到了类似于case-3（未加prefetch）的情形，指令无法大量进入CPU的视野，以致于内存访问无法占满内存带宽。只不过因为ROB 的资源没有RS那么紧张，所以阻塞的情况没有case-3那么严重。</p>

<p>基于以上说明，我们改造case-6（未加prefetch、复杂计算）看看。对于复杂计算，calc过程的指令更多，按理说，阻塞的情况会更严重，直接load应该效果更差。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[case-6.2]$ g++ -O2 prefetch.cpp -DHEAVYCALC
</span><span class='line'>[case-6.2]$ ./a.out test.tar.gz 1024 4
</span><span class='line'>array size: 468787200, step: 1024. run with prefetch(4)...
</span><span class='line'>time cost: 100.910547, result: 1625037789</span></code></pre></td></tr></table></div></figure>


<p>果然，这个结果比起原本的case-6（107.783801）已经没有优势了。</p>

<p>那么为什么prefetch不会受 ROB的大小限制呢？因为prefetch是一个特殊指令，没有输出，对程序上下文也没有影响，甚至于分支预测失败时也不需要回滚。那么CPU完全没必要 让prefetch指令进ROB（当然RS还是要进的，因为prefetch可能依赖于前面指令的结果）。</p>

<h4>其他问题 关于硬件prefetch</h4>

<p>虽然CPU提供了显式prefetch指令，其实它自己暗中也会进行一些prefetch，可以称之为硬件prefetch。</p>

<p>硬件prefetch有这么几个要点：<br/>
1、CPU在经历连续一定次数的cache miss后触发。偶尔发生的一次cache miss是很正常的，比如访问一个不常使用的全局变量；<br/>
2、CPU有一定的模式匹配策略，能够识别顺序访问和一些固定step的跳跃访问；<br/>
3、最重要的一点，硬件 prefetch不会跨page进行。因为内存是按page管理的，跨page意味着可能触发page fault，这是CPU自己所无法handle的，得由kernel来解决。CPU暗中的prefetch动作对软件来说本来是透明的，不能让 kernel去handle可能本不应发生的page fault，甚至于这样的page fault可能导致segment fault（相反，软件prefetch是软件自己发起的，有什么后果自己承担）；</p>

<p>基于第3点，CPU一般不会试图去识别 步长高于512字节的跳跃访问。因为要经历三次cache miss，CPU才能发现跳读内存的步长是相同的（pos2 – pos1 == pos3 – pos2），而后如果触发硬件prefetch的话，大于512字节的步长可能使得访存操作很快跨跃page边界，触发prefetch意义已经不大了。</p>

<p>我们可以继续用前面的程序来观察一下硬件prefetch的表现。将step从1到1024递增，不使用软件prefetch：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ for x in 1 2 4 8 16 32 64 128 256 512 1024; do ./prefetch.normal test.tar.gz $x 0; done
</span><span class='line'>array size: 468787200, step: 1. run...
</span><span class='line'>time cost: 22.863716, result: 1309150882
</span><span class='line'>array size: 468787200, step: 2. run...
</span><span class='line'>time cost: 23.438035, result: 1309150882
</span><span class='line'>array size: 468787200, step: 4. run...
</span><span class='line'>time cost: 23.846166, result: 1309150882
</span><span class='line'>array size: 468787200, step: 8. run...
</span><span class='line'>time cost: 24.171723, result: 1309150882
</span><span class='line'>array size: 468787200, step: 16. run...
</span><span class='line'>time cost: 25.502980, result: 1309150882
</span><span class='line'>array size: 468787200, step: 32. run...
</span><span class='line'>time cost: 37.461018, result: 1309150882
</span><span class='line'>array size: 468787200, step: 64. run...
</span><span class='line'>time cost: 39.829086, result: 1309150882
</span><span class='line'>array size: 468787200, step: 128. run...
</span><span class='line'>time cost: 44.291904, result: 1309150882
</span><span class='line'>array size: 468787200, step: 256. run...
</span><span class='line'>time cost: 65.332225, result: 1309150882
</span><span class='line'>array size: 468787200, step: 512. run...
</span><span class='line'>time cost: 64.764071, result: 1309150882
</span><span class='line'>array size: 468787200, step: 1024. run...
</span><span class='line'>time cost: 65.952260, result: 1309150882</span></code></pre></td></tr></table></div></figure>


<p>随着step的逐步增大，可以看出时间消耗分为三个档次：</p>

<p>step 1~16，cost 22~25，因为16个int是64byte，正好在一个cache line中。这么小的step再加上硬件预取基本上都能cache hit了；</p>

<p>step 32~128，cost 37~44，这个区间的cost跨度较大。在这些step下，单个page内读取值的个数分是32、16、8，硬件prefetch尚有一定的余地被触发、并发挥作用。然后随着可预取数目的减少，cost也不段增加；</p>

<p>step 256~，cost 64~65，步长超过了1024byte，硬件prefetch已经不会被触发；</p>

<h4>关于TLB cache miss</h4>

<p>应用程序中使用地址的都是虚拟地址，访问内存时存在虚拟地址到物理地址的转换过程。转换规则（即页表）是放在内存中的，并由TLB来cache。地址转换需要跳多级页表、多次读内存，所以如果TLB cache miss，代价是很大的。</p>

<p>不过在我的环境中貌似并不存在TLB cache miss的问题。继续改造程序验证一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int run(const int *array, int size, int step, int blocksize)
</span><span class='line'>{
</span><span class='line'>    int result = 0;
</span><span class='line'>    blocksize *= 4096;
</span><span class='line'>    if (blocksize == 0) {
</span><span class='line'>        blocksize = size;
</span><span class='line'>    }
</span><span class='line'>    printf("run... (block=%d pages)\n", blocksize/4096);
</span><span class='line'>    int start = 0;
</span><span class='line'>    int nsize = blocksize;
</span><span class='line'>    while (nsize == blocksize) {
</span><span class='line'>        if (start + blocksize &gt; size)
</span><span class='line'>            nsize = size - start;
</span><span class='line'>        for (int i = 0; i &lt; step; i+=32) {
</span><span class='line'>            for (int j = i; j &lt; nsize; j += step) {
</span><span class='line'>                int thissize = j + 32 &lt; nsize ? j + 32 : nsize;
</span><span class='line'>                for (int k = j; k &lt; thissize; k++) {
</span><span class='line'>                    result += calcu(array[start+k]);
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        start += nsize;
</span><span class='line'>    }
</span><span class='line'>    return result;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>改造run函数把整个文件按blocksize划分成若干个块，每个块单独完成跳读逻辑。</p>

<p>于是，当块比较小时块内跳读时所涉及的page比较少，TLB应该能将相关的页表都cache住；而当块比较大，可能就会出现TLB cache miss。</p>

<p>这里面还存在另一个问题，按之前的做 法，每个int跳一次。如果块比较小，第一轮跳读时可能整个块都被cache了，后续的跳读都将cache hit。而块大时又无法cache整个块，后续的跳读又将继续cache miss。这就对观察TLB cache miss产生很大影响。所以程序改成每32个int跳读一次（按前面的结果，跳读32以后性能就不好了），以忽略cache hit所带来的影响。</p>

<p>修改main函数，用第4个参数来传递blocksize（0值表示不分block）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ for x in 128 256 512 1024 0; do ./a.out test.tar.gz 1024 $x; done
</span><span class='line'>array size: 468787200, step: 1024. run... (block=128 pages)
</span><span class='line'>time cost: 22.501363, result: 1309150882
</span><span class='line'>array size: 468787200, step: 1024. run... (block=256 pages)
</span><span class='line'>time cost: 22.627935, result: 1309150882
</span><span class='line'>array size: 468787200, step: 1024. run... (block=512 pages)
</span><span class='line'>time cost: 25.064514, result: 1309150882
</span><span class='line'>array size: 468787200, step: 1024. run... (block=1024 pages)
</span><span class='line'>time cost: 24.976720, result: 1309150882
</span><span class='line'>array size: 468787200, step: 1024. run... (block=114450 pages)
</span><span class='line'>time cost: 24.900870, result: 1309150882</span></code></pre></td></tr></table></div></figure>


<p>看起来TLB cache miss所带来的影响不大。</p>

<h4>关于L1 cache</h4>

<p>前面一直在讲cache，并没有细分是第几级的cache。其实前面的例子对内存的使用并没有那么精细，主要利用的cache还是L2 cache。</p>

<p>继续用前面分块的例子来看看，因为要考查cache，所以把连读32个int的逻辑去掉。run函数改造如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int run(const int *array, int size, int step, int blocksize)
</span><span class='line'>{
</span><span class='line'>    int result = 0;
</span><span class='line'>    blocksize *= 4096;
</span><span class='line'>    if (blocksize == 0) {
</span><span class='line'>        blocksize = size;
</span><span class='line'>    }
</span><span class='line'>    printf("run... (block=%d pages)\n", blocksize/4096);
</span><span class='line'>    int start = 0;
</span><span class='line'>    int nsize = blocksize;
</span><span class='line'>    while (nsize == blocksize) {
</span><span class='line'>        if (start + blocksize &gt; size)
</span><span class='line'>            nsize = size - start;
</span><span class='line'>        for (int i = 0; i &lt; step; i++) {
</span><span class='line'>            for (int j = i; j &lt; nsize; j += step) {
</span><span class='line'>                result += calcu(array[start+j]);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        start += nsize;
</span><span class='line'>    }
</span><span class='line'>    return result;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在一个块内反复跳读，如果以块的大小刚好能被cache住，则程序运行时间会很短；否则又得经历漫长的读内存过程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ for x in 1 2 4 8 16 32 64 128 256 512 1024; do ./a.out test.tar.gz 1024 $x; done
</span><span class='line'>array size: 468787200, step: 1024. run... (block=1 pages)
</span><span class='line'>time cost: 1.614654, result: 692002678
</span><span class='line'>array size: 468787200, step: 1024. run... (block=2 pages)
</span><span class='line'>time cost: 1.554286, result: 692002678
</span><span class='line'>array size: 468787200, step: 1024. run... (block=4 pages)
</span><span class='line'>time cost: 1.625566, result: 692002678
</span><span class='line'>array size: 468787200, step: 1024. run... (block=8 pages)
</span><span class='line'>time cost: 2.621453, result: 692002678
</span><span class='line'>array size: 468787200, step: 1024. run... (block=16 pages)
</span><span class='line'>time cost: 2.697908, result: 692002678
</span><span class='line'>array size: 468787200, step: 1024. run... (block=32 pages)
</span><span class='line'>time cost: 2.724401, result: 692002678
</span><span class='line'>array size: 468787200, step: 1024. run... (block=64 pages)
</span><span class='line'>time cost: 2.710056, result: 692002678
</span><span class='line'>array size: 468787200, step: 1024. run... (block=128 pages)
</span><span class='line'>time cost: 3.864916, result: 692002678
</span><span class='line'>array size: 468787200, step: 1024. run... (block=256 pages)
</span><span class='line'>time cost: 4.241000, result: 692002678
</span><span class='line'>array size: 468787200, step: 1024. run... (block=512 pages)
</span><span class='line'>time cost: 20.216653, result: 692002678
</span><span class='line'>array size: 468787200, step: 1024. run... (block=1024 pages)
</span><span class='line'>time cost: 24.361176, result: 692002678</span></code></pre></td></tr></table></div></figure>


<p>随着block size的逐渐增大，程序运行时间显现出三个层次。分别代表着L1 cache hit（1〜4）、L2 cache hit（8〜256）、cache miss（512〜）三种状态。看起来L1 cache在本例中影响并不大。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2014/03/17/lang-c-const/">const的使用</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-03-17T17:31:00+08:00'><span class='date'>2014-03-17</span> <span class='time'>17:31:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>1、定义常量</h4>

<h5>(1)const修饰变量</h5>

<p>以下两种定义形式在本质上是一样的。<br/>
它的含义是：const修饰的类型为TYPE的变量value是不可变的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TYPE const ValueName = value;
</span><span class='line'>const TYPE ValueName = value;</span></code></pre></td></tr></table></div></figure>


<h5>(2)将const改为外部连接</h5>

<p>作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extend const int ValueName = value;</span></code></pre></td></tr></table></div></figure>


<h4><span style="color:red">2、指针使用CONST</span></h4>

<h5>(1)指针本身是常量不可变</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(char*) const pContent;
</span><span class='line'>const (char*) pContent;</span></code></pre></td></tr></table></div></figure>


<h5>(2)指针所指向的内容是常量不可变</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const (char) *pContent;
</span><span class='line'>(char) const *pContent;</span></code></pre></td></tr></table></div></figure>


<h5>(3)两者都不可变</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const char* const pContent;</span></code></pre></td></tr></table></div></figure>


<h5>(4)还有其中区别方法，沿着*号划一条线：</h5>

<p>如果const位于<em>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；<br/>
如果const位于</em>的右侧，const就是修饰指针本身，即指针本身是常量。</p>

<h4>3、函数中使用CONST</h4>

<h5>(1)const修饰函数参数</h5>

<h6>a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void function(const int Var);</span></code></pre></td></tr></table></div></figure>


<h6>b.参数指针所指内容为常量不可变</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void function(const char* Var);</span></code></pre></td></tr></table></div></figure>


<h6>c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void function(char* const Var);</span></code></pre></td></tr></table></div></figure>


<h6>d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void function(const Class& Var);//引用参数在函数内不可以改变
</span><span class='line'>void function(const TYPE& Var); //引用参数在函数内为常量不可变</span></code></pre></td></tr></table></div></figure>


<p>这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的,他禁止对引用的对象的一切修改,唯一不同的是按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效.另外只有引用的const传递可以传递一个临时对象,因为临时对象都是const属性, 且是不可见的,他短时间存在一个局部域中,所以不能使用指针,只有引用的const传递能够捕捉到这个家伙.</p>

<h5>(2)const 修饰函数返回值</h5>

<p>const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。</p>

<h6>a.</h6>

<p>const int fun1() // 这个其实无意义，因为参数返回本身就是赋值。</p>

<h6>b.</h6>

<p>const int * fun2() //调用时 const int *pValue = fun2();<br/>
                   //我们可以把fun2()看作成一个变量，即指针内容不可变。</p>

<h6>c.</h6>

<p>int* const fun3()   //调用时 int * const pValue = fun2();<br/>
                    //我们可以把fun2()看作成一个变量，即指针本身不可变。</p>

<p>一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。<br/>
通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。<br/>
原因如下：<br/>
如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A&amp; test = A实例） ，<br/>
则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，<br/>
并且不允许对其进行赋值操作，这在一般情况下很少用到。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2014/02/28/debug-kgdb-ttys/">VMware配置KGDB串口</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-02-28T18:23:00+08:00'><span class='date'>2014-02-28</span> <span class='time'>18:23:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在配置KGDB时,必须通过串口才能调试一台测试Linux, 如果通过本机是Linux的话, 就可以使用应用直接链接上VMware的linux,进行通讯.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1: VM-&gt;Settings-&gt;Hardware-&gt;Add
</span><span class='line'>2: 选择Serial Port-&gt;next-&gt; Output to socket -&gt; next
</span><span class='line'>3: Socket=/tmp/ttyS1, From: Server To: An Application
</span><span class='line'>4: Finesh
</span><span class='line'>5: 在本机Linux,运行socat TCP-LISTEN:5555,fork /tmp/ttyS1 &, 绑定本地端口5555到vmware的socket文件.
</span><span class='line'>6: telnet 0:5555
</span><span class='line'>aaa
</span><span class='line'>bbb
</span><span class='line'>7: 在target Linux上, cat /dev/ttyS1, 如果有aaa bbb,则通讯成功.</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2014/02/28/debug-kgdb-conf/">KGDB配置</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-02-28T18:18:00+08:00'><span class='date'>2014-02-28</span> <span class='time'>18:18:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Host机：一个装有Ubuntu12.04-x86-64的主机<br/>
Target机：运行在vmware上的 Ubuntu12.04-server-x86-64 的Linux.</p>

<h4>Target机器配置</h4>

<ol>
<li>配置好VMware对外串口, 详情见:<a href="http://my.oschina.net/u/139611/blog/110052">http://my.oschina.net/u/139611/blog/110052</a></li>
<li>下载源码到/usr/src/linux-source-3.2.0下, 解压.</li>
<li>make menuconfig</li>
<li>进入General setup，把Local version设置一下(-kgdb)</li>
<li>进入Kernel hacking，选"Compile the kernel with debug info"为*</li>
<li>选"KGDB: kernel debugging with remote gdb"为*</li>
<li>选"Write protect kernel read-only data structures"为空 （否则在断下来继续执行的时候可能会报错：Cannot remove breakpoints because program is no longer writable）</li>
<li>进入"KGDB: &hellip; &ldquo; 选"KGDB: use KGDB over the serial console"为*，选"KGDB: internal test suite“为空，否则kgdboc会注册不了</li>
<li>保存，编译: make -j4 &amp;&amp; make modules install &amp;&amp; make install</li>
<li>把vmliunux和System.map拷贝到host机器上</li>
<li>修改/boot/grub/grub.cfg中menuentry为kgdb的项，在kernel后面添加参数: kgdboc=ttyS1,115200 kgdbwait</li>
<li>重启，系统进入等待状态。</li>
</ol>


<h4>Host机：</h4>

<ol>
<li>安装好GDB，配好串口等。
2.运行 socat TCP-LISTEN:5555,fork /tmp/ttyS1 &amp; , 链接到vmware对外的串口文件</li>
<li>gdb vmlinux</li>
<li>在GDB中:
(gdb) target remote 0:5555
就可以进入调试状态了</li>
<li>(gdb) c ,则target进入Linux系统</li>
</ol>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/23">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/21">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(12)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>12</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(22)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>8</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(36)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>12</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>11</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(17)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(48)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(10)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>10</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(111)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(59)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(33)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(26)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/01/14/debug-mod-timer/">mod_timer会切换cpu</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/14/debug-softirq-time-count/">中断时间统计</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/14/kernel-sched-alg1/">linux内核分析之调度算法（一）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/14/kernel-sched-idle/">Idle进程的切换过程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/14/kernel-nmi-irq/">NMI 看门狗</a>
      </li>
    
  </ul>
</section>
<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>
