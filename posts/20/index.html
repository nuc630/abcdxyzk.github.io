
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/02/11/kernel-sched-balance/">Linux内核CPU负载均衡机制</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-02-11T14:00:00+08:00'><span class='date'>2015-02-11</span> <span class='time'>14:00:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.oenhan.com/cpu-load-balance">http://www.oenhan.com/cpu-load-balance</a></p>

<p> 还是神奇的进程调度问题引发的，参看Linux进程组调度机制分析，组调度机制是看清楚了，发现在重启过程中，很多内核调用栈阻塞在了double_rq_lock函数上，而double_rq_lock则是load_balance触发的，怀疑当时的核间调度出现了问题，在某个负责场景下产生了多核互锁，后面看了一下CPU负载平衡下的代码实现，写一下总结。</p>

<p>内核代码版本：kernel-3.0.13-0.27。</p>

<p>内核代码函数起自load_balance函数,从load_balance函数看引用它的函数可以一直找到schedule函数这里，便从这里开始往下看，在__schedule中有下面一句话。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (unlikely(!rq-&gt;nr_running))
</span><span class='line'>    idle_balance(cpu, rq);</span></code></pre></td></tr></table></div></figure>


<p>从上面可以看出什么时候内核会尝试进行CPU负载平衡：即当前CPU运行队列为NULL的时候。</p>

<p>CPU负载平衡有两种方式：pull和push，即空闲CPU从其他忙的CPU队列中拉一个进程到当前CPU队列；或者忙的CPU队列将一个进程推送到空闲的CPU队列中。idle_balance干的则是pull的事情，具体push下面会提到。</p>

<p>在idle_balance里面，有一个proc阀门控制当前CPU是否pull:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (this_rq-&gt;avg_idle &lt; sysctl_sched_migration_cost)
</span><span class='line'>    return;</span></code></pre></td></tr></table></div></figure>


<p>sysctl_sched_migration_cost对应proc控制文件是/proc/sys/kernel/sched_migration_cost，开关代表如果CPU队列空闲了500ms（sysctl_sched_migration_cost默认值）以上，则进行pull，否则则返回。</p>

<p>for_each_domain(this_cpu, sd) 则是遍历当前CPU所在的调度域，可以直观的理解成一个CPU组，类似task_group，核间平衡指组内的平衡。负载平衡有一个矛盾就是：负载平衡的频度和CPU cache的命中率是矛盾的，CPU调度域就是将各个CPU分成层次不同的组，低层次搞定的平衡就绝不上升到高层次处理，避免影响cache的命中率。</p>

<p>图例如下;</p>

<p><img src="/images/kernel/2015-02-11-1.jpg" alt="" /></p>

<p>最终通过load_balance进入正题。</p>

<p>首先通过find_busiest_group获取当前调度域中的最忙的调度组，首先update_sd_lb_stats更新sd的状态，也就是遍历对应的sd，将sds里面的结构体数据填满，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sd_lb_stats {
</span><span class='line'>    struct sched_group *busiest; /* Busiest group in this sd */
</span><span class='line'>    struct sched_group *this;  /* Local group in this sd */
</span><span class='line'>    unsigned long total_load;  /* Total load of all groups in sd */
</span><span class='line'>    unsigned long total_pwr;   /*   Total power of all groups in sd */
</span><span class='line'>    unsigned long avg_load;    /* Average load across all groups in sd */
</span><span class='line'> 
</span><span class='line'>    /** Statistics of this group */
</span><span class='line'>    unsigned long this_load; //当前调度组的负载
</span><span class='line'>    unsigned long this_load_per_task; //当前调度组的平均负载
</span><span class='line'>    unsigned long this_nr_running; //当前调度组内运行队列中进程的总数
</span><span class='line'>    unsigned long this_has_capacity;
</span><span class='line'>    unsigned int  this_idle_cpus;
</span><span class='line'> 
</span><span class='line'>    /* Statistics of the busiest group */
</span><span class='line'>    unsigned int  busiest_idle_cpus;
</span><span class='line'>    unsigned long max_load; //最忙的组的负载量
</span><span class='line'>    unsigned long busiest_load_per_task; //最忙的组中平均每个任务的负载量
</span><span class='line'>    unsigned long busiest_nr_running; //最忙的组中所有运行队列中进程的个数
</span><span class='line'>    unsigned long busiest_group_capacity;
</span><span class='line'>    unsigned long busiest_has_capacity;
</span><span class='line'>    unsigned int  busiest_group_weight;</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>do
</span><span class='line'>{
</span><span class='line'>    local_group = cpumask_test_cpu(this_cpu, sched_group_cpus(sg));
</span><span class='line'>    if (local_group) {
</span><span class='line'>                  //如果是当前CPU上的group，则进行赋值
</span><span class='line'>        sds-&gt;this_load = sgs.avg_load;
</span><span class='line'>        sds-&gt;this = sg;
</span><span class='line'>        sds-&gt;this_nr_running = sgs.sum_nr_running;
</span><span class='line'>        sds-&gt;this_load_per_task = sgs.sum_weighted_load;
</span><span class='line'>        sds-&gt;this_has_capacity = sgs.group_has_capacity;
</span><span class='line'>        sds-&gt;this_idle_cpus = sgs.idle_cpus;
</span><span class='line'>    } else if (update_sd_pick_busiest(sd, sds, sg, &sgs, this_cpu)) {
</span><span class='line'>                 //在update_sd_pick_busiest判断当前sgs的是否超过了之前的最大值，如果是
</span><span class='line'>                 //则将sgs值赋给sds
</span><span class='line'>        sds-&gt;max_load = sgs.avg_load;
</span><span class='line'>        sds-&gt;busiest = sg;
</span><span class='line'>        sds-&gt;busiest_nr_running = sgs.sum_nr_running;
</span><span class='line'>        sds-&gt;busiest_idle_cpus = sgs.idle_cpus;
</span><span class='line'>        sds-&gt;busiest_group_capacity = sgs.group_capacity;
</span><span class='line'>        sds-&gt;busiest_load_per_task = sgs.sum_weighted_load;
</span><span class='line'>        sds-&gt;busiest_has_capacity = sgs.group_has_capacity;
</span><span class='line'>        sds-&gt;busiest_group_weight = sgs.group_weight;
</span><span class='line'>        sds-&gt;group_imb = sgs.group_imb;
</span><span class='line'>    }
</span><span class='line'>    sg = sg-&gt;next;
</span><span class='line'>} while (sg != sd-&gt;groups);</span></code></pre></td></tr></table></div></figure>


<p>决定选择调度域中最忙的组的参照标准是该组内所有 CPU上负载(load) 的和， 找到组中找到忙的运行队列的参照标准是该CPU运行队列的长度， 即负载，并且 load 值越大就表示越忙。在平衡的过程中，通过比较当前队列与以前记录的busiest 的负载情况，及时更新这些变量，让 busiest 始终指向域内最忙的一组，以便于查找。</p>

<p>调度域的平均负载计算</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sds.avg_load = (SCHED_POWER_SCALE * sds.total_load) / sds.total_pwr;
</span><span class='line'>if (sds.this_load &gt;= sds.avg_load)
</span><span class='line'>    goto out_balanced;</span></code></pre></td></tr></table></div></figure>


<p>在比较负载大小的过程中， 当发现当前运行的CPU所在的组中busiest为空时，或者当前正在运行的 CPU队列就是最忙的时， 或者当前 CPU队列的负载不小于本组内的平均负载时，或者不平衡的额度不大时，都会返回 NULL 值，即组组之间不需要进行平衡；当最忙的组的负载小于该调度域的平均负载时，只需要进行小范围的负载平衡；当要转移的任务量小于每个进程的平均负载时，如此便拿到了最忙的调度组。</p>

<p>然后find_busiest_queue中找到最忙的调度队列，遍历该组中的所有 CPU 队列，经过依次比较各个队列的负载，找到最忙的那个队列。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for_each_cpu(i, sched_group_cpus(group)) {
</span><span class='line'>    /*rq-&gt;cpu_power表示所在处理器的计算能力,在函式sched_init初始化时,会把这值设定为SCHED_LOAD_SCALE (=Nice 0的Load Weight=1024).并可透过函式update_cpu_power (in kernel/sched_fair.c)更新这个值.*/
</span><span class='line'>    unsigned long power = power_of(i);
</span><span class='line'>    unsigned long capacity = DIV_ROUND_CLOSEST(power,SCHED_POWER_SCALE);
</span><span class='line'>    unsigned long wl;
</span><span class='line'>    if (!cpumask_test_cpu(i, cpus))
</span><span class='line'>        continue;
</span><span class='line'> 
</span><span class='line'>    rq = cpu_rq(i);
</span><span class='line'>/*获取队列负载cpu_rq(cpu)-&gt;load.weight;*/
</span><span class='line'>    wl = weighted_cpuload(i);
</span><span class='line'> 
</span><span class='line'>    /*
</span><span class='line'>     * When comparing with imbalance, use weighted_cpuload()
</span><span class='line'>     * which is not scaled with the cpu power.
</span><span class='line'>     */
</span><span class='line'>    if (capacity && rq-&gt;nr_running == 1 && wl &gt; imbalance)
</span><span class='line'>        continue;
</span><span class='line'> 
</span><span class='line'>    /*
</span><span class='line'>     * For the load comparisons with the other cpu's, consider
</span><span class='line'>     * the weighted_cpuload() scaled with the cpu power, so that
</span><span class='line'>     * the load can be moved away from the cpu that is potentially
</span><span class='line'>     * running at a lower capacity.
</span><span class='line'>     */
</span><span class='line'>    wl = (wl * SCHED_POWER_SCALE) / power;
</span><span class='line'> 
</span><span class='line'>    if (wl &gt; max_load) {
</span><span class='line'>        max_load = wl;
</span><span class='line'>        busiest = rq;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>通过上面的计算，便拿到了最忙队列。<br/>
当busiest->nr_running运行数大于1的时候，进行pull操作，pull前对move_tasks,先进行double_rq_lock加锁处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>double_rq_lock(this_rq, busiest);
</span><span class='line'>ld_moved = move_tasks(this_rq, this_cpu, busiest,
</span><span class='line'>        imbalance, sd, idle, &all_pinned);
</span><span class='line'>double_rq_unlock(this_rq, busiest);</span></code></pre></td></tr></table></div></figure>


<p>move_tasks进程pull task是允许失败的，即move_tasks->balance_tasks，在此处，有sysctl_sched_nr_migrate开关控制进程迁移个数，对应proc的是/proc/sys/kernel/sched_nr_migrate。</p>

<p>下面有can_migrate_task函数检查选定的进程是否可以进行迁移，迁移失败的原因有3个，1.迁移的进程处于运行状态；2.进程被绑核了，不能迁移到目标CPU上；3.进程的cache仍然是hot，此处也是为了保证cache命中率。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*关于cache cold的情况下，如果迁移失败的个数太多，仍然进行迁移
</span><span class='line'> * Aggressive migration if:
</span><span class='line'> * 1) task is cache cold, or
</span><span class='line'> * 2) too many balance attempts have failed.
</span><span class='line'> */
</span><span class='line'> 
</span><span class='line'>tsk_cache_hot = task_hot(p, rq-&gt;clock_task, sd);
</span><span class='line'>if (!tsk_cache_hot ||
</span><span class='line'>    sd-&gt;nr_balance_failed &gt; sd-&gt;cache_nice_tries) {
</span><span class='line'>#ifdef CONFIG_SCHEDSTATS
</span><span class='line'>    if (tsk_cache_hot) {
</span><span class='line'>        schedstat_inc(sd, lb_hot_gained[idle]);
</span><span class='line'>        schedstat_inc(p, se.statistics.nr_forced_migrations);
</span><span class='line'>    }
</span><span class='line'>#endif
</span><span class='line'>    return 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>判断进程cache是否有效，判断条件，进程的运行的时间大于proc控制开关sysctl_sched_migration_cost，对应目录/proc/sys/kernel/sched_migration_cost_ns</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int
</span><span class='line'>task_hot(struct task_struct *p, u64 now, struct sched_domain *sd)
</span><span class='line'>{
</span><span class='line'>        s64 delta;
</span><span class='line'>    delta = now - p-&gt;se.exec_start;
</span><span class='line'>    return delta &lt; (s64)sysctl_sched_migration_cost;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在load_balance中，move_tasks返回失败也就是ld_moved==0，其中sd->nr_balance_failed++对应can_migrate_task中的”too many balance attempts have failed”,然后busiest->active_balance = 1设置，active_balance = 1。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (active_balance)
</span><span class='line'>//如果pull失败了，开始触发push操作
</span><span class='line'>stop_one_cpu_nowait(cpu_of(busiest),
</span><span class='line'>    active_load_balance_cpu_stop, busiest,
</span><span class='line'>    &busiest-&gt;active_balance_work);</span></code></pre></td></tr></table></div></figure>


<p>push整个触发操作代码机制比较绕，stop_one_cpu_nowait把active_load_balance_cpu_stop添加到cpu_stopper每CPU变量的任务队列里面，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,
</span><span class='line'>            struct cpu_stop_work *work_buf)
</span><span class='line'>{
</span><span class='line'>    *work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, };
</span><span class='line'>    cpu_stop_queue_work(&per_cpu(cpu_stopper, cpu), work_buf);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>而cpu_stopper则是cpu_stop_init函数通过cpu_stop_cpu_callback创建的migration内核线程，触发任务队列调度。因为migration内核线程是绑定每个核心上的，进程迁移失败的1和3问题就可以通过push解决。active_load_balance_cpu_stop则调用move_one_task函数迁移指定的进程。</p>

<p>上面描述的则是整个pull和push的过程，需要补充的pull触发除了schedule后触发，还有scheduler_tick通过触发中断，调用run_rebalance_domains再调用rebalance_domains触发，不再细数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __init sched_init(void)
</span><span class='line'>{
</span><span class='line'>      open_softirq(SCHED_SOFTIRQ, run_rebalance_domains);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/02/11/kernel-sched-trywakeup/">try_to_wake_up函数</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-02-11T11:32:00+08:00'><span class='date'>2015-02-11</span> <span class='time'>11:32:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>  try_to_wake_up函数通过把进程状态设置为TASK_RUNNING，并把该进程插入本地CPU运行队列rq来达到唤醒睡眠和停止的进程的目的。<br/>
例如：调用该函数唤醒等待队列中的进程，或恢复执行等待信号的进程。该函数接受的参数有：<br/>
- 被唤醒进程的描述符指针（p）<br/>
- 可以被唤醒的进程状态掩码（state）<br/>
- 一个标志（sync），用来禁止被唤醒的进程抢占本地CPU上正在运行的进程</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int try_to_wake_up(struct task_struct *p, unsigned int state, int sync)
</span><span class='line'>{
</span><span class='line'>    int cpu, this_cpu, success = 0;
</span><span class='line'>    unsigned long flags;
</span><span class='line'>    long old_state;
</span><span class='line'>    struct rq *rq;
</span><span class='line'>#ifdef CONFIG_SMP
</span><span class='line'>    struct sched_domain *sd, *this_sd = NULL;
</span><span class='line'>    unsigned long load, this_load;
</span><span class='line'>    int new_cpu;
</span><span class='line'>#endif
</span><span class='line'>    rq = task_rq_lock(p, &flags);
</span><span class='line'>    old_state = p-&gt;state;
</span><span class='line'>    if (!(old_state & state))
</span><span class='line'>        goto out;
</span><span class='line'>    if (p-&gt;array)
</span><span class='line'>        goto out_running;
</span><span class='line'>    cpu = task_cpu(p);
</span><span class='line'>    this_cpu = smp_processor_id();
</span><span class='line'>#ifdef CONFIG_SMP
</span><span class='line'>... // [多处理器负载平衡工作](/blog/2015/02/11/kernel-sched-balance/)
</span><span class='line'>#endif /* CONFIG_SMP */
</span><span class='line'>    if (old_state == TASK_UNINTERRUPTIBLE) {
</span><span class='line'>        rq-&gt;nr_uninterruptible--;
</span><span class='line'>        /*
</span><span class='line'>         * Tasks on involuntary sleep don't earn
</span><span class='line'>         * sleep_avg beyond just interactive state.
</span><span class='line'>         */
</span><span class='line'>        p-&gt;sleep_type = SLEEP_NONINTERACTIVE; //简单判断出非交互进程
</span><span class='line'>    } else
</span><span class='line'>        if (old_state & TASK_NONINTERACTIVE)
</span><span class='line'>            p-&gt;sleep_type = SLEEP_NONINTERACTIVE;//同上
</span><span class='line'>    activate_task(p, rq, cpu == this_cpu);
</span><span class='line'>    if (!sync || cpu != this_cpu) {
</span><span class='line'>        if (TASK_PREEMPTS_CURR(p, rq))
</span><span class='line'>            resched_task(rq-&gt;curr);
</span><span class='line'>    }
</span><span class='line'>    success = 1;
</span><span class='line'>out_running:
</span><span class='line'>    trace_sched_wakeup(rq, p, success);
</span><span class='line'>    p-&gt;state = TASK_RUNNING;
</span><span class='line'>out:
</span><span class='line'>    task_rq_unlock(rq, &flags);
</span><span class='line'>    return success;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>代码解释如下：<br/>
1.首先调用task_rq_lock( )禁止本地中断，并获得最后执行进程的CPU（他可能不同于本地CPU）所拥有的运行队列rq的锁。CPU的逻辑号存储在p->thread_info->cpu字段。</p>

<p>2.检查进程的状态p->state是否属于被当作参数传递给函数的状态掩码state，如果不是，就跳到第9步终止函数。</p>

<p>3.如果p->array字段不等于NULL，那么进程已经属于某个运行队列，因此跳转到第8步。</p>

<p>4.在多处理器系统中，该函数检查要被唤醒的进程是否应该从最近运行的CPU的运行队列迁移到另外一个CPU的运行队列。实际上，函数就是根据一些启发式规则选择一个目标运行队列。</p>

<p>5.如果进程处于TASK_UNINTERRUPTIBLE状态，函数递减目标运行队列的nr_uninterruptible字段，并把进程描述符的p->activated字段设置为-1。</p>

<p>6.调用activate_task( )函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void activate_task(struct task_struct *p, struct rq *rq, int local)
</span><span class='line'>{
</span><span class='line'>    unsigned long long now;
</span><span class='line'>    now = sched_clock();
</span><span class='line'>#ifdef CONFIG_SMP
</span><span class='line'>...
</span><span class='line'>#endif
</span><span class='line'>    if (!rt_task(p))
</span><span class='line'>        p-&gt;prio = recalc_task_prio(p, now); //计算平均睡眠时间并返回之后的优先级。
</span><span class='line'>    if (p-&gt;sleep_type == SLEEP_NORMAL) {
</span><span class='line'>        if (in_interrupt())
</span><span class='line'>            p-&gt;sleep_type = SLEEP_INTERRUPTED;
</span><span class='line'>        else {
</span><span class='line'>            p-&gt;sleep_type = SLEEP_INTERACTIVE;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    p-&gt;timestamp = now;
</span><span class='line'>    __activate_task(p, rq);
</span><span class='line'>}
</span><span class='line'>static void __activate_task(struct task_struct *p, struct rq *rq)
</span><span class='line'>{
</span><span class='line'>    struct prio_array *target = rq-&gt;active;
</span><span class='line'>    trace_activate_task(p, rq);
</span><span class='line'>    if (batch_task(p))
</span><span class='line'>        target = rq-&gt;expired;
</span><span class='line'>    enqueue_task(p, target);
</span><span class='line'>    inc_nr_running(p, rq);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>它依次执行下面的子步骤：<br/>
  a) 调用sched_clock( )获取以纳秒为单位的当前时间戳。如果目标CPU不是本地CPU，就要补偿本地时钟中断的偏差，这是通过使用本地CPU和目标CPU上最近一次发生时钟中断的相对时间戳来达到的：now = (sched_clock( ) - this_rq( )->timestamp_last_tick)  +  rq->timestamp_last_tick;<br/>
  b) 调用recalc_task_prio()，把进程描述的指针和上一步计算出的时间戳传递给它。recalc_task_prio()主要更新进程的平均睡眠时间和动态优先级，下一篇博文将详细说明这个函数。<br/>
  c) 根据下表设置p->activated字段的值，该字段的意义为：<br/>
        值             说明<br/>
        0   进程处于TASK_RUNNING 状态。<br/>
        1   进程处于TASK_INTERRUPTIBLE 或TASK_STOPPED 状态，而且正在被系统调用服务例程或内核线程唤醒。<br/>
        2   进程处于TASK_INTERRUPTIBLE 或TASK_STOPPED 状态，而且正在被中断处理程序或可延迟函数唤醒。<br/>
        -1  进程处于TASK_UNINTERRUPTIBLE 状态而且正在被唤醒。
  d) 使用在第6a步中计算的时间戳设置p->timestamp字段。<br/>
  e) 把进程描述符插入活动进程集合：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enqueue_task(p, rq-&gt;active);
</span><span class='line'>rq-&gt;nr_running++;</span></code></pre></td></tr></table></div></figure>


<p>7.如果目标CPU不是本地CPU，或者没有设置sync标志，就检查可运行的新进程的动态优先级是否比rq运行对了中当前进程的动态优先级高（p->prio &lt; rq->curr->prio）；如果是，就调用resched_task()抢占rq->curr。在单处理器系统中，后面的函数只是执行set_tsk_need_resched()来设置rq->curr进程的TIF_NEED_RESCHED标志。在多处理器系统中，resched_task()也检查TIF_NEED_RESCHED的旧值是否为0、目标CPU与本地CPU是否不同、rq->curr进程的TIF_POLLING_NRFLAG标志是否清0（目标CPU没有轮询进程TIF_NEED_RESCHED标志的值）。如果是，resched_task()调用smp_send_reschedule()产生IPI，并强制目标CPU重新调度。</p>

<p>8.把进程的p->state字段设置为TASK_RUNNING状态。</p>

<p>9.调用task_rq_unlock()来打开rq运行队列的锁并打开本地中断。</p>

<p>10.返回1（若成功唤醒进程）或0（如果进程没有被唤醒）</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/02/11/kernel-sched-kthread/">内核线程使用</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-02-11T11:06:00+08:00'><span class='date'>2015-02-11</span> <span class='time'>11:06:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/newnewman80/article/details/7050090">http://blog.csdn.net/newnewman80/article/details/7050090</a></p>

<h5>kthread_create：创建线程。</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct task_struct *kthread_create(int (*threadfn)(void *data),void *data,const char *namefmt, ...);</span></code></pre></td></tr></table></div></figure>


<p>线程创建后，不会马上运行，而是需要将kthread_create() 返回的task_struct指针传给wake_up_process()，然后通过此函数运行线程。</p>

<h5>kthread_run ：创建并启动线程的函数：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct task_struct *kthread_run(int (*threadfn)(void *data),void *data,const char *namefmt, ...);</span></code></pre></td></tr></table></div></figure>


<h5>kthread_stop：通过发送信号给线程，使之退出。</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int kthread_stop(struct task_struct *thread);</span></code></pre></td></tr></table></div></figure>


<p>线程一旦启动起来后，会一直运行，除非该线程主动调用do_exit函数，或者其他的进程调用kthread_stop函数，结束线程的运行。<br/>
但如果线程函数正在处理一个非常重要的任务，它不会被中断的。当然如果线程函数永远不返回并且不检查信号，它将永远都不会停止。</p>

<h4>1. 头文件</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;linux/sched.h&gt;       //wake_up_process()
</span><span class='line'>#include &lt;linux/kthread.h&gt;      //kthread_create()、kthread_run()   
</span><span class='line'>#include &lt;err.h&gt;                //IS_ERR()、PTR_ERR()  </span></code></pre></td></tr></table></div></figure>


<h4>2. 实现</h4>

<h5>2.1创建线程</h5>

<p>kernel thread可以用kernel_thread创建，但是在执行函数里面必须用daemonize释放资源并挂到init下，还需要用completion等待这一过程的完成。为了简化操作kthread_create闪亮登场。
在模块初始化时，可以进行线程的创建。使用下面的函数和宏定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct task_struct *kthread_create(int (*threadfn)(void *data),     
</span><span class='line'>                            void *data,  
</span><span class='line'>                            const char namefmt[], ...);  </span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define kthread_run(threadfn, data, namefmt, ...)                      \
</span><span class='line'>({                                                                     \
</span><span class='line'>    struct task_struct *__k                                            \
</span><span class='line'>           = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__);  \
</span><span class='line'>    if (!IS_ERR(__k))                                                  \
</span><span class='line'>           wake_up_process(__k);                                       \
</span><span class='line'>    __k;                                                               \
</span><span class='line'>})  </span></code></pre></td></tr></table></div></figure>


<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct task_struct *test_task;  
</span><span class='line'>static int test_init_module(void)  
</span><span class='line'>{  
</span><span class='line'>    int err;  
</span><span class='line'>    test_task = kthread_create(test_thread, NULL, "test_task");  
</span><span class='line'>    if (IS_ERR(test_task)) {  
</span><span class='line'>        printk("Unable to start kernel thread./n");  
</span><span class='line'>        err = PTR_ERR(test_task);  
</span><span class='line'>        test_task = NULL;  
</span><span class='line'>        return err;  
</span><span class='line'>    }  
</span><span class='line'>    wake_up_process(test_task);  
</span><span class='line'>    return 0;  
</span><span class='line'>}  
</span><span class='line'>module_init(test_init_module);  </span></code></pre></td></tr></table></div></figure>


<h5>2.2线程函数</h5>

<p>在线程函数里，完成所需的业务逻辑工作。主要框架如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int threadfunc(void *data) {
</span><span class='line'>    ...        
</span><span class='line'>    while(1) {
</span><span class='line'>        set_current_state(TASK_UNINTERRUPTIBLE);
</span><span class='line'>        if (kthread_should_stop()) break;
</span><span class='line'>        if () { //条件为真
</span><span class='line'>            //进行业务处理
</span><span class='line'>        } else { //条件为假
</span><span class='line'>            //让出CPU运行其他线程，并在指定的时间内重新被调度
</span><span class='line'>            schedule_timeout(HZ);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    ...
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>2.3结束线程</h5>

<p>在模块卸载时，可以结束线程的运行。使用下面的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int kthread_stop(struct task_struct *k);</span></code></pre></td></tr></table></div></figure>


<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void test_cleanup_module(void)  
</span><span class='line'>{  
</span><span class='line'>    if (test_task) {  
</span><span class='line'>        kthread_stop(test_task);  
</span><span class='line'>        test_task = NULL;  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>module_exit(test_cleanup_module);  </span></code></pre></td></tr></table></div></figure>


<h4>设置普通线程优先级</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void set_user_nice(struct task_struct *p, long nice);
</span><span class='line'>// -20 &lt;= nice &lt; 20</span></code></pre></td></tr></table></div></figure>


<h4>将线程设置为实时线程并设置优先级</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int sched_setscheduler(struct task_struct *p, int policy, struct sched_param *param);
</span><span class='line'>struct sched_param {
</span><span class='line'>    int sched_priority; // 实时线程对应区间[1, 99]
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>CFS 调度模块（在 kernel/sched_fair.c 中实现）用于以下调度策略：SCHED_NORMAL、SCHED_BATCH 和 SCHED_IDLE。<br/>
对于 SCHED_RR 和 SCHED_FIFO 策略，将使用实时调度模块（该模块在 kernel/sched_rt.c 中实现）。</p>

<h4>top中NI, PR</h4>

<p>NI，nice，动态修正CPU调度。范围（-20~19）。越大，cpu调度越一般，越小，cpu调度越偏向它。一般用于后台进程，调整也是往大了调，用来给前台进程让出CPU资源。命令行下可以用renice设置。</p>

<h5>PR：优先级，会有两种格式，一种是数字（默认20），一种是RT字符串。</h5>

<p>PR默认是20，越小，优先级越高。修改nice可以同时修改PR，测试过程：先开一个窗口，运行wc，另开一个窗口运行top，按N按照PID倒序排，按r输入要renice的PID，然后输入-19~20之间的值，可以看到NI变成输入的值，PR=PR+NI。修改NI得到PR的范围是0~39。优先级由高到低</p>

<p>RT是real-time。只能用chrt -p (1~99) pid来修改。chrt -p 1 1234会将1234的PR改成-2，chrt -p 98 1234变成-99。chrt -p 99 1234会变成RT&hellip;&hellip;只要chrt过，修改nice后PR不会再更改。修改chrt得到的PR范围是RT~-2。优先级由高到低</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/02/09/kernel-mm-numa2/">NUMA技术相关笔记</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-02-09T16:34:00+08:00'><span class='date'>2015-02-09</span> <span class='time'>16:34:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.csdn.net/jollyjumper/article/details/17168175">http://blog.csdn.net/jollyjumper/article/details/17168175</a></p>

<p>起源于在mongo启动脚本中看到<code>numactl --interleave=all mongod ...</code>。</p>

<p>  NUMA,非统一内存访问(Non-uniform Memory Access),介于SMP(对称多处理)和MPP(大规模并行处理)之间，各个节点自有内存(甚至IO子系统),访问其它节点的内存则通过高速网络通道。NUMA信息主要通过BIOS中的ACPI(高级配置和编程接口)进行配置,Linux对NUMA系统的物理内存分布信息从系统firmware的ACPi表中获得，最重要的是SRAT(System Resource Affinity Table)和SLIT(System locality Information Table)表。SRAT表包含CPU信息、内存相关性信息,SLIT表则记录了各个节点之间的距离，在系统中由数组node_distance[]记录。这样系统可以就近分配内存，减少延迟。</p>

<p>Linux中用一个struct pg_data_t表示一个numa节点，Linux内核支持numa调度,并实现CPU的负载均衡。</p>

<h5>查看是否支持:</h5>

<p>dmesg | grep -i numa</p>

<h5>要查看具体的numa信息用numastat</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numastat
</span><span class='line'>                           node0           node1
</span><span class='line'>numa_hit             19983469427     20741805466
</span><span class='line'>numa_miss             1981451471      2503049250
</span><span class='line'>numa_foreign          2503049250      1981451471
</span><span class='line'>interleave_hit         849781831       878579884
</span><span class='line'>local_node           19627390917     20298995632
</span><span class='line'>other_node            2337529981      2945859084</span></code></pre></td></tr></table></div></figure>


<p>numa_hit是打算在该节点上分配内存，最后从这个节点分配的次数;<br/>
num_miss是打算在该节点分配内存，最后却从其他节点分配的次数;<br/>
num_foregin是打算在其他节点分配内存，最后却从这个节点分配的次数;<br/>
interleave_hit是采用interleave策略最后从该节点分配的次数;<br/>
local_node该节点上的进程在该节点上分配的次数<br/>
other_node是其他节点进程在该节点上分配的次数</p>

<h5>lscpu可以看到两个node的cpu归属:</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lscpu
</span><span class='line'>...
</span><span class='line'>NUMA node0 CPU(s):     0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30
</span><span class='line'>NUMA node1 CPU(s):     1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31</span></code></pre></td></tr></table></div></figure>


<h5><code>numactl --hardware</code>命令</h5>

<p>会返回不同节点的内存总大小，可用大小,以及node distance等信息。</p>

<p>各个cpu负载情况，使用命令:mpstat -P ALL(需要安装sysstat)</p>

<p>Linux上使用numactl设定进程的numa策略。常见的情况是,数据库daemon进程(mongodb,mysql)可能会吃掉很多内存，而一个numa节点上的内存很有限，内存不够时虚拟内存频繁与硬盘交换数据，导致性能急剧下降(标识是irqbalance进程top中居高不下),这时应该采用interleave的numa策略，允许从其他节点分配内存。</p>

<p>各个内存的访问延迟如何?numactl man中的example提供了参考,我在公司的服务器上测了一下:</p>

<h5>写速度:</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numactl --cpubind=0 --membind=0 dd if=/dev/zero of=/dev/shm/A bs=1M count=1024
</span><span class='line'>
</span><span class='line'>1024+0 records in
</span><span class='line'>1024+0 records out
</span><span class='line'>1073741824 bytes (1.1 GB) copied, 0.546679 s, 2.0 GB/s
</span><span class='line'>
</span><span class='line'>numactl --cpubind=0 --membind=1 dd if=/dev/zero of=/dev/shm/A bs=1M count=1024
</span><span class='line'>1024+0 records in
</span><span class='line'>1024+0 records out
</span><span class='line'>1073741824 bytes (1.1 GB) copied, 0.612825 s, 1.8 GB/s</span></code></pre></td></tr></table></div></figure>


<h5>读速度:</h5>

<p>测试从同一个节点读取:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numactl --cpubind=0 --membind=0 dd if=/dev/zero of=/dev/shm/A bs=1M count=1000
</span><span class='line'>date +%s.%N
</span><span class='line'>numactl --cpubind=0 --membind=0 cp /dev/shm/A /dev/null
</span><span class='line'>date +%s.%N
</span><span class='line'>rm /dev/shm/A</span></code></pre></td></tr></table></div></figure>


<p>花费0.264556884765625秒,速度是3.779905410081901GB/s。</p>

<p>从另一个节点读取:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numactl --cpubind=0 --membind=0 dd if=/dev/zero of=/dev/shm/A bs=1M count=1000
</span><span class='line'>date +%s.%N
</span><span class='line'>numactl --cpubind=1 --membind=1 cp /dev/shm/A /dev/null
</span><span class='line'>date +%s.%N
</span><span class='line'>rm /dev/shm/A</span></code></pre></td></tr></table></div></figure>


<p>花费0.3308408260345459秒,速度是3.022601569419312GB/s。</p>

<p>加速效果还是很明显的。</p>

<h4>参考:</h4>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-numa/  ">http://www.ibm.com/developerworks/cn/linux/l-numa/  </a>
<a href="http://www.dedecms.com/knowledge/data-base/nosql/2012/0820/8684.html">http://www.dedecms.com/knowledge/data-base/nosql/2012/0820/8684.html</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2015/02/09/kernel-mm-numa/">玩转CPU Topology</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-02-09T16:19:00+08:00'><span class='date'>2015-02-09</span> <span class='time'>16:19:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.searchtb.com/2012/12/%E7%8E%A9%E8%BD%ACcpu-topology.html">http://www.searchtb.com/2012/12/%E7%8E%A9%E8%BD%ACcpu-topology.html</a></p>

<h4>先温习几个概念</h4>

<p>请原谅对部分术语笔者直接引用了wikipedia上的英文解释，因为哥实在做不到比wikipedia上更准确描述。我会试着解释部分的术语，并在本节的最后梳理一下这些术语之间的关系。注意，笔者对由于不准确的描述导致的性能下降，进程crash等任何问题不承担任何责任☺</p>

<p>NUMA：Non-Uniform Memory Access (NUMA) is a computer memory design used in multiprocessing, where the memory access time depends on the memory location relative to a processor. Under NUMA, a processor can access its own local memory faster than non-local memory, that is, memory local to another processor or memory shared between processors.NUMA architectures logically follow in scaling from symmetric multiprocessing (SMP) architectures.</p>

<p>提到NUMA就不能不对比SMP，</p>

<p>SMP：Symmetric multiprocessing (SMP) involves a multiprocessor computer hardware architecture where two or more identical processors are connected to a single shared main memory and are controlled by a single OS instance.</p>

<p>说了这么多其实都是为了介绍NUMA Node:</p>

<p>A fairly technically correct and also fairly ugly definition of a node is: a region of memory in which every byte has the same distance from each CPU.<br/>
A more common definition is: a block of memory and the CPUs, I/O, etc. physically on the same bus as the memory.</p>

<p>CPU：这个不解释，原因你懂得。想当年CPU拼的是频率，频率越高越NB，但是提升频率和制程密切相关。</p>

<p><img src="/images/kernel/2015-02-09-11.jpg" alt="" /></p>

<p>Intel cpu制程<br/>
但是制程这玩意有一个物理天花板，提升越来越难，有报道指出，现阶段普遍应用的硅晶体管在尺寸上有一个10nm的物理极限。为了提升性能cpu走上了多核的道路，即在一个封装（socket或者processor）里放多个core。这还不够，又发明了超线程技术Hyper-threading</p>

<p>HT：HT Technology is used to improve parallelization of computations (doing multiple tasks at once) performed on PC microprocessors. For each processor core that is physically present, the operating system addresses two virtual or logical cores, and shares the workload between them when possible. They appear to the OS as two processors, thus the OS can schedule two processes at once. 一个core 在HT之后OS看到的就是2个Logical Processor。</p>

<p>下图展示了这些术语之间的逻辑关系：</p>

<p><img src="/images/kernel/2015-02-09-12.jpg" alt="" /></p>

<h4>cpu 概念逻辑关系</h4>

<p>一个NUMA node包括一个或者多个Socket，以及与之相连的local memory。一个多核的Socket有多个Core。如果CPU支持HT，OS还会把这个Core看成 2个Logical Processor。为了避免混淆，在下文中统一用socket指代Processor or Socket;为了偷懒，下文中用Processor指代Logical Processor，击键能省则省不是。</p>

<h4>查看CPU Topology</h4>

<p>本文以笔者能访问的某台Red Hat Enterprise Linux Server release 5.4为例介绍，其他系统请自行google。</p>

<h5>NUMA Node</h5>

<p>第一种方法使用numactl查看</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numactl --hardware
</span><span class='line'>available: 2 nodes (0-1)  //当前机器有2个NUMA node,编号0&amp;1
</span><span class='line'>node 0 size: 12091 MB  //node 0 物理内存大小
</span><span class='line'>node 0 free: 988 MB    //node 0 当前free内存大小
</span><span class='line'>node 1 size: 12120 MB
</span><span class='line'>node 1 free: 1206 MB
</span><span class='line'>node distances:        //node 距离，可以简单认为是CPU本node内存访问和跨node内存访问的成本。从下表可知跨node的内存访问成本（20）是本地node内存（10）的2倍。
</span><span class='line'>node   0   1
</span><span class='line'>  0:  10  20
</span><span class='line'>  1:  20  10</span></code></pre></td></tr></table></div></figure>


<p>第二种方法是通过sysfs查看，这种方式可以查看到更多的信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls /sys/devices/system/node/
</span><span class='line'>1</span></code></pre></td></tr></table></div></figure>


<p>node0  node1 //两个目标表示本机有2个node，每个目录内部有多个文件和子目录描述node内cpu，内存等信息。比如说node0/meminfo描述了node0内存相关信息。</p>

<h5>Socket</h5>

<p>可以直接通过/proc/cpuinfo查看，cpuinfo里的physical id描述的就是Socket的编号，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /proc/cpuinfo | grep "physical id"
</span><span class='line'>physical id     : 0
</span><span class='line'>physical id     : 0
</span><span class='line'>physical id     : 0
</span><span class='line'>physical id     : 0
</span><span class='line'>physical id     : 1
</span><span class='line'>physical id     : 1
</span><span class='line'>physical id     : 1
</span><span class='line'>physical id     : 1
</span><span class='line'>physical id     : 0
</span><span class='line'>physical id     : 0
</span><span class='line'>physical id     : 0
</span><span class='line'>physical id     : 0
</span><span class='line'>physical id     : 1
</span><span class='line'>physical id     : 1
</span><span class='line'>physical id     : 1
</span><span class='line'>physical id     : 1</span></code></pre></td></tr></table></div></figure>


<p>由上可知本机有2个Socket，编号为0和1。
还可以简单的使用如下命令直接查看Socket个数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /proc/cpuinfo|grep "physical id" | sort -u | wc –l
</span><span class='line'>2   //本机有2个物理CPU封装</span></code></pre></td></tr></table></div></figure>


<h5>Core</h5>

<p>仍然是可以通过/proc/cpuinfo查看，cpuinfo中跟core相关的信息有2行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cpu cores : 4 //一个socket有4个核，
</span><span class='line'>core id : 1 //一个core在socket内的编号</span></code></pre></td></tr></table></div></figure>


<p>通过如下命令可以直接查看core的数量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /proc/cpuinfo | grep "cpu cores" | uniq | cut -d: -f2
</span><span class='line'>4  //1个socket有4个core</span></code></pre></td></tr></table></div></figure>


<ul>
<li>本机有2个socket，每个有4个core，所以一共有8个core</li>
</ul>


<p>还可以查看core在Socket里的编号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /proc/cpuinfo | grep "core id" | sort -u
</span><span class='line'>core id         : 0
</span><span class='line'>core id         : 1
</span><span class='line'>core id         : 10
</span><span class='line'>core id         : 9</span></code></pre></td></tr></table></div></figure>


<p>一个socket里面4个core的编号为0,1,9,10。是的，core id是不连续的。如果谁知道为啥麻烦通知我，先谢了。</p>

<h5>Logical Processor</h5>

<p>仍然是可以通过/proc/cpuinfo查看在OS的眼里有多少个Logical Processor</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /proc/cpuinfo | grep processor | wc –l
</span><span class='line'>16</span></code></pre></td></tr></table></div></figure>


<p>Ok，8个core变成了16个Logical Processor，所以本机开启了HT。</p>

<p>问题来了，cpuinfo里面16个Processor编号为0-15，Core的id为0,1,9,10，Socket的id为0,1。这些编号是如何对应的呢？</p>

<p>我们查看一个Processor完整的cpuinfo就比较清楚了，我剔除了不相关的行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>processor : 0    processor : 5
</span><span class='line'>physical id : 0
</span><span class='line'>siblings : 8
</span><span class='line'>core id : 0
</span><span class='line'>cpu cores : 4     physical id : 1
</span><span class='line'>siblings : 8
</span><span class='line'>core id : 1
</span><span class='line'>cpu cores : 4</span></code></pre></td></tr></table></div></figure>


<p>明白了？<br/>
Processor 0:在socket 0的core 0 里。<br/>
Processor 5：在socket 1的core 1 里。</p>

<h5>Cache</h5>

<p>仍然可以通过/proc/cpuinfo查看，OMG， cpuinfo难道是万能的？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>processor       : 0
</span><span class='line'>cache size      : 12288 KB //cpu cache 大小
</span><span class='line'>cache_alignment : 64 </span></code></pre></td></tr></table></div></figure>


<p>问题又来了，我们知道CPU cache分为L1，L2，L3, L1一般还分为独立的指令cache和数据cache。Cpuinfo里这个cache size指的是？</p>

<p>好吧，cpuinfo也不是万能的。详细的cache信息可以通过sysfs查看</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls /sys/devices/system/cpu/cpu0/cache/
</span><span class='line'>index0  index1  index2  index3</span></code></pre></td></tr></table></div></figure>


<p>4个目录 <br/>
index0: 1级数据cache<br/>
index1: 1级指令cache<br/>
index2: 2级cache<br/>
index3: 3级cache ,对应cpuinfo里的cache</p>

<p>目录里的文件是cache信息描述，以本机的cpu0/index0为例简单解释一下：</p>

<table border="1">
<tr>
<td>文件</td>
<td>内容</td>
<td>说明</td>
</tr>
<tr>
<td>type</td>
<td>Data</td>
<td>数据cache，如果查看index1就是Instruction</td>
</tr>
<tr>
<td>Level</td>
<td>1</td>
<td>L1</td>
</tr>
<tr>
<td>Size</td>
<td>32K</td>
<td>大小为32K</td>
</tr>
<tr>
<td>coherency_line_size</td>
<td>64</td>
<th rowspan="4">64*4*128=32K</th>
</tr>
<tr>
<td>physical_line_partition</td>
<td>1</td>
</tr>
<tr>
<td>ways_of_associativity</td>
<td>4</td>
</tr>
<tr>
<td>number_of_sets</td>
<td>128</td>
</tr>
<tr>
<td>shared_cpu_map</td>
<td>00000101</td>
<td>表示这个cache被CPU0和CPU8 share</td>
</tr>
</table>


<p>解释一下shared_cpu_map内容的格式：<br />
表面上看是2进制，其实是16进制表示，每个bit表示一个cpu，1个数字可以表示4个cpu<br />
截取00000101的后4位，转换为2进制表示</p>


<table border="1">
<tr>
<td>CPU id</td>
<td>15</td>
<td>14</td>
<td>13</td>
<td>12</td>
<td>11</td>
<td>10</td>
<td>9</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0&#215;0101的2进制表示</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</table>


<p>0101表示cpu8和cpu0，即cpu0的L1 data cache是和cpu8共享的。<br/>
验证一下？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /sys/devices/system/cpu/cpu8/cache/index0/shared_cpu_map
</span><span class='line'>00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000101</span></code></pre></td></tr></table></div></figure>


<p>再看一下index3 shared_cpu_map的例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /sys/devices/system/cpu/cpu0/cache/index3/shared_cpu_map
</span><span class='line'>00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000f0f</span></code></pre></td></tr></table></div></figure>


<table border="1">
<tr>
<td>CPU id</td>
<td>15</td>
<td>14</td>
<td>13</td>
<td>12</td>
<td>11</td>
<td>10</td>
<td>9</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0x0f0f的2进制表示</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>


<p>cpu0,1,2,3和cpu8,9,10,11共享L3 cache</p>

<h4>小结</h4>

<p>综合以上信息可以绘制出以下的cpu topology图:</p>

<p><img src="/images/kernel/2015-02-09-13.jpg" alt="" /></p>

<p>抱歉，图比较大，网页上看不清楚，下面放大单node图，另一个node基本上可以类推。</p>

<p><img src="/images/kernel/2015-02-09-14.jpg" alt="" /></p>

<h5>使用CPU Topology</h5>

<p>好吧，现在我们知道了如何查看CPU topology。那么这与各位攻城狮的工作有什么关系呢？</p>

<p>以淘宝搜索常见的服务模型为例，服务端把离线处理的数据load到内存中，开始监听某个服务端口，接收到客户端请求后从线程池中分配一个工作线程，该线程解析请求，读取内存中对应的数据，进行一些计算，然后把结果返回给客户端。</p>

<p>把这个过程简化简化再简化，抽象抽象再抽象，可以得到一个简单的测试程序，程序流程为：<br/>
1. 主线程申请2块256M的内存，使用memset初始化这两块内存的每个byte<br/>
2. 启动2个子线程，每个线程内循环16M次，在每次循环中随机读取2块内存中的各1K数据，对每个byte进行简单加和，返回。<br/>
3. 主线程等待子线程结束，打印每个线程的结果，结束。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>
</span><span class='line'>char *p1, *p2;
</span><span class='line'>
</span><span class='line'>int run(unsigned r)
</span><span class='line'>{
</span><span class='line'>        int i,j,k,ret=0;
</span><span class='line'>        unsigned r1,r2;
</span><span class='line'>        srand(r);
</span><span class='line'>        for (i=0;i&lt;(16&lt;&lt;20);i++) {
</span><span class='line'>                r1 = (unsigned)(rand() % ((256&lt;&lt;20)-(1&lt;&lt;10)));
</span><span class='line'>                r2 = (unsigned)(rand() % ((256&lt;&lt;20)-(1&lt;&lt;10)));
</span><span class='line'>                k = 0;
</span><span class='line'>                for (j=0;j&lt;(1&lt;&lt;10);j++) {
</span><span class='line'>                        k += *(p1+r1+j);
</span><span class='line'>                        k += *(p2+r2+j);
</span><span class='line'>                }
</span><span class='line'>                ret += k;
</span><span class='line'>        }
</span><span class='line'>        return ret;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>        int i,j;
</span><span class='line'>        pthread_t pth1, pth2;
</span><span class='line'>        p1 = (char*)malloc(256&lt;&lt;20);
</span><span class='line'>        p2 = (char*)malloc(256&lt;&lt;20);
</span><span class='line'>        memset(p1, sizeof(p1), 0);
</span><span class='line'>        memset(p2, sizeof(p2), 0);
</span><span class='line'>        pthread_create(&pth1, NULL, run, 123);
</span><span class='line'>        pthread_create(&pth2, NULL, run, 456);
</span><span class='line'>        pthread_join(pth1, NULL);
</span><span class='line'>        pthread_join(pth2, NULL);
</span><span class='line'>        return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>使用-O2编译出可执行文件test，分别使用下面2个命令运行该程序。运行时间和机器配置以及当前load有关，绝对值没有意义，这里仅比较相对值。</p>

<table border="1">
<tr>
<td>命令</td>
<td>time ./test</td>
<td>time numactl -m 0 &#8211;physcpubind=2,3  ./test</td>
</tr>
<tr>
<td>用时</td>
<td><strong>real    0m38.678s</strong><br />
user    1m6.270s<br />
sys     0m5.569s
</td>
<td><strong>real    0m28.410s</strong><br />
user    0m54.997s<br />
sys     0m0.961s
</td>
</tr>
</table>


<p>发生了什么？为什么有这么大的差异？
第一个命令直观，那么我们看一下第二个命令具体做了什么：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numactl -m 0 --physcpubind=2,3 ./test
</span><span class='line'>-m 0：在node 0上分配内存
</span><span class='line'>--physcpubind=2,3：在cpu 2和3上运行程序，即一个线程运行在cpu2上，另一个运行在cpu3上。</span></code></pre></td></tr></table></div></figure>


<p>参考上面的CPUtopology图就很容易理解了，由于线程绑定cpu2和3执行，共享了L3 cache，且全部内存都是本node访问，运行效率自然比随机选择cpu运行，运行中还有可能切换cpu，内存访问有可能跨node的第一种方式要快了。</p>

<p>接下来，让我们看看完整的表格，读者可以看看有没有惊喜：</p>

<table border="1">
<tr>
<td>情况</td>
<td>命令</td>
<td>用时</td>
<td>解释</td>
</tr>
<tr>
<td>完全由OS控制</td>
<td>time ./test</td>
<td>real    0m38.678s<br />
user    1m6.270s<br />
sys     0m5.569s
</td>
<td>乐观主义者，甩手掌柜型</td>
</tr>
<tr>
<td>绑定跨node的Cpu执行</td>
<td>time numactl &#8211;physcpubind=2,6  ./test</td>
<td>real    0m38.657s<br />
user    1m7.126s<br />
sys     0m5.045s
</td>
<td>Cpu 2和6不在同一个node，不能share L3 cache</td>
</tr>
<tr>
<td>绑定单node的Cpu执行</td>
<td>time numactl &#8211;physcpubind=2,3  ./test</td>
<td>real    0m28.605s<br />
user    0m55.161s<br />
sys     0m0.856s
</td>
<td>Cpu 2和3在同一个node，share L3 cache。内存使用由OS控制，一般来说node 0和1内存都会使用。</td>
</tr>
<tr>
<td>跨node内存访问+绑定单node CPU执行</td>
<td>time numactl -m 1 &#8211;physcpubind=2,3  ./test</td>
<td>real    0m33.218s<br />
user    1m4.494s<br />
sys     0m0.911s
</td>
<td>内存全使用node1，2个cpu在node0，内存访问比较吃亏</td>
</tr>
<tr>
<td>单node内存访问+绑定本node CPU执行</td>
<td>time numactl -m 0 &#8211;physcpubind=2,3  ./test</td>
<td>real    0m28.367s<br />
user    0m55.062s<br />
sys     0m0.825s
</td>
<td>内存&amp;cpu都使用node0</td>
</tr>
<tr>
<td>单node内存访问+绑定本node 单core执行</td>
<td>time numactl -m 0 &#8211;physcpubind=2,10  ./test</td>
<td>real    0m58.062s<br />
user    1m55.520s<br />
sys     0m0.270s
</td>
<td>CPU2和10不但在同一个node，且在同一个core，本意是希望共享L1，L2cache，提升性能。但是不要忘了，CPU2和10是HT出来的logical Processor，在本例cpu密集型的线程中硬件争用严重，效率急剧下降。有没有发现和上一个case的时间比率很有意思？</td>
</tr>
</table>


<p>现在谁还能说了解点cpu topology没用呢？☺</p>

<h4>Tips</h4>

<p>补充几个小tips，方便有兴趣的同学分析上面表格的各个case</p>

<h5>1.查看进程的内存numa node分布</h5>

<p>简单的说可以查看进程的numa_maps文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /proc/pid/numa_maps</span></code></pre></td></tr></table></div></figure>


<p>文件格式可以直接：man numa_maps<br/>
为了避免输入数字pid，我使用如下命令查看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /proc/$(pidof test|cut –d” ” -f1)/numa_maps</span></code></pre></td></tr></table></div></figure>


<h5>2.查看线程run在哪个processor</h5>

<p>可以使用top命令查看一个进程的各个线程分别run在哪个processor上<br/>
同样，为了避免输入数字pid，我使用如下命令启动top：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>top -p$(pidof test |sed -e ‘s/ /,/g’)</span></code></pre></td></tr></table></div></figure>


<p>在默认配置下不显示线程信息，需要进入Top后按“shift+H”，打开线程显示。<br/>
另外，如果没有P列，还需要按“f”，按“j”，添加，这一列显示的数字就是这个线程上次run的processor id。<br/>
关于top的使用，请读者自行man top</p>

<h5>3.另一种绑定cpu执行的方法</h5>

<p>如果读者的程序不涉及大量内存的访问，可以通过taskset绑定cpu执行。别怪我没提醒你，仔细判断是否应该绑定到同一个core的processor上哦。<br/>
关于命令的使用，请读者自行Man taskset</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/21">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/19">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~arm/?opendiv=assembly'>arm</a><a href='##' onmousedown=showDiv('assembly~arm') id='aexp_assembly~arm'><span class='exp_style' id='exp_assembly~arm'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly~arm')) document.getElementById('aexp_assembly~arm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>12</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>3</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(31)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>14</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>9</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(123)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~irq/?opendiv=kernel'>irq</a><a href='##' onmousedown=showDiv('kernel~irq') id='aexp_kernel~irq'><span class='exp_style' id='exp_kernel~irq'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~irq')) document.getElementById('aexp_kernel~irq').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>57</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>18</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(19)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>5</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(26)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>19</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(123)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~07/?opendiv=2015'>2015-07</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2015~06/?opendiv=2015'>2015-06</a><span class='right_span'>24</span></li>
<li><a href='/blog/cats/2015~05/?opendiv=2015'>2015-05</a><span class='right_span'>22</span></li>
<li><a href='/blog/cats/2015~04/?opendiv=2015'>2015-04</a><span class='right_span'>23</span></li>
<li><a href='/blog/cats/2015~03/?opendiv=2015'>2015-03</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2015~02/?opendiv=2015'>2015-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>19</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(112)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(60)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2012~01/?opendiv=2012'>2012-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(35)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/07/07/ubuntu-kvm/">ubuntu安装kvm虚拟机</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/07/centos-kvm/">centos安装kvm虚拟机</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/06/centos-vnc/">vnc远程连接，远程登录服务器或者虚拟机</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/02/debug-crash-kmem/">crash kmem</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/02/kernel-net-info/">查看所有tcp连接</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  
  <a href="https://github.com/abcdxyzk">abcdxyzk on GitHub</a>
  
</section>

<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/zhangskd target=_blank>zhangsk</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/justlinux2010 target=_blank>justlinux2010</a>
	</li>
	<li>
		<a href=http://simohayha.iteye.com/ target=_blank>simohayha</a>
	</li>
	<li>
		<a href=http://linux.chinaunix.net/techdoc/net/ target=_blank>技术文档</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/cybertan target=_blank>cybertan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/newnewman80 target=_blank>newnewman80</a>
	</li>
	<li>
		<a href=http://www.cppblog.com/fwxjj/ target=_blank>fwxjj</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/ustc_dylan target=_blank>ustc_dylan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/nkguohao target=_blank>nkguohao</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/yusiguyuan target=_blank>yusiguyuan</a>
	</li>
	<li>
		<a href=http://www.oenhan.com/ target=_blank>oenhan</a>
	</li>
	<li>
		<a href=http://blog.csdn.net/bullbat target=_blank>bullbat</a>
	</li>
	<li>
		<a href=http://www.wowotech.net/ target=_blank>wowotech</a>
	</li>
	<li>
		<a href=http://www.lenky.info/ target=_blank>lenky</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
</script>





</body>
</html>
