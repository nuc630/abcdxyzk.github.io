<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title><![CDATA[Tag: ar | kk Blog —— 通用基础]]></title>
<link href="http://abcdxyzk.github.io/tags/ar/atom.xml" rel="self"/>
<link href="http://abcdxyzk.github.io/"/>
<updated>2014-11-25T18:07:20+08:00</updated>
<id>http://abcdxyzk.github.io/</id>
<author>
<name><![CDATA[kk]]></name>

</author>
<generator uri="http://octopress.org/">Octopress</generator>

<entry>
<title type="html"><![CDATA[ar ranlib nm 命令--制作.a文件]]></title>
<link href="http://abcdxyzk.github.io/blog/2014/11/06/command-ar/"/>
<updated>2014-11-06T23:08:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2014/11/06/command-ar</id>
<content type="html"><![CDATA[<h4>1.ar基本用法</h4>

<h5>功能说明：建立或修改备存文件，或是从备存文件中抽取文件。</h5>

<p>ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。</p>

<!--more-->


<h5>下面是ar命令的格式：</h5>

<p>　　ar [-]{dmpqrtx}[abcfilNoPsSuvV] [membername] [count] archive files&hellip;<br/>
　　例如我们可以用ar rv libtest.a hello.o hello1.o来 生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-&lsquo;字符，也可以 没有。下面我们来看看命令的操作选项和任选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。<br/>
　　{dmpqrtx}中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下：<br/>
    d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。<br/>
    m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用'a'，'b'，或'I'任选项移动到指定的位置。<br/>
    p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。<br/>
    q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。'a'，'b'，或'I'任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用'ar s'或ranlib来更新库的符号表索引。<br/>
    r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。<br/>
    t：显示库的模块表清单。一般只显示模块名。<br/>
    x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。<br/>
　　下面在看看可与操作选项结合使用的任选项：<br/>
    a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。<br/>
    b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。<br/>
    c：创建一个库。不管库是否存在，都将创建。<br/>
    f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。<br/>
    i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。<br/>
    l：暂未使用<br/>
    N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。<br/>
    o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。<br/>
    P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。<br/>
    s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。<br/>
    S：不创建目标文件索引，这在创建较大的库时能加快时间。<br/>
    u：一般说来，命令ar r&hellip;插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。<br/>
    v：该选项用来显示执行操作选项的附加信息。<br/>
    V：显示ar的版本。</p>

<h4>2.ranlib命令</h4>

<p>静态库文件需要使用“ar”来创建和维护。当给静态库增建一个成员时（加入一个.o文件到静态库中），“ar”可直接 将需要增加的.o文件简单的追加到静态库的末尾。之后当我们使用这个库进行连接生成可执行文件时，链接程序“ld”却提示错误，这可能是：主程序使用了之 前加入到库中的.o文件中定义的一个函数或者全局变量，但连接程序无法找到这个函数或者变量。</p>

<p>这个问题的原因是：之前我们将编译完成的.o文件直接加入到了库的末尾，却并没有更新库的有效符号表。连接程序进行连接时，在静态库的符号索引表中无法定 位刚才加入的.o文件中定义的函数或者变量。这就需要在完成库成员追加以后让加入的所有.o文件中定义的函数（变量）有效，完成这个工作需要使用另外一个 工具“ranlib”来对静态库的符号索引表进行更新。</p>

<p>我们所使用到的静态库（文档文件）中，存在这样一个特殊的成员，它的名字是“<strong>.SYMDEF”。它包含了静态库中所有成员所定义的有效符号（函数名、 变量名）。因此，当为库增加了一个成员时，相应的就需要更新成员“</strong>.SYMDEF”，否则所增加的成员中定义的所有的符号将无法被连接程序定位。完成 更新的命令是：
<code>
    ranlib ARCHIVEFILE
</code>
通常在Makefile中我们可以这样来实现：
<code>
    libfoo.a: libfoo.a(x.o) libfoo.a(y.o) ...
    ranlib libfoo.a
</code>
它所实现的是在更新静态库成员“x.o”和“y.o”之后，对静态库的成员“__.SYMDEF”进行更新（更新库的符号索引表）。
如果我们使用GNU ar工具来维护、管理静态库，我们就不需要考虑这一步。GNU ar本身已经提供了在更新库的同时更新符号索引表的功能（这是默认行为，也可以通过命令行选项控制ar的具体行为。可参考 GNU ar工具的man手册）。</p>

<p>GNU工具中ar是用来制作库文件.a的，但同时还提供了一个ranlib，从手册上看ranlib相当于ar -s，为什么这样呢？<br/>
这是由于最早在Unix系统上ar程序是单纯用来打包多个.o到.a（类似于tar做的事情），而不处理.o里的符号表。Linker程序则需 要.a文件提供一个完整的符号表，所以当时就写了单独的ranlib程序用来产生linker所需要的符号信息。也就是说，产生一个对linker合 格的的.a文件需要做ar和ranlib两步 。<br/>
很快，Unix厂商就发现ranlib做得事情完全可以合并到ar里面去，于是ar程序的升级版本就包括了ranlib的功能，但早期的很多项目的Makefile都已经是按照两步式的方法生成.a，所以为了保证这些早期文件的兼容性，ranlib被保留下来了。<br/>
如今，GNU/Linux系统上，ranlib依然存在，当然大部分项目已经不使用它了，因为ar -s就做了ranlib的工作。<br/>
历史通常是进步和妥协的混合！</p>

<h4>3.nm基本用法命令</h4>

<p>　　nm用来列出目标文件的符号清单。下面是nm命令的格式：
<code>
    nm [-a|--debug-syms] [-g|--extern-only] [-B][-C|--demangle] [-D|--dynamic] [-s|--print-armap][-o|--print-file-name] [-n|--numeric-sort][-p|--no-sort] [-r|--reverse-sort] [--size-sort][-u|--undefined-only] [-l|--line-numbers] [--help][--version] [-t radix|--radix=radix][-P|--portability] [-f format|--format=format][--target=bfdname] [objfile...]
</code>
如果没有为nm命令指出目标文件，则nm假定目标文件是a.out。下面列出该命令的任选项，大部分支持"-&ldquo;开头的短格式和"—"开头的长格式。<br/>
-A、-o或&ndash;print-file-name：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。<br/>
    例如nm libtest.a的输出如下：
<code>
    CPThread.o:
    00000068 T Main__8CPThreadPv
    00000038 T Start__8CPThread
    00000014 T _._8CPThread
    00000000 T __8CPThread
    00000000 ? __FRAME_BEGIN__
    .......................................
    则nm -A 的输出如下：
    libtest.a:CPThread.o:00000068 T Main__8CPThreadPv
    libtest.a:CPThread.o:00000038 T Start__8CPThread
    libtest.a:CPThread.o:00000014 T _._8CPThread
    libtest.a:CPThread.o:00000000 T __8CPThread
    libtest.a:CPThread.o:00000000 ? __FRAME_BEGIN__
    ..................................................................
</code>
nm命令<br/>
    -a或&ndash;debug-syms：显示调试符号。<br/>
    -B：等同于&ndash;format=bsd，用来兼容MIPS的nm。<br/>
    -C或&ndash;demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。<br/>
    -D或&ndash;dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。<br/>
    -f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。<br/>
    -g或&ndash;extern-only：仅显示外部符号。<br/>
    -n、-v或&ndash;numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。<br/>
    -p或&ndash;no-sort：按目标文件中遇到的符号顺序显示，不排序。<br/>
    -P或&ndash;portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。<br/>
    -s或&ndash;print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。<br/>
    -r或&ndash;reverse-sort：反转排序的顺序(例如，升序变为降序)。<br/>
    &ndash;size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。<br/>
    -t radix或&ndash;radix=radix：使用radix进制显示符号值。radix只能为"d"表示十进制、"o"表示八进制或"x"表示十六进制。<br/>
    &ndash;target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。<br/>
    -u或&ndash;undefined-only：仅显示没有定义的符号(那些外部符号)。<br/>
    -l或&ndash;line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。<br/>
    -V或&ndash;version：显示nm的版本号。<br/>
    &ndash;help：显示nm的任选项。</p>
]]></content>
</entry>

</feed>
