<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-07-27T18:24:50+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[系统级性能分析工具 --- Perf]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/27/debug-perf/"/>
    <updated>2015-07-27T17:09:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/27/debug-perf</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/37902159">http://blog.csdn.net/zhangskd/article/details/37902159</a></p>

<p>从2.6.31内核开始，linux内核自带了一个性能分析工具perf，能够进行函数级与指令级的热点查找。</p>

<h4>perf</h4>

<p>Performance analysis tools for Linux.<br/>
Performance counters for Linux are a new kernel-based subsystem that provide a framework for all things performance analysis. It covers hardware level (CPU/PMU, Performance Monitoring Unit) features and software features (software counters, tracepoints) as well.</p>

<p>perf是内置于Linux内核源码树中的性能剖析(profiling)工具。</p>

<p>它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。</p>

<p>常用于性能瓶颈的查找与热点代码的定位。</p>

<p>CPU周期(cpu-cycles)是默认的性能事件，所谓的CPU周期是指CPU所能识别的最小时间单元，通常为亿分之几秒，是CPU执行最简单的指令时所需要的时间，例如读取寄存器中的内容，也叫做clock tick。</p>

<p>perf是一个包含22种子工具的工具集，以下是最常用的5种：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf list
</span><span class='line'>perf stat
</span><span class='line'>perf top
</span><span class='line'>perf record
</span><span class='line'>perf report</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>perf list</h4>

<p>perf list用来查看perf所支持的性能事件，有软件的也有硬件的。</p>

<p>List all symbolic event types.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf list [hw | sw | cache | tracepoint | event_glob]</span></code></pre></td></tr></table></div></figure>


<h5>(1) 性能事件的分布</h5>

<p>hw：Hardware event，9个<br/>
sw：Software event，9个<br/>
cache：Hardware cache event，26个<br/>
tracepoint：Tracepoint event，775个</p>

<p>sw实际上是内核的计数器，与硬件无关。<br/>
hw和cache是CPU架构相关的，依赖于具体硬件。<br/>
tracepoint是基于内核的ftrace，主线2.6.3x以上的内核版本才支持。</p>

<h5>(2) 指定性能事件(以它的属性)</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-e &lt;event&gt; : u // userspace
</span><span class='line'>-e &lt;event&gt; : k // kernel
</span><span class='line'>-e &lt;event&gt; : h // hypervisor
</span><span class='line'>-e &lt;event&gt; : G // guest counting (in KVM guests)
</span><span class='line'>-e &lt;event&gt; : H // host counting (not in KVM guests)</span></code></pre></td></tr></table></div></figure>


<h5>(3) 使用例子</h5>

<p>显示内核和模块中，消耗最多CPU周期的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf top -e cycles:k</span></code></pre></td></tr></table></div></figure>


<p>显示分配高速缓存最多的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf top -e kmem:kmem_cache_alloc</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>perf top</h4>

<p>对于一个指定的性能事件(默认是CPU周期)，显示消耗最多的函数或指令。</p>

<p>System profiling tool.<br/>
Generates and displays a performance counter profile in real time.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf top [-e &lt;EVENT&gt; | --event=EVENT] [&lt;options&gt;]</span></code></pre></td></tr></table></div></figure>


<p>perf top主要用于实时分析各个函数在某个性能事件上的热度，能够快速的定位热点函数，包括应用程序函数、模块函数与内核函数，甚至能够定位到热点指令。默认的性能事件为cpu cycles。</p>

<h5>(1) 输出格式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf top
</span><span class='line'>
</span><span class='line'>Samples: 1M of event 'cycles', Event count (approx.): 73891391490
</span><span class='line'>     5.44%  perf              [.] 0x0000000000023256
</span><span class='line'>     4.86%  [kernel]          [k] _spin_lock
</span><span class='line'>     2.43%  [kernel]          [k] _spin_lock_bh
</span><span class='line'>     2.29%  [kernel]          [k] _spin_lock_irqsave
</span><span class='line'>     1.77%  [kernel]          [k] __d_lookup
</span><span class='line'>     1.55%  libc-2.12.so      [.] __strcmp_sse42
</span><span class='line'>     1.43%  nginx             [.] ngx_vslprintf
</span><span class='line'>     1.37%  [kernel]          [k] tcp_poll</span></code></pre></td></tr></table></div></figure>


<p>第一列：符号引发的性能事件的比例，默认指占用的cpu周期比例。<br/>
第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。<br/>
第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库)。[k]表述此符号属于内核或模块。<br/>
第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p>

<h5>(2) 常用交互命令</h5>

<p>h：显示帮助<br/>
UP/DOWN/PGUP/PGDN/SPACE：上下和翻页。<br/>
a：annotate current symbol，注解当前符号。能够给出汇编语言的注解，给出各条指令的采样率。<br/>
d：过滤掉所有不属于此DSO的符号。非常方便查看同一类别的符号。<br/>
P：将当前信息保存到perf.hist.N中。<br/>
s：输入函数，查看函数内部热点。</p>

<h5>(3) 常用命令行参数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-e &lt;event&gt;：指明要分析的性能事件。
</span><span class='line'>-p &lt;pid&gt;：Profile events on existing Process ID (comma sperated list). 仅分析目标进程及其创建的线程。
</span><span class='line'>-k &lt;path&gt;：Path to vmlinux. Required for annotation functionality. 带符号表的内核映像所在的路径。
</span><span class='line'>-K：不显示属于内核或模块的符号。
</span><span class='line'>-U：不显示属于用户态程序的符号。
</span><span class='line'>-d &lt;n&gt;：界面的刷新周期，默认为2s，因为perf top默认每2s从mmap的内存区域读取一次性能数据。
</span><span class='line'>-G：得到函数的调用关系图。
</span><span class='line'>perf top -G [fractal]，路径概率为相对值，加起来为100%，调用顺序为从下往上。
</span><span class='line'>perf top -G graph，路径概率为绝对值，加起来为该函数的热度。</span></code></pre></td></tr></table></div></figure>


<h5>(4) 使用例子</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf top // 默认配置
</span><span class='line'># perf top -G // 得到调用关系图
</span><span class='line'># perf top -e cycles // 指定性能事件
</span><span class='line'># perf top -p 23015,32476 // 查看这两个进程的cpu cycles使用情况
</span><span class='line'># perf top -s comm,pid,symbol // 显示调用symbol的进程名和进程号
</span><span class='line'># perf top --comms nginx,top // 仅显示属于指定进程的符号
</span><span class='line'># perf top --symbols kfree // 仅显示指定的符号</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>perf stat</h4>

<p>用于分析指定程序的性能概况。</p>

<p>Run a command and gather performance counter statistics.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] &lt;command&gt;
</span><span class='line'>perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] - &lt;command&gt; [&lt;options&gt;]</span></code></pre></td></tr></table></div></figure>


<h5>(1) 输出格式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat ls
</span><span class='line'>
</span><span class='line'>Performance counter stats for 'ls':
</span><span class='line'>
</span><span class='line'>         0.653782 task-clock                #    0.691 CPUs utilized
</span><span class='line'>                0 context-switches          #    0.000 K/sec
</span><span class='line'>                0 CPU-migrations            #    0.000 K/sec
</span><span class='line'>              247 page-faults               #    0.378 M/sec
</span><span class='line'>        1,625,426 cycles                    #    2.486 GHz
</span><span class='line'>        1,050,293 stalled-cycles-frontend   #   64.62% frontend cycles idle
</span><span class='line'>          838,781 stalled-cycles-backend    #   51.60% backend  cycles idle
</span><span class='line'>        1,055,735 instructions              #    0.65  insns per cycle
</span><span class='line'>                                            #    0.99  stalled cycles per insn
</span><span class='line'>          210,587 branches                  #  322.106 M/sec
</span><span class='line'>           10,809 branch-misses             #    5.13% of all branches
</span><span class='line'>
</span><span class='line'>      0.000945883 seconds time elapsed</span></code></pre></td></tr></table></div></figure>


<p>输出包括ls的执行时间，以及10个性能事件的统计。</p>

<p>task-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized = task-clock / time elapsed，CPU的占用率。<br/>
context-switches：上下文的切换次数。<br/>
CPU-migrations：处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。<br/>
page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。<br/>
cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles / task-clock算出。<br/>
stalled-cycles-frontend：略过。<br/>
stalled-cycles-backend：略过。<br/>
instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。<br/>
branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p>

<h5>(2) 常用参数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-p：stat events on existing process id (comma separated list). 仅分析目标进程及其创建的线程。
</span><span class='line'>-a：system-wide collection from all CPUs. 从所有CPU上收集性能数据。
</span><span class='line'>-r：repeat command and print average + stddev (max: 100). 重复执行命令求平均。
</span><span class='line'>-C：Count only on the list of CPUs provided (comma separated list), 从指定CPU上收集性能数据。
</span><span class='line'>-v：be more verbose (show counter open errors, etc), 显示更多性能数据。
</span><span class='line'>-n：null run - don't start any counters，只显示任务的执行时间 。
</span><span class='line'>-x SEP：指定输出列的分隔符。
</span><span class='line'>-o file：指定输出文件，--append指定追加模式。
</span><span class='line'>--pre &lt;cmd&gt;：执行目标程序前先执行的程序。
</span><span class='line'>--post &lt;cmd&gt;：执行目标程序后再执行的程序。</span></code></pre></td></tr></table></div></figure>


<h5>(3) 使用例子</h5>

<p>执行10次程序，给出标准偏差与期望的比值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat -r 10 ls &gt; /dev/null</span></code></pre></td></tr></table></div></figure>


<p>显示更详细的信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat -v ls &gt; /dev/null</span></code></pre></td></tr></table></div></figure>


<p>只显示任务执行时间，不显示性能计数器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat -n ls &gt; /dev/null</span></code></pre></td></tr></table></div></figure>


<p>单独给出每个CPU上的信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat -a -A ls &gt; /dev/null</span></code></pre></td></tr></table></div></figure>


<p>ls命令执行了多少次系统调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat -e syscalls:sys_enter ls </span></code></pre></td></tr></table></div></figure>


<hr />

<h4>perf record</h4>

<p>收集采样信息，并将其记录在数据文件中。随后可以通过其它工具(perf-report)对数据文件进行分析，结果类似于perf-top的。</p>

<p>Run a command and record its profile into perf.data.<br/>
This command runs a command and gathers a performance counter profile from it, into perf.data,without displaying anything. This file can then be inspected later on, using perf report.</p>

<h5>(1) 常用参数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-e：Select the PMU event.
</span><span class='line'>-a：System-wide collection from all CPUs.
</span><span class='line'>-p：Record events on existing process ID (comma separated list).
</span><span class='line'>-A：Append to the output file to do incremental profiling.
</span><span class='line'>-f：Overwrite existing data file.
</span><span class='line'>-o：Output file name.
</span><span class='line'>-g：Do call-graph (stack chain/backtrace) recording.
</span><span class='line'>-C：Collect samples only on the list of CPUs provided.</span></code></pre></td></tr></table></div></figure>


<h5>(2) 使用例子</h5>

<p>记录nginx进程的性能数据：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf record -p `pgrep -d ',' nginx`</span></code></pre></td></tr></table></div></figure>


<p>记录执行ls时的性能数据：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf record ls -g</span></code></pre></td></tr></table></div></figure>


<p>记录执行ls时的系统调用，可以知道哪些系统调用最频繁：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf record -e syscalls:sys_enter ls</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>perf report</h4>

<p>读取perf record创建的数据文件，并给出热点分析结果。</p>

<p>Read perf.data (created by perf record) and display the profile.<br/>
This command displays the performance counter profile information recorded via perf record.</p>

<h5>(1) 常用参数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-i：Input file name. (default: perf.data)</span></code></pre></td></tr></table></div></figure>


<h5>(2) 使用例子</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf report -i perf.data.2</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>More</h3>

<p>除了以上5个常用工具外，还有一些适用于较特殊场景的工具， 比如内核锁、slab分配器、调度器，也支持自定义探测点。</p>

<h4>perf lock</h4>

<p>内核锁的性能分析。</p>

<p>Analyze lock events.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf lock {record | report | script | info}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>需要编译选项的支持：CONFIG_LOCKDEP、CONFIG_LOCK_STAT。</li>
</ul>


<p>CONFIG_LOCKDEP defines acquired and release events.<br/>
CONFIG_LOCK_STAT defines contended and acquired lock events.</p>

<h5>(1) 常用选项</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-i &lt;file&gt;：输入文件
</span><span class='line'>-k &lt;value&gt;：sorting key，默认为acquired，还可以按contended、wait_total、wait_max和wait_min来排序。</span></code></pre></td></tr></table></div></figure>


<h5>(2) 使用例子</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf lock record ls // 记录
</span><span class='line'># perf lock report // 报告</span></code></pre></td></tr></table></div></figure>


<h5>(3) 输出格式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>               Name   acquired  contended total wait (ns)   max wait (ns)   min wait (ns)
</span><span class='line'>
</span><span class='line'>&mm-&gt;page_table_...        382          0               0               0               0
</span><span class='line'>&mm-&gt;page_table_...         72          0               0               0               0
</span><span class='line'>          &fs-&gt;lock         64          0               0               0               0
</span><span class='line'>        dcache_lock         62          0               0               0               0
</span><span class='line'>      vfsmount_lock         43          0               0               0               0
</span><span class='line'>&newf-&gt;file_lock...         41          0               0               0               0</span></code></pre></td></tr></table></div></figure>


<p>Name：内核锁的名字。<br/>
aquired：该锁被直接获得的次数，因为没有其它内核路径占用该锁，此时不用等待。<br/>
contended：该锁等待后获得的次数，此时被其它内核路径占用，需要等待。<br/>
total wait：为了获得该锁，总共的等待时间。<br/>
max wait：为了获得该锁，最大的等待时间。<br/>
min wait：为了获得该锁，最小的等待时间。</p>

<p>最后还有一个Summary：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>=== output for debug===  
</span><span class='line'>  
</span><span class='line'>bad: 10, total: 246  
</span><span class='line'>bad rate: 4.065041 %  
</span><span class='line'>histogram of events caused bad sequence  
</span><span class='line'>    acquire: 0  
</span><span class='line'>   acquired: 0  
</span><span class='line'>  contended: 0  
</span><span class='line'>    release: 10  </span></code></pre></td></tr></table></div></figure>


<hr />

<h5>perf kmem</h5>

<p>slab分配器的性能分析。</p>

<p>Tool to trace/measure kernel memory(slab) properties.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf kmem {record | stat} [&lt;options&gt;]</span></code></pre></td></tr></table></div></figure>


<h5>(1) 常用选项</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>--i &lt;file&gt;：输入文件
</span><span class='line'>--caller：show per-callsite statistics，显示内核中调用kmalloc和kfree的地方。
</span><span class='line'>--alloc：show per-allocation statistics，显示分配的内存地址。
</span><span class='line'>-l &lt;num&gt;：print n lines only，只显示num行。
</span><span class='line'>-s &lt;key[,key2...]&gt;：sort the output (default: frag,hit,bytes)</span></code></pre></td></tr></table></div></figure>


<h5>(2) 使用例子</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf kmem record ls // 记录
</span><span class='line'># perf kmem stat --caller --alloc -l 20 // 报告</span></code></pre></td></tr></table></div></figure>


<h5>(3) 输出格式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>------------------------------------------------------------------------------------------------------
</span><span class='line'> Callsite                           | Total_alloc/Per | Total_req/Per   | Hit      | Ping-pong | Frag
</span><span class='line'>------------------------------------------------------------------------------------------------------
</span><span class='line'> perf_event_mmap+ec                 |    311296/8192  |    155952/4104  |       38 |        0 | 49.902%
</span><span class='line'> proc_reg_open+41                   |        64/64    |        40/40    |        1 |        0 | 37.500%
</span><span class='line'> __kmalloc_node+4d                  |      1024/1024  |       664/664   |        1 |        0 | 35.156%
</span><span class='line'> ext3_readdir+5bd                   |        64/64    |        48/48    |        1 |        0 | 25.000%
</span><span class='line'> load_elf_binary+8ec                |       512/512   |       392/392   |        1 |        0 | 23.438%</span></code></pre></td></tr></table></div></figure>


<p>Callsite：内核代码中调用kmalloc和kfree的地方。<br/>
Total_alloc/Per：总共分配的内存大小，平均每次分配的内存大小。<br/>
Total_req/Per：总共请求的内存大小，平均每次请求的内存大小。<br/>
Hit：调用的次数。<br/>
Ping-pong：kmalloc和kfree不被同一个CPU执行时的次数，这会导致cache效率降低。<br/>
Frag：碎片所占的百分比，碎片 = 分配的内存 - 请求的内存，这部分是浪费的。<br/>
有使用&ndash;alloc选项，还会看到Alloc Ptr，即所分配内存的地址。</p>

<p>最后还有一个Summary：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SUMMARY
</span><span class='line'>=======
</span><span class='line'>Total bytes requested: 290544
</span><span class='line'>Total bytes allocated: 447016
</span><span class='line'>Total bytes wasted on internal fragmentation: 156472
</span><span class='line'>Internal fragmentation: 35.003669%
</span><span class='line'>Cross CPU allocations: 2/509</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>probe sched</h4>

<p>调度模块分析。</p>

<p>trace/measure scheduler properties (latencies)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf sched {record | latency | map | replay | script}</span></code></pre></td></tr></table></div></figure>


<h5>(1) 使用例子</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf sched record sleep 10 // perf sched record &lt;command&gt;
</span><span class='line'># perf report latency --sort max</span></code></pre></td></tr></table></div></figure>


<h5>(2) 输出格式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---------------------------------------------------------------------------------------------------------------
</span><span class='line'> Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at     |
</span><span class='line'>---------------------------------------------------------------------------------------------------------------
</span><span class='line'> events/10:61          |      0.655 ms |       10 | avg:    0.045 ms | max:    0.161 ms | max at: 9804.958730 s
</span><span class='line'> sleep:11156           |      2.263 ms |        4 | avg:    0.052 ms | max:    0.118 ms | max at: 9804.865552 s
</span><span class='line'> edac-poller:1125      |      0.598 ms |       10 | avg:    0.042 ms | max:    0.113 ms | max at: 9804.958698 s
</span><span class='line'> events/2:53           |      0.676 ms |       10 | avg:    0.037 ms | max:    0.102 ms | max at: 9814.751605 s
</span><span class='line'> perf:11155            |      2.109 ms |        1 | avg:    0.068 ms | max:    0.068 ms | max at: 9814.867918 s</span></code></pre></td></tr></table></div></figure>


<p>TASK：进程名和pid。<br/>
Runtime：实际的运行时间。<br/>
Switches：进程切换的次数。<br/>
Average delay：平均的调度延迟。<br/>
Maximum delay：最大的调度延迟。<br/>
Maximum delay at：最大调度延迟发生的时刻。</p>

<hr />

<h4>perf probe</h4>

<p>可以自定义探测点。</p>

<p>Define new dynamic tracepoints.</p>

<h5>使用例子</h5>

<p>(1) Display which lines in schedule() can be probed</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf probe --line schedule</span></code></pre></td></tr></table></div></figure>


<p>前面有行号的可以探测，没有行号的就不行了。</p>

<p>(2) Add a probe on schedule() function 12th line.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf probe -a schedule:12</span></code></pre></td></tr></table></div></figure>


<p>在schedule函数的12处增加一个探测点。</p>

<hr />

<h4>Reference</h4>

<p>[1]. Linux的系统级性能剖析工具系列，by 承刚</p>

<p>[2]. <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/">http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/</a></p>

<p>[3]. <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/">http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/</a></p>

<p>[4]. <a href="https://perf.wiki.kernel.org/index.php/Tutorial">https://perf.wiki.kernel.org/index.php/Tutorial</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[haproxy splice]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/24/tools-haproxy-splice/"/>
    <updated>2015-07-24T16:45:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/24/tools-haproxy-splice</id>
    <content type="html"><![CDATA[<p>www.haproxy.org/download/1.5/doc/configuration.txt 或 <a href="http://abcdxyzk.github.io/download/tools/haproxy-1.5-configuration.txt">configuration.txt</a></p>

<p>旧版编译加</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>USE_TCPSPLICE=1</span></code></pre></td></tr></table></div></figure>


<p>比较新的加</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>USE_LINUX_SPLICE=1</span></code></pre></td></tr></table></div></figure>


<p>默认编译会加入</p>

<p>编译加入了也要在配置文件中开启才有效</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>option splice-auto
</span><span class='line'>option splice-request
</span><span class='line'>option splice-response</span></code></pre></td></tr></table></div></figure>


<p>在global中关闭splice功能</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nosplice</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[haproxy log]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/24/tools-haproxy-log/"/>
    <updated>2015-07-24T16:39:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/24/tools-haproxy-log</id>
    <content type="html"><![CDATA[<p><a href="http://sharadchhetri.com/2013/10/16/how-to-enable-logging-of-haproxy-in-rsyslog/">http://sharadchhetri.com/2013/10/16/how-to-enable-logging-of-haproxy-in-rsyslog/</a></p>

<p>  After installing the HAproxy 1.4 in CentOS 6.4 bydefault logging of haproxy was not enable.To enable the logging of HAProxy you have to enable it in rsyslog(In CentOS 6.4 minimal installation,rsyslog version 5.2 is shipped).
To setup logging in HAproxy,follow the given below steps</p>

<h4>Step 1:</h4>

<p>In Global Section of haproxy.cfg put the value log 127.0.0.1 local0 .Like given below</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>global
</span><span class='line'>    log 127.0.0.1   local0</span></code></pre></td></tr></table></div></figure>


<h4>Step 2:</h4>

<p>Create new haproxy configuration file in /etc/rsyslog.d . Here we are keeping the log in localhost or in other words we should say HAproxy server</p>

<h4>Note:</h4>

<p>local0.=info -/var/log/haproxy.log defines the http log will be saved in haproxy.log</p>

<p>local0.notice -/var/log/haproxy-status.log defines the Server status like start,stop,restart,down,up etc. will be saved in haproxy-status.log</p>

<p>UDPServerRun 514 means opening UDP port no. 514 to listen haproxy messages</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vi /etc/rsyslog.d/haproxy.conf
</span><span class='line'>
</span><span class='line'>$ModLoad imudp
</span><span class='line'>$UDPServerRun 514 
</span><span class='line'>$template Haproxy,"%msg%\n"
</span><span class='line'>local0.=info -/var/log/haproxy.log;Haproxy
</span><span class='line'>local0.notice -/var/log/haproxy-status.log;Haproxy
</span><span class='line'>### keep logs in localhost ##
</span><span class='line'>local0.* ~ </span></code></pre></td></tr></table></div></figure>


<h4>Step 3:</h4>

<p>Now restart the HAproxy service</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/etc/init.d/haproxy restart</span></code></pre></td></tr></table></div></figure>


<p>After restarting the haproxy service two logs will be created itself i.e haproxy.log and haproxy-status.log</p>

<h4>Step 4:</h4>

<p>Check your logrotae file for haproxy also so that logs keep on rotating and compress itself. If bydefault it is not present in /etc/logrotate.d directory then create a new file called haproxy and paste the given below code.</p>

<p>Here I am keeping the logs upto 120 days hence rotate 120 and daily is written in file.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /etc/logrotate.d/haproxy
</span><span class='line'>
</span><span class='line'>/var/log/haproxy.log {
</span><span class='line'>    missingok
</span><span class='line'>    notifempty
</span><span class='line'>    sharedscripts
</span><span class='line'>    rotate 120
</span><span class='line'>    daily
</span><span class='line'>    compress
</span><span class='line'>    postrotate
</span><span class='line'>        reload rsyslog &gt;/dev/null 2&gt;&1 || true
</span><span class='line'>    endscript
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[haproxy安装配置]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/23/tools-haproxy/"/>
    <updated>2015-07-23T15:47:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/23/tools-haproxy</id>
    <content type="html"><![CDATA[<p>HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上.</p>

<p>haproxy 配置中分成五部分内容，分别如下：</p>

<p>1、global：参数是进程级的，通常是和操作系统相关。这些参数一般只设置一次，如果配置无误，就不需要再次进行修改</p>

<p>2、defaults：配置默认参数，这些参数可以被用到frontend，backend，Listen组件</p>

<p>3、frontend：接收请求的前端虚拟节点，Frontend可以更加规则直接指定具体使用后端的backend</p>

<p>4、backend：后端服务集群的配置，是真实服务器，一个Backend对应一个或者多个实体服务器</p>

<p>5、Listen Fronted和backend的组合体</p>

<h4>一、安装HAProxy</h4>

<h5>1.下载最新haproxy安装包</h5>

<p>官网：<a href="http://www.haproxy.org">http://www.haproxy.org</a> ,如果不能访问，可以使用在线代理访问下载。下载：<a href="http://fossies.org/linux/misc/haproxy-1.5.14.tar.gz">http://fossies.org/linux/misc/haproxy-1.5.14.tar.gz</a> 或 <a href="http://abcdxyzk.github.io/download/tools/haproxy-1.5.14.tar.gz">haproxy-1.5.14.tar.gz</a></p>

<h5>2.上传到linux的haproxy用户根目录下，并解压：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tar -zxvf haproxy-1.5.14.tar.gz </span></code></pre></td></tr></table></div></figure>


<p>创建目录/home/haproxy/haproxy</p>

<h5>3.安装</h5>

<p>CentOS5编译新的haproxy需要在Makefile中禁掉USE_ACCEPT4</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd haproxy-1.5.14
</span><span class='line'>make  TARGET=linux26 ARCH=x86_64 PREFIX=/home/haproxy/haproxy   #将haproxy安装到/home/haproxy/haproxy ,TARGET是指定内核版本
</span><span class='line'>make install PREFIX=/home/haproxy/haproxy  </span></code></pre></td></tr></table></div></figure>


<p>进入/home/haproxy/haproxy  目录创建/home/haproxy/haproxy/conf目录，复制配置examples</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cp  /home/haproxy/haproxy-1.5.14/examples/haproxy.cfg  /home/haproxy/haproxy/conf/</span></code></pre></td></tr></table></div></figure>


<h5>4.修改配置</h5>

<p>配置说明如下：(参考:<a href="http://freehat.blog.51cto.com/1239536/1347882">http://freehat.blog.51cto.com/1239536/1347882</a>)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>###########全局配置#########
</span><span class='line'>global
</span><span class='line'>    log 127.0.0.1   local0          #[日志输出配置，所有日志都记录在本机，通过local0输出]
</span><span class='line'>    log 127.0.0.1   local1 notice   #定义haproxy 日志级别[error warringinfo debug]
</span><span class='line'>    daemon                          #以后台形式运行harpoxy
</span><span class='line'>    nbproc    1                     #设置进程数量
</span><span class='line'>    maxconn   4096                  #默认最大连接数,需考虑ulimit-n限制
</span><span class='line'>    #pidfile  /var/run/haproxy.pid  #haproxy 进程PID文件
</span><span class='line'>    #ulimit-n 819200                #ulimit 的数量限制
</span><span class='line'>    #chroot   /usr/share/haproxy    #chroot运行路径
</span><span class='line'>    #debug                          #haproxy 调试级别，建议只在开启单进程的时候调试
</span><span class='line'>    #quiet
</span><span class='line'>
</span><span class='line'>########默认配置############
</span><span class='line'>defaults
</span><span class='line'>    log      global
</span><span class='line'>    mode     http                  #默认的模式mode { tcp|http|health }，tcp是4层，http是7层，health只会返回OK
</span><span class='line'>    option   httplog               #日志类别,采用httplog
</span><span class='line'>    option   dontlognull           #不记录健康检查日志信息
</span><span class='line'>    retries  2                     #两次连接失败就认为是服务器不可用，也可以通过后面设置
</span><span class='line'>    option   forwardfor            #如果后端服务器需要获得客户端真实ip需要配置的参数，可以从Http Header中获得客户端ip
</span><span class='line'>    option   httpclose             #每次请求完毕后主动关闭http通道,haproxy不支持keep-alive,只能模拟这种模式的实现
</span><span class='line'>    #option  redispatch            #当serverId对应的服务器挂掉后，强制定向到其他健康的服务器，以后将不支持
</span><span class='line'>    option   abortonclose          #当服务器负载很高的时候，自动结束掉当前队列处理比较久的链接
</span><span class='line'>    maxconn  4096                  #默认的最大连接数
</span><span class='line'>    timeout  connect  5000ms       #连接超时
</span><span class='line'>    timeout  client 30000ms        #客户端超时
</span><span class='line'>    timeout  server 30000ms        #服务器超时
</span><span class='line'>    #timeout check 2000            #心跳检测超时
</span><span class='line'>    #timeout http-keep-alive10s    #默认持久连接超时时间
</span><span class='line'>    #timeout http-request   10s    #默认http请求超时时间
</span><span class='line'>    #timeout queue          1m     #默认队列超时时间
</span><span class='line'>    balance  roundrobin            #设置默认负载均衡方式，轮询方式
</span><span class='line'>    #balance source                #设置默认负载均衡方式，类似于nginx的ip_hash
</span><span class='line'>    #balnace leastconn             #设置默认负载均衡方式，最小连接数
</span><span class='line'>
</span><span class='line'>########统计页面配置########
</span><span class='line'>listen admin_stats
</span><span class='line'>    bind 0.0.0.0:1080               #设置Frontend和Backend的组合体，监控组的名称，按需要自定义名称
</span><span class='line'>    mode http                       #http的7层模式
</span><span class='line'>    option httplog                  #采用http日志格式
</span><span class='line'>    #log 127.0.0.1 local0 err       #错误日志记录
</span><span class='line'>    maxconn 10                      #默认的最大连接数
</span><span class='line'>    stats refresh 30s               #统计页面自动刷新时间
</span><span class='line'>    stats uri /stats                #统计页面url
</span><span class='line'>    stats realm XingCloud\ Haproxy  #统计页面密码框上提示文本
</span><span class='line'>    stats auth admin:admin          #设置监控页面的用户和密码:admin,可以设置多个用户名
</span><span class='line'>    stats auth  Frank:Frank         #设置监控页面的用户和密码：Frank
</span><span class='line'>    stats hide-version              #隐藏统计页面上HAProxy的版本信息
</span><span class='line'>    stats  admin if TRUE            #设置手工启动/禁用，后端服务器(haproxy-1.4.9以后版本)
</span><span class='line'>    
</span><span class='line'>########设置haproxy 错误页面#####
</span><span class='line'>errorfile 403 /home/haproxy/haproxy/errorfiles/403.http
</span><span class='line'>errorfile 500 /home/haproxy/haproxy/errorfiles/500.http
</span><span class='line'>errorfile 502 /home/haproxy/haproxy/errorfiles/502.http
</span><span class='line'>errorfile 503 /home/haproxy/haproxy/errorfiles/503.http
</span><span class='line'>errorfile 504 /home/haproxy/haproxy/errorfiles/504.http
</span><span class='line'>
</span><span class='line'>########frontend前端配置##############
</span><span class='line'>bind *:80         #这里建议使用bind *:80的方式，要不然做集群高可用的时候有问题，vip切换到其他机器就不能访问了。
</span><span class='line'>    acl web hdr(host) -i www.abc.com  #acl后面是规则名称，-i是要访问的域名，如果访问www.abc.com这个域名就分发到下面的webserver 的作用域。
</span><span class='line'>    acl img hdr(host) -i img.abc.com  #如果访问img.abc.com.cn就分发到imgserver这个作用域。
</span><span class='line'>    use_backend webserver if web
</span><span class='line'>    use_backend imgserver if img
</span><span class='line'>
</span><span class='line'>########backend后端配置##############
</span><span class='line'>backend webserver             #webserver作用域
</span><span class='line'>    mode http
</span><span class='line'>    balance   roundrobin                  #balance roundrobin 轮询，balance source 保存session值，支持static-rr，leastconn，first，uri等参数
</span><span class='line'>    option  httpchk /index.html HTTP/1.0  #健康检查, 检测文件，如果分发到后台index.html访问不到就不再分发给它
</span><span class='line'>    server  web1 10.16.0.9:8085  cookie 1 weight 5 check inter 2000 rise 2 fall 3
</span><span class='line'>    server  web2 10.16.0.10:8085 cookie 2 weight 3 check inter 2000 rise 2 fall 3
</span><span class='line'>    #cookie 1表示serverid为1，check inter 1500 是检测心跳频率  
</span><span class='line'>    #rise 2是2次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重
</span><span class='line'>backend imgserver
</span><span class='line'>    mode http
</span><span class='line'>    option  httpchk /index.php
</span><span class='line'>    balance     roundrobin                          
</span><span class='line'>    server      img01 192.168.137.101:80  check inter 2000 fall 3
</span><span class='line'>    server      img02 192.168.137.102:80  check inter 2000 fall 3
</span><span class='line'>listen tcptest  
</span><span class='line'>    bind 0.0.0.0:5222  
</span><span class='line'>    mode tcp  
</span><span class='line'>    option tcplog                  #采用tcp日志格式  
</span><span class='line'>    balance source  
</span><span class='line'>    #log 127.0.0.1 local0 debug  
</span><span class='line'>    server s1 192.168.100.204:7222    weight 1  
</span><span class='line'>    server s2 192.168.100.208:7222    weight 1</span></code></pre></td></tr></table></div></figure>


<h5>5.加上日志支持</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># vim /etc/syslog.conf
</span><span class='line'>在最下边增加
</span><span class='line'>local1.*        /home/haproxy/haproxy/logs/haproxy.log
</span><span class='line'>local0.*        /home/haproxy/haproxy/logs/haproxy.log</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># vim /etc/sysconfig/syslog
</span><span class='line'>修改： SYSLOGD_OPTIONS="-r -m 0"
</span><span class='line'>重启日志服务 service syslog restart</span></code></pre></td></tr></table></div></figure>


<h6>6.启动服务</h6>

<p>启动服务：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># /home/haproxy/haproxy/sbin/haproxy -f /home/haproxy/haproxy/conf/haproxy.cfg</span></code></pre></td></tr></table></div></figure>


<p>重启服务：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># /home/haproxy/haproxy/sbin/haproxy -f /home/haproxy/haproxy/conf/haproxy.cfg -st `cat /home/haproxy/haproxy/conf/haproxy.pid`</span></code></pre></td></tr></table></div></figure>


<p>停止服务：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># killall haproxy</span></code></pre></td></tr></table></div></figure>


<h5>7.监控</h5>

<p>访问：<a href="http://192.168.101.125:1080/stats">http://192.168.101.125:1080/stats</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[同时运行多个squid]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/23/tools-squid-muti/"/>
    <updated>2015-07-23T15:32:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/23/tools-squid-muti</id>
    <content type="html"><![CDATA[<p><a href="http://wenku.baidu.com/link?url=UXFXZVxSsQMyXVzoTA5y3Oal6s5zknpozLhfodYZ7d43R_XpziB08h28ynXZy3Sq8r-XH1tdXGvxD_X2Pa_aI4f6pFTBgGXMm0QRaRbEYmq">http://wenku.baidu.com/link?url=UXFXZVxSsQMyXVzoTA5y3Oal6s5zknpozLhfodYZ7d43R_XpziB08h28ynXZy3Sq8r-XH1tdXGvxD_X2Pa_aI4f6pFTBgGXMm0QRaRbEYmq</a></p>

<h4>多代理（SQUID）同时运行的配置方法 </h4>

<p>作成日期：2012/8/24 </p>

<h5>多代理用途： </h5>

<p>1、HTTP反向加速； 
2、权限控制部分客户端，而权限控制选项是全局设置时； </p>

<p>总之，一般的代理服务器运行一个即可，当有特殊要求的时候，才有此需要，HTTP反向代理本文没有涉及，仅是为了权限控制，一台机器同一网卡运行了2个Squid，对于HTTP反向代理，有兴趣者可自行研究配置。  </p>

<h5>环境： </h5>

<p>1、 Cent OS 5 
2、 Squid （Version 2.6.STABLE21） <br/>
3、 DELL R710  </p>

<h5>配置： </h5>

<p>在配置多Squid同时运行时，我的服务器已经安装配置好的Squid，并正常运行，如果你的服务器还不具备此条件，请先配置好Squid，并确保可以正确运行。 </p>

<p>1、 复制一份Squid .conf配置文件 <br/>
2、 编辑新文件，配置如下的选项与第一个Squid区分开 </p>

<table>
    <tr>
        <th>项目</th>
        <th>参数</th>
        <th>备注</th>
    </tr>
    <tr>
        <td>端口</td>
        <td>8080</td>
        <td>端口可自定，但要注意两个问题，与原有的Squid 默认的3128区分开，并且与系统已经存在的服务占用端口区分开，避免冲突发生。</td>
    </tr>
    <tr>
        <td>缓存目录</td>
        <td>指定一个新目录与第一个Squid区分开</td>
        <td>TAG: cache_dir， 注意，新的目录必须将权限设定为777。</td>
    </tr>
    <tr>
        <td>系统日志</td>
        <td>指定一个新目录与第一个Squid区分开</td>
        <td>TAG: access_log TAG: cache_log TAG: cache_store_log 以上日志存放地点可自定与第一个Squid区分开即可，注意，新的目录必须将权限设定为777。</td>
    </tr>
    <tr>
        <td>PID文件</td>
        <td>指定一个新目录与第一个Squid区分开</td>
        <td>TAG: pid_filename 第1个Suqid的PID文件默认存放地点是/VAR/RUN 重新指定新的目录，避免与第1个Squid文件冲突。</td>
    </tr>
</table>


<p>3、初始化缓存目录 <br/>
命令如下：<code>squid -z -f 新的配置文件</code> 
注意，"-f"参数后面一定要写上新配置文件，一般设定2个Squid同时运行时，都是这一步没有处理或者处理错误，比如没有加"-f"参数的话，就会初始化原有的Squid缓存目录 而不是新squid缓存目录。 </p>

<p>4、运行第2个代理服务器 <br/>
命令如下：<code>squid -D -f 新的配置文件</code>  </p>

<p> var script = document.createElement(&lsquo;script&rsquo;); script.src = &lsquo;<a href="http://static.pay.baidu.com/resource/baichuan/ns.js">http://static.pay.baidu.com/resource/baichuan/ns.js</a>&rsquo;; document.body.appendChild(script);</p>

<h4> 维护： </h4>

<p>至此，服务器上已经运行两个代理服务器，使用不同的端口，就会通过不同代理服务器进行网络连接，设定配置文件，可为客户端设定不同的网络权限。   </p>

<p>1、关于配置文件的更新后Reload 
如更新第1个代理，使用默认系统命令：squid -k reconfigure      如更新第2个代理，squid -k reconfigure -f 新的配置文件   </p>

<p>2、第2个代理的自动启动 <br/>
当系统重新时，想第2个代理随机启动，请参照以下脚本（第1个代理启动，可以在系统中设定）： </p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /bin/sh 
</span><span class='line'>echo "Start special squid”             #输出一些提示信息 
</span><span class='line'>squid -D -f /etc/squid/squidnew.conf   #我的新配置文件在/etc/squid下面 
</span><span class='line'>echo "Please wait ...."                #输出一些提示信息 
</span><span class='line'>sleep 5                             #等待5秒，给Squid启动时间，实际可能不需要怎么久 
</span><span class='line'>cd /var/cache/squidnew/             #进入缓存目录，我的PID文件放在这里 
</span><span class='line'>if [ -s squid.pid ];                #判断PID文件是否存在，存在squid启动成功，否则失败      
</span><span class='line'>then                                              
</span><span class='line'>    echo "Squid start success"      
</span><span class='line'>else 
</span><span class='line'>    echo "Squid start failed" 
</span><span class='line'>fi
</span><span class='line'>exit 0 </span></code></pre></td></tr></table></div></figure>


<p>将该脚本放置到启动目录，自行启动即可，另外我不是自行启动，因有时候不运行，如自行启动，可将判断的部分删除，因为系统启动，可能看不到脚本提示信息。 </p>

<p>关于关闭Squid，请使用多次的 squid -k shutdown 命令关闭服务， 同时使用ps -ef |grep squid 判断代理服务是否全部关闭完成。 </p>

<p>调试过程如有问题，使用tail -f /var/log/messages 排错也是个不错的办法。  </p>

<p>备注： </p>

<p>另外，系统究竟可以运行多少个Squid？没有测试，猜测如CPU足够快、内存足够大，应该可以运行很多副本。</p>
]]></content>
  </entry>
  
</feed>
