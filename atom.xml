<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-10-31T23:58:56+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[tcp连接建立过程]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/10/31/kernel-net-connect/"/>
    <updated>2015-10-31T22:13:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/10/31/kernel-net-connect</id>
    <content type="html"><![CDATA[<h4>一、server</h4>

<h5>1. 接收syn</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_v4_do_rcv {
</span><span class='line'>&#9;nsk = tcp_v4_hnd_req(sk, skb);
</span><span class='line'>
</span><span class='line'>&#9;nsk == sk
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&#9;tcp_rcv_state_process {
</span><span class='line'>&#9;&#9;icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb)
</span><span class='line'>&#9;&#9;tcp_v4_conn_request {
</span><span class='line'>&#9;&#9;&#9;__tcp_v4_send_synack {
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;2. 发送syn/ack
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>2. 接收ack</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_v4_do_rcv {
</span><span class='line'>&#9;nsk = tcp_v4_hnd_req(sk, skb) {
</span><span class='line'>&#9;&#9;req = inet_csk_search_req
</span><span class='line'>&#9;&#9;nsk = tcp_check_req {
</span><span class='line'>&#9;&#9;&#9;tcp_v4_syn_recv_sock {
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_create_openreq_child {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;inet_csk_clone {
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;newsk-&gt;sk_state = TCP_SYN_RECV;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;nsk != sk {
</span><span class='line'>&#9;&#9;tcp_child_process {
</span><span class='line'>&#9;&#9;&#9;tcp_rcv_state_process {
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (!tcp_validate_incoming(sk, skb, th, 0))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;return 0;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;/* step 5: check the ACK field */
</span><span class='line'>&#9;&#9;&#9;&#9;if (th-&gt;ack) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;int acceptable = tcp_ack(sk, skb, FLAG_SLOWPATH) &gt; 0;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;switch (sk-&gt;sk_state) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;case TCP_SYN_RECV:
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;tcp_set_state(sk, TCP_ESTABLISHED);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;case TCP_ESTABLISHED:
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;tcp_data_queue(sk, skb);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;queued = 1;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>二、client</h4>

<h5>1. 发送syn</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_v4_connect {
</span><span class='line'>
</span><span class='line'>&#9;tcp_set_state(sk, TCP_SYN_SENT);
</span><span class='line'>
</span><span class='line'>&#9;tcp_connect {
</span><span class='line'>&#9;&#9;__tcp_add_write_queue_tail
</span><span class='line'>&#9;&#9;tcp_transmit_skb
</span><span class='line'>&#9;&#9;inet_csk_reset_xmit_timer
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>2. 接收syn/ack</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_v4_do_rcv {
</span><span class='line'>&#9;sk-&gt;sk_state == TCP_SYN_SENT
</span><span class='line'>
</span><span class='line'>&#9;tcp_rcv_state_process {
</span><span class='line'>&#9;&#9;queued = tcp_rcv_synsent_state_process(sk, skb, th, len) {
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;tcp_set_state(sk, TCP_ESTABLISHED);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;tcp_send_ack(sk); // 发送ack
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[udp协议]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/10/31/kernel-net-udp/"/>
    <updated>2015-10-31T21:47:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/10/31/kernel-net-udp</id>
    <content type="html"><![CDATA[<p>UDP数据段格式：udp包头8字节</p>

<table>
    <tr>
        <td width="200">源端口号（16）</td>
        <td width="200">目的端口号（16）</td>
    </tr>
    <tr>
        <td width="200">长度（16）</td>
        <td width="200">校验和（16）</td>
    </tr>
    <tr>
        <td width="400" colspan="2">数据（若有的话）</td>
    </tr>
</table>


<p>长度：UDP报头 加上 UDP数据的长度。</p>

<p>校验和：UDP报头和UDP数据字段两者的校验和。（加伪首部）</p>

<p>raw socket 发送udp包</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//mdos.c
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;errno.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;netdb.h&gt;
</span><span class='line'>#include &lt;sys/socket.h&gt;
</span><span class='line'>#include &lt;sys/types.h&gt;
</span><span class='line'>#include &lt;netinet/in.h&gt;
</span><span class='line'>#include &lt;netinet/ip.h&gt;
</span><span class='line'>#include &lt;arpa/inet.h&gt;
</span><span class='line'>#include &lt;linux/udp.h&gt;
</span><span class='line'>
</span><span class='line'>#include &lt;linux/if_ether.h&gt;
</span><span class='line'>#include &lt;linux/if_arp.h&gt;
</span><span class='line'>#include &lt;linux/sockios.h&gt;
</span><span class='line'>
</span><span class='line'>unsigned csum_tcpudp_nofold(unsigned saddr, unsigned daddr,
</span><span class='line'>&#9;                unsigned len, unsigned proto, unsigned sum)
</span><span class='line'>{
</span><span class='line'>&#9;unsigned long long s = (unsigned)sum;
</span><span class='line'>&#9;s += (unsigned)saddr;
</span><span class='line'>&#9;s += (unsigned)daddr;
</span><span class='line'>&#9;s += (proto + len) &lt;&lt; 8;
</span><span class='line'>&#9;s += (s &gt;&gt; 32);
</span><span class='line'>&#9;return (unsigned)s;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>unsigned short check_sum(unsigned short *addr, int len, unsigned sum)
</span><span class='line'>{
</span><span class='line'>&#9;int nleft = len;
</span><span class='line'>&#9;unsigned short *w = addr;
</span><span class='line'>&#9;unsigned short ret = 0;
</span><span class='line'>&#9;while (nleft &gt; 1) {
</span><span class='line'>&#9;        sum += *w++;
</span><span class='line'>&#9;        nleft -= 2;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (nleft == 1) {
</span><span class='line'>&#9;        *(unsigned char *)(&ret) = *(unsigned char *)w;
</span><span class='line'>&#9;        sum += ret;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;sum = (sum&gt;&gt;16) + (sum&0xffff);
</span><span class='line'>&#9;sum += (sum&gt;&gt;16);
</span><span class='line'>&#9;ret = ~sum;
</span><span class='line'>&#9;return ret;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//在该函数中构造整个IP报文，最后调用sendto函数将报文发送出去
</span><span class='line'>void attack(int skfd, struct sockaddr_in *target, unsigned short srcport)
</span><span class='line'>{
</span><span class='line'>&#9;char buf[512] = {0};
</span><span class='line'>&#9;struct ip *ip;
</span><span class='line'>&#9;struct udphdr *udp;
</span><span class='line'>&#9;int ip_len;
</span><span class='line'>&#9;/*
</span><span class='line'>#define kk 16
</span><span class='line'>&#9;char ch[kk] = {0x47,0x45,0x54,0x20,0x2f,0x20,0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x31,0x0d,0x0a};
</span><span class='line'>*/
</span><span class='line'>#define kk 168
</span><span class='line'>&#9;char ch[kk] = {
</span><span class='line'>0x47, 0x45, 0x54, 0x20, 0x2f, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x31, 0x0d, 0x0a,
</span><span class='line'>0x55, 0x73, 0x65, 0x72, 0x2d, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x3a, 0x20, 0x63, 0x75, 0x72, 0x6c,
</span><span class='line'>0x2f, 0x37, 0x2e, 0x31, 0x39, 0x2e, 0x37, 0x20, 0x28, 0x78, 0x38, 0x36, 0x5f, 0x36, 0x34, 0x2d,
</span><span class='line'>0x72, 0x65, 0x64, 0x68, 0x61, 0x74, 0x2d, 0x6c, 0x69, 0x6e, 0x75, 0x78, 0x2d, 0x67, 0x6e, 0x75,
</span><span class='line'>0x29, 0x20, 0x6c, 0x69, 0x62, 0x63, 0x75, 0x72, 0x6c, 0x2f, 0x37, 0x2e, 0x31, 0x39, 0x2e, 0x37,
</span><span class='line'>0x20, 0x4e, 0x53, 0x53, 0x2f, 0x33, 0x2e, 0x31, 0x35, 0x2e, 0x33, 0x20, 0x7a, 0x6c, 0x69, 0x62,
</span><span class='line'>0x2f, 0x31, 0x2e, 0x32, 0x2e, 0x33, 0x20, 0x6c, 0x69, 0x62, 0x69, 0x64, 0x6e, 0x2f, 0x31, 0x2e,
</span><span class='line'>0x31, 0x38, 0x20, 0x6c, 0x69, 0x62, 0x73, 0x73, 0x68, 0x32, 0x2f, 0x31, 0x2e, 0x34, 0x2e, 0x32,
</span><span class='line'>0x0d, 0x0a, 0x48, 0x6f, 0x73, 0x74, 0x3a, 0x20, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e,
</span><span class='line'>0x31, 0x30, 0x39, 0x2e, 0x32, 0x32, 0x32, 0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x3a,
</span><span class='line'>0x20, 0x2a, 0x2f, 0x2a, 0x0d, 0x0a, 0x0d, 0x0a
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>&#9;int data_len = kk;
</span><span class='line'>
</span><span class='line'>&#9;//在我们UDP的报文中Data没有字段，所以整个IP报文的长度
</span><span class='line'>&#9;ip_len = sizeof(struct ip) + sizeof(struct udphdr) + data_len;
</span><span class='line'>
</span><span class='line'>&#9;//开始填充IP首部
</span><span class='line'>&#9;ip=(struct ip*)buf;
</span><span class='line'>&#9;ip-&gt;ip_v = IPVERSION;
</span><span class='line'>&#9;ip-&gt;ip_hl = sizeof(struct ip)&gt;&gt;2;
</span><span class='line'>&#9;ip-&gt;ip_tos = 0;
</span><span class='line'>&#9;ip-&gt;ip_len = htons(ip_len);
</span><span class='line'>&#9;ip-&gt;ip_id = 0;
</span><span class='line'>&#9;ip-&gt;ip_off = 0;
</span><span class='line'>&#9;ip-&gt;ip_ttl = MAXTTL;
</span><span class='line'>&#9;ip-&gt;ip_p = IPPROTO_UDP;
</span><span class='line'>&#9;ip-&gt;ip_sum = 0;
</span><span class='line'>&#9;ip-&gt;ip_dst = target-&gt;sin_addr;
</span><span class='line'>
</span><span class='line'>&#9;//开始填充UDP首部
</span><span class='line'>&#9;udp = (struct udphdr*)(buf+sizeof(struct ip));
</span><span class='line'>&#9;udp-&gt;source = htons(srcport);
</span><span class='line'>&#9;udp-&gt;dest = target-&gt;sin_port;
</span><span class='line'>&#9;udp-&gt;check = 0;
</span><span class='line'>&#9;udp-&gt;len = htons(data_len + sizeof(struct udphdr));
</span><span class='line'>
</span><span class='line'>&#9;int i = ip_len - data_len;
</span><span class='line'>&#9;int j = i;
</span><span class='line'>&#9;for (;i&lt;ip_len;i++)
</span><span class='line'>&#9;&#9;buf[i] = ch[i-j];
</span><span class='line'>&#9;/*
</span><span class='line'>&#9;int s = 'A';
</span><span class='line'>&#9;buf[i++] = 0x00 + s;
</span><span class='line'>&#9;buf[i++] = 0x01 + s;
</span><span class='line'>&#9;buf[i++] = 0x02 + s;
</span><span class='line'>&#9;buf[i++] = 0x03 + s;
</span><span class='line'>&#9;buf[i++] = 0x04 + s;
</span><span class='line'>&#9;buf[i++] = 0x05 + s;
</span><span class='line'>&#9;buf[i++] = 0x06 + s;
</span><span class='line'>&#9;buf[i++] = 0x07 + s;
</span><span class='line'>&#9;buf[i++] = 0x08 + s;
</span><span class='line'>&#9;buf[i++] = 0x09 + s;
</span><span class='line'>*/
</span><span class='line'>&#9;printf("%lx %d %d\n", ip-&gt;ip_dst, udp-&gt;dest, udp-&gt;source);
</span><span class='line'>&#9;int T = 1;
</span><span class='line'>&#9;while(1) {
</span><span class='line'>&#9;&#9;if (T == 0) break;
</span><span class='line'>&#9;&#9;T--;
</span><span class='line'>&#9;&#9;//printf("%d\n", T);
</span><span class='line'>&#9;&#9;//udp-&gt;seq = random();
</span><span class='line'>&#9;        //源地址伪造，我们随便任意生成个地址，让服务器一直等待下去
</span><span class='line'>&#9;        //ip-&gt;ip_src.s_addr = random();
</span><span class='line'>&#9;&#9;//自定义源地址192.168.204.136 = 0xc0a8cc88; 反转赋值
</span><span class='line'>&#9;        ip-&gt;ip_src.s_addr = 0xf86da8c0;
</span><span class='line'>&#9;&#9;unsigned sum = csum_tcpudp_nofold(ip-&gt;ip_src.s_addr, ip-&gt;ip_dst.s_addr, sizeof(struct udphdr)+data_len, IPPROTO_UDP, 0);
</span><span class='line'>&#9;        udp-&gt;check = check_sum((unsigned short*)udp, sizeof(struct udphdr)+data_len, sum);
</span><span class='line'>&#9;&#9;ip-&gt;ip_sum = check_sum((unsigned short*)ip, sizeof(struct ip), 0);
</span><span class='line'>&#9;&#9;printf("s1 s2 %lx %lx\n", udp-&gt;check, ip-&gt;ip_sum);
</span><span class='line'>&#9;        sendto(skfd, buf, ip_len, 0, (struct sockaddr*)target, sizeof(struct sockaddr_in));
</span><span class='line'>&#9;}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(int argc, char** argv)
</span><span class='line'>{
</span><span class='line'>&#9;int skfd;
</span><span class='line'>&#9;struct sockaddr_in target;
</span><span class='line'>&#9;struct hostent *host;
</span><span class='line'>&#9;const int on = 1;
</span><span class='line'>&#9;unsigned short srcport;
</span><span class='line'>
</span><span class='line'>&#9;if (argc != 4) {
</span><span class='line'>&#9;        printf("Usage:%s target dstport srcport\n", argv[0]);
</span><span class='line'>&#9;        exit(1);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;bzero(&target, sizeof(struct sockaddr_in));
</span><span class='line'>&#9;target.sin_family = AF_INET;
</span><span class='line'>&#9;target.sin_port = htons(atoi(argv[2]));
</span><span class='line'>
</span><span class='line'>&#9;if (inet_aton(argv[1], &target.sin_addr) == 0) {
</span><span class='line'>&#9;        host = gethostbyname(argv[1]);
</span><span class='line'>&#9;        if(host == NULL) {
</span><span class='line'>&#9;                printf("TargetName Error:%s\n", hstrerror(h_errno));
</span><span class='line'>&#9;                exit(1);
</span><span class='line'>&#9;        }
</span><span class='line'>&#9;        target.sin_addr = *(struct in_addr *)(host-&gt;h_addr_list[0]);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//将协议字段置为IPPROTO_UDP，来创建一个UDP的原始套接字
</span><span class='line'>&#9;if (0 &gt; (skfd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP))) {
</span><span class='line'>&#9;        perror("Create Error");
</span><span class='line'>&#9;        exit(1);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//用模板代码来开启IP_HDRINCL特性，我们完全自己手动构造IP报文
</span><span class='line'>&#9;if (0 &gt; setsockopt(skfd, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on))) {
</span><span class='line'>&#9;        perror("IP_HDRINCL failed");
</span><span class='line'>&#9;        exit(1);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//因为只有root用户才可以play with raw socket :)
</span><span class='line'>&#9;setuid(getpid());
</span><span class='line'>&#9;srcport = atoi(argv[3]);
</span><span class='line'>&#9;attack(skfd, &target, srcport);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kernel 3.10内核源码分析--Out of Memory(OOM)处理流程]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/09/30/kernel-mm-oom/"/>
    <updated>2015-09-30T15:56:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/09/30/kernel-mm-oom</id>
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-20671208-id-4440249.html">http://blog.chinaunix.net/uid-20671208-id-4440249.html</a></p>

<p>Out Of Memory(OOM)，即内存耗尽，当系统中内存耗尽时，如果不做处理，将处于崩溃的边缘，因为无内核资源可用，而系统运行时刻都可能需要申请内存。这时，内核需要采取一定的措施来防止系统崩溃，这就是我们熟知的OOM流程，其实就是要回收一些内存，而走到OOM流程，已经基本说明其它的回收内存的手段都已经尝试过了(比如回收cache)，这里通常只能通过kill进程来回收内存了，而选择被kill进程的标准就比较简单直接了，总体就是：谁用的多，就kill谁。</p>

<p>OOM处理的基本流程简单描述如下：</p>

<p>1、检查是否配置了/proc/sys/kernel/panic_on_oom，如果是则直接触发panic。</p>

<p>2、检查是否配置了oom_kill_allocating_task，即是否需要kill current进程来回收内存，如果是，且current进程是killable的，则kill current进程。</p>

<p>3、根据既定策略选择需要kill的process，基本策略为：通过进程的内存占用情况计算“点数”，点数最高者被选中。</p>

<p>4、如果没有选出来可kill的进程，那么直接panic(通常不会走到这个流程，但也有例外，比如，当被选中的进程处于D状态，或者正在被kill)</p>

<p>5、kill掉被选中的进程，以释放内存。</p>

<p>代码注释如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'>  * OOM处理的主流程，上面的注释应该比较清楚了。
</span><span class='line'>  */
</span><span class='line'>void out_of_memory(struct zonelist *zonelist, gfp_t gfp_mask,
</span><span class='line'>&#9;&#9;int order, nodemask_t *nodemask, bool force_kill)
</span><span class='line'>{
</span><span class='line'>&#9;const nodemask_t *mpol_mask;
</span><span class='line'>&#9;struct task_struct *p;
</span><span class='line'>&#9;unsigned long totalpages;
</span><span class='line'>&#9;unsigned long freed = 0;
</span><span class='line'>&#9;unsigned int uninitialized_var(points);
</span><span class='line'>&#9;enum oom_constraint constraint = CONSTRAINT_NONE;
</span><span class='line'>&#9;int killed = 0;
</span><span class='line'>
</span><span class='line'>&#9;// 调用block通知链oom_nofify_list中的函数
</span><span class='line'>&#9;blocking_notifier_call_chain(&oom_notify_list, 0, &freed);
</span><span class='line'>
</span><span class='line'>&#9;if (freed &gt; 0)
</span><span class='line'>&#9;&#9;/* Got some memory back in the last second. */
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * If current has a pending SIGKILL or is exiting, then automatically
</span><span class='line'>&#9; * select it. The goal is to allow it to allocate so that it may
</span><span class='line'>&#9; * quickly exit and free its memory.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 如果当前进程有pending的SIGKILL(9)信号，或者正在退出，则选择当前进程来kill,
</span><span class='line'>&#9; * 这样可以最快的达到释放内存的目的。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (fatal_signal_pending(current) || current-&gt;flags & PF_EXITING) {
</span><span class='line'>&#9;&#9;set_thread_flag(TIF_MEMDIE);
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Check if there were limitations on the allocation (only relevant for
</span><span class='line'>&#9; * NUMA) that may require different handling.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 检查是否有限制，有几种不同的限制策略，仅用于NUMA场景
</span><span class='line'>&#9; */
</span><span class='line'>&#9;constraint = constrained_alloc(zonelist, gfp_mask, nodemask,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&totalpages);
</span><span class='line'>&#9;mpol_mask = (constraint == CONSTRAINT_MEMORY_POLICY) ? nodemask : NULL;
</span><span class='line'>&#9;// 检查是否配置了/proc/sys/kernel/panic_on_oom，如果是则直接触发panic
</span><span class='line'>&#9;check_panic_on_oom(constraint, gfp_mask, order, mpol_mask);
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 检查是否配置了oom_kill_allocating_task，即是否需要kill current进程来
</span><span class='line'>&#9; * 回收内存，如果是，且current进程是killable的，则kill current进程。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (sysctl_oom_kill_allocating_task && current-&gt;mm &&
</span><span class='line'>&#9; !oom_unkillable_task(current, NULL, nodemask) &&
</span><span class='line'>&#9; current-&gt;signal-&gt;oom_score_adj != OOM_SCORE_ADJ_MIN) {
</span><span class='line'>&#9;&#9;get_task_struct(current);
</span><span class='line'>&#9;&#9;// kill被选中的进程。
</span><span class='line'>&#9;&#9;oom_kill_process(current, gfp_mask, order, 0, totalpages, NULL,
</span><span class='line'>&#9;&#9;&#9;&#9; nodemask,
</span><span class='line'>&#9;&#9;&#9;&#9; "Out of memory (oom_kill_allocating_task)");
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;// 根据既定策略选择需要kill的process。
</span><span class='line'>&#9;p = select_bad_process(&points, totalpages, mpol_mask, force_kill);
</span><span class='line'>&#9;/* Found nothing?!?! Either we hang forever, or we panic. */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 如果没有选出来，即没有可kill的进程，那么直接panic
</span><span class='line'>&#9; * 通常不会走到这个流程，但也有例外，比如，当被选中的进程处于D状态，或者正在被kill
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (!p) {
</span><span class='line'>&#9;&#9;dump_header(NULL, gfp_mask, order, NULL, mpol_mask);
</span><span class='line'>&#9;&#9;panic("Out of memory and no killable processes...\n");
</span><span class='line'>&#9;}
</span><span class='line'>&#9;// kill掉被选中的进程，以释放内存。
</span><span class='line'>&#9;if (PTR_ERR(p) != -1UL) {
</span><span class='line'>&#9;&#9;oom_kill_process(p, gfp_mask, order, points, totalpages, NULL,
</span><span class='line'>&#9;&#9;&#9;&#9; nodemask, "Out of memory");
</span><span class='line'>&#9;&#9;killed = 1;
</span><span class='line'>&#9;}
</span><span class='line'>out:
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Give the killed threads a good chance of exiting before trying to
</span><span class='line'>&#9; * allocate memory again.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 在重新分配内存之前，给被kill的进程1s的时间完成exit相关处理，通常情况
</span><span class='line'>&#9; * 下，1s应该够了。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (killed)
</span><span class='line'>&#9;&#9;schedule_timeout_killable(1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>out_of_memory->select_bad_process</p>

<p>通过select_bad_process函数选择被kill的进程，其基本流程为：</p>

<p>1、遍历系统中的所有进程，进行"点数"计算</p>

<p>2、进行一些特殊情况的处理，比如: 优先选择触发OOM的进程、不处理正在exit的进程等。</p>

<p>3、计算"点数"，选择点数最大的进程。通过函数oom_badness()</p>

<p>代码注释和分析如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'>  * OOM流程中，用来选择被kill的进程的函数
</span><span class='line'>  * @ppoints:点数，用来计算每个进程被"选中"可能性，点数越高，越可能被"选中"
</span><span class='line'>  */
</span><span class='line'>static struct task_struct *select_bad_process(unsigned int *ppoints,
</span><span class='line'>&#9;&#9;unsigned long totalpages, const nodemask_t *nodemask,
</span><span class='line'>&#9;&#9;bool force_kill)
</span><span class='line'>{
</span><span class='line'>&#9;struct task_struct *g, *p;
</span><span class='line'>&#9;struct task_struct *chosen = NULL;
</span><span class='line'>&#9;unsigned long chosen_points = 0;
</span><span class='line'>
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;// 遍历系统中的所有进程，进行"点数"计算
</span><span class='line'>&#9;do_each_thread(g, p) {
</span><span class='line'>&#9;&#9;unsigned int points;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * 进行一些特殊情况的处理，比如: 优先选择触发OOM的进程、不处理
</span><span class='line'>&#9;&#9; * 正在exit的进程等。
</span><span class='line'>&#9;&#9; */        
</span><span class='line'>&#9;&#9;switch (oom_scan_process_thread(p, totalpages, nodemask,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;force_kill)) {
</span><span class='line'>&#9;&#9;case OOM_SCAN_SELECT:
</span><span class='line'>&#9;&#9;&#9;chosen = p;
</span><span class='line'>&#9;&#9;&#9;chosen_points = ULONG_MAX;
</span><span class='line'>&#9;&#9;&#9;/* fall through */
</span><span class='line'>&#9;&#9;case OOM_SCAN_CONTINUE:
</span><span class='line'>&#9;&#9;&#9;continue;
</span><span class='line'>&#9;&#9;case OOM_SCAN_ABORT:
</span><span class='line'>&#9;&#9;&#9;rcu_read_unlock();
</span><span class='line'>&#9;&#9;&#9;return ERR_PTR(-1UL);
</span><span class='line'>&#9;&#9;case OOM_SCAN_OK:
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;};
</span><span class='line'>&#9;&#9;// 计算"点数"，选择点数最大的进程。
</span><span class='line'>&#9;&#9;points = oom_badness(p, NULL, nodemask, totalpages);
</span><span class='line'>&#9;&#9;if (points &gt; chosen_points) {
</span><span class='line'>&#9;&#9;&#9;chosen = p;
</span><span class='line'>&#9;&#9;&#9;chosen_points = points;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;} while_each_thread(g, p);
</span><span class='line'>&#9;if (chosen)
</span><span class='line'>&#9;&#9;get_task_struct(chosen);
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>
</span><span class='line'>&#9;*ppoints = chosen_points * 1000 / totalpages;
</span><span class='line'>&#9;return chosen;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>out_of_memory->select_bad_process->oom_scan_process_thread</p>

<p>oom_scan_process_thread函数的分析和注释如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum oom_scan_t oom_scan_process_thread(struct task_struct *task,
</span><span class='line'>&#9;&#9;unsigned long totalpages, const nodemask_t *nodemask,
</span><span class='line'>&#9;&#9;bool force_kill)
</span><span class='line'>{
</span><span class='line'>&#9;// 如果进程正在exit
</span><span class='line'>&#9;if (task-&gt;exit_state)
</span><span class='line'>&#9;&#9;return OOM_SCAN_CONTINUE;
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 如果进程不能被kill，比如: init进程或进程在nodemask对应的节点上，
</span><span class='line'>&#9; * 没有可以释放的内存。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (oom_unkillable_task(task, NULL, nodemask))
</span><span class='line'>&#9;&#9;return OOM_SCAN_CONTINUE;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * This task already has access to memory reserves and is being killed.
</span><span class='line'>&#9; * Don't allow any other task to have access to the reserves.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 如果有进程正在被OOM流程kill，那么应该有内存可以释放了，就不需要再kill
</span><span class='line'>&#9; * 其它进程了，此时返回abort，结束oom kill流程。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (test_tsk_thread_flag(task, TIF_MEMDIE)) {
</span><span class='line'>&#9;&#9;if (unlikely(frozen(task)))
</span><span class='line'>&#9;&#9;&#9;__thaw_task(task);
</span><span class='line'>&#9;&#9;if (!force_kill)
</span><span class='line'>&#9;&#9;&#9;return OOM_SCAN_ABORT;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;// 如果不存在mm了(可能进程刚退出了)
</span><span class='line'>&#9;if (!task-&gt;mm)
</span><span class='line'>&#9;&#9;return OOM_SCAN_CONTINUE;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * If task is allocating a lot of memory and has been marked to be
</span><span class='line'>&#9; * killed first if it triggers an oom, then select it.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;// 优先选择触发OOM的进程。
</span><span class='line'>&#9;if (oom_task_origin(task))
</span><span class='line'>&#9;&#9;return OOM_SCAN_SELECT;
</span><span class='line'>
</span><span class='line'>&#9;if (task-&gt;flags & PF_EXITING && !force_kill) {
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * If this task is not being ptraced on exit, then wait for it
</span><span class='line'>&#9;&#9; * to finish before killing some other task unnecessarily.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (!(task-&gt;group_leader-&gt;ptrace & PT_TRACE_EXIT))
</span><span class='line'>&#9;&#9;&#9;return OOM_SCAN_ABORT;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return OOM_SCAN_OK;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>out_of_memory->select_bad_process->oom_badness</p>

<p>oom_badness用于计算进程的“点数”，点数最高者被选中，代码注释和分析如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * 计算进程"点数"(代表进程被选中的可能性)的函数，点数根据进程占用的物理内存来计算
</span><span class='line'> * 物理内存占用越多，被选中的可能性越大。root processes有3%的bonus。
</span><span class='line'> */
</span><span class='line'>unsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,
</span><span class='line'>&#9;&#9;&#9; const nodemask_t *nodemask, unsigned long totalpages)
</span><span class='line'>{
</span><span class='line'>&#9;long points;
</span><span class='line'>&#9;long adj;
</span><span class='line'>
</span><span class='line'>&#9;if (oom_unkillable_task(p, memcg, nodemask))
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;// 确认进程是否还存在
</span><span class='line'>&#9;p = find_lock_task_mm(p);
</span><span class='line'>&#9;if (!p)
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>
</span><span class='line'>&#9;adj = (long)p-&gt;signal-&gt;oom_score_adj;
</span><span class='line'>&#9;if (adj == OOM_SCORE_ADJ_MIN) {
</span><span class='line'>&#9;&#9;task_unlock(p);
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * The baseline for the badness score is the proportion of RAM that each
</span><span class='line'>&#9; * task's rss, pagetable and swap space use.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;// 点数=rss(驻留内存/占用物理内存)+pte数+交换分区用量
</span><span class='line'>&#9;points = get_mm_rss(p-&gt;mm) + p-&gt;mm-&gt;nr_ptes +
</span><span class='line'>&#9;&#9; get_mm_counter(p-&gt;mm, MM_SWAPENTS);
</span><span class='line'>&#9;task_unlock(p);
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Root processes get 3% bonus, just like the __vm_enough_memory()
</span><span class='line'>&#9; * implementation used by LSMs.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * root用户启动的进程，有总 内存*3% 的bonus，就是说可以使用比其它进程多3%的内存
</span><span class='line'>&#9; * 3%=30/1000
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (has_capability_noaudit(p, CAP_SYS_ADMIN))
</span><span class='line'>&#9;&#9;adj -= 30;
</span><span class='line'>
</span><span class='line'>&#9;/* Normalize to oom_score_adj units */
</span><span class='line'>&#9;// 归一化"点数"单位
</span><span class='line'>&#9;adj *= totalpages / 1000;
</span><span class='line'>&#9;points += adj;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Never return 0 for an eligible task regardless of the root bonus and
</span><span class='line'>&#9; * oom_score_adj (oom_score_adj can't be OOM_SCORE_ADJ_MIN here).
</span><span class='line'>&#9; */
</span><span class='line'>&#9;return points &gt; 0 ? points : 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>out_of_memory->oom_kill_process</p>

<p>oom_kill_process()函数用于：kill被选中的进程，其实就是给指定进程发送SIGKILL信号，待被选中进程返回用户态时，进行信号处理。</p>

<p>相关代码注释和分析如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'>  * kill被选中的进程，在OOM流程中被调用
</span><span class='line'>  */
</span><span class='line'>void oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
</span><span class='line'>&#9;&#9; unsigned int points, unsigned long totalpages,
</span><span class='line'>&#9;&#9; struct mem_cgroup *memcg, nodemask_t *nodemask,
</span><span class='line'>&#9;&#9; const char *message)
</span><span class='line'>{
</span><span class='line'>&#9;struct task_struct *victim = p;
</span><span class='line'>&#9;struct task_struct *child;
</span><span class='line'>&#9;struct task_struct *t = p;
</span><span class='line'>&#9;struct mm_struct *mm;
</span><span class='line'>&#9;unsigned int victim_points = 0;
</span><span class='line'>&#9;static DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; DEFAULT_RATELIMIT_BURST);
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * If the task is already exiting, don't alarm the sysadmin or kill
</span><span class='line'>&#9; * its children or threads, just set TIF_MEMDIE so it can die quickly
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 如果进程正在exiting，就没有必要再kill它了，直接设置TIF_MEMDIE，然后返回。
</span><span class='line'>&#9;*/
</span><span class='line'>&#9;if (p-&gt;flags & PF_EXITING) {
</span><span class='line'>&#9;&#9;set_tsk_thread_flag(p, TIF_MEMDIE);
</span><span class='line'>&#9;&#9;put_task_struct(p);
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (__ratelimit(&oom_rs))
</span><span class='line'>&#9;&#9;dump_header(p, gfp_mask, order, memcg, nodemask);
</span><span class='line'>
</span><span class='line'>&#9;task_lock(p);
</span><span class='line'>&#9;pr_err("%s: Kill process %d (%s) score %d or sacrifice child\n",
</span><span class='line'>&#9;&#9;message, task_pid_nr(p), p-&gt;comm, points);
</span><span class='line'>&#9;task_unlock(p);
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * If any of p's children has a different mm and is eligible for kill,
</span><span class='line'>&#9; * the one with the highest oom_badness() score is sacrificed for its
</span><span class='line'>&#9; * parent. This attempts to lose the minimal amount of work done while
</span><span class='line'>&#9; * still freeing memory.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 如果被选中的进程的子进程，不跟其共享mm(通常是这样)，且膐om_badness的
</span><span class='line'>&#9; * 得分更高，那么重新选择该子进程为被kill的进程。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;read_lock(&tasklist_lock);
</span><span class='line'>&#9;do {
</span><span class='line'>&#9;&#9;// 遍历被选中进程的所有子进程
</span><span class='line'>&#9;&#9;list_for_each_entry(child, &t-&gt;children, sibling) {
</span><span class='line'>&#9;&#9;&#9;unsigned int child_points;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;// 如果不共享mm
</span><span class='line'>&#9;&#9;&#9;if (child-&gt;mm == p-&gt;mm)
</span><span class='line'>&#9;&#9;&#9;&#9;continue;
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * oom_badness() returns 0 if the thread is unkillable
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;// 计算child?om_badness得分
</span><span class='line'>&#9;&#9;&#9;child_points = oom_badness(child, memcg, nodemask,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;totalpages);
</span><span class='line'>&#9;&#9;&#9;// 如果child得分更高，则将被选中进程换成child
</span><span class='line'>&#9;&#9;&#9;if (child_points &gt; victim_points) {
</span><span class='line'>&#9;&#9;&#9;&#9;put_task_struct(victim);
</span><span class='line'>&#9;&#9;&#9;&#9;victim = child;
</span><span class='line'>&#9;&#9;&#9;&#9;victim_points = child_points;
</span><span class='line'>&#9;&#9;&#9;&#9;get_task_struct(victim);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;} while_each_thread(p, t);
</span><span class='line'>&#9;read_unlock(&tasklist_lock);
</span><span class='line'>
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 遍历确认被选中进程的线程组，判断是否还存在task_struct-&gt;mm，如果不存在
</span><span class='line'>&#9; * (有可能这个时候进程退出了，或释放了mm),就没必要再kill了。
</span><span class='line'>&#9; * 如果存在则选择线程组中的进程。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;p = find_lock_task_mm(victim);
</span><span class='line'>&#9;if (!p) {
</span><span class='line'>&#9;&#9;rcu_read_unlock();
</span><span class='line'>&#9;&#9;put_task_struct(victim);
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;// 如果新选择的进程跟之前的不是同一个，那么更新victim。
</span><span class='line'>&#9;} else if (victim != p) {
</span><span class='line'>&#9;&#9;get_task_struct(p);
</span><span class='line'>&#9;&#9;put_task_struct(victim);
</span><span class='line'>&#9;&#9;victim = p;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/* mm cannot safely be dereferenced after task_unlock(victim) */
</span><span class='line'>&#9;mm = victim-&gt;mm;
</span><span class='line'>&#9;pr_err("Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB\n",
</span><span class='line'>&#9;&#9;task_pid_nr(victim), victim-&gt;comm, K(victim-&gt;mm-&gt;total_vm),
</span><span class='line'>&#9;&#9;K(get_mm_counter(victim-&gt;mm, MM_ANONPAGES)),
</span><span class='line'>&#9;&#9;K(get_mm_counter(victim-&gt;mm, MM_FILEPAGES)));
</span><span class='line'>&#9;task_unlock(victim);
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Kill all user processes sharing victim-&gt;mm in other thread groups, if
</span><span class='line'>&#9; * any. They don't get access to memory reserves, though, to avoid
</span><span class='line'>&#9; * depletion of all memory. This prevents mm-&gt;mmap_sem livelock when an
</span><span class='line'>&#9; * oom killed thread cannot exit because it requires the semaphore and
</span><span class='line'>&#9; * its contended by another thread trying to allocate memory itself.
</span><span class='line'>&#9; * That thread will now get access to memory reserves since it has a
</span><span class='line'>&#9; * pending fatal signal.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 遍历系统中的所有进程，寻找在其它线程组中，跟被选中进程(victim)共享mm结构
</span><span class='line'>&#9; * 的进程(内核线程除外)，共享mm结构即共享进程地址空间，比如fork后exec之前，
</span><span class='line'>&#9; * 父子进程是共享mm的，回收内存必须要将共享mm的所有进程都kill掉。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;for_each_process(p)
</span><span class='line'>&#9;&#9;if (p-&gt;mm == mm && !same_thread_group(p, victim) &&
</span><span class='line'>&#9;&#9; !(p-&gt;flags & PF_KTHREAD)) {
</span><span class='line'>&#9;&#9;&#9;if (p-&gt;signal-&gt;oom_score_adj == OOM_SCORE_ADJ_MIN)
</span><span class='line'>&#9;&#9;&#9;&#9;continue;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;// 进行task_struct相关操作时，通常需要获取该锁。
</span><span class='line'>&#9;&#9;&#9;task_lock(p);    /* Protect -&gt;comm from prctl() */
</span><span class='line'>&#9;&#9;&#9;pr_err("Kill process %d (%s) sharing same memory\n",
</span><span class='line'>&#9;&#9;&#9;&#9;task_pid_nr(p), p-&gt;comm);
</span><span class='line'>&#9;&#9;&#9;task_unlock(p);
</span><span class='line'>&#9;&#9;&#9;// 通过向被选中的进程发送kill信号，来kill进程。
</span><span class='line'>&#9;&#9;&#9;do_send_sig_info(SIGKILL, SEND_SIG_FORCED, p, true);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>
</span><span class='line'>&#9;// 进程设置TIF_MEMDIE标记，表示进程正在被oom killer终止中。
</span><span class='line'>&#9;set_tsk_thread_flag(victim, TIF_MEMDIE);
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 最终通过向被选中的进程发送kill信号，来kill进程，被kill的进程在从内核态
</span><span class='line'>&#9; * 返回用户态时，进行信号处理。
</span><span class='line'>&#9; * 被选中的进程可以是自己(current)，则current进程会在oom流程执行完成后，返回
</span><span class='line'>&#9; * 用户态时，处理信号。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;do_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);
</span><span class='line'>&#9;put_task_struct(victim);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kernel 3.10内核源码分析--内核页表创建]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/09/30/kernel-mm-init/"/>
    <updated>2015-09-30T15:53:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/09/30/kernel-mm-init</id>
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-20671208-id-4440253.html">http://blog.chinaunix.net/uid-20671208-id-4440253.html</a></p>

<p>内核页表创建基本流程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>start_kernel
</span><span class='line'>&#9;setup_arch
</span><span class='line'>&#9;&#9;init_mem_mapping
</span><span class='line'>&#9;&#9;&#9;init_range_memory_mapping
</span><span class='line'>&#9;&#9;&#9;&#9;init_memory_mapping
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;kernel_physical_mapping_init  </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'>  * 创建内核页表，将内核页表中能线性映射的部分(0-896M，还要刨去ISA等区域)
</span><span class='line'>  * 进行映射，创建相应的页表项，在内核初始化的时候(setup_arch())完成。
</span><span class='line'>  */
</span><span class='line'>unsigned long __init
</span><span class='line'>kernel_physical_mapping_init(unsigned long start,
</span><span class='line'>&#9;&#9;&#9; unsigned long end,
</span><span class='line'>&#9;&#9;&#9; unsigned long page_size_mask)
</span><span class='line'>{
</span><span class='line'>&#9;int use_pse = page_size_mask == (1&lt;&lt;PG_LEVEL_2M);
</span><span class='line'>&#9;unsigned long last_map_addr = end;
</span><span class='line'>&#9;unsigned long start_pfn, end_pfn;
</span><span class='line'>&#9; /*内核页表页目录所在的位置，其所占的内存是在head_32.S中预先分配好的*/
</span><span class='line'>&#9;pgd_t *pgd_base = swapper_pg_dir;
</span><span class='line'>&#9;int pgd_idx, pmd_idx, pte_ofs;
</span><span class='line'>&#9;unsigned long pfn;
</span><span class='line'>&#9;pgd_t *pgd;
</span><span class='line'>&#9;pmd_t *pmd;
</span><span class='line'>&#9;pte_t *pte;
</span><span class='line'>&#9;unsigned pages_2m, pages_4k;
</span><span class='line'>&#9;int mapping_iter;
</span><span class='line'>&#9;/*计算欲映射区域的起始和结束pfn*/
</span><span class='line'>&#9;start_pfn = start &gt;&gt; PAGE_SHIFT;
</span><span class='line'>&#9;end_pfn = end &gt;&gt; PAGE_SHIFT;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * First iteration will setup identity mapping using large/small pages
</span><span class='line'>&#9; * based on use_pse, with other attributes same as set by
</span><span class='line'>&#9; * the early code in head_32.S
</span><span class='line'>&#9; *
</span><span class='line'>&#9; * Second iteration will setup the appropriate attributes (NX, GLOBAL..)
</span><span class='line'>&#9; * as desired for the kernel identity mapping.
</span><span class='line'>&#9; *
</span><span class='line'>&#9; * This two pass mechanism conforms to the TLB app note which says:
</span><span class='line'>&#9; *
</span><span class='line'>&#9; * "Software should not write to a paging-structure entry in a way
</span><span class='line'>&#9; * that would change, for any linear address, both the page size
</span><span class='line'>&#9; * and either the page frame or attributes."
</span><span class='line'>&#9; */
</span><span class='line'>&#9;mapping_iter = 1;
</span><span class='line'>
</span><span class='line'>&#9;if (!cpu_has_pse)
</span><span class='line'>&#9;&#9;use_pse = 0;
</span><span class='line'>
</span><span class='line'>repeat:
</span><span class='line'>&#9;pages_2m = pages_4k = 0;
</span><span class='line'>&#9;pfn = start_pfn;
</span><span class='line'>&#9;pgd_idx = pgd_index((pfn&lt;&lt;PAGE_SHIFT) + PAGE_OFFSET);
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * pgd、pmd等存放的是本级页表中对应index项的虚拟地址，页表项的内容中存放的是
</span><span class='line'>&#9; * 下一级页表的起始物理地址
</span><span class='line'>&#9; */
</span><span class='line'>&#9;pgd = pgd_base + pgd_idx;
</span><span class='line'>&#9;for (; pgd_idx &lt; PTRS_PER_PGD; pgd++, pgd_idx++) {
</span><span class='line'>&#9;&#9;//创建pmd，如果没有pmd，则返回pgd。实际通过get_free_page接口分配，此时buddy系统已经可用?
</span><span class='line'>&#9;&#9;pmd = one_md_table_init(pgd);
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (pfn &gt;= end_pfn)
</span><span class='line'>&#9;&#9;&#9;continue;
</span><span class='line'>#ifdef CONFIG_X86_PAE
</span><span class='line'>&#9;&#9;pmd_idx = pmd_index((pfn&lt;&lt;PAGE_SHIFT) + PAGE_OFFSET);
</span><span class='line'>&#9;&#9;pmd += pmd_idx;
</span><span class='line'>#else
</span><span class='line'>&#9;&#9;pmd_idx = 0;
</span><span class='line'>#endif
</span><span class='line'>&#9;&#9;for (; pmd_idx &lt; PTRS_PER_PMD && pfn &lt; end_pfn;
</span><span class='line'>&#9;&#9; pmd++, pmd_idx++) {
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * 页框虚拟地址，就是物理地址(pfn * PAGE_SIZE)+固定偏移
</span><span class='line'>&#9;&#9;&#9; * 这就是线性映射的实质。
</span><span class='line'>&#9;&#9;&#9;*/
</span><span class='line'>&#9;&#9;&#9;unsigned int addr = pfn * PAGE_SIZE + PAGE_OFFSET;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * Map with big pages if possible, otherwise
</span><span class='line'>&#9;&#9;&#9; * create normal page tables:
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;if (use_pse) {
</span><span class='line'>&#9;&#9;&#9;&#9;unsigned int addr2;
</span><span class='line'>&#9;&#9;&#9;&#9;pgprot_t prot = PAGE_KERNEL_LARGE;
</span><span class='line'>&#9;&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9;&#9; * first pass will use the same initial
</span><span class='line'>&#9;&#9;&#9;&#9; * identity mapping attribute + _PAGE_PSE.
</span><span class='line'>&#9;&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;&#9;pgprot_t init_prot =
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;__pgprot(PTE_IDENT_ATTR |
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;_PAGE_PSE);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;pfn &= PMD_MASK &gt;&gt; PAGE_SHIFT;
</span><span class='line'>&#9;&#9;&#9;&#9;addr2 = (pfn + PTRS_PER_PTE-1) * PAGE_SIZE +
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;PAGE_OFFSET + PAGE_SIZE-1;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (is_kernel_text(addr) ||
</span><span class='line'>&#9;&#9;&#9;&#9; is_kernel_text(addr2))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;prot = PAGE_KERNEL_LARGE_EXEC;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;pages_2m++;
</span><span class='line'>&#9;&#9;&#9;&#9;if (mapping_iter == 1)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;set_pmd(pmd, pfn_pmd(pfn, init_prot));
</span><span class='line'>&#9;&#9;&#9;&#9;else
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;set_pmd(pmd, pfn_pmd(pfn, prot));
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;pfn += PTRS_PER_PTE;
</span><span class='line'>&#9;&#9;&#9;&#9;continue;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;// 创建页表
</span><span class='line'>&#9;&#9;&#9;pte = one_page_table_init(pmd);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;pte_ofs = pte_index((pfn&lt;&lt;PAGE_SHIFT) + PAGE_OFFSET);
</span><span class='line'>&#9;&#9;&#9;pte += pte_ofs;
</span><span class='line'>&#9;&#9;&#9;// 填写每项页表的内容。
</span><span class='line'>&#9;&#9;&#9;for (; pte_ofs &lt; PTRS_PER_PTE && pfn &lt; end_pfn;
</span><span class='line'>&#9;&#9;&#9; pte++, pfn++, pte_ofs++, addr += PAGE_SIZE) {
</span><span class='line'>&#9;&#9;&#9;&#9;pgprot_t prot = PAGE_KERNEL;
</span><span class='line'>&#9;&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9;&#9; * first pass will use the same initial
</span><span class='line'>&#9;&#9;&#9;&#9; * identity mapping attribute.
</span><span class='line'>&#9;&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;&#9;pgprot_t init_prot = __pgprot(PTE_IDENT_ATTR);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (is_kernel_text(addr))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;prot = PAGE_KERNEL_EXEC;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;pages_4k++;
</span><span class='line'>&#9;&#9;&#9;&#9;if (mapping_iter == 1) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;// 将pfn(页框号)和相关属性转换为物理地址，然后写入pte中
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;set_pte(pte, pfn_pte(pfn, init_prot));
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;last_map_addr = (pfn &lt;&lt; PAGE_SHIFT) + PAGE_SIZE;
</span><span class='line'>&#9;&#9;&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;set_pte(pte, pfn_pte(pfn, prot));
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (mapping_iter == 1) {
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * update direct mapping page count only in the first
</span><span class='line'>&#9;&#9; * iteration.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;update_page_count(PG_LEVEL_2M, pages_2m);
</span><span class='line'>&#9;&#9;update_page_count(PG_LEVEL_4K, pages_4k);
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * local global flush tlb, which will flush the previous
</span><span class='line'>&#9;&#9; * mappings present in both small and large page TLB's.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;__flush_tlb_all();
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * Second iteration will set the actual desired PTE attributes.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;mapping_iter = 2;
</span><span class='line'>&#9;&#9;goto repeat;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return last_map_addr;</span></code></pre></td></tr></table></div></figure>


<p>swapper_pg_dir为内核页表页目录所在的位置，其所占的内存是在head_32.S中预先分配好的，从下面的汇编代码看，预先分配了1024*4=4k的空间，可以容纳1024个entry。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ENTRY(swapper_pg_dir)
</span><span class='line'>&#9;.fill 1024,4,0</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP的定时器系列 — 保活定时器]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/09/30/kernel-net-keepalive/"/>
    <updated>2015-09-30T15:32:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/09/30/kernel-net-keepalive</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/44177475">http://blog.csdn.net/zhangskd/article/details/44177475</a></p>

<p>主要内容：保活定时器的实现，TCP_USER_TIMEOUT选项的实现。<br/>
内核版本：3.15.2</p>

<h4>原理</h4>

<p>HTTP有Keepalive功能，TCP也有Keepalive功能，虽然都叫Keepalive，但是它们的目的却是不一样的。为了说明这一点，先来看下长连接和短连接的定义。</p>

<p>连接的“长短”是什么？<br/>
短连接：建立一条连接，传输一个请求，马上关闭连接。<br/>
长连接：建立一条连接，传输一个请求，过会儿，又传输若干个请求，最后再关闭连接。</p>

<p>长连接的好处是显而易见的，多个请求可以复用一条连接，省去连接建立和释放的时间开销和系统调用，但也意味着服务器的一部分资源会被长时间占用着。</p>

<p>HTTP的Keepalive，顾名思义，目的在于延长连接的时间，以便在同一条连接中传输多个HTTP请求。</p>

<p>HTTP服务器一般会提供Keepalive Timeout参数，用来决定连接保持多久，什么时候关闭连接。</p>

<p>当连接使用了Keepalive功能时，对于客户端发送过来的一个请求，服务器端会发送一个响应，然后开始计时，如果经过Timeout时间后，客户端没有再发送请求过来，服务器端就把连接关了，不再保持连接了。</p>

<p>TCP的Keepalive，是挂羊头卖狗肉的，目的在于看看对方有没有发生异常，如果有异常就及时关闭连接。</p>

<p>当传输双方不主动关闭连接时，就算双方没有交换任何数据，连接也是一直有效的。</p>

<p>如果这个时候对端、中间网络出现异常而导致连接不可用，本端如何得知这一信息呢？</p>

<p>答案就是保活定时器。它每隔一段时间会超时，超时后会检查连接是否空闲太久了，如果空闲的时间超过了设置时间，就会发送探测报文。然后通过对端是否响应、响应是否符合预期，来判断对端是否正常，如果不正常，就主动关闭连接，而不用等待HTTP层的关闭了。</p>

<p>当服务器发送探测报文时，客户端可能处于4种不同的情况：仍然正常运行、已经崩溃、已经崩溃并重启了、由于中间链路问题不可达。在不同的情况下，服务器会得到不一样的反馈。</p>

<p>(1) 客户主机依然正常运行，并且从服务器端可达</p>

<p>客户端的TCP响应正常，从而服务器端知道对方是正常的。保活定时器会在两小时以后继续触发。</p>

<p>(2) 客户主机已经崩溃，并且关闭或者正在重新启动</p>

<p>客户端的TCP没有响应，服务器没有收到对探测包的响应，此后每隔75s发送探测报文，一共发送9次。</p>

<p>socket函数会返回-1，errno设置为ETIMEDOUT，表示连接超时。</p>

<p>(3) 客户主机已经崩溃，并且重新启动了</p>

<p>客户端的TCP发送RST，服务器端收到后关闭此连接。</p>

<p>socket函数会返回-1，errno设置为ECONNRESET，表示连接被对端复位了。</p>

<p>(4) 客户主机依然正常运行，但是从服务器不可达</p>

<p>双方的反应和第二种是一样的，因为服务器不能区分对端异常与中间链路异常。</p>

<p>socket函数会返回-1，errno设置为EHOSTUNREACH，表示对端不可达。</p>

<h4>选项</h4>

<p>内核默认并不使用TCP Keepalive功能，除非用户设置了SO_KEEPALIVE选项。</p>

<p>有两种方式可以自行调整保活定时器的参数：一种是修改TCP参数，一种是使用TCP层选项。</p>

<p>(1) TCP参数</p>

<p>tcp_keepalive_time</p>

<p>最后一次数据交换到TCP发送第一个保活探测报文的时间，即允许连接空闲的时间，默认为7200s。</p>

<p>tcp_keepalive_intvl</p>

<p>保活探测报文的重传时间，默认为75s。</p>

<p>tcp_keepalive_probes</p>

<p>保活探测报文的发送次数，默认为9次。</p>

<p>Q：一次完整的保活探测需要花费多长时间？</p>

<p>A：tcp_keepalive_time + tcp_keepalive_intvl * tcp_keepalive_probes，默认值为7875s。如果觉得两个多小时太长了，可以自行调整上述参数。</p>

<p>(2) TCP层选项</p>

<p>TCP_KEEPIDLE：含义同tcp_keepalive_time。</p>

<p>TCP_KEEPINTVL：含义同tcp_keepalive_intvl。</p>

<p>TCP_KEEPCNT：含义同tcp_keepalive_probes。</p>

<p>Q：既然有了TCP参数可供调整，为什么还增加了上述的TCP层选项？</p>

<p>A：TCP参数是面向本机的所有TCP连接，一旦调整了，对所有的连接都有效。而TCP层选项是面向一条连接的，一旦调整了，只对本条连接有效。</p>

<h4>激活</h4>

<p>在连接建立后，可以通过设置SO_KEEPALIVE选项，来激活保活定时器。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int keepalive = 1;
</span><span class='line'>setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &keepalive, sizeof(keepalive));</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval,   
</span><span class='line'>&#9;unsigned int optlen)  
</span><span class='line'>{  
</span><span class='line'>&#9;...  
</span><span class='line'>&#9;case SO_KEEPALIVE:  
</span><span class='line'>#ifdef CONFIG_INET  
</span><span class='line'>&#9;&#9;if (sk-&gt;sk_protocol == IPPROTO_TCP && sk-&gt;sk_type == SOCK_STREAM)  
</span><span class='line'>&#9;&#9;&#9;tcp_set_keepalive(sk, valbool); /* 激活或删除保活定时器 */  
</span><span class='line'>#endif  
</span><span class='line'>&#9;&#9;sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool); /* 设置或取消SOCK_KEEPOPEN标志位 */  
</span><span class='line'>&#9;&#9;break;  
</span><span class='line'>&#9;...  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>static inline void sock_valbool_flag (struct sock *sk, int bit, int valbool)  
</span><span class='line'>{  
</span><span class='line'>&#9;if (valbool)  
</span><span class='line'>&#9;&#9;sock_set_flag(sk, bit);  
</span><span class='line'>&#9;else  
</span><span class='line'>&#9;&#9;sock_reset_flag(sk, bit);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_set_keepalive(struct sock *sk, int val)  
</span><span class='line'>{  
</span><span class='line'>&#9;/* 不在以下两个状态设置保活定时器： 
</span><span class='line'>&#9; * TCP_CLOSE：sk_timer用作FIN_WAIT2定时器 
</span><span class='line'>&#9; * TCP_LISTEN：sk_timer用作SYNACK重传定时器 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if ((1 &lt;&lt; sk-&gt;sk_state) & (TCPF_CLOSE | TCPF_LISTEN))  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>  
</span><span class='line'>&#9;/* 如果SO_KEEPALIVE选项值为1，且此前没有设置SOCK_KEEPOPEN标志， 
</span><span class='line'>&#9; * 则激活sk_timer，用作保活定时器。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (val && !sock_flag(sk, SOCK_KEEPOPEN))  
</span><span class='line'>&#9;&#9;inet_csk_reset_keepalive_timer(sk, keepalive_time_when(tcp_sk(sk)));  
</span><span class='line'>&#9;else if (!val)  
</span><span class='line'>&#9;&#9;/* 如果SO_KEEPALIVE选项值为0，则删除保活定时器 */  
</span><span class='line'>&#9;&#9;inet_csk_delete_keepalive_timer(sk);  
</span><span class='line'>}  
</span><span class='line'>   
</span><span class='line'>/* 保活定时器的超时时间 */  
</span><span class='line'>static inline int keepalive_time_when(const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;return tp-&gt;keepalive_time ? : sysctl_tcp_keepalive_time;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>void inet_csk_reset_keepalive_timer (struc sock *sk, unsigned long len)  
</span><span class='line'>{  
</span><span class='line'>&#9;sk_reset_timer(sk, &sk-&gt;sk_timer, jiffies + len);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>可以使用TCP层选项来动态调整保活定时器的参数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int keepidle = 600;
</span><span class='line'>int keepintvl = 10;
</span><span class='line'>int keepcnt = 6;
</span><span class='line'>
</span><span class='line'>setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, &keepidle, sizeof(keepidle));
</span><span class='line'>setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, &keepintvl, sizeof(keepintvl));
</span><span class='line'>setsockopt(fd, SOL_TCP, TCP_KEEPCNT, &keepcnt, sizeof(keepcnt));</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_sock {  
</span><span class='line'>&#9;...  
</span><span class='line'>&#9;/* 最后一次接收到ACK的时间 */  
</span><span class='line'>&#9;u32 rcv_tstamp; /* timestamp of last received ACK (for keepalives) */  
</span><span class='line'>&#9;...  
</span><span class='line'>&#9;/* time before keep alive takes place, 空闲多久后才发送探测报文 */  
</span><span class='line'>&#9;unsigned int keepalive_time;  
</span><span class='line'>&#9;/* time iterval between keep alive probes */  
</span><span class='line'>&#9;unsigned int keepalive_intvl; /* 探测报文之间的时间间隔 */  
</span><span class='line'>&#9;/* num of allowed keep alive probes */  
</span><span class='line'>&#9;u8 keepalive_probes; /* 探测报文的发送次数 */  
</span><span class='line'>&#9;...  
</span><span class='line'>&#9;struct {  
</span><span class='line'>&#9;&#9;...  
</span><span class='line'>&#9;&#9;/* 最后一次接收到带负荷的报文的时间 */  
</span><span class='line'>&#9;&#9;__u32 lrcvtime; /* timestamp of last received data packet */  
</span><span class='line'>&#9;&#9;...  
</span><span class='line'>&#9;} icsk_ack;  
</span><span class='line'>&#9;...  
</span><span class='line'>};  
</span><span class='line'>  
</span><span class='line'>#define TCP_KEEPIDLE 4 /* Start Keepalives after this period */  
</span><span class='line'>#define TCP_KEEPINTVL 5 /* Interval between keepalives */  
</span><span class='line'>#define TCP_KEEPCNT 6 /* Number of keepalives before death */  
</span><span class='line'>   
</span><span class='line'>#define MAX_TCP_KEEPIDLE 32767  
</span><span class='line'>#define MAX_TCP_KEEPINTVL 32767  
</span><span class='line'>#define MAX_TCP_KEEPCNT 127  </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int do_tcp_setsockopt(struct sock *sk, int level, int optname, char __user *optval,  
</span><span class='line'>&#9;unsigned int optlen)  
</span><span class='line'>{  
</span><span class='line'>&#9;...  
</span><span class='line'>&#9;case TCP_KEEPIDLE:  
</span><span class='line'>&#9;   if (val &lt; 1 || val &gt; MAX_TCP_KEEPIDLE)  
</span><span class='line'>&#9;&#9;   err = -EINVAL;  
</span><span class='line'>&#9;&#9;else {  
</span><span class='line'>&#9;&#9;&#9;tp-&gt;keepalive_time = val * HZ; /* 设置新的空闲时间 */  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;&#9;/* 如果有使用SO_KEEPALIVE选项，连接处于非监听非结束的状态。 
</span><span class='line'>&#9;&#9;&#9; * 这个时候保活定时器已经在计时了，这里设置新的超时时间。 
</span><span class='line'>&#9;&#9;&#9; */  
</span><span class='line'>&#9;&#9;&#9;if (sock_flag(sk, SOCK_KEEPOPEN) &&   
</span><span class='line'>&#9;&#9;&#9;&#9;!((1 &lt;&lt; sk-&gt;sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {  
</span><span class='line'>&#9;&#9;&#9;&#9;u32 elapsed = keepalive_time_elapsed(tp); /* 连接已经经历的空闲时间 */  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;&#9;&#9;if (tp-&gt;keepalive_time &gt; elapsed)  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;elapsed = tp-&gt;keepalive_time - elapsed; /* 接着等待的时间，然后超时 */  
</span><span class='line'>&#9;&#9;&#9;&#9;else  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;elapsed = 0; /* 会导致马上超时 */  
</span><span class='line'>&#9;&#9;&#9;&#9;inet_csk_reset_keepalive_timer(sk, elapsed);  
</span><span class='line'>&#9;&#9;&#9;}  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;&#9;break;  
</span><span class='line'>  
</span><span class='line'>&#9;case TCP_KEEPINTVL:  
</span><span class='line'>&#9;&#9;if (val &lt; 1 || val &gt; MAX_TCP_KEEPINTVL)  
</span><span class='line'>&#9;&#9;&#9;err = -EINVAL;  
</span><span class='line'>&#9;&#9;else  
</span><span class='line'>&#9;&#9;&#9;tp-&gt;keepalive_intvl = val * HZ; /* 设置新的探测报文间隔 */  
</span><span class='line'>&#9;&#9;break;  
</span><span class='line'>  
</span><span class='line'>&#9;case TCP_KEEPCNT:  
</span><span class='line'>&#9;&#9;if (val &lt; 1 || val &gt; MAX_TCP_KEEPCNT)  
</span><span class='line'>&#9;&#9;&#9;err = -EINVAL;  
</span><span class='line'>&#9;&#9;else  
</span><span class='line'>&#9;&#9;&#9;tp-&gt;keepalive_probes = val; /* 设置新的探测次数 */  
</span><span class='line'>&#9;&#9;break;  
</span><span class='line'>&#9;...  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>到目前为止，连接已经经历的空闲时间，即最后一次接收到报文至今的时间。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline u32 keepalive_time_elapsed (const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;const struct inet_connection_sock *icsk = &tp-&gt;inet_conn;  
</span><span class='line'>  
</span><span class='line'>&#9;/* lrcvtime是最后一次接收到数据报的时间 
</span><span class='line'>&#9; * rcv_tstamp是最后一次接收到ACK的时间 
</span><span class='line'>&#9; * 返回值就是最后一次接收到报文，到现在的时间，即经历的空闲时间。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;return min_t(u32, tcp_time_stamp - icsk-&gt;icsk_ack.lrcvtime,  
</span><span class='line'>&#9;&#9;tcp_time_stamp - tp-&gt;rcv_tstamp);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h4>超时处理函数</h4>

<p>我们知道保活定时器、SYNACK重传定时器、FIN_WAIT2定时器是共用一个定时器实例sk->sk_timer，所以它们的超时处理函数也是一样的，都为tcp_keepalive_timer()。而在函数内部，可以根据此时连接所处的状态，来判断是哪个定时器触发了超时。</p>

<p>Q：什么时候判断对端为异常并关闭连接？</p>

<p>A：分两种情况。</p>

<ol>
<li><p>用户使用了TCP_USER_TIMEOUT选项。当连接的空闲时间超过了用户设置的时间，且有发送过探测报文。</p></li>
<li><p>用户没有使用TCP_USER_TIMEOUT选项。当发送保活探测包的次数达到了保活探测的最大次数时。</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_keepalive_timer (unsigned long data)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct sock *sk = (struct sock *) data;  
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;u32 elapsed;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Only process if socket is not in use. */  
</span><span class='line'>&#9;bh_lock_sock(sk);  
</span><span class='line'>  
</span><span class='line'>&#9;/* 加锁以保证在此期间，连接状态不会被用户进程修改。 
</span><span class='line'>&#9; * 如果用户进程正在使用此sock，那么过50ms再来看看。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (sock_owned_by_user(sk)) {  
</span><span class='line'>&#9;&#9;/* Try again later. */  
</span><span class='line'>&#9;&#9;inet_csk_reset_keepalive_timer(sk, HZ/20);  
</span><span class='line'>&#9;&#9;goto out;  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;/* 三次握手期间，用作SYNACK定时器 */  
</span><span class='line'>&#9;if (sk-&gt;sk_state == TCP_LISTEN) {  
</span><span class='line'>&#9;&#9;tcp_synack_timer(sk);  
</span><span class='line'>&#9;&#9;goto out;  
</span><span class='line'>&#9;}      
</span><span class='line'>  
</span><span class='line'>&#9;/* 连接释放期间，用作FIN_WAIT2定时器 */  
</span><span class='line'>&#9;if (sk-&gt;sk_state == TCP_FIN_WAIT2 && sock_flag(sk, SOCK_DEAD)) {  
</span><span class='line'>&#9;&#9;...  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;/* 接下来就是用作保活定时器了 */  
</span><span class='line'>&#9;if (!sock_flag(sk, SOCK_KEEPOPEN) || sk-&gt;sk_state == TCP_CLOSE)  
</span><span class='line'>&#9;&#9;goto out;  
</span><span class='line'>  
</span><span class='line'>&#9;elapsed = keepalive_time_when(tp); /* 连接的空闲时间超过此值，就发送保活探测报文 */  
</span><span class='line'>  
</span><span class='line'>&#9;/* It is alive without keepalive. 
</span><span class='line'>&#9; * 如果网络中有发送且未确认的数据包，或者发送队列不为空，说明连接不是idle的？ 
</span><span class='line'>&#9; * 既然连接不是idle的，就没有必要探测对端是否正常。 
</span><span class='line'>&#9; * 保活定时器重新开始计时即可。 
</span><span class='line'>&#9; *  
</span><span class='line'>&#9; * 而实际上当网络中有发送且未确认的数据包时，对端也可能会发生异常而没有响应。 
</span><span class='line'>&#9; * 这个时候会导致数据包的不断重传，只能依靠重传超过了允许的最大时间，来判断连接超时。 
</span><span class='line'>&#9; * 为了解决这一问题，引入了TCP_USER_TIMEOUT，允许用户指定超时时间，可见下文：） 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (tp-&gt;packets_out || tcp_send_head(sk))  
</span><span class='line'>&#9;&#9;goto resched; /* 保活定时器重新开始计时 */  
</span><span class='line'>  
</span><span class='line'>&#9;/* 连接经历的空闲时间，即上次收到报文至今的时间 */  
</span><span class='line'>&#9;elapsed = keepalive_time_elapsed(tp);  
</span><span class='line'>  
</span><span class='line'>&#9;/* 如果连接空闲的时间超过了设置的时间值 */  
</span><span class='line'>&#9;if (elapsed &gt;= keepalive_time_when(tp)) {  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* 什么时候关闭连接？ 
</span><span class='line'>&#9;&#9; * 1. 使用了TCP_USER_TIMEOUT选项。当连接空闲时间超过了用户设置的时间，且有发送过探测报文。 
</span><span class='line'>&#9;&#9; * 2. 用户没有使用选项。当发送的保活探测包达到了保活探测的最大次数。 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;if (icsk-&gt;icsk_user_timeout != 0 && elapsed &gt;= icsk-&gt;icsk_user_timeout &&  
</span><span class='line'>&#9;&#9;&#9;icsk-&gt;icsk_probes_out &gt; 0) || (icsk-&gt;icsk_user_timeout == 0 &&  
</span><span class='line'>&#9;&#9;&#9;icsk-&gt;icsk_probes_out &gt;= keepalive_probes(tp))) {  
</span><span class='line'>&#9;&#9;&#9;tcp_send_active_reset(sk, GFP_ATOMIC); /* 构造一个RST包并发送 */  
</span><span class='line'>&#9;&#9;&#9;tcp_write_err(sk); /* 报告错误，关闭连接 */  
</span><span class='line'>&#9;&#9;&#9;goto out;  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* 如果还不到关闭连接的时候，就继续发送保活探测包 */  
</span><span class='line'>&#9;&#9;if (tcp_write_wakeup(sk) &lt;= 0) {  
</span><span class='line'>&#9;&#9;&#9;icsk-&gt;icsk_probes_out++; /* 已发送的保活探测包个数 */  
</span><span class='line'>&#9;&#9;&#9;elapsed = keepalive_intvl_when(tp); /* 下次超时的时间，默认为75s */  
</span><span class='line'>&#9;&#9;} else {  
</span><span class='line'>&#9;&#9;&#9;/* If keepalive was lost due to local congestion, try harder. */  
</span><span class='line'>&#9;&#9;&#9;elapsd = TCP_RESOURCE_PROBE_INTERVAL; /* 默认为500ms，会使超时更加频繁 */  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;} else {  
</span><span class='line'>&#9;&#9;/* 如果连接的空闲时间，还没有超过设定值，则接着等待 */  
</span><span class='line'>&#9;&#9;elapsed = keepalive_time_when(tp) - elapsed;  
</span><span class='line'>&#9;}   
</span><span class='line'>  
</span><span class='line'>&#9;sk_mem_reclaim(sk);  
</span><span class='line'>  
</span><span class='line'>resched: /* 重设保活定时器 */  
</span><span class='line'>&#9;inet_csk_reset_keepalive_timer(sk, elapsed);  
</span><span class='line'>&#9;goto out;   
</span><span class='line'>  
</span><span class='line'>out:  
</span><span class='line'>&#9;bh_unlock_sock(sk);  
</span><span class='line'>&#9;sock_put(sk);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>Q：TCP是如何发送Keepalive探测报文的？</p>

<p>A：分两种情况。</p>

<ol>
<li><p>有新的数据段可供发送，且对端接收窗口还没被塞满。发送新的数据段，来作为探测包。</p></li>
<li><p>没有新的数据段可供发送，或者对端的接收窗口满了。发送序号为snd_una - 1、长度为0的ACK包作为探测包。</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Initiate keepalive or window probe from timer. */  
</span><span class='line'>  
</span><span class='line'>int tcp_write_wakeup (struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;struct sk_buff *skb;  
</span><span class='line'>  
</span><span class='line'>&#9;if (sk-&gt;sk_state == TCP_CLOSE)  
</span><span class='line'>&#9;&#9;return -1;  
</span><span class='line'>  
</span><span class='line'>&#9;/* 如果还有未发送过的数据包，并且对端的接收窗口还没有满 */  
</span><span class='line'>&#9;if ((skb = tcp_send_head(sk)) != NULL && before(TCP_SKB_CB(skb)-&gt;seq, tcp_wnd_end(tp))) {  
</span><span class='line'>&#9;&#9;int err;  
</span><span class='line'>&#9;&#9;unsigned int mss = tcp_current_mss(sk); /* 当前的MSS */  
</span><span class='line'>&#9;&#9;/* 对端接收窗口所允许的最大报文长度 */  
</span><span class='line'>&#9;&#9;unsigned int seg_size = tcp_wnd_end(tp) - TCP_SKB_CB(skb)-&gt;seq;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* pushed_seq记录发送出去的最后一个字节的序号 */  
</span><span class='line'>&#9;&#9;if (before(tp-&gt;pushed_seq, TCP_SKB_CB(skb)-&gt;end_seq))  
</span><span class='line'>&#9;&#9;&#9;tp-&gt;pushed_seq = TCP_SKB_CB(skb)-&gt;end_seq;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* 如果对端接收窗口小于此数据段的长度，或者此数据段的长度超过了MSS，那么就要进行分段 */  
</span><span class='line'>&#9;&#9;if (seg_size &lt; TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq || skb-&gt;len &gt; mss) {  
</span><span class='line'>&#9;&#9;&#9;seg_size = min(seg_size, mss);  
</span><span class='line'>&#9;&#9;&#9;TCP_SKB_CB(skb)-&gt;tcp_flags |= TCPHDR_PSH; /* 设置PSH标志，让对端马上把数据提交给程序 */  
</span><span class='line'>&#9;&#9;&#9;if (tcp_fragment(sk, skb, seg_size, mss)) /* 进行分段 */  
</span><span class='line'>&#9;&#9;&#9;&#9;return -1;  
</span><span class='line'>&#9;&#9;} else if (! tcp_skb_pcount(skb)) /* 进行TSO分片 */  
</span><span class='line'>&#9;&#9;&#9;tcp_set_skb_tso_segs(sk, skb, mss); /* 初始化分片相关变量 */  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;TCP_SKB_CB(skb)-&gt;tcp_flags |= TCPHDR_PSH;  
</span><span class='line'>&#9;&#9;TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;  
</span><span class='line'>&#9;&#9;err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC); /* 发送此数据段 */  
</span><span class='line'>&#9;&#9;if (!err)  
</span><span class='line'>&#9;&#9;&#9;tcp_event_new_data_sent(sk, skb); /* 发送了新的数据，更新相关参数 */  
</span><span class='line'>  
</span><span class='line'>&#9;} else { /* 如果没有新的数据段可用作探测报文发送，或者对端的接收窗口为0 */  
</span><span class='line'>  
</span><span class='line'>&#9;   /* 处于紧急模式时，额外发送一个序号为snd_una的ACK包，告诉对端紧急指针 */  
</span><span class='line'>&#9;   if (between(tp-&gt;snd_up, tp-&gt;snd_una + 1, tp-&gt;snd_una + 0xFFFF))  
</span><span class='line'>&#9;&#9;   tcp_xmit_probe_skb(sk, 1);  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* 发送一个序号为snd_una -1的ACK包，长度为0，这是一个序号过时的报文。 
</span><span class='line'>&#9;&#9; * snd_una: first byte we want an ack for，所以snd_una - 1序号的字节已经被确认过了。 
</span><span class='line'>&#9;&#9; * 对端会响应一个ACK。 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;return tcp_xmit_probe_skb(sk, 0);  
</span><span class='line'>&#9;}  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>Q：当没有新的数据可以用作探测包、或者对端的接收窗口为0时，怎么办呢？</p>

<p>A：发送一个序号为snd_una - 1、长度为0的ACK包，对端收到此包后会发送一个ACK响应。如此一来本端就能够知道对端是否还活着、接收窗口是否打开了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* This routine sends a packet with an out of date sequence number. 
</span><span class='line'> * It assumes the other end will try to ack it. 
</span><span class='line'> *  
</span><span class='line'> * Question: what should we make while urgent mode? 
</span><span class='line'> * 4.4BSD forces sending single byte of data. We cannot send out of window 
</span><span class='line'> * data, because we have SND.NXT == SND.MAX... 
</span><span class='line'> *  
</span><span class='line'> * Current solution: to send TWO zero-length segments in urgent mode: 
</span><span class='line'> * one is with SEG.SEG=SND.UNA to deliver urgent pointer, another is out-of-date with 
</span><span class='line'> * SND.UNA - 1 to probe window. 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>static int tcp_xmit_probe_skb (struct sock *sk, int urgent)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;struct sk_buff *skb;  
</span><span class='line'>  
</span><span class='line'>&#9;/* We don't queue it, tcp_transmit_skb() sets ownership. */  
</span><span class='line'>&#9;skb = alloc_skb(MAX_TCP_HEADER, sk_gfp_atomic(sk, GFP_ATOMIC));  
</span><span class='line'>&#9;if (skb == NULL)  
</span><span class='line'>&#9;&#9;return -1;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Reserve space for headers and set control bits. */  
</span><span class='line'>&#9;skb_reserve(skb, MAX_TCP_HEADER);  
</span><span class='line'>  
</span><span class='line'>&#9;/* Use a previous sequence. This should cause the other end to send an ack. 
</span><span class='line'>&#9; * Don't queue or clone SKB, just send it. 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;/* 如果没有设置紧急指针，那么发送的序号为snd_una - 1，否则发送的序号为snd_una */  
</span><span class='line'>&#9;tcp_init_nondata_skb(skb, tp-&gt;snd_una - !urgent, TCPHDR_ACK);  
</span><span class='line'>&#9;TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;  
</span><span class='line'>&#9;return tcp_transmit_skb(sk, skb, 0, GFP_ATOMIC); /* 发送探测包 */  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>发送RST包。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* We get here when a process closes a file descriptor (either due to an explicit close() 
</span><span class='line'> * or as a byproduct of exit()'ing) and there was unread data in the receive queue. 
</span><span class='line'> * This behavior is recommended by RFC 2525, section 2.17. -DaveM 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>void tcp_send_active_reset (struct sock *sk, gfp_t priority)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct sk_buff *skb;  
</span><span class='line'>&#9;/* NOTE: No TCP options attached and we never retransmit this. */  
</span><span class='line'>&#9;skb = alloc_skb(MAX_TCP_HEADER, priority);  
</span><span class='line'>&#9;if (!skb) {  
</span><span class='line'>&#9;&#9;NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTFAILED);  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;/* Reserve space for headers and prepare control bits. */  
</span><span class='line'>&#9;skb_reserve(skb, MAX_TCP_HEADER); /* 为报文头部预留空间 */  
</span><span class='line'>&#9;/* 初始化不携带数据的skb的一些控制字段 */  
</span><span class='line'>&#9;tcp_init_nondata_skb(skb, tcp_acceptable_seq(sk), TCPHDR_ACK | TCPHDR_RST);  
</span><span class='line'>  
</span><span class='line'>&#9;/* Send if off，发送此RST包*/  
</span><span class='line'>&#9;TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;  
</span><span class='line'>&#9;if (tcp_transmit_skb(sk, skb, 0, priority))  
</span><span class='line'>&#9;&#9;NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTFAILED);  
</span><span class='line'>&#9;TCP_INC_STATS(sock_net(sk), TCP_MIB_OUTRSTS);  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>static inline __u32 tcp_acceptable_seq (const struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>&#9;const struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>  
</span><span class='line'>&#9;/* 如果snd_nxt在对端接收窗口范围内 */  
</span><span class='line'>&#9;if (! before(tcp_wnd_end(tp), tp-&gt;snd_nxt))  
</span><span class='line'>&#9;&#9;return tp-&gt;snd_nxt;  
</span><span class='line'>&#9;else  
</span><span class='line'>&#9;&#9;return tcp_wnd_end(tp);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h4>TCP_USER_TIMEOUT选项</h4>

<p>从上文可知同时符合以下条件时，保活定时器才会发送探测报文：</p>

<ol>
<li><p>网络中没有发送且未确认的数据包。</p></li>
<li><p>发送队列为空。</p></li>
<li><p>连接的空闲时间超过了设定的时间。</p></li>
</ol>


<p>Q：如果网络中有发送且未确认的数据包、或者发送队列不为空时，保活定时器不起作用了，岂不是不能够检测到对端的异常了？</p>

<p>A：可以使用TCP_USER_TIMEOUT，显式的指定当发送数据多久后还没有得到响应，就判定连接超时，从而主动关闭连接。</p>

<p>TCP_USER_TIMEOUT选项会影响到超时重传定时器和保活定时器。</p>

<p>(1) 超时重传定时器</p>

<p>判断连接是否超时，分3种情况：</p>

<ol>
<li><p>SYN包：当SYN包的重传次数达到上限时，判定连接超时。(默认允许重传5次，初始超时时间为1s，总共历时31s)</p></li>
<li><p>非SYN包，用户使用TCP_USER_TIMEOUT：当数据包发出去后的等待时间超过用户设置的时间时，判定连接超时。</p></li>
<li><p>非SYN包，用户没有使用TCP_USER_TIMEOUT：当数据包发出去后的等待时间超过以TCP_RTO_MIN为初始超时时间，重传boundary次所花费的时间后，判定连接超时。(boundary的最大值为tcp_retries2，默认值为15)</p></li>
</ol>


<p>(2) 保活定时器</p>

<p>判断连接是否异常，分2种情况：</p>

<ol>
<li><p>用户使用了TCP_USER_TIMEOUT选项。当连接的空闲时间超过了用户设置的时间，且有发送过探测报文。</p></li>
<li><p>用户没有使用TCP_USER_TIMEOUT选项。当发送保活探测包的次数达到了保活探测的最大次数时。</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
