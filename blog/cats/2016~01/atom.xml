<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2016~01 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2016~01/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2016-01-12T16:14:03+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[linux 实时时钟（RTC）驱动]]></title>
    <link href="http://abcdxyzk.github.io/blog/2016/01/12/kernel-base-rtc/"/>
    <updated>2016-01-12T15:53:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2016/01/12/kernel-base-rtc</id>
    <content type="html"><![CDATA[<p><a href="/download/kernel/rtc.txt">Documentation/rtc.txt</a></p>

<hr />

<p><a href="http://blog.csdn.net/yaozhenguo2006/article/details/6820218">http://blog.csdn.net/yaozhenguo2006/article/details/6820218</a></p>

<p>这个是linux内核文档关于rtc实时时钟部分的说明，此文档主要描述了rtc实时时钟的作用和编程接口，分别介绍了老的rtc接口和新的rtc类架构。并给出了一个测试rtc驱动的程序。</p>

<h3>linux 实时时钟（RTC）驱动</h3>

<p>翻译：窗外云天<a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x79;&#x61;&#111;&#122;&#x68;&#x65;&#x6e;&#x67;&#117;&#x6f;&#50;&#48;&#48;&#x36;&#64;&#49;&#50;&#54;&#x2e;&#99;&#111;&#x6d;">&#121;&#x61;&#111;&#x7a;&#104;&#101;&#x6e;&#103;&#117;&#111;&#x32;&#48;&#x30;&#54;&#64;&#49;&#50;&#54;&#46;&#99;&#111;&#109;</a>  最后矫正时间：2011.9.25</p>

<p>当linux开发者提到“实时时钟”的时候，他们通常所指的就是墙钟时间，这个时间是电池供电的，所以在系统掉电的情况下还能正常工作。除非在MS-Windows启动的时候设置，否则这个时钟不会同步于本地时区和夏令时间。事实上，他被设置成格林威治时间。</p>

<p>最新的非pc体系的硬件趋向于记秒数，比如time(2)系统调用的输出，但是实时时钟用公历和24小时表示日期与时间，比如gmtime(3)的输出。</p>

<p>linux提供两类的rtc兼容性很高的用户空间系统调用接口，如下所示：<br/>
（1） /dev/rtc &hellip; 这个RTC适合pc体系的系统，而并不适合非x86体系的系统<br/>
（2） /dev/rtc0,/dev/rtc1 &hellip; 他们依赖一种架构，这种架构在所有的系统上被RTC芯片广泛的支持。</p>

<p>程序员必须知道，PC/AT的功能不总是有效，其他的系统可能会有另外的实现。这种情况下，如果在相同的系统结构上使用同样的RTC API，那么硬件会有不同的反应。例如，不是每一个RTC都提供IRQ，所以这些不能处理报警中断；标准的PC系统RTC只能处理未来24小时以内的闹钟，而其他系统的RTC可能处理未来一个世纪的任何时间。</p>

<h4>老的PC/AT驱动：/dev/rtc</h4>

<p>所有基于PC的系统（甚至Alpha体系的机器）都有一个集成的实时时钟。通常他们集成在计算机的芯片组内，但是也有一些系统是在主板上焊接着摩托罗拉MC146818（或者类似的芯片），他们给系统提供时间和日期，这个时间和日期在系统掉电后仍然会保存。</p>

<p>ACPT(高级配置与电源管理接口)对MC146818的功能进行了标准化，并且在一些方面进行了功能扩展（提供了更长的定时周期，睡眠唤醒功能）。然而这些扩展的功能不适合老的驱动程序。</p>

<p>这个RTC还可以产生频率从 2HZ 到 8192HZ 的信号，以2的乘方增长。这些信号通过中断信号线8报告给系统。这个RTC还可以用作定时限制为24小时的闹钟，当定时时间到时产生8号中断。这个闹钟可以设置成任意一个可编程值的子集，这意味着可以设置成任意小时的任意分钟任意秒，例如，可以将这个时钟设置成在每个clk产生中断，从而产生1hz的信号。</p>

<p>这些中断通过/dev/rtc报告给系统（主设备号10,次设备号135，只读字符设备），中断传回一个无符号整数类型的数据。最低的位包含中断的类型（更新，闹钟，或者期），其他的字节代表了最后一次读到现在中断发生的次数。状态信息由虚拟文件/proc/driver/rtc产生，前提条件是使能了/proc文件系统。驱动应该提供锁机制，保证在同一时刻只有一个进程访问/dev/rtc。</p>

<p>用户进程通过系统调用read(2)或者select(2)读取/dev/rtc来获取这些中断。当调用这两个系统调用的时候，进程会阻塞或者退出直到下一个中断到来。这个功能用在需要不频繁的获取数据而又不希望通过轮询当前时间而占用CPU时间的情况下。</p>

<p>在高频率中断或者高系统负载下，用户进程应该检查从上次读取到现在发生中断的次数以判断是否有未处理的中断。例如，一个典型的 486-33 对/dev/rtc以大于1024hz的频率进行循环读，偶尔会产生中断积累（从上次读取到现在发生大于一次的中断）。鉴于此你应该检查读取数据的高字节，特别是在频率高于普通定时器中断&ndash;100hz的情况下。</p>

<p>中断频率是可编程的或可以让他超过64hz，但是只有root权限的用户可以这样做。这样做可能有点保守，但是我们不希望有恶意的用户在一个较慢的386sx-16机器上产生很多中断，这样会严重影响系统的性能。我们可以通过向/proc/sys/dev/rtc/max-user-freq写入值来修改这个64hz的限制。但是注意你一定要这样做，减少中断处理程序的代码才会亡羊补牢，使对系统性能的影响降到最小。</p>

<p>如果内核时间是和外部时钟源同步的，那么内核将每隔11分钟就会将时间写回CMOS时钟。在这个过程中，内核会关闭rtc周期中断，如果你的程序在做一些关键的工作一定要注意到。如果你的内核不和外部时钟源同步，那么内核会一直处理rtc中断，处理方式根据你具体的应用。</p>

<p>闹钟和中断频率可以通过系统调用ioctl(2)来设置，ioctl的命令定义在./include/linux/rtc.h。与其长篇大论的介绍怎么样使用这个系统调用，还不如写一个实例程序来的方便，这个程序用来演示驱动的功能，对很多人来说用驱动程序提供的功能来进行应用编程他们会更感兴趣。在这个文档的最后有这段程序。</p>

<h4>新接口 “RTC类” 驱动：/dev/rtcn</h4>

<p>因为linux支持许多非ACPI非PC平台，其中一些平台有不只一个RTC，所以需要更多可移植性的设计，而不是仅仅在每个系统都实现类似MC146818的接口。在这种情况下，新的“RTC类”构架产生了。他提供不同的用户空间接口：
（1） /dev/rtcn 和老的接口一样
（2）/dev/class/rtc/rtcn   sysfs 属性，一些属性是只读的
（3） /dev/driver/rtc 第一个rtc会使用procfs接口。更多的信息会显示在这里而不是sysfs。</p>

<p>RTC类构架支持很多类型的RTC，从集成在嵌入式SOC处理器内的RTC到通过I2C，SPI和其他总线连接到CPU的芯片。这个架构甚至还支持PC系统的RTC，包括使用ACPI，PC的一些新特性。</p>

<p>新架构也打破了“每个系统只有一个RTC”的限制。例如，一个低功耗电池供电的RTC是一个分离的I2C接口的芯片，但是系统可能还集成了一个多功能的RTC。系统可能从分离的RTC读取系统时钟，但是对于其他任务用集成的RTC，因为这个RTC提供更多的功能。</p>

<h4>SYSFS 接口</h4>

<p>在/sys/class/rtc/rtcn下面的sysfs接口提供了操作rtc属性的方法，而不用通过Ioclt系统调用。所有的日期时间都是墙钟时间，而不是系统时间。
<code>
    date:           RTC提供的日期
    hctosys:        如果在内核配置选项中配置了CONFIG_RTC_HCTOSYS，RTC会在系统启动的时候提供系统时间，这种情况下这个位就是1,否则为0
    max_user_freq:  非特权用户可以从RTC得到的最大中断频率
    name:           RTC的名字，与sysfs目录相关
    since_epoch:    从纪元开始所经历的秒数
    time:           RTC提供的时间
    wakealarm:      唤醒时间的时间事件。 这是一种单次的唤醒事件，所以如果还需要唤醒，在唤醒发生后必须复位。这个域的数据结构或者是从纪元开始经历的妙数，或者是相对的秒数
</code></p>

<h4>IOCTL 接口</h4>

<p>/dev/rtc支持的Ioctl系统调用，RTC类构架也支持。然而，因为芯片和系统没有一个统一的标准，一些PC/AT功能可能没有提供。以相同方式工作的一些新特性，&ndash;包括ACPI提供的，&ndash;在RTC类构架中表现出的，在老的驱动上不会工作。</p>

<p>（1） RTC_RD_TIME,RTC_SET_TIME .. 每一个RTC都至少支持读时间这个命令，时间格式为公历和24小时制墙钟时间。最有用的特性是，这个时间可以更新。<br/>
（2） RTC_ATE_ON,RTC_ATE_OFF,RTC_ALM_SET,RTC_ALM_READ &hellip; 当RTC连接了一条IRQ线，他还能处理在未来24小时的报警中断。<br/>
（3） RTC_WKALM_SET，RTC_WKALM_RD 。。。 RTCs 使用一个功能更强大的api,他可以处理超过24小时的报警时间。这个API支持设置更长的报警时间，支持单次请求的IRQ中断。<br/>
（4） RTC_UIE_ON,RTC_UIE_OFF &hellip; 如果RTC提供IRQ，他可能也提供每秒更新的IRQ中断。如果需要，RTC结构可以模仿这个机制。</p>

<p>（5） RTC_PIE_ON,RTC_PIE_OFF,RTC_IRQP_SET,RTC_IRQP_READ &hellip; 如果一个IRQ是周期中断，那么这个IRQ还有可设置频率的特性（频率通常是2的n次方）</p>

<p>很多情况下，RTC报警时钟通常是一个系统唤醒事件，用于将Linux从低功耗睡眠模式唤醒到正常的工作模式。例如，系统会处于低功耗的模式下，直到时间到了去执行一些任务。注意这些ioctl的一些功能不必在你的驱动程序中实现。如果一个ioctl调用，你的驱动返回ENOIOCTLCMD，那么这个Ioctl就由通用RTC设备接口处理。下面是一些通用的例子：<br/>
（6） RTC_RD_TIME, RTC_SET_TIME: read_time/set_time 函数会被调用。<br/>
（7） RTC_ALM_SET, RTC_ALM_READ, RTC_WKALM_SET, RTC_WKALM_RD: set_alarm/read_alarm 函数将会被调用.<br/>
（8） RTC_IRQP_SET, RTC_IRQP_READ: irq_set_freq 函数将会调用，用来设置频率，RTC类构架会处理读请求，而频率保存在RTC设备结构中的irq_freq域。你的驱动需要在模块初始化的时候初始化irq_freq，你必须在irq_set_freq函数里检查设置的频率是否在硬件允许的范围。如果不是那么驱动应该返回-EINVAL。如果你不需要改变这个频率，那么不要定义irq_set_freq这个函数。<br/>
（7） RTC_PIE_ON, RTC_PIE_OFF: irq_set_state 函数会被调用。</p>

<p>  如果所有的ioctl都失败了，用下面的rtc-test.c检查一下你的驱动吧！</p>

<pre><code>    /*
     *      Real Time Clock Driver Test/Example Program
     *
     *      Compile with:
     *           gcc -s -Wall -Wstrict-prototypes rtctest.c -o rtctest
     *
     *      Copyright (C) 1996, Paul Gortmaker.
     *
     *      Released under the GNU General Public License, version 2,
     *      included herein by reference.
     *
     */

    #include &lt;stdio.h&gt;
    #include &lt;linux/rtc.h&gt;
    #include &lt;sys/ioctl.h&gt;
    #include &lt;sys/time.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;fcntl.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;errno.h&gt;


    /*
     * This expects the new RTC class driver framework, working with
     * clocks that will often not be clones of what the PC-AT had.
     * Use the command line to specify another RTC if you need one.
     */
    static const char default_rtc[] = "/dev/rtc0";


    int main(int argc, char **argv)
    {
        int i, fd, retval, irqcount = 0;
        unsigned long tmp, data;
        struct rtc_time rtc_tm;
        const char *rtc = default_rtc;

        switch (argc) {
        case 2:
            rtc = argv[1];
            /* FALLTHROUGH */
        case 1:
            break;
        default:
            fprintf(stderr, "usage:  rtctest [rtcdev]\n");
            return 1;
        }

        fd = open(rtc, O_RDONLY);

        if (fd ==  -1) {
            perror(rtc);
            exit(errno);
        }

        fprintf(stderr, "\n\t\t\tRTC Driver Test Example.\n\n");

        /* Turn on update interrupts (one per second) */
        retval = ioctl(fd, RTC_UIE_ON, 0);
        if (retval == -1) {
            if (errno == ENOTTY) {
                fprintf(stderr,
                    "\n...Update IRQs not supported.\n");
                goto test_READ;
            }
            perror("RTC_UIE_ON ioctl");
            exit(errno);
        }

        fprintf(stderr, "Counting 5 update (1/sec) interrupts from reading %s:",
                rtc);
        fflush(stderr);
        for (i=1; i&lt;6; i++) {
            /* This read will block */
            retval = read(fd, &amp;data, sizeof(unsigned long));
            if (retval == -1) {
                perror("read");
                exit(errno);
            }
            fprintf(stderr, " %d",i);
            fflush(stderr);
            irqcount++;
        }

        fprintf(stderr, "\nAgain, from using select(2) on /dev/rtc:");
        fflush(stderr);
        for (i=1; i&lt;6; i++) {
            struct timeval tv = {5, 0};     /* 5 second timeout on select */
            fd_set readfds;

            FD_ZERO(&amp;readfds);
            FD_SET(fd, &amp;readfds);
            /* The select will wait until an RTC interrupt happens. */
            retval = select(fd+1, &amp;readfds, NULL, NULL, &amp;tv);
            if (retval == -1) {
                    perror("select");
                    exit(errno);
            }
            /* This read won't block unlike the select-less case above. */
            retval = read(fd, &amp;data, sizeof(unsigned long));
            if (retval == -1) {
                    perror("read");
                    exit(errno);
            }
            fprintf(stderr, " %d",i);
            fflush(stderr);
            irqcount++;
        }

        /* Turn off update interrupts */
        retval = ioctl(fd, RTC_UIE_OFF, 0);
        if (retval == -1) {
            perror("RTC_UIE_OFF ioctl");
            exit(errno);
        }

    test_READ:
        /* Read the RTC time/date */
        retval = ioctl(fd, RTC_RD_TIME, &amp;rtc_tm);
        if (retval == -1) {
            perror("RTC_RD_TIME ioctl");
            exit(errno);
        }

        fprintf(stderr, "\n\nCurrent RTC date/time is %d-%d-%d, %02d:%02d:%02d.\n",
            rtc_tm.tm_mday, rtc_tm.tm_mon + 1, rtc_tm.tm_year + 1900,
            rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec);

        /* Set the alarm to 5 sec in the future, and check for rollover */
        rtc_tm.tm_sec += 5;
        if (rtc_tm.tm_sec &gt;= 60) {
            rtc_tm.tm_sec %= 60;
            rtc_tm.tm_min++;
        }
        if (rtc_tm.tm_min == 60) {
            rtc_tm.tm_min = 0;
            rtc_tm.tm_hour++;
        }
        if (rtc_tm.tm_hour == 24)
            rtc_tm.tm_hour = 0;

        retval = ioctl(fd, RTC_ALM_SET, &amp;rtc_tm);
        if (retval == -1) {
            if (errno == ENOTTY) {
                fprintf(stderr,
                    "\n...Alarm IRQs not supported.\n");
                goto test_PIE;
            }
            perror("RTC_ALM_SET ioctl");
            exit(errno);
        }

        /* Read the current alarm settings */
        retval = ioctl(fd, RTC_ALM_READ, &amp;rtc_tm);
        if (retval == -1) {
            perror("RTC_ALM_READ ioctl");
            exit(errno);
        }

        fprintf(stderr, "Alarm time now set to %02d:%02d:%02d.\n",
            rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec);

        /* Enable alarm interrupts */
        retval = ioctl(fd, RTC_AIE_ON, 0);
        if (retval == -1) {
            perror("RTC_AIE_ON ioctl");
            exit(errno);
        }

        fprintf(stderr, "Waiting 5 seconds for alarm...");
        fflush(stderr);
        /* This blocks until the alarm ring causes an interrupt */
        retval = read(fd, &amp;data, sizeof(unsigned long));
        if (retval == -1) {
            perror("read");
            exit(errno);
        }
        irqcount++;
        fprintf(stderr, " okay. Alarm rang.\n");

        /* Disable alarm interrupts */
        retval = ioctl(fd, RTC_AIE_OFF, 0);
        if (retval == -1) {
            perror("RTC_AIE_OFF ioctl");
            exit(errno);
        }

    test_PIE:
        /* Read periodic IRQ rate */
        retval = ioctl(fd, RTC_IRQP_READ, &amp;tmp);
        if (retval == -1) {
            /* not all RTCs support periodic IRQs */
            if (errno == ENOTTY) {
                fprintf(stderr, "\nNo periodic IRQ support\n");
                goto done;
            }
            perror("RTC_IRQP_READ ioctl");
            exit(errno);
        }
        fprintf(stderr, "\nPeriodic IRQ rate is %ldHz.\n", tmp);

        fprintf(stderr, "Counting 20 interrupts at:");
        fflush(stderr);

        /* The frequencies 128Hz, 256Hz, ... 8192Hz are only allowed for root. */
        for (tmp=2; tmp&lt;=64; tmp*=2) {

            retval = ioctl(fd, RTC_IRQP_SET, tmp);
            if (retval == -1) {
                /* not all RTCs can change their periodic IRQ rate */
                if (errno == ENOTTY) {
                    fprintf(stderr,
                        "\n...Periodic IRQ rate is fixed\n");
                    goto done;
                }
                perror("RTC_IRQP_SET ioctl");
                exit(errno);
            }

            fprintf(stderr, "\n%ldHz:\t", tmp);
            fflush(stderr);

            /* Enable periodic interrupts */
            retval = ioctl(fd, RTC_PIE_ON, 0);
            if (retval == -1) {
                perror("RTC_PIE_ON ioctl");
                exit(errno);
            }

            for (i=1; i&lt;21; i++) {
                /* This blocks */
                retval = read(fd, &amp;data, sizeof(unsigned long));
                if (retval == -1) {
                    perror("read");
                    exit(errno);
                }
                fprintf(stderr, " %d",i);
                fflush(stderr);
                irqcount++;
            }

            /* Disable periodic interrupts */
            retval = ioctl(fd, RTC_PIE_OFF, 0);
            if (retval == -1) {
                perror("RTC_PIE_OFF ioctl");
                exit(errno);
            }
        }

    done:
        fprintf(stderr, "\n\n\t\t\t *** Test complete ***\n");

        close(fd);

        return 0;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kdump时间错误]]></title>
    <link href="http://abcdxyzk.github.io/blog/2016/01/12/debug-kdump-rtc/"/>
    <updated>2016-01-12T15:39:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2016/01/12/debug-kdump-rtc</id>
    <content type="html"><![CDATA[<p><a href="/blog/2016/01/06/debug-mark-rtc/">CentOS 5.x安装新内核之后时钟混乱问题</a></p>

<p>解决kdump的vmcore保存的目录的时间错误问题</p>

<pre><code>    diff --git a/mkdumprd b/mkdumprd
    index d567085..7d946f4 100755
    --- a/mkdumprd
    +++ b/mkdumprd
    @@ -2279,12 +2279,19 @@ mknod /dev/systty c 4 0
     mknod /dev/tty c 5 0
     mknod /dev/console c 5 1
     mknod /dev/ptmx c 5 2
    -mknod /dev/rtc c 10 135
     mknod /dev/urandom c 1 9
     mknod /dev/efirtc c 10 136
     export network_up=0
     EOF

    +kernelval=`echo $kernel | awk -F "[-|.]" '{print $1*65536+$2*256+$3}'`
    +#echo "kernel=$kernel kernelval=$kernelval"
    +if [ $kernelval -lt 132640 ]; then
    +   emit "mknod /dev/rtc c 10 135"
    +else
    +   emit "mknod /dev/rtc c 254 0"
    +fi
    +
     # XXX really we need to openvt too, in case someting changes the
     # color palette and then changes vts on fbcon before gettys start.
     # (yay, fbcon bugs!)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 5.x安装新内核之后时钟混乱问题]]></title>
    <link href="http://abcdxyzk.github.io/blog/2016/01/06/debug-mark-rtc/"/>
    <updated>2016-01-06T11:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2016/01/06/debug-mark-rtc</id>
    <content type="html"><![CDATA[<p>el5在调用mkinitrd命令时，会将/dev/rtc生成好，放到initrd- x.x.x.img文件中。而el6的系统在 /etc/rc.sysinit的/sbin/start_udev 之前是有这两个文件，也没找到el6的系统是在哪里加的这两句。</p>

<p>el5可选的一个做法是：修改/etc/rc.sysinit,在/sbin/start_udev这行之前加入两行：
<code>
    mv /dev/rtc /dev/rtc0
    ln -sf rtc0 /dev/rtc
</code>
这样el5系统用18、32内核都没问题了。</p>

<p>el5试着将这两句改在/sbin/mkinitrd里修改，但不知道为什么改完后在执行到 /etc/rc.sysinit 时 /dev/rtc 这个软连接不见了。</p>

<p>或者直接将/dev/rtc改成254，0
<code>``
    diff --git a/mkinitrd b/mkinitrd
    index 5ddb909..dcba61d 100755
    --- a/mkinitrd
    +++ b/mkinitrd
    @@ -1708,7 +1708,14 @@ done
     mknod $MNTIMAGE/dev/tty c 5 0
     mknod $MNTIMAGE/dev/console c 5 1
     mknod $MNTIMAGE/dev/ptmx c 5 2
    -mknod $MNTIMAGE/dev/rtc c 10 135
    +
    +kernelval=</code>echo $kernel | awk -F &ldquo;[-|.]&rdquo; &lsquo;{print $1<em>65536+$2</em>256+$3}&rsquo;`
    +#echo &ldquo;kernel=$kernel kernelval=$kernelval&rdquo;
    +if [ $kernelval -lt 132640 ]; then
    +   mknod $MNTIMAGE/dev/rtc c 10 135
    +else
    +   mknod $MNTIMAGE/dev/rtc c 254 0
    +fi</p>

<pre><code> if [ "$(uname -m)" == "ia64" ]; then
     mknod $MNTIMAGE/dev/efirtc c 10 136
@@ -1911,8 +1918,16 @@ mknod /dev/systty c 4 0
 mknod /dev/tty c 5 0
 mknod /dev/console c 5 1
 mknod /dev/ptmx c 5 2
-mknod /dev/rtc c 10 135
 EOF
+
+kernelval=`echo $kernel | awk -F "[-|.]" '{print $1*65536+$2*256+$3}'`
+#echo "kernel=$kernel kernelval=$kernelval"
+if [ $kernelval -lt 132640 ]; then
+   emit "mknod /dev/rtc c 10 135"
+else
+   emit "mknod /dev/rtc c 254 0"
+fi
+
 if [ "$(uname -m)" == "ia64" ]; then
     emit "mknod /dev/efirtc c 10 136"
 fi
</code></pre>

<pre><code>
------------------

http://www.csdn123.com/html/mycsdn20140110/59/59dd8c5f069a09bf9dc1785e19eb329f.html

CentOS在安装完新内核之后，每次重启之后时钟总是会发生一些变化，使得系统时钟不准确。在多操作系统的情况下（例如windows和 linux双系统），还可能会出现时区的偏差，而且无论如何设置，在重启之后都会恢复原样。如何解决这个问题还得从操作系统的时钟原理开始。

#### 1. 操作系统中的时钟

操作系统为实现其功能，必须知道当前外部世界的时间（年月日时分秒等）。为实现这一目的，计算机设计者在主板上设置了一个硬件时钟，由主板上的一块纽扣电池（Cell）供电，这个硬件时钟无论计算机电源是否接通都会不停的数秒，来计算当前时间。

操作系统在启动的时候，会调用一段程序来读取主板上的硬件时钟，并记录在操作系统的一个（或一组）变量中。自此之后，操作系统的时钟便脱离主板的硬件时钟，开始单独运行（操作系统时钟的运行是由时钟中断来驱动的，不同于主板上的时钟）。

无论做工多么精细，主板硬件时钟和由时钟中断维护的操作系统内的时钟多多少少会有一些误差。所以，操作系统在每次关闭的时候会调用另一段程序，将操作系统 内的时钟写到主板硬件时钟里（这样设计是不是说明时钟中断比主板硬件时钟更准确一些呢？）。类似的，当用户在操作系统内修改时钟之后，也不会立即写入主板 时钟，而是在关机的时候写入硬件时钟。

#### 2. 旧汤和新药的冲突
主板上的硬件时钟在Linux操作系统中呈现为一个设备，设备名称为rtc（Real Time Clock）。

使用旧的系统（如CentOS的2.6.18内核）编译新内核时，在调用mkinitrd命令时，会将/dev/rtc生成好，放到initrd- x.x.x.img文件中;而新的内核是自己生成/dev/rtc文件的，当kernel生成/dev/rtc时，发现系统内已经有了这个设备，于是就会 创建/dev/rtc0设备。这时hwclock程序仍然会读取rtc设备，就会造成设备读写失败。运行`hwclock --debug`命令可以看到如下输出：
</code></pre>

<pre><code>[root@localhost ~]# hwclock --debug
hwclock from util-linux-2.13-pre7
hwclock: Open of /dev/rtc failed, errno=19: No such device.
No usable clock interface found.
Cannot access the Hardware Clock via any known method.
</code></pre>

<pre><code>但是有的能够直接读写I/O，这样虽然/dev/rtc是错的，但还能正常运行
</code></pre>

<pre><code>[root@localhost ~]# hwclock --debug
hwclock from util-linux-2.13-pre7
hwclock: Open of /dev/rtc failed, errno=19: No such device.
Using direct I/O instructions to ISA clock.
.....
</code></pre>

<pre><code>
其实，对应这个问题，新版的hwclock已经做出了调整。新的hwclock会主动去寻找/dev/rtc0设备，来操作主板硬件时钟。于是，解决方法就出现了。

#### 3. 新汤配新药
既然内核这剂药已经换成了新的，那我们就把外围应用程序hwclock也换成新的。

从这里可以下载比较新的（不用最新的是因为最新的源码在旧版的CentOS上编译会出现错误）程序源码：http://now-code.com/download/util-linux-ng-2.17.tar.bz2 

如果需要更多版本的程序源码，请到这里下载：ftp://ftp.kernel.org/pub/linux/utils/。

下载完成之后，编译该程序：
</code></pre>

<pre><code>tar xfv util-linux-ng-2.17.tar.bz2
cd util-linux-ng-2.17
./configure
make
</code></pre>

<pre><code>编译完成之后，将生成的hwclock文件拷贝到指定位置即可：
</code></pre>

<pre><code>cp hwclock/hwclock /sbin/
</code></pre>

<p>```</p>

<p>之后，操作系统和主板的硬件时钟就可以同步起来了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux系统时间和硬件时钟问题(date和hwclock)]]></title>
    <link href="http://abcdxyzk.github.io/blog/2016/01/06/system-base-time/"/>
    <updated>2016-01-06T10:48:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2016/01/06/system-base-time</id>
    <content type="html"><![CDATA[<p><a href="http://rpf413.blog.163.com/blog/static/4556376020122831444674/">http://rpf413.blog.163.com/blog/static/4556376020122831444674/</a></p>

<h4>总结一下hwclock，这个容易晕：</h4>

<p>1）/etc/sysconfig/clock 文件，只对 hwclock 命令有效，且只在系统启动和关闭的时候才有用（修改了其中的 UTC=true 到 UTC=false 的前后，执行 hwclock (<code>--utc</code>, 或 <code>--localtime</code>) 都没有变化，要重启系统后才生效）；</p>

<p>2）/etc/rc.d/rc.sysinit 文件，run once at boot time，其中有从硬件时钟同步时间到系统时间的操作；</p>

<p>3）<code>hwclock --localtime</code> 的输出，才是硬件时钟真正的时间。如果输出结果带时区（比如CST），还要看/etc/sysconfig/clock里的UTC参数，如果 UTC=false，那时区有意义；如果 UTC=true，那时区没意义，实际上是UTC时间。</p>

<p>4）在 /etc/sysconfig/clock 中 UTC=false 时，date、hwclock、<code>hwclcok --localtime</code> 输出的时间应该都一致，且此时 <code>hwclock --utc</code>是没有意义的；</p>

<p>5）在 /etc/sysconfig/clock 中 UTC=ture 时，date、hwclock 的输出是一致的，<code>hwclock --localtime</code> 的输出则是UTC时间；</p>

<p>6）如果不想在输出中带时区，则 export LANG=C ，然后再运行 hwclock 就没有什么CST了，免得时区误导你；</p>

<p>7）<code>hwclock --utc</code> 很闹腾，还是别看了，你会晕的。。。</p>

<p>8）系统关闭时会同步系统时间到硬件时钟，系统启动时会从硬件时钟读取时间更新到系统，这2个步骤都要根据 /etc/sysconfig/clock 文件中UTC的参数来设置时区转换。</p>

<h4>实际案例分析</h4>

<p>修改了 /etc/sysconfig/clock 中UTC参数但系统未正常关闭的情况</p>

<p>修改 /etc/sysconfig/clock 文件后，如果系统内核突然崩溃，然后直接按电源重启，则系统没有进行 系统时间到硬件时钟的 同步；但是 系统启动时，又根据 /etc/sysconfig/clock 中UTC的参数，来同步硬件时钟到系统，这时就会出现时间问题：</p>

<p>0）假设系统的时区为CST（UTC+8）；<br/>
1）假设原 /etc/sysconfig/clock 中 UTC=true，修改成 UTC=false；<br/>
2）如果此时系统未正常关机，系统时间未按参数 UTC=false 同步时间到硬件时钟（没有+8小时）；<br/>
3）但系统被按电源重启后，系统读取到 UTC=false，认为硬件时钟为CST时间，直接用于系统时间；<br/>
4）那么此时，系统时间将少了8小时。</p>

<hr />

<p><a href="http://hi.baidu.com/lujunqianglw/blog/item/bc2d9144d24fc48fb3b7dc1d.html">http://hi.baidu.com/lujunqianglw/blog/item/bc2d9144d24fc48fb3b7dc1d.html</a></p>

<h4>一、首先要弄清几个概念：</h4>

<h5>1. “系统时间”与“硬件时间”</h5>

<p>系统时间: 一般说来就是我们执行 date 命令看到的时间，linux系统下所有的时间调用（除了直接访问硬件时间的命令）都是使用的这个时间。</p>

<p>硬件时间: 主板上BIOS中的时间，由主板电池供电来维持运行，系统开机时要读取这个时间，并根据它来设定系统时间（注意：系统启动时根据硬件时间设定系统时间的过程可能存在时区换算，这要视具体的系统及相关设置而定）。</p>

<h5>2. “UTC时间”与“本地时间”</h5>

<p>UTC时间：Coordinated Universal 8 e2 i( H7 t0 ^/ ^Time 世界协调时间（又称世界标准时间、世界统一时间），在一般精度要求下，它与GMT（Greenwich Mean Time，格林威治标准时间）是一样的，其实也就是说 GMT≈UTC，但 UTC 是以原子钟校准的，更精确。</p>

<p>本地时间：由于处在不同的时区，本地时间一般与UTC是不同的，换算方法就是</p>

<p>本地时间 = UTC + 时区 或 UTC = 本地时间 - 时区</p>

<p>时区东为正，西为负，例如在中国，本地时间都使用北京时间，在linux上显示就是 CST（China Standard Time，中国标准时，注意美国的中部标准时Central Standard Time也缩写为CST，与这里的CST不是一回事！），时区为东八区，也就是 +8 区，所以 CST=UTC+(+8小时) 或 UTC=CST-(+8小时)。</p>

<h4>二、时间命令</h4>

<h5>1. 系统时间 date</h5>

<p>直接调用 date，得到的是本地时间。如果想得到UTC时间的话，使用 date -u。
<code>
    [12-01 19:07&gt; ~]$ date
    2009年 12月 07日 星期一 14:22:20 CST
    [12-01 19:07&gt; ~]$ date -u
    2009年 12月 07日 星期一 06:22:22 UTC
</code></p>

<h5>2. 硬件时间 /sbin/hwclock</h5>

<p>直接调用 /sbin/hwclock 显示的时间就是 BIOS 中的时间吗？未必！这要看 /etc/sysconfig/clock 中是否启用了UTC，如果启用了UTC（UTC=true），显示的其实是经过时区换算的时间而不是BIOS中真正的时间，如果加上 &ndash;localtime 选项，则得到的总是 BIOS 中实际的时间.</p>

<pre><code>    [12-01 19:07&gt; ~]# hwclock
    2009年12月07日 星期一 14时28分43秒 -0.611463 seconds
    [12-01 19:07&gt; ~]# hwclock --utc
    2009年12月07日 星期一 14时28分46秒 -0.594189 seconds
    [12-01 19:07&gt; ~]# hwclock --localtime
    2009年12月07日 星期一 06时28分50秒 -0.063875 seconds
</code></pre>

<h5>3. /etc/localtime</h5>

<p>这个文件用来设置系统的时区，将 /usr/share/zoneinfo/ 中相应文件拷贝到/etc下并重命名为 localtime 即可修改时区设置，而且这种修改对 date 命令是及时生效的。不论是 date 还是 hwclock 都会用到这个文件，会根据这个文件的时区设置来进行UTC和本地之间之间的换算。</p>

<h5>4. /etc/sysconfig/clock</h5>

<p>这个文件只对 hwclock 有效，而且似乎是只在系统启动和关闭的时候才有用，比如修改了其中的 UTC=true 到 UTC=false 的前后，执行 hwclock (<code>--utc</code>, 或 <code>--localtime</code>) 都没有变化，要重启系统后才生效。注：如果设置 UTC=false 并重启系统后,执行一些命令结果如下：</p>

<pre><code>    date 2009年 12月 07日 星期一 19:26:29 CST
    date -u 2009年 12月 07日 星期一 11:26:29 UTC
    hwclock 2009年12月07日 星期一 19时26分30秒 -0.442668 seconds
    hwclock --utc 2009年12月08日 星期二 03时26分31秒 -0.999091 seconds
    hwclock --localtime 2009年12月07日 星期一 19时26分32秒 -0.999217 seconds
</code></pre>

<p>可见，如果不使用UTC，BIOS时间（红色部分）就是系统本地时间，而且注意这时执行 <code>hwclock --utc</code> 得到的结果没有任何意义，因为这里我们已经禁用了UTC，而且也明显不符合“本地时间=UTC+时区”的关系。</p>

<h4>三、linux与windows双系统间的时间同步</h4>

<p>系统启动和关闭时，硬件时间与系统时间之间的同步有两种方式(假设在中国，用CST代表本地时间)：</p>

<p>方式A: 使用UTC（对linux就是 /etc/sysconfig/clock 中 UTC=true）</p>

<p>开机: BIOS&mdash;&mdash;->UTC（将BIOS中的时间看成是UTC）&mdash;&mdash;(时区变化)&mdash;&ndash;>CST<br/>
关机: CST &mdash;&mdash;-(时区变化)&mdash;&ndash;>UTC&mdash;&mdash;-存储到&mdash;&mdash;>BIOS</p>

<p>方式B: 不使用UTC（对linux就是 /etc/sysconfig/clock 中 UTC=false）</p>

<p>开机: BIOS&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;>CST（将BIOS中的时间看成是CST）<br/>
关机: CST &mdash;&mdash;&mdash;存储到&mdash;&mdash;>BIOS</p>

<hr />

<p>FIX:</p>

<p>方式A: 使用UTC（对linux就是 /etc/sysconfig/clock 中 UTC=true）</p>

<p>关机: CST &mdash;&mdash;-操作系统根据时区算出UTC时间&mdash;&mdash;-存储到&mdash;&mdash;>BIOS<br/>
开机: BIOS&mdash;&mdash;->BIOS中的时间是UTC&mdash;&mdash;&mdash;&ndash;操作系统根据时区计算出localtime&mdash;&mdash;&mdash;-CST</p>

<p>方式B: 不使用UTC（对linux就是 /etc/sysconfig/clock 中 UTC=false）</p>

<p>关机: CST &mdash;&mdash;&ndash;操作系统中UTC=false，直接将localtime存储到&mdash;&mdash;>BIOS<br/>
开机: BIOS&mdash;&mdash;&ndash;BIOS中的时间是localtime&mdash;&ndash;操作系统中UTC=false，BIOS时间当成localtime&mdash;&mdash;&ndash;>CST（将BIOS中的时间看成是CST）</p>

<hr />

<p>通过设定 /etc/sysconfig/clock，linux可以支持这两种方式，然而windows只支持方式B（至少是默认支持B，而我不知道怎么能让它支 持A），那么在双系统情况下，如果linux设成A方式，那么在linux与windows系统切换时一定会造成时间混乱的，解决办法就是将linux中 的UTC禁用，也设成B方式就可以了。</p>

<p>注：可以通过 <code>hwclock --hctosys</code> 来利用硬件时间来设置系统时间（注意不是简单的复制BIOS中的时间为系统时间，要看是否使用UTC，如果使用的话则要做时区换算），通过 <code>hwclock --systohc</code> 来根据系统时间设置硬件时间（也要看是否启用UTC来决定是否做时区换算）。</p>

<p>总之，不论使用 <code>--systohc</code> 还是 <code>--hctosys</code>，同步后直接运行不带参数的 hwclock 得到的时间与直接运行 date 得到的时间应该一致，这个时间是否就是BIOS中的时间（<code>hwclock --localtime</code>)那就不一定了，如果启用了UTC就不是，没启用UTC就是。</p>

<p>而且还要注意：在系统中手动使用 <code>hwclock hwclock --set --date='yyyy-mm-dd'</code> 来设置BIOS时间只在系统运行时有效，因为当系统关闭时，还会按设定好的方式根据系统时间来重设BIOS时间的，于是手动的设置便被覆盖掉了。</p>
]]></content>
  </entry>
  
</feed>
