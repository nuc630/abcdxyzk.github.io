<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2011~11 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2011~11/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-11-26T12:16:21+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一个简单的 ptrace 例子]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/11/29/tools-ptrace-sample/"/>
    <updated>2011-11-29T20:16:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/11/29/tools-ptrace-sample</id>
    <content type="html"><![CDATA[<pre><code>    // test.cpp

    #include &lt;stdio.h&gt;

    int main()
    {
        printf("---------- test 1 ----------\n");
        printf("---------- test 2 ----------\n");
        printf("---------- test 3 ----------\n");
        return 0;
    }
</code></pre>

<p>编译 g++ test.cpp -o test &ndash;static
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// ptrace.cpp&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;sys/ptrace.h&gt;
</span><span class='line'>#include &lt;sys/types.h&gt;
</span><span class='line'>#include &lt;sys/wait.h&gt;
</span><span class='line'>#include &lt;sys/reg.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>pid_t pid;
</span><span class='line'>int orig_eax, eax, ebx, ecx, edx;
</span><span class='line'>
</span><span class='line'>pid = fork();
</span><span class='line'>if(pid == 0)
</span><span class='line'>{
</span><span class='line'>    ptrace(PTRACE_TRACEME, 0, NULL, NULL);
</span><span class='line'>    printf("execve = %d\n", execve("./test", NULL, NULL));
</span><span class='line'>    exit(0);
</span><span class='line'>}
</span><span class='line'>while(1)
</span><span class='line'>{
</span><span class='line'>    int status;
</span><span class='line'>    wait(&amp;status);
</span><span class='line'>    if(WIFEXITED(status)) break;
</span><span class='line'>
</span><span class='line'>    orig_eax = ptrace(PTRACE_PEEKUSER, pid, ORIG_EAX&lt;&lt;2, NULL);
</span><span class='line'>    eax = ptrace(PTRACE_PEEKUSER, pid, EAX&lt;&lt;2, NULL);
</span><span class='line'>    ebx = ptrace(PTRACE_PEEKUSER, pid, EBX&lt;&lt;2, NULL);
</span><span class='line'>
</span><span class='line'>    printf("ORIG_EAX = %d,        EAX = %d,        EBX = %d\n", orig_eax, eax, ebx);
</span><span class='line'>
</span><span class='line'>    ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
</span><span class='line'>}
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;编译 `g++ ptrace.cpp -o ptrace --static`  
</span><span class='line'>测试 `./ptrace` 输出
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ORIG_EAX = 11,        EAX = 0,        EBX = 0
</span><span class='line'>ORIG_EAX = 122,        EAX = -38,        EBX = -1074643290
</span><span class='line'>ORIG_EAX = 122,        EAX = 0,        EBX = -1074643290
</span><span class='line'>ORIG_EAX = 45,        EAX = -38,        EBX = 0
</span><span class='line'>ORIG_EAX = 45,        EAX = 161513472,        EBX = 0
</span><span class='line'>ORIG_EAX = 45,        EAX = -38,        EBX = 161516752
</span><span class='line'>ORIG_EAX = 45,        EAX = 161516752,        EBX = 161516752
</span><span class='line'>ORIG_EAX = 243,        EAX = -38,        EBX = -1074642896
</span><span class='line'>ORIG_EAX = 243,        EAX = 0,        EBX = -1074642896
</span><span class='line'>ORIG_EAX = 45,        EAX = -38,        EBX = 161651920
</span><span class='line'>ORIG_EAX = 45,        EAX = 161651920,        EBX = 161651920
</span><span class='line'>ORIG_EAX = 45,        EAX = -38,        EBX = 161652736
</span><span class='line'>ORIG_EAX = 45,        EAX = 161652736,        EBX = 161652736
</span><span class='line'>ORIG_EAX = 197,        EAX = -38,        EBX = 1
</span><span class='line'>ORIG_EAX = 197,        EAX = 0,        EBX = 1
</span><span class='line'>ORIG_EAX = 192,        EAX = -38,        EBX = 0
</span><span class='line'>ORIG_EAX = 192,        EAX = -1217093632,        EBX = 0
</span><span class='line'>ORIG_EAX = 4,        EAX = -38,        EBX = 1
</span><span class='line'>&mdash;&mdash;&mdash;- test 1 &mdash;&mdash;&mdash;-
</span><span class='line'>ORIG_EAX = 4,        EAX = 29,        EBX = 1
</span><span class='line'>ORIG_EAX = 4,        EAX = -38,        EBX = 1
</span><span class='line'>&mdash;&mdash;&mdash;- test 2 &mdash;&mdash;&mdash;-
</span><span class='line'>ORIG_EAX = 4,        EAX = 29,        EBX = 1
</span><span class='line'>ORIG_EAX = 4,        EAX = -38,        EBX = 1
</span><span class='line'>&mdash;&mdash;&mdash;- test 3 &mdash;&mdash;&mdash;-
</span><span class='line'>ORIG_EAX = 4,        EAX = 29,        EBX = 1
</span><span class='line'>ORIG_EAX = 252,        EAX = -38,        EBX = 0</span></code></pre></td></tr></table></div></figure>
内核 Linux 2.6.32-35-generic</p>

<p>ubuntu 10.04
linux 系统调用号 /usr/include/asm/unistd_32.h<br/>
linux 系统EAX等值 /usr/include/sys/reg.h</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Playing with ptrace, Part I — 玩转ptrace(二)]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/11/29/tools-ptrace-ii/"/>
    <updated>2011-11-29T19:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/11/29/tools-ptrace-ii</id>
    <content type="html"><![CDATA[<p><a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_ii/">本文地址</a></p>

<p>版权所有 © 转载时必须以链接形式注明作者和原始出处！</p>

<p>Playing with ptrace, Part II<br/>
by Pradeep Padala <code>p_padala@yahoo.com</code> <a href="http://www.cise.ufl.edu/~ppadala  ">http://www.cise.ufl.edu/~ppadala  </a>
Created 2002-11-01 02:00</p>

<p>翻译: Magic.D E-mail: <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x61;&#100;&#x61;&#109;&#103;&#x69;&#x63;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;">&#97;&#100;&#97;&#x6d;&#103;&#x69;&#x63;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;</a></p>

<p>在第一部分中我们已经看到ptrace怎么获取子进程的系统调用以及改变系统调用的参数。在这篇文章中，我们将要研究如何在子进程中设置断点和往运行中的程序里插入代码。实际上调试器就是用这种方法来设置断点和执行调试句柄。与前面一样，这里的所有代码都是针对i386平台的。<br/>
附着在进程上</p>

<p>在第一部分钟，我们使用ptrace(PTRACE_TRACEME, …)来跟踪一个子进程，如果你只是想要看进程是怎么进行系统调用和跟踪程序的，这个做法是不错的。但如果你要对运行中的进程进行调试，则需要使用 ptrace( PTRACE_ATTACH, ….)</p>

<p>当 ptrace( PTRACE_ATTACH, …)在被调用的时候传入了子进程的pid时， 它大体是与ptrace( PTRACE_TRACEME, …)的行为相同的，它会向子进程发送SIGSTOP信号，于是我们可以察看和修改子进程，然后使用 ptrace( PTRACE_DETACH, …)来使子进程继续运行下去。</p>

<p>下面是调试程序的一个简单例子
<code>
    int main()
    {
        int i;
        for(i = 0;i &lt; 10; ++i) {
            printf("My counter: %d ", i);
            sleep(2);
        }
        return 0;
    }
</code>
将上面的代码保存为dummy2.c。按下面的方法编译运行：<br/>
gcc -o dummy2 dummy2.c<br/>
./dummy2 &amp;</p>

<p>现在我们可以用下面的代码来附着到dummy2上。
<code>
    #include &lt;sys/ptrace.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/wait.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;linux/user.h&gt;   /* For user_regs_struct
                                 etc. */
    int main(int argc, char *argv[])
    {
        pid_t traced_process;
        struct user_regs_struct regs;
        long ins;
        if(argc != 2) {
            printf("Usage: %s &lt;pid to be traced&gt;\n",
                argv[0], argv[1]);
            exit(1);
        }
        traced_process = atoi(argv[1]);
        ptrace(PTRACE_ATTACH, traced_process,
            NULL, NULL);
        wait(NULL);
        ptrace(PTRACE_GETREGS, traced_process,
            NULL, &amp;regs);
        ins = ptrace(PTRACE_PEEKTEXT, traced_process,
            regs.eip, NULL);
        printf("EIP: %lx Instruction executed: %lx\n",
            regs.eip, ins);
        ptrace(PTRACE_DETACH, traced_process,
            NULL, NULL);
        return 0;
    }
</code>
上面的程序仅仅是附着在子进程上，等待它结束，并测量它的eip( 指令指针)然后释放子进程。
设置断点</p>

<p>调试器是怎么设置断点的呢？通常是将当前将要执行的指令替换成trap指令，于是被调试的程序就会在这里停滞，这时调试器就可以察看被调试程序的信息了。被调试程序恢复运行以后调试器会把原指令再放回来。这里是一个例子：
<code>
    #include &lt;sys/ptrace.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/wait.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;linux/user.h&gt;
    const int long_size = sizeof(long);
    void getdata(pid_t child, long addr, char *str, int len)
    {
        char *laddr;
        int i, j;
        union u {
            long val;
            char chars[long_size];
        } data;
        i = 0;
        j = len / long_size;
        laddr = str;
        while(i &lt; j) {
            data.val = ptrace(PTRACE_PEEKDATA, child,
                addr + i * 4, NULL);
            memcpy(laddr, data.chars, long_size);
            ++i;
            laddr += long_size;
        }
        j = len % long_size;
        if(j != 0) {
            data.val = ptrace(PTRACE_PEEKDATA, child,
                addr + i * 4, NULL);
            memcpy(laddr, data.chars, j);
        }
        str[len] = '\0';
    }
    void putdata(pid_t child, long addr, char *str, int len)
    {
        char *laddr;
        int i, j;
        union u {
            long val;
            char chars[long_size];
        } data;
        i = 0;
        j = len / long_size;
        laddr = str;
        while(i &lt; j) {
            memcpy(data.chars, laddr, long_size);
            ptrace(PTRACE_POKEDATA, child,
                addr + i * 4, data.val);
            ++i;
            laddr += long_size;
        }
        j = len % long_size;
        if(j != 0) {
            memcpy(data.chars, laddr, j);
            ptrace(PTRACE_POKEDATA, child,
                addr + i * 4, data.val);
        }
    }
    int main(int argc, char *argv[])
    {
        pid_t traced_process;
        struct user_regs_struct regs, newregs;
        long ins;
        /* int 0x80, int3 */
        char code[] = {0xcd,0x80,0xcc,0};
        char backup[4];
        if(argc != 2) {
            printf("Usage: %s &lt;pid to be traced&gt;\n",
                argv[0], argv[1]);
            exit(1);
        }
        traced_process = atoi(argv[1]);
        ptrace(PTRACE_ATTACH, traced_process,
            NULL, NULL);
        wait(NULL);
        ptrace(PTRACE_GETREGS, traced_process,
            NULL, &amp;regs);
        /* Copy instructions into a backup variable */
        getdata(traced_process, regs.eip, backup, 3);
        /* Put the breakpoint */
        putdata(traced_process, regs.eip, code, 3);
        /* Let the process continue and execute
           the int 3 instruction */
        ptrace(PTRACE_CONT, traced_process, NULL, NULL);
        wait(NULL);
        printf("The process stopped, putting back "
            "the original instructions\n");
        printf("Press &lt;enter&gt; to continue\n");
        getchar();
        putdata(traced_process, regs.eip, backup, 3);
        /* Setting the eip back to the original
           instruction to let the process continue */
        ptrace(PTRACE_SETREGS, traced_process,
            NULL, &amp;regs);
        ptrace(PTRACE_DETACH, traced_process,
            NULL, NULL);
        return 0;
    }
</code>
上面的程序将把三个byte的内容进行替换以执行trap指令，等被调试进程停滞以后，我们把原指令再替换回来并把eip修改为原来的值。下面的图中演示了指令的执行过程<br/>
1. 进程停滞后<br/>
2. 替换入trap指令<br/>
3.断点成功，控制权交给了调试器<br/>
4. 继续运行，将原指令替换回来并将eip复原<br/>
在了解了断点的机制以后，往运行中的程序里面添加指令也不再是难事了，下面的代码会使原程序多出一个”hello world”的输出</p>

<p>这时一个简单的”hello world”程序，当然为了我们的特殊需要作了点修改：
<code>
    void main()
    {
        __asm__("
            jmp forward
            backward:
                popl   %esi # Get the address of
                        # hello world string
                movl   $4, %eax # Do write system call
                movl   $2, %ebx
                movl   %esi, %ecx
                movl   $12, %edx
                int $0x80
                int3        # Breakpoint. Here the
                        # program will stop and
                        # give control back to
                        # the parent
            forward:
                call   backward
                .string \"Hello World\\n\""
        );
    }
</code>
使用
gcc -o hello hello.c<br/>
来编译它。<br/>
在backward和forward之间的跳转是为了使程序能够找到”hello world” 字符串的地址。<br/>
使用GDB我们可以得到上面那段程序的机器码。启动GDB,然后对程序进行反汇编：
<code>
(gdb) disassemble main
Dump of assembler code forfunction main:
0x80483e0&lt;main&gt;:       push   %ebp
0x80483e1&lt;main+1&gt;:   mov    %esp,%ebp
0x80483e3&lt;main+3&gt;:   jmp    0x80483fa&lt;forward&gt;
End of assembler dump.
(gdb) disassemble forward
Dump of assembler code forfunction forward:
0x80483fa&lt;forward&gt;: call   0x80483e5&lt;backward&gt;
0x80483ff&lt;forward+5&gt;:  dec  %eax
0x8048400&lt;forward+6&gt;:  gs
0x8048401&lt;forward+7&gt;:  insb   (%dx),%es:(%edi)
0x8048402&lt;forward+8&gt;:  insb   (%dx),%es:(%edi)
0x8048403&lt;forward+9&gt;:  outsl  %ds:(%esi),(%dx)
0x8048404&lt;forward+10&gt;: and  %dl,0x6f(%edi)
0x8048407&lt;forward+13&gt;: jb    0x8048475
0x8048409&lt;forward+15&gt;: or    %fs:(%eax),%al
0x804840c&lt;forward+18&gt;: mov  %ebp,%esp
0x804840e&lt;forward+20&gt;: pop  %ebp
0x804840f&lt;forward+21&gt;: ret
End of assembler dump.
(gdb) disassemble backward
Dump of assembler code forfunction backward:
0x80483e5&lt;backward&gt;:   pop  %esi
0x80483e6&lt;backward+1&gt;: mov  $0x4,%eax
0x80483eb&lt;backward+6&gt;: mov  $0x2,%ebx
0x80483f0&lt;backward+11&gt;:     mov %esi,%ecx
0x80483f2&lt;backward+13&gt;:     mov $0xc,%edx
0x80483f7&lt;backward+18&gt;:int  $0x80
0x80483f9&lt;backward+20&gt;:     int3
End of assembler dump.
</code>
我们需要使用从man+3到backward+20之间的字节码，总共41字节。使用GDB中的x命令来察看机器码。
<code>
(gdb) x/40bx main+3
&lt;main+3&gt;: eb 15 5e b8 04000000
&lt;backward+6&gt;: bb 0200000089 f1 ba
&lt;backward+14&gt;: 0c 000000 cd 80 cc
&lt;forward+1&gt;: e6 ff ff ff 4865 6c 6c
&lt;forward+9&gt;:6f20576f72 6c 64 0a
</code>
已经有了我们想要执行的指令，还等什么呢？只管把它们根前面那个例子一样插入到被调试程序中去！</p>

<p>代码：
<code>
    int main(int argc,char*argv[])
    {
        pid_t traced_process;
        struct user_regs_struct regs, newregs;
        long ins;
        int len =41;
        char insertcode[]=
            "\xeb\x15\x5e\xb8\x04\x00"
            "\x00\x00\xbb\x02\x00\x00\x00\x89\xf1\xba"
            "\x0c\x00\x00\x00\xcd\x80\xcc\xe8\xe6\xff"
            "\xff\xff\x48\x65\x6c\x6c\x6f\x20\x57\x6f"
            "\x72\x6c\x64\x0a\x00";
        char backup[len];
        if(argc != 2) {
            printf("Usage: %s &lt;pid to be traced&gt;\n",
                argv[0], argv[1]);
            exit(1);
        }
        traced_process = atoi(argv[1]);
        ptrace(PTRACE_ATTACH, traced_process,
            NULL, NULL);
        wait(NULL);
        ptrace(PTRACE_GETREGS, traced_process,
            NULL,&amp;regs);
        getdata(traced_process, regs.eip, backup, len);
        putdata(traced_process, regs.eip,
            insertcode, len);
        ptrace(PTRACE_SETREGS, traced_process,
            NULL,&amp;regs);
        ptrace(PTRACE_CONT, traced_process,
            NULL, NULL);
        wait(NULL);
        printf("The process stopped, Putting back the original instructions\n");
        putdata(traced_process, regs.eip, backup, len);
        ptrace(PTRACE_SETREGS, traced_process,
            NULL,&amp;regs);
        printf("Letting it continue with original flow\n");
        ptrace(PTRACE_DETACH, traced_process,
            NULL, NULL);
        return0;
    }
</code>
将代码插入到自由空间</p>

<p>在前面的例子中我们将代码直接插入到了正在执行的指令流中，然而，调试器可能会被这种行为弄糊涂，所以我们决定把指令插入到进程中的自由空间中去。通过察看/proc/pid/maps可以知道这个进程中自由空间的分布。接下来这个函数可以找到这个内存映射的起始点：
<code>
    long freespaceaddr(pid_t pid)
    {
        FILE *fp;
        char filename[30];
        char line[85];
        long addr;
        char str[20];
        sprintf(filename,"/proc/%d/maps", pid);
        fp = fopen(filename,"r");
        if(fp == NULL)
            exit(1);
        while(fgets(line,85, fp) != NULL) {
            sscanf(line,"%lx-%*lx %*s %*s %s",&amp;addr,
                str, str, str, str);
            if(strcmp(str,"00:00")==0)
                break;
        }
        fclose(fp);
        return addr;
    }
</code>
在/proc/pid/maps中的每一行都对应了进程中一段内存区域。主函数的代码如下：
<code>
    int main(int argc,char*argv[])
    {
        pid_t traced_process;
        struct user_regs_struct oldregs, regs;
        long ins;
        int len =41;
        char insertcode[]=
            "\xeb\x15\x5e\xb8\x04\x00"
            "\x00\x00\xbb\x02\x00\x00\x00\x89\xf1\xba"
            "\x0c\x00\x00\x00\xcd\x80\xcc\xe8\xe6\xff"
            "\xff\xff\x48\x65\x6c\x6c\x6f\x20\x57\x6f"
            "\x72\x6c\x64\x0a\x00";
        char backup[len];
        long addr;
        if(argc !=2){
            printf("Usage: %s &lt;pid to be traced&gt;\n",
                argv[0], argv[1]);
                exit(1);
        }
        traced_process = atoi(argv[1]);
        ptrace(PTRACE_ATTACH, traced_process,
            NULL, NULL);
        wait(NULL);
        ptrace(PTRACE_GETREGS, traced_process,
            NULL,&amp;regs);
        addr = freespaceaddr(traced_process);
        getdata(traced_process, addr, backup, len);
        putdata(traced_process, addr, insertcode, len);
        memcpy(&amp;oldregs,&amp;regs,sizeof(regs));
        regs.eip= addr;
        ptrace(PTRACE_SETREGS, traced_process,
            NULL,&amp;regs);
        ptrace(PTRACE_CONT, traced_process,
            NULL, NULL);
        wait(NULL);
        printf("The process stopped, Putting back the original instructions\n");
        putdata(traced_process, addr, backup, len);
        ptrace(PTRACE_SETREGS, traced_process,
            NULL,&amp;oldregs);
        printf("Letting it continue with original flow\n");
        ptrace(PTRACE_DETACH, traced_process,
            NULL, NULL);
        return0;
    }
</code>
ptrace的幕后工作</p>

<p>那么，在使用ptrace的时候，内核里发生了声么呢？这里有一段简要的说明：当一个进程调用了 ptrace( PTRACE_TRACEME, …)之后，内核为该进程设置了一个标记，注明该进程将被跟踪。内核中的相关原代码如下：
<code>
Source: arch/i386/kernel/ptrace.c
    if(request == PTRACE_TRACEME){
        /* are we already being traced? */
        if(current-&gt;ptrace &amp; PT_PTRACED)
            goto out;
        /* set the ptrace bit in the process flags. */
        current-&gt;ptrace |= PT_PTRACED;
        ret =0;
        goto out;
    }
</code>
一次系统调用完成之后，内核察看那个标记，然后执行trace系统调用（如果这个进程正处于被跟踪状态的话）。其汇编的细节可以在 arh/i386/kernel/entry.S中找到。</p>

<p>现在让我们来看看这个sys_trace()函数（位于 arch/i386/kernel/ptrace.c ）。它停止子进程，然后发送一个信号给父进程，告诉它子进程已经停滞，这个信号会激活正处于等待状态的父进程，让父进程进行相关处理。父进程在完成相关操作以后就调用ptrace( PTRACE_CONT, …)或者 ptrace( PTRACE_SYSCALL, …), 这将唤醒子进程，内核此时所作的是调用一个叫wake_up_process() 的进程调度函数。其他的一些系统架构可能会通过发送SIGCHLD给子进程来达到这个目的。
小结：</p>

<p>ptrace函数可能会让人们觉得很奇特，因为它居然可以检测和修改一个运行中的程序。这种技术主要是在调试器和系统调用跟踪程序中使用。它使程序员可以在用户级别做更多有意思的事情。已经有过很多在用户级别下扩展操作系统得尝试，比如UFO,一个用户级别的文件系统扩展，它使用ptrace来实现一些安全机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Playing with ptrace, Part I — 玩转ptrace(一)]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/11/29/tools-ptrace-i/"/>
    <updated>2011-11-29T19:20:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/11/29/tools-ptrace-i</id>
    <content type="html"><![CDATA[<p><a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/">原文</a><br/>
版权所有 © 转载时必须以链接形式注明作者和原始出处！</p>

<p> Playing with ptrace, Part I<br/>
by Pradeep Padala <code>p_padala@yahoo.com</code> <a href="http://www.cise.ufl.edu/~ppadala  ">http://www.cise.ufl.edu/~ppadala  </a>
Created 2002-11-01 02:00</p>

<p>翻译: Magic.D E-mail: adamgic@163.com<br/>
译者序：</p>

<p>在开发Hust Online Judge的过程中，查阅了不少资料，关于调试器技术的资料在网上是很少，即便是UNIX编程巨著《UNIX环境高级编程》中，相关内容也不多，直到我在 <a href="http://www.linuxjournal.com">http://www.linuxjournal.com</a> 上找到这篇文章，如获至宝，特翻译之，作为鄙人翻译技术文档的第一次尝试，必定会有不少蹩脚之处，各位就将就一下吧，欢迎大力拍砖。</p>

<p>你想过怎么实现对系统调用的拦截吗？你尝试过通过改变系统调用的参数来愚弄你的系统kernel吗？你想过调试器是如何使运行中的进程暂停并且控制它吗？</p>

<p>你可能会开始考虑怎么使用复杂的kernel编程来达到目的，那么，你错了。实际上Linux提供了一种优雅的机制来完成这些：ptrace系统函数。 ptrace提供了一种使父进程得以监视和控制其它进程的方式，它还能够改变子进程中的寄存器和内核映像，因而可以实现断点调试和系统调用的跟踪。</p>

<p>使用ptrace，你可以在用户层拦截和修改系统调用(sys call)</p>

<p>在这篇文章中，我们将学习如何拦截一个系统调用，然后修改它的参数。在本文的第二部分我们将学习更先进的技术：设置断点，插入代码到一个正在运行的程序中；我们将潜入到机器内部，偷窥和纂改进程的寄存器和数据段。</p>

<h4>基本知识</h4>

<p>操作系统提供了一种标准的服务来让程序员实现对底层硬件和服务的控制（比如文件系统），叫做系统调用(system calls)。当一个程序需要作系统调用的时候，它将相关参数放进系统调用相关的寄存器，然后调用软中断0×80，这个中断就像一个让程序得以接触到内核模式的窗口，程序将参数和系统调用号交给内核，内核来完成系统调用的执行。</p>

<p>在i386体系中(本文中所有的代码都是面向i386体系)，系统调用号将放入%eax,它的参数则依次放入%ebx, %ecx, %edx, %esi 和 %edi。 比如，在以下的调用
<code>
    Write(2, “Hello”, 5)
</code>
的汇编形式大概是这样的
<code>
    movl $4, %eax
    movl $2, %ebx
    movl $hello, %ecx
    movl $5, %edx
    int $0×80
</code>
这里的$hello指向的是标准字符串”Hello”。</p>

<p>那么，ptrace会在什么时候出现呢？在执行系统调用之前，内核会先检查当前进程是否处于被“跟踪”(traced)的状态。如果是的话，内核暂停当前进程并将控制权交给跟踪进程，使跟踪进程得以察看或者修改被跟踪进程的寄存器。</p>

<p>让我们来看一个例子，演示这个跟踪程序的过程
<code>
    #include &lt;sys/ptrace.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/wait.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;linux/user.h&gt; /* For constants
                   ORIG_EAX etc */
    int main()
    {
        pid_t child;
        long orig_eax;
        child = fork();
        if(child ==0){
            ptrace(PTRACE_TRACEME,0, NULL, NULL);
            execl("/bin/ls","ls", NULL);
        } else {
            wait(NULL);
            orig_eax = ptrace(PTRACE_PEEKUSER,
                          child,4* ORIG_EAX,
                          NULL);
            printf("The child made a "
                "system call %ld\n", orig_eax);
            ptrace(PTRACE_CONT, child, NULL, NULL);
        }
        return0;
    }
</code>
运行这个程序，将会在输出ls命令的结果的同时，输出:
The child made a system call 11</p>

<p>说明：11是execve的系统调用号，这是该程序调用的第一个系统调用。<br/>
想知道系统调用号的详细内容，察看 /usr/include/asm/unistd.h。</p>

<p>在以上的示例中，父进程fork出了一个子进程，然后跟踪它。在调用exec函数之前，子进程用PTRACE_TRACEME作为第一个参数调用了 ptrace函数，它告诉内核：让别人跟踪我吧！然后，在子进程调用了execve()之后，它将控制权交还给父进程。当时父进程正使用wait()函数来等待来自内核的通知，现在它得到了通知，于是它可以开始察看子进程都作了些什么，比如看看寄存器的值之类。</p>

<p>出现系统调用之后，内核会将eax中的值（此时存的是系统调用号）保存起来，我们可以使用PTRACE_PEEKUSER作为ptrace的第一个参数来读到这个值。<br/>
我们察看完系统调用的信息后，可以使用PTRACE_CONT作为ptrace的第一个参数，调用ptrace使子进程继续系统调用的过程。<br/>
ptrace函数的参数<br/>
Ptrace有四个参数<br/>
<code>
    long ptrace(enum __ptrace_request request,
        pid_t pid,
        void *addr,
        void *data);
</code>
第一个参数决定了ptrace的行为与其它参数的使用方法，可取的值有:
<code>
    PTRACE_ME
    PTRACE_PEEKTEXT
    PTRACE_PEEKDATA
    PTRACE_PEEKUSER
    PTRACE_POKETEXT
    PTRACE_POKEDATA
    PTRACE_POKEUSER
    PTRACE_GETREGS
    PTRACE_GETFPREGS,
    PTRACE_SETREGS
    PTRACE_SETFPREGS
    PTRACE_CONT
    PTRACE_SYSCALL,
    PTRACE_SINGLESTEP
    PTRACE_DETACH
</code>
在下文中将对这些常量的用法进行说明。<br/>
读取系统调用的参数</p>

<p>通过将PTRACE_PEEKUSER作为ptrace 的第一个参数进行调用，可以取得与子进程相关的寄存器值。</p>

<p>先看下面这个例子
<code>
    #include &lt;sys/ptrace.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/wait.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;linux/user.h&gt;
    #include &lt;sys/syscall.h&gt;   /* For SYS_write etc */
    int main()
    {
        pid_t child;
        long orig_eax, eax;
        long params[3];
        int status;
        int insyscall =0;
        child = fork();
        if(child ==0){
            ptrace(PTRACE_TRACEME,0, NULL, NULL);
            execl("/bin/ls","ls", NULL);
        } else {
            while(1) {
                wait(&amp;status);
                if(WIFEXITED(status))
                break;
                orig_eax = ptrace(PTRACE_PEEKUSER,
                child,4* ORIG_EAX, NULL);
                if(orig_eax == SYS_write) {
                    if(insyscall == 0) {
                        /* Syscall entry */
                        insyscall =1;
                        params[0]= ptrace(PTRACE_PEEKUSER,
                                child,4* EBX,
                                NULL);
                        params[1]= ptrace(PTRACE_PEEKUSER,
                                child,4* ECX,
                                NULL);
                        params[2]= ptrace(PTRACE_PEEKUSER,
                                child,4* EDX,
                                NULL);
                        printf("Write called with "
                                "%ld, %ld, %ld\n",
                                params[0], params[1],
                                params[2]);
                    } else {/* Syscall exit */
                        eax = ptrace(PTRACE_PEEKUSER,
                            child,4* EAX, NULL);
                        printf("Write returned "
                            "with %ld\n", eax);
                                insyscall =0;
                    }
                }
                ptrace(PTRACE_SYSCALL,
                    child, NULL, NULL);
            }
        }
        return0;
    }
</code>
这个程序的输出是这样的
<code>
    ppadala@linux:~/ptrace &gt; ls
    a.out        dummy.s      ptrace.txt
    libgpm.html  registers.c  syscallparams.c
    dummy        ptrace.html  simple.c
    ppadala@linux:~/ptrace &gt; ./a.out
    Write called with 1,1075154944,48
    a.out        dummy.s      ptrace.txt
    Write returned with 48
    Write called with 1,1075154944,59
    libgpm.html  registers.c  syscallparams.c
    Write returned with 59
    Write called with 1,1075154944,30
    dummy        ptrace.html  simple.c
    Write returned with 30
</code></p>

<p>以上的例子中我们跟踪了write系统调用，而ls命令的执行将产生三个write系统调用。使用PTRACE_SYSCALL作为ptrace的第一个参数，使内核在子进程做出系统调用或者准备退出的时候暂停它。这种行为与使用PTRACE_CONT，然后在下一个系统调用/进程退出时暂停它是等价的。</p>

<p>在前一个例子中，我们用PTRACE_PEEKUSER来察看write系统调用的参数。系统调用的返回值会被放入%eax。</p>

<p>wait函数使用status变量来检查子进程是否已退出。它是用来判断子进程是被ptrace暂停掉还是已经运行结束并退出。有一组宏可以通过status的值来判断进程的状态，比如WIFEXITED等，详情可以察看wait(2) man。
读取寄存器的值</p>

<p>如果你想在系统调用或者进程终止的时候读取它的寄存器，使用前面那个例子的方法是可以的，但是这是笨拙的方法。使用PRACE_GETREGS作为ptrace的第一个参数来调用，可以只需一次函数调用就取得所有的相关寄存器值。
获得寄存器值得例子如下：</p>

<pre><code>    #include &lt;sys/ptrace.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/wait.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;linux/user.h&gt;
    #include &lt;sys/syscall.h&gt;
    int main()
    {
        pid_t child;
        long orig_eax, eax;
        long params[3];
        int status;
        int insyscall =0;
        struct user_regs_struct regs;
        child = fork();
        if(child == 0) {
            ptrace(PTRACE_TRACEME,0, NULL, NULL);
            execl("/bin/ls","ls", NULL);
        } else {
            while(1) {
                wait(&amp;status);
                if(WIFEXITED(status))
                break;
                orig_eax = ptrace(PTRACE_PEEKUSER,
                    child,4* ORIG_EAX,
                    NULL);
                if(orig_eax == SYS_write) {
                    if(insyscall == 0) {
                        /* Syscall entry */
                        insyscall =1;
                        ptrace(PTRACE_GETREGS, child,
                            NULL,&amp;regs);
                        printf("Write called with "
                            "%ld, %ld, %ld\n",
                            regs.ebx, regs.ecx,
                            regs.edx);
                    } else { /* Syscall exit */
                        eax = ptrace(PTRACE_PEEKUSER,
                            child,4* EAX,
                            NULL);
                        printf("Write returned "
                            "with %ld\n", eax);
                            insyscall =0;
                    }
                }
                ptrace(PTRACE_SYSCALL, child,
                    NULL, NULL);
            }
        }
        return0;
    }
</code></pre>

<p>这段代码与前面的例子是比较相似的，不同的是它使用了PTRACE_GETREGS。 其中的user_regs_struct结构是在中定义的。<br/>
来点好玩的</p>

<p>现在该做点有意思的事情了，我们将要把传给write系统调用的字符串给反转。</p>

<pre><code>    #include &lt;sys/ptrace.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/wait.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;linux/user.h&gt;
    #include &lt;sys/syscall.h&gt;
    constint long_size =sizeof(long);
    void reverse(char*str)
    {
        int i, j;
        char temp;
        for(i =0, j = strlen(str)-2;
            i &lt;= j;++i,--j){
            temp = str[i];
            str[i]= str[j];
            str[j]= temp;
        }
    }
    void getdata(pid_t child,long addr, char*str,int len)
    {
        char*laddr;
        int i, j;
        union u {
            long val;
            char chars[long_size];
        } data;
        i =0;
        j = len / long_size;
        laddr = str;
        while(i &lt; j) {
            data.val= ptrace(PTRACE_PEEKDATA,
                child, addr + i *4,
                NULL);
            memcpy(laddr, data.chars, long_size);
            ++i;
            laddr += long_size;
        }
        j = len % long_size;
        if(j != 0) {
            data.val= ptrace(PTRACE_PEEKDATA,
                child, addr + i *4,
                NULL);
            memcpy(laddr, data.chars, j);
        }
        str[len]='\0';
    }
    void putdata(pid_t child,long addr, char*str,int len)
    {
        char*laddr;
        int i, j;
        union u {
            long val;
            char chars[long_size];
        } data;
        i =0;
        j = len / long_size;
        laddr = str;
        while(i &lt; j) {
            memcpy(data.chars, laddr, long_size);
            ptrace(PTRACE_POKEDATA, child,
                addr + i *4, data.val);
                ++i;
            laddr += long_size;
        }
        j = len % long_size;
        if(j != 0) {
            memcpy(data.chars, laddr, j);
            ptrace(PTRACE_POKEDATA, child,
            addr + i *4, data.val);
        }
    }
    int main()
    {
        pid_t child;
        child = fork();
        if(child ==0){
            ptrace(PTRACE_TRACEME,0, NULL, NULL);
            execl("/bin/ls","ls", NULL);
        } else {
            long orig_eax;
            long params[3];
            int status;
            char*str,*laddr;
            int toggle =0;
            while(1) {
                wait(&amp;status);
                if(WIFEXITED(status))
                break;
                orig_eax = ptrace(PTRACE_PEEKUSER,
                    child,4* ORIG_EAX,
                    NULL);
                if(orig_eax == SYS_write){
                    if(toggle ==0){
                    toggle =1;
                    params[0]= ptrace(PTRACE_PEEKUSER,
                        child,4* EBX,
                        NULL);
                    params[1]= ptrace(PTRACE_PEEKUSER,
                        child,4* ECX,
                        NULL);
                    params[2]= ptrace(PTRACE_PEEKUSER,
                        child,4* EDX,
                        NULL);
                    str =(char*)calloc((params[2]+1) * sizeof(char));
                    getdata(child, params[1], str, params[2]);
                    reverse(str);
                    putdata(child, params[1], str, params[2]);
                } else {
                    toggle =0;
                }
            }
            ptrace(PTRACE_SYSCALL, child, NULL, NULL);
            }
        }
        return0;
    }
</code></pre>

<p>输出是这样的：</p>

<pre><code>    ppadala@linux:~/ptrace &gt; ls
    a.out dummy.s ptrace.txt
    libgpm.html registers.c syscallparams.c
    dummy ptrace.html simple.c
    ppadala@linux:~/ptrace &gt; ./a.out
    txt.ecartp s.ymmud tuo.a
    c.sretsiger lmth.mpgbil c.llacys_egnahc
    c.elpmis lmth.ecartp ymmud
</code></pre>

<p>这个例子中涵盖了前面讨论过的所有知识点，当然还有些新的内容。这里我们用PTRACE_POKEDATA作为第一个参数，以此来改变子进程中的变量值。它以与PTRACE_PEEKDATA相似的方式工作，当然，它不只是偷窥变量的值了，它可以修改它们。</p>

<h4>单步</h4>

<p>ptrace 提供了对子进程进行单步的功能。 ptrace(PTRACE_SINGLESTEP, …) 会使内核在子进程的每一条指令执行前先将其阻塞，然后将控制权交给父进程。下面的例子可以查出子进程当前将要执行的指令。为了便于理解，我用汇编写了这个受控程序，而不是让你为c的库函数到底会作那些系统调用而头痛。</p>

<p>以下是被控程序的代码 dummy1.s，使用gcc –o dummy1 dummy1.s来编译</p>

<pre><code>    .data
    hello:
        .string"hello world\n"
    .globl main
    main:
        movl $4,%eax
        movl $2,%ebx
        movl $hello,%ecx
        movl $12,%edx
    int $0x80
        movl $1,%eax
        xorl %ebx,%ebx
    int $0x80
        ret
</code></pre>

<p>以下的程序则用来完成单步</p>

<pre><code>    #include &lt;sys/ptrace.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/wait.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;linux/user.h&gt;
    #include &lt;sys/syscall.h&gt;
    int main()
    {
        pid_t child;
        const int long_size =sizeof(long);
        child = fork();
        if(child ==0){
            ptrace(PTRACE_TRACEME,0, NULL, NULL);
            execl("./dummy1","dummy1", NULL);
        } else {
            int status;
            union u {
            long val;
            char chars[long_size];
        } data;
        struct user_regs_struct regs;
        int start =0;
        long ins;
        while(1) {
            wait(&amp;status);
            if(WIFEXITED(status))
            break;
            ptrace(PTRACE_GETREGS, child, NULL,&amp;regs);
            if(start ==1){
                ins = ptrace(PTRACE_PEEKTEXT,
                    child, regs.eip,
                    NULL);
                printf("EIP: %lx Instruction executed: %lx ",
                    regs.eip, ins);
            }
            if(regs.orig_eax== SYS_write){
                start =1;
                ptrace(PTRACE_SINGLESTEP, child, NULL, NULL);
            }
            else
                ptrace(PTRACE_SYSCALL, child, NULL, NULL);
            }
        }
        return0;
    }
</code></pre>

<p>程序的输出是这样的：<br/>
你可能需要察看Intel的用户手册来了解这些指令代码的意思。<br/>
更复杂的单步，比如设置断点，则需要很仔细的设计和更复杂的代码才可以实现。</p>

<p>在第二部分，我们将会看到如何在程序中加入断点，以及将代码插入到已经在运行的程序中</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux ptrace函数]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/11/29/tools-ptrace/"/>
    <updated>2011-11-29T19:05:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/11/29/tools-ptrace</id>
    <content type="html"><![CDATA[<pre><code>    #include &lt;sys/ptrace.h&gt;
    int ptrace(int request, int pid, int addr, int data);
</code></pre>

<h5>描述</h5>

<p>Ptrace提供了一种父进程可以控制子进程运行，并可以检查和改变它的核心image。它主要用于实现断点调试。一个被跟踪的进程运行中，直到发生一个信号。则进程被中止，并且通知其父进程。在进程中止的状态下，进程的内存空间可以被读写。父进程还可以使子进程继续执行，并选择是否是否忽略引起中止的信号。</p>

<!--more-->


<p>Request参数决定了系统调用的功能：</p>

<p>PTRACE_TRACEME<br/>
本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。</p>

<p>PTRACE_PEEKTEXT, PTRACE_PEEKDATA<br/>
从内存地址中读取一个字节，内存地址由addr给出。</p>

<p>PTRACE_PEEKUSR<br/>
从USER区域中读取一个字节，偏移量为addr。</p>

<p>PTRACE_POKETEXT, PTRACE_POKEDATA<br/>
往内存地址中写入一个字节。内存地址由addr给出。</p>

<p>PTRACE_POKEUSR<br/>
往USER区域中写入一个字节。偏移量为addr。</p>

<p>PTRACE_SYSCALL, PTRACE_CONT<br/>
重新运行。</p>

<p>PTRACE_KILL<br/>
杀掉子进程，使它退出。</p>

<p>PTRACE_SINGLESTEP<br/>
设置单步执行标志</p>

<p>PTRACE_ATTACH<br/>
跟踪指定pid 进程。</p>

<p>PTRACE_DETACH<br/>
结束跟踪</p>

<p>Intel386特有：
PTRACE_GETREGS<br/>
读取寄存器</p>

<p>PTRACE_SETREGS<br/>
设置寄存器</p>

<p>PTRACE_GETFPREGS<br/>
读取浮点寄存器</p>

<p>PTRACE_SETFPREGS<br/>
设置浮点寄存器
init进程不可以使用此函数</p>

<h5>返回值</h5>

<p>成功返回0。错误返回-1。errno被设置。</p>

<h5>错误</h5>

<p>EPERM<br/>
特殊进程不可以被跟踪或进程已经被跟踪。</p>

<p>ESRCH<br/>
指定的进程不存在</p>

<p>EIO<br/>
请求非法ptrace系统函数。</p>

<p>ptrace提供了一种使父进程得以监视和控制其它进程的方式，它还能够改变子进程中的寄存器和内核映像，因而可以实现断点调试和系统调用的跟踪。使用ptrace，你可以在用户层拦截和修改系统调用(syscall).</p>

<h5>功能详细描述</h5>

<p>1)   PTRACE_TRACEME<br/>
形式：ptrace(PTRACE_TRACEME,0 ,0 ,0)<br/>
描述：本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。</p>

<p>2)  PTRACE_PEEKTEXT,PTRACE_PEEKDATA<br/>
形式：ptrace(PTRACE_PEEKTEXT, pid, addr, data)<br/>
描述：从内存地址中读取一个字节，pid表示被跟踪的子进程，内存地址由addr给出，data为用户变量地址用于返回读到的数据。在Linux（i386）中用户代码段与用户数据段重合所以读取代码段和数据段数据处理是一样的。</p>

<p>3)  PTRACE_POKETEXT,PTRACE_POKEDATA<br/>
形式：ptrace(PTRACE_POKETEXT, pid, addr, data)<br/>
描述：往内存地址中写入一个字节。pid表示被跟踪的子进程，内存地址由addr给出，data为所要写入的数据。</p>

<p>4)  TRACE_PEEKUSR<br/>
形式：ptrace(PTRACE_PEEKUSR, pid, addr, data)<br/>
描述：从USER区域中读取一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为用户变量地址用于返回读到的数据。USER结构为core文件的前面一部分，它描述了进程中止时的一些状态，如：寄存器值，代码、数据段大小，代码、数据段开始地址等。在Linux（i386）中通过PTRACE_PEEKUSER和PTRACE_POKEUSR可以访问USER结构的数据有寄存器和调试寄存器。</p>

<p>5)  PTRACE_POKEUSR<br/>
形式：ptrace(PTRACE_POKEUSR, pid, addr, data)<br/>
描述：往USER区域中写入一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为需写入的数据。</p>

<p>6)   PTRACE_CONT<br/>
形式：ptrace(PTRACE_CONT, pid, 0, signal)<br/>
描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。</p>

<p>7)  PTRACE_SYSCALL<br/>
形式：ptrace(PTRACE_SYS, pid, 0, signal)<br/>
描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。与PTRACE_CONT不同的是进行系统调用跟踪。在被跟踪进程继续运行直到调用系统调用开始或结束时，被跟踪进程被中止，并通知父进程。</p>

<p>8)   PTRACE_KILL<br/>
形式：ptrace(PTRACE_KILL,pid)<br/>
描述：杀掉子进程，使它退出。pid表示被跟踪的子进程。</p>

<p>9)   PTRACE_SINGLESTEP<br/>
形式：ptrace(PTRACE_KILL, pid, 0, signle)<br/>
描述：设置单步执行标志，单步执行一条指令。pid表示被跟踪的子进程。signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。当被跟踪进程单步执行完一个指令后，被跟踪进程被中止，并通知父进程。</p>

<p>10)  PTRACE_ATTACH<br/>
形式：ptrace(PTRACE_ATTACH,pid)<br/>
描述：跟踪指定pid 进程。pid表示被跟踪进程。被跟踪进程将成为当前进程的子进程，并进入中止状态。</p>

<p>11)  PTRACE_DETACH
形式：ptrace(PTRACE_DETACH,pid)
描述：结束跟踪。 pid表示被跟踪的子进程。结束跟踪后被跟踪进程将继续执行。</p>

<p>12)  PTRACE_GETREGS<br/>
形式：ptrace(PTRACE_GETREGS, pid, 0, data)<br/>
描述：读取寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有17个基本寄存器的值。</p>

<p>13)  PTRACE_SETREGS<br/>
形式：ptrace(PTRACE_SETREGS, pid, 0, data)<br/>
描述：设置寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有17个基本寄存器的值。</p>

<p>14)  PTRACE_GETFPREGS
形式：ptrace(PTRACE_GETFPREGS, pid, 0, data)<br/>
描述：读取浮点寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有浮点协处理器387的所有寄存器的值。</p>

<p>15)  PTRACE_SETFPREGS<br/>
形式：ptrace(PTRACE_SETREGS, pid, 0, data)<br/>
描述：设置浮点寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有浮点协处理器387的所有寄存器的值。</p>

<hr />

<p>在用户模式中，虽然只有一个函数可用，即ptrace(int <em>request, pid_t </em>pid, caddr_t <em>addr, int </em>data)，
但是这个函数能做所有的事情！如果你愿意，也可以花费几个小时来编写自己的小调试器，以解决特定的问题。</p>

<p>ptrace函数的_request参数是最重要的一个参数，因为它确定你将做什么。BSD和Linux的头文件使用不同的定义，这使得将ptrace应用从一个平台移植到另一个平台变得很复杂。默认地，我们使用BSD头文件中的定义。</p>

<p>r  PT_TRACE_ME（PTRACE_TRACEME）<br/>
将当前进程切换到停止状态。它通常总是与fork/exec一起使用，虽然也能遇到自我追踪的应用程序。
对于每一个进程，PT_TRACE_ME只能被调用一次。
追踪一个正被追踪的进程是会失败的（另一个较不重要的结果是进程不能追踪它自己。
如果要这样做，应该首先从自身派生一个进程）。大量的反调试技术都是以这一事实为基础的。
为了克服这类技术，必须使用绕过ptrace的调试器。
一个信号被发送到正被调试的进程，并将该进程切换到停止状态，
该进程可以使用从父进程上下文中调用的PT_CONTINUE和PT_STEP命令从停止状态退出。
wait函数会延迟父进程的执行，直到被调试的进程切换为停止状态或者终止为止（终止时，返回值为1407）。
其他的所有参数都被忽略。</p>

<p>r  PT_ATTACH（PTRACE_ATTACH）<br/>
将进程标志为pid的运行进程切换为停止状态，在这种情形下，
调试器进程成为“父进程”。其他的所有参数都被忽略。进程必须具有与调试进程相同的用户标志（UID），
并且不能是setuid/setduid进程（否则就要用root来调试）。</p>

<p>r  PT_DETACH（PTRACE_DETACH）
停止进程标志为pid进程（由PT_ATTACH和PT_TRACE_ME指定）的调试，
并继续其常态运行。其他的所有参数都被忽略。</p>

<p>r  PT_CONTINUE（PTRACE_CONT）<br/>
继续进程标志为pid的被调试进程的执行，而不中断与调试器进程的通信。
如果addr ＝＝ 1（在Linux中为0），从上次停止的地址继续执行；否则，从指定的地址继续执行。
参数_data指定发送到被调试进程的信号数量（零说明没有信号）。</p>

<p>r  PT_STEP（PTRACE_SINGLESTEP）<br/>
进行进程标志为pid的进程的单步执行，即执行下一条机器指令并切换为停止状态（在i386中，这是根据设置追踪标志来实现的，虽然有些“黑客”函数库使用硬件断点）。BSD要求将参数addr置为1，而Linux要求将该参数置为0。其他的所有参数都被忽略。</p>

<p>r  PT_READ_I和PT_READ_D（PTRACE_PEEKTEXT和PTRACE_PEEKDATA）<br/>
分别从代码区和正被调试进程的地址空间区读取机器字。在许多当代的平台中，这两个指令是等价的。
ptrace函数接收目标地址addr，并返回读到的结果。</p>

<p>r  PT_WRITE_I和PR_READ_D（PTRACE_POKETEXT和PTRACE_POKEDATA）<br/>
将由_data传入的机器字写入addr所指定的地址。</p>

<p>r  PT_GETREGS，PT_GETFPREGS和PT_GETDBREGS（PTRACE_GETREGS，PTRACE<em> FPREGS和PT_GETFPXREGS）<br/>
将一般用途寄存器、段寄存器和调试寄存器的值读入到地址由</em>addr指针所指定的调试器进程的内存区中。
只有i386平台接收这些与系统相关的命令。寄存器结构的描述放在头文件machine/reg.h文件中。</p>

<p>r  PT_SETREGS，PT_SETFPREGS和PT_SETDBREGS（PTRACE_SETREGS，PTRACE<em> SETFPREGS和PT_SETFPXREGS）<br/>
通过拷贝由</em>addr指针所指定的内存区域的内容来设置被调试进程的寄存器的值。</p>

<p>r  PT_KILL（PTRACE_KILL）<br/>
将sigkill发送到被调试进程，以终止其执行。</p>
]]></content>
  </entry>
  
</feed>
