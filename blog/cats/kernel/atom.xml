<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2016-02-29T23:44:14+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[socket建立连接 sys_connect]]></title>
    <link href="http://abcdxyzk.github.io/blog/2016/02/29/kernel-net-connect/"/>
    <updated>2016-02-29T22:52:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2016/02/29/kernel-net-connect</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/chensichensi/article/details/5272346">http://blog.csdn.net/chensichensi/article/details/5272346</a></p>

<p><a href="http://blog.csdn.net/qy532846454/article/details/7882819">http://blog.csdn.net/qy532846454/article/details/7882819</a></p>

<p><a href="http://www.2cto.com/kf/201303/198459.html">http://www.2cto.com/kf/201303/198459.html</a></p>

<pre><code>    connect(fd, servaddr, addrlen);
    -&gt; SYSCALL_DEFINE3()
    -&gt; sock-&gt;ops-&gt;connect() == inet_stream_connect (sock-&gt;ops即inet_stream_ops)
    -&gt; tcp_v4_connect()
        -&gt; inet_hash_connect()
            -&gt; __inet_hash_connect()
                -&gt; check_established()
                    -&gt; __inet_check_established()
</code></pre>

<pre><code>    SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
            int, addrlen)
    {
        struct socket *sock;
        struct sockaddr_storage address;
        int err, fput_needed;
        /* 找到文件描述符对应的BSD socket结构，在前面的socket调用中建立*/
        sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);
        if (!sock)
            goto out;
        /* copy对端的地址到内核空间 */
        err = move_addr_to_kernel(uservaddr, addrlen, (struct sockaddr *)&amp;address);
        if (err &lt; 0)
            goto out_put;

        err =
            security_socket_connect(sock, (struct sockaddr *)&amp;address, addrlen);
        if (err)
            goto out_put;
        /* 调用该BSD socket对应的connect调用 */
        err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)&amp;address, addrlen,
                     sock-&gt;file-&gt;f_flags);
    out_put:
        /* 释放文件的引用 */
        fput_light(sock-&gt;file, fput_needed);
    out:
        return err;
    }
</code></pre>

<pre><code>    /*
     *  Connect to a remote host. There is regrettably still a little
     *  TCP 'magic' in here.
     */
    int inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,
                int addr_len, int flags)
    {
        struct sock *sk = sock-&gt;sk;
        int err;
        long timeo;

        lock_sock(sk);

        if (uaddr-&gt;sa_family == AF_UNSPEC) {
            err = sk-&gt;sk_prot-&gt;disconnect(sk, flags);
            sock-&gt;state = err ? SS_DISCONNECTING : SS_UNCONNECTED;
            goto out;
        }

        switch (sock-&gt;state) {
        default:
            err = -EINVAL;
            goto out;
        case SS_CONNECTED:     /* 该BSD socket已连接*/
            err = -EISCONN;
            goto out;
        case SS_CONNECTING:   /* 该BSD socket正在连接*/
            err = -EALREADY;
            /* Fall out of switch with err, set for this state */
            break;
        case SS_UNCONNECTED:
            err = -EISCONN;
            if (sk-&gt;sk_state != TCP_CLOSE)
                goto out;
                /* INET SOCKET 调用协议特有connect操作符 */
            err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);
            if (err &lt; 0)
                goto out;
                /* 上面的调用完成后，连接并没有完成，*/
            sock-&gt;state = SS_CONNECTING;

            /* Just entered SS_CONNECTING state; the only
             * difference is that return value in non-blocking
             * case is EINPROGRESS, rather than EALREADY.
             */
            err = -EINPROGRESS;
            break;
        }
        /* 获取连接超时时间*/
        timeo = sock_sndtimeo(sk, flags &amp; O_NONBLOCK);

        if ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
            /* Error code is set above 进入定时等待 */
            if (!timeo || !inet_wait_for_connect(sk, timeo))
                goto out;

            err = sock_intr_errno(timeo);
            if (signal_pending(current))
                goto out;
        }

        /* Connection was closed by RST, timeout, ICMP error
         * or another process disconnected us.
         */
        if (sk-&gt;sk_state == TCP_CLOSE)
            goto sock_error;

        /* sk-&gt;sk_err may be not zero now, if RECVERR was ordered by user
         * and error was received after socket entered established state.
         * Hence, it is handled normally after connect() return successfully.
         */

        sock-&gt;state = SS_CONNECTED;
        err = 0;
    out:
        release_sock(sk);
        return err;

    sock_error:
        err = sock_error(sk) ? : -ECONNABORTED;
        sock-&gt;state = SS_UNCONNECTED;
        if (sk-&gt;sk_prot-&gt;disconnect(sk, flags))
            sock-&gt;state = SS_DISCONNECTING;
        goto out;
    }
</code></pre>

<pre><code>    /* This will initiate an outgoing connection. */
    int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
    {
        struct inet_sock *inet = inet_sk(sk);
        struct tcp_sock *tp = tcp_sk(sk);
        struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;
        struct rtable *rt;
        __be32 daddr, nexthop;
        int tmp;
        int err;

        if (addr_len &lt; sizeof(struct sockaddr_in))
            return -EINVAL;

        if (usin-&gt;sin_family != AF_INET)
            return -EAFNOSUPPORT;
        /* 开始准备路由 */
        nexthop = daddr = usin-&gt;sin_addr.s_addr;
        if (inet-&gt;opt &amp;&amp; inet-&gt;opt-&gt;srr) {
            if (!daddr)
                return -EINVAL;
            nexthop = inet-&gt;opt-&gt;faddr;
        }
        /* 调用路由模块获取出口信息，这里不深入 */
        tmp = ip_route_connect(&amp;rt, nexthop, inet-&gt;saddr,
                       RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,
                       IPPROTO_TCP,
                       inet-&gt;sport, usin-&gt;sin_port, sk, 1);
        if (tmp &lt; 0) {
            if (tmp == -ENETUNREACH)
                IP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);
            return tmp;
        }
        /* 如果获取的路由是广播或多播域， 返回网络不可达，tcp不支持多播与广播 */
        if (rt-&gt;rt_flags &amp; (RTCF_MULTICAST | RTCF_BROADCAST)) {
            ip_rt_put(rt);
            return -ENETUNREACH;
        }

        if (!inet-&gt;opt || !inet-&gt;opt-&gt;srr)
            daddr = rt-&gt;rt_dst;

        if (!inet-&gt;saddr)
            inet-&gt;saddr = rt-&gt;rt_src;
        inet-&gt;rcv_saddr = inet-&gt;saddr;

        if (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; inet-&gt;daddr != daddr) {
            /* Reset inherited state */
            tp-&gt;rx_opt.ts_recent       = 0;
            tp-&gt;rx_opt.ts_recent_stamp = 0;
            tp-&gt;write_seq          = 0;
        }

        if (tcp_death_row.sysctl_tw_recycle &amp;&amp;
            !tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; rt-&gt;rt_dst == daddr) {
            struct inet_peer *peer = rt_get_peer(rt);
            /*
             * VJ's idea. We save last timestamp seen from
             * the destination in peer table, when entering state
             * TIME-WAIT * and initialize rx_opt.ts_recent from it,
             * when trying new connection.
             */
            if (peer != NULL &amp;&amp;
                peer-&gt;tcp_ts_stamp + TCP_PAWS_MSL &gt;= get_seconds()) {
                tp-&gt;rx_opt.ts_recent_stamp = peer-&gt;tcp_ts_stamp;
                tp-&gt;rx_opt.ts_recent = peer-&gt;tcp_ts;
            }
        }

        inet-&gt;dport = usin-&gt;sin_port;
        inet-&gt;daddr = daddr;

        inet_csk(sk)-&gt;icsk_ext_hdr_len = 0;
        if (inet-&gt;opt)
            inet_csk(sk)-&gt;icsk_ext_hdr_len = inet-&gt;opt-&gt;optlen;
        /* mss_clamp */
        tp-&gt;rx_opt.mss_clamp = 536;

        /* Socket identity is still unknown (sport may be zero).
         * However we set state to SYN-SENT and not releasing socket
         * lock select source port, enter ourselves into the hash tables and
         * complete initialization after this.
         */
        tcp_set_state(sk, TCP_SYN_SENT);
        err = inet_hash_connect(&amp;tcp_death_row, sk);
        if (err)
            goto failure;

        err = ip_route_newports(&amp;rt, IPPROTO_TCP,
                    inet-&gt;sport, inet-&gt;dport, sk);
        if (err)
            goto failure;

        /* OK, now commit destination to socket.  */
        sk-&gt;sk_gso_type = SKB_GSO_TCPV4;
        sk_setup_caps(sk, &amp;rt-&gt;u.dst);

        if (!tp-&gt;write_seq)
            tp-&gt;write_seq = secure_tcp_sequence_number(inet-&gt;saddr,
                                   inet-&gt;daddr,
                                   inet-&gt;sport,
                                   usin-&gt;sin_port);
        /* id是IP包头的id域 */
        inet-&gt;id = tp-&gt;write_seq ^ jiffies;

        err = tcp_connect(sk);
        rt = NULL;
        if (err)
            goto failure;

        return 0;

    failure:
        /*
         * This unhashes the socket and releases the local port,
         * if necessary.
         */
        tcp_set_state(sk, TCP_CLOSE);
        ip_rt_put(rt);
        sk-&gt;sk_route_caps = 0;
        inet-&gt;dport = 0;
        return err;
    }
</code></pre>

<p>当snum==0时，表明此时源端口没有指定，此时会随机选择一个空闲端口作为此次连接的源端口。low和high分别表示可用端口的下限和上限，remaining表示可用端口的数，注意这里的可用只是指端口可以用作源端口，其中部分端口可能已经作为其它socket的端口号在使用了，所以要循环1~remaining，直到查找到空闲的源端口。</p>

<p>下面来看下对每个端口的检查，即//choose a valid port部分的代码。这里要先了解下tcp的内核表组成，udp的表内核表udptable只是一张hash表，tcp的表则稍复杂，它的名字是tcp_hashinfo，在tcp_init()中被初始化，这个数据结构定义如下(省略了不相关的数据)：</p>

<pre><code>    struct inet_hashinfo {
        struct inet_ehash_bucket *ehash;
        ……
        struct inet_bind_hashbucket *bhash;
        ……
        struct inet_listen_hashbucket  listening_hash[INET_LHTABLE_SIZE]
                        ____cacheline_aligned_in_smp;
    };
</code></pre>

<p>从定义可以看出，tcp表又分成了三张表ehash, bhash, listening_hash，其中ehash, listening_hash对应于socket处在TCP的ESTABLISHED, LISTEN状态，bhash对应于socket已绑定了本地地址。三者间并不互斥，如一个socket可同时在bhash和ehash中，由于TIME_WAIT是一个比较特殊的状态，所以ehash又分成了chain和twchain，为TIME_WAIT的socket单独形成一张表。</p>

<p>回到刚才的代码，现在还只是建立socket连接，使用的就应该是tcp表中的bhash。首先取得内核tcp表的bind表 – bhash，查看是否已有socket占用：</p>

<p>如果没有，则调用inet_bind_bucket_create()创建一个bind表项tb，并插入到bind表中，跳转至goto ok代码段；
如果有，则跳转至goto ok代码段。</p>

<p>进入ok代码段表明已找到合适的bind表项(无论是创建的还是查找到的)，调用inet_bind_hash()赋值源端口inet_num。</p>

<p>inet_hash_connect()函数只是对<code>__inet_hash_connect()</code>函数进行了简单的封装。在<code>__inet_hash_connect()</code>中如果已绑定了端口号，并且是和其他传输控制块共享绑定的端口号，则会调用check_established参数指向的函数来检查这个绑定的端口号是否可用，代码如下所示：</p>

<pre><code>    int __inet_hash_connect(struct inet_timewait_death_row *death_row,
            struct sock *sk, u32 port_offset,
            int (*check_established)(struct inet_timewait_death_row *,
            struct sock *, __u16, struct inet_timewait_sock **),
            void (*hash)(struct sock *sk))
    {
        struct inet_hashinfo *hinfo = death_row-&gt;hashinfo;
        const unsigned short snum = inet_sk(sk)-&gt;num;
        struct inet_bind_hashbucket *head;
        struct inet_bind_bucket *tb;
        int ret;
        struct net *net = sock_net(sk);

        if (!snum) {
            int i, remaining, low, high, port;
            static u32 hint;
            u32 offset = hint + port_offset;
            struct hlist_node *node;
            struct inet_timewait_sock *tw = NULL;

            inet_get_local_port_range(&amp;low, &amp;high);
            remaining = (high - low) + 1;

            local_bh_enable();
            for (i = 1; i &lt;= remaining; i++) {
                port = low + (i + offset) % remaining;
                if (inet_is_reserved_local_port(port)
                    continue;
                head = &amp;hinfo-&gt;bhash[inet_bhashfn(net, port, hinfo-&gt;bhash_size)];
                spin_lock(&amp;head-&gt;lock);
                inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain) {
                    if (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == port) {
                        if (tb-&gt;fastreuse &gt;= 0)
                            goto next_port;
                        WARN_ON(hlist_empty(&amp;tb-&gt;owners));
                        if (!check_established(death_row, sk, port, &amp;tw))
                            goto ok;
                        goto next_port;
                    }
                }

                tb = inet_bind_bucket_create(hinfo-&gt;bind_bucket_cachep, net, head, port);
                if (!tb) {
                    spin_unlock(&amp;head-&gt;lock);
                    break;
                }
                tb-&gt;fastreuse = -1;
                tb-&gt;fastreuseport = -1;
                goto ok;
            next_port:
                spin_unlock(&amp;head-&gt;lock);
            }
            local_bh_enable();

            return -EADDRNOTAVAIL;

    ok:
            hint += i;

            inet_bind_hash(sk, tb, port);
            if (sk_unhashed(sk)) {
                inet_sk(sk)-&gt;sport = htons(port);
                hash(sk);
            }
            spin_unlock(&amp;head-&gt;lock);
            if (tw) {
                inet_twsk_deschedule(tw, death_row);
                inet_twsk_put(tw);
            }

            ret = 0;
            goto out;
        }

        head = &amp;hinfo-&gt;bhash[inet_bhashfn(net, snum, hinfo-&gt;bhash_size)];
        tb  = inet_csk(sk)-&gt;icsk_bind_hash;
        spin_lock_bh(&amp;head-&gt;lock);
        if (sk_head(&amp;tb-&gt;owners) == sk &amp;&amp; !sk-&gt;sk_bind_node.next) {
            hash(sk);
            spin_unlock_bh(&amp;head-&gt;lock);
            return 0;
        } else {
            spin_unlock(&amp;head-&gt;lock);
            /* No definite answer... Walk to established hash table */
            ret = check_established(death_row, sk, snum, NULL);
    out:
            local_bh_enable();
            return ret;
        }
    }
</code></pre>

<p>(sk_head(&amp;tb->owners) == sk &amp;&amp; !sk->sk_bind_node.next)这个判断条件就是用来判断是不是只有当前传输控制块在使用已绑定的端口，条件为false时，会执行else分支，检查是否可用。这么看来，调用bind()成功并不意味着这个端口就真的可以用。</p>

<p>check_established参数对应的函数是<code>__inet_check_established()</code>，在inet_hash_connect()中可以看到。在上面的代码中我们还注意到调用check_established()时第三个参数为NULL，这在后面的分析中会用到。</p>

<p><code>__inet_check_established()</code>函数中，会分别在TIME_WAIT传输控制块和除TIME_WIAT、LISTEN状态外的传输控制块中查找是已绑定的端口是否已经使用，代码片段如下所示：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
<span class='line-number'>571</span>
<span class='line-number'>572</span>
<span class='line-number'>573</span>
<span class='line-number'>574</span>
<span class='line-number'>575</span>
<span class='line-number'>576</span>
<span class='line-number'>577</span>
<span class='line-number'>578</span>
<span class='line-number'>579</span>
<span class='line-number'>580</span>
<span class='line-number'>581</span>
<span class='line-number'>582</span>
<span class='line-number'>583</span>
<span class='line-number'>584</span>
<span class='line-number'>585</span>
<span class='line-number'>586</span>
<span class='line-number'>587</span>
<span class='line-number'>588</span>
<span class='line-number'>589</span>
<span class='line-number'>590</span>
<span class='line-number'>591</span>
<span class='line-number'>592</span>
<span class='line-number'>593</span>
<span class='line-number'>594</span>
<span class='line-number'>595</span>
<span class='line-number'>596</span>
<span class='line-number'>597</span>
<span class='line-number'>598</span>
<span class='line-number'>599</span>
<span class='line-number'>600</span>
<span class='line-number'>601</span>
<span class='line-number'>602</span>
<span class='line-number'>603</span>
<span class='line-number'>604</span>
<span class='line-number'>605</span>
<span class='line-number'>606</span>
<span class='line-number'>607</span>
<span class='line-number'>608</span>
<span class='line-number'>609</span>
<span class='line-number'>610</span>
<span class='line-number'>611</span>
<span class='line-number'>612</span>
<span class='line-number'>613</span>
<span class='line-number'>614</span>
<span class='line-number'>615</span>
<span class='line-number'>616</span>
<span class='line-number'>617</span>
<span class='line-number'>618</span>
<span class='line-number'>619</span>
<span class='line-number'>620</span>
<span class='line-number'>621</span>
<span class='line-number'>622</span>
<span class='line-number'>623</span>
<span class='line-number'>624</span>
<span class='line-number'>625</span>
<span class='line-number'>626</span>
<span class='line-number'>627</span>
<span class='line-number'>628</span>
<span class='line-number'>629</span>
<span class='line-number'>630</span>
<span class='line-number'>631</span>
<span class='line-number'>632</span>
<span class='line-number'>633</span>
<span class='line-number'>634</span>
<span class='line-number'>635</span>
<span class='line-number'>636</span>
<span class='line-number'>637</span>
<span class='line-number'>638</span>
<span class='line-number'>639</span>
<span class='line-number'>640</span>
<span class='line-number'>641</span>
<span class='line-number'>642</span>
<span class='line-number'>643</span>
<span class='line-number'>644</span>
<span class='line-number'>645</span>
<span class='line-number'>646</span>
<span class='line-number'>647</span>
<span class='line-number'>648</span>
<span class='line-number'>649</span>
<span class='line-number'>650</span>
<span class='line-number'>651</span>
<span class='line-number'>652</span>
<span class='line-number'>653</span>
<span class='line-number'>654</span>
<span class='line-number'>655</span>
<span class='line-number'>656</span>
<span class='line-number'>657</span>
<span class='line-number'>658</span>
<span class='line-number'>659</span>
<span class='line-number'>660</span>
<span class='line-number'>661</span>
<span class='line-number'>662</span>
<span class='line-number'>663</span>
<span class='line-number'>664</span>
<span class='line-number'>665</span>
<span class='line-number'>666</span>
<span class='line-number'>667</span>
<span class='line-number'>668</span>
<span class='line-number'>669</span>
<span class='line-number'>670</span>
<span class='line-number'>671</span>
<span class='line-number'>672</span>
<span class='line-number'>673</span>
<span class='line-number'>674</span>
<span class='line-number'>675</span>
<span class='line-number'>676</span>
<span class='line-number'>677</span>
<span class='line-number'>678</span>
<span class='line-number'>679</span>
<span class='line-number'>680</span>
<span class='line-number'>681</span>
<span class='line-number'>682</span>
<span class='line-number'>683</span>
<span class='line-number'>684</span>
<span class='line-number'>685</span>
<span class='line-number'>686</span>
<span class='line-number'>687</span>
<span class='line-number'>688</span>
<span class='line-number'>689</span>
<span class='line-number'>690</span>
<span class='line-number'>691</span>
<span class='line-number'>692</span>
<span class='line-number'>693</span>
<span class='line-number'>694</span>
<span class='line-number'>695</span>
<span class='line-number'>696</span>
<span class='line-number'>697</span>
<span class='line-number'>698</span>
<span class='line-number'>699</span>
<span class='line-number'>700</span>
<span class='line-number'>701</span>
<span class='line-number'>702</span>
<span class='line-number'>703</span>
<span class='line-number'>704</span>
<span class='line-number'>705</span>
<span class='line-number'>706</span>
<span class='line-number'>707</span>
<span class='line-number'>708</span>
<span class='line-number'>709</span>
<span class='line-number'>710</span>
<span class='line-number'>711</span>
<span class='line-number'>712</span>
<span class='line-number'>713</span>
<span class='line-number'>714</span>
<span class='line-number'>715</span>
<span class='line-number'>716</span>
<span class='line-number'>717</span>
<span class='line-number'>718</span>
<span class='line-number'>719</span>
<span class='line-number'>720</span>
<span class='line-number'>721</span>
<span class='line-number'>722</span>
<span class='line-number'>723</span>
<span class='line-number'>724</span>
<span class='line-number'>725</span>
<span class='line-number'>726</span>
<span class='line-number'>727</span>
<span class='line-number'>728</span>
<span class='line-number'>729</span>
<span class='line-number'>730</span>
<span class='line-number'>731</span>
<span class='line-number'>732</span>
<span class='line-number'>733</span>
<span class='line-number'>734</span>
<span class='line-number'>735</span>
<span class='line-number'>736</span>
<span class='line-number'>737</span>
<span class='line-number'>738</span>
<span class='line-number'>739</span>
<span class='line-number'>740</span>
<span class='line-number'>741</span>
<span class='line-number'>742</span>
<span class='line-number'>743</span>
<span class='line-number'>744</span>
<span class='line-number'>745</span>
<span class='line-number'>746</span>
<span class='line-number'>747</span>
<span class='line-number'>748</span>
<span class='line-number'>749</span>
<span class='line-number'>750</span>
<span class='line-number'>751</span>
<span class='line-number'>752</span>
<span class='line-number'>753</span>
<span class='line-number'>754</span>
<span class='line-number'>755</span>
<span class='line-number'>756</span>
<span class='line-number'>757</span>
<span class='line-number'>758</span>
<span class='line-number'>759</span>
<span class='line-number'>760</span>
<span class='line-number'>761</span>
<span class='line-number'>762</span>
<span class='line-number'>763</span>
<span class='line-number'>764</span>
<span class='line-number'>765</span>
<span class='line-number'>766</span>
<span class='line-number'>767</span>
<span class='line-number'>768</span>
<span class='line-number'>769</span>
<span class='line-number'>770</span>
<span class='line-number'>771</span>
<span class='line-number'>772</span>
<span class='line-number'>773</span>
<span class='line-number'>774</span>
<span class='line-number'>775</span>
<span class='line-number'>776</span>
<span class='line-number'>777</span>
<span class='line-number'>778</span>
<span class='line-number'>779</span>
<span class='line-number'>780</span>
<span class='line-number'>781</span>
<span class='line-number'>782</span>
<span class='line-number'>783</span>
<span class='line-number'>784</span>
<span class='line-number'>785</span>
<span class='line-number'>786</span>
<span class='line-number'>787</span>
<span class='line-number'>788</span>
<span class='line-number'>789</span>
<span class='line-number'>790</span>
<span class='line-number'>791</span>
<span class='line-number'>792</span>
<span class='line-number'>793</span>
<span class='line-number'>794</span>
<span class='line-number'>795</span>
<span class='line-number'>796</span>
<span class='line-number'>797</span>
<span class='line-number'>798</span>
<span class='line-number'>799</span>
<span class='line-number'>800</span>
<span class='line-number'>801</span>
<span class='line-number'>802</span>
<span class='line-number'>803</span>
<span class='line-number'>804</span>
<span class='line-number'>805</span>
<span class='line-number'>806</span>
<span class='line-number'>807</span>
<span class='line-number'>808</span>
<span class='line-number'>809</span>
<span class='line-number'>810</span>
<span class='line-number'>811</span>
<span class='line-number'>812</span>
<span class='line-number'>813</span>
<span class='line-number'>814</span>
<span class='line-number'>815</span>
<span class='line-number'>816</span>
<span class='line-number'>817</span>
<span class='line-number'>818</span>
<span class='line-number'>819</span>
<span class='line-number'>820</span>
<span class='line-number'>821</span>
<span class='line-number'>822</span>
<span class='line-number'>823</span>
<span class='line-number'>824</span>
<span class='line-number'>825</span>
<span class='line-number'>826</span>
<span class='line-number'>827</span>
<span class='line-number'>828</span>
<span class='line-number'>829</span>
<span class='line-number'>830</span>
<span class='line-number'>831</span>
<span class='line-number'>832</span>
<span class='line-number'>833</span>
<span class='line-number'>834</span>
<span class='line-number'>835</span>
<span class='line-number'>836</span>
<span class='line-number'>837</span>
<span class='line-number'>838</span>
<span class='line-number'>839</span>
<span class='line-number'>840</span>
<span class='line-number'>841</span>
<span class='line-number'>842</span>
<span class='line-number'>843</span>
<span class='line-number'>844</span>
<span class='line-number'>845</span>
<span class='line-number'>846</span>
<span class='line-number'>847</span>
<span class='line-number'>848</span>
<span class='line-number'>849</span>
<span class='line-number'>850</span>
<span class='line-number'>851</span>
<span class='line-number'>852</span>
<span class='line-number'>853</span>
<span class='line-number'>854</span>
<span class='line-number'>855</span>
<span class='line-number'>856</span>
<span class='line-number'>857</span>
<span class='line-number'>858</span>
<span class='line-number'>859</span>
<span class='line-number'>860</span>
<span class='line-number'>861</span>
<span class='line-number'>862</span>
<span class='line-number'>863</span>
<span class='line-number'>864</span>
<span class='line-number'>865</span>
<span class='line-number'>866</span>
<span class='line-number'>867</span>
<span class='line-number'>868</span>
<span class='line-number'>869</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt; called with local bh disabled &lt;/em&gt;/
</span><span class='line'>static int &lt;strong&gt;inet_check_established(struct inet_timewait_death_row &lt;em&gt;death_row,
</span><span class='line'>            struct sock &lt;/em&gt;sk, &lt;/strong&gt;u16 lport,
</span><span class='line'>            struct inet_timewait_sock &lt;em&gt;&lt;em&gt;twp)
</span><span class='line'>{
</span><span class='line'>    struct inet_hashinfo &lt;/em&gt;hinfo = death_row-&gt;hashinfo;
</span><span class='line'>    struct inet_sock &lt;/em&gt;inet = inet_sk(sk);
</span><span class='line'>    &lt;strong&gt;be32 daddr = inet-&gt;rcv_saddr;
</span><span class='line'>    &lt;/strong&gt;be32 saddr = inet-&gt;daddr;
</span><span class='line'>    int dif = sk-&gt;sk_bound_dev_if;
</span><span class='line'>    INET_ADDR_COOKIE(acookie, saddr, daddr)
</span><span class='line'>    const __portpair ports = INET_COMBINED_PORTS(inet-&gt;dport, lport);
</span><span class='line'>    struct net &lt;em&gt;net = sock_net(sk);
</span><span class='line'>    unsigned int hash = inet_ehashfn(net, daddr, lport, saddr, inet-&gt;dport);
</span><span class='line'>    struct inet_ehash_bucket &lt;/em&gt;head = inet_ehash_bucket(hinfo, hash);
</span><span class='line'>    spinlock_t &lt;em&gt;lock = inet_ehash_lockp(hinfo, hash);
</span><span class='line'>    struct sock &lt;/em&gt;sk2;
</span><span class='line'>    const struct hlist_nulls_node &lt;em&gt;node;
</span><span class='line'>    struct inet_timewait_sock &lt;/em&gt;tw;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    spin_lock(lock);
</span><span class='line'>
</span><span class='line'>/* Check TIME-WAIT sockets first. */
</span><span class='line'>sk_nulls_for_each(sk2, node, &amp;head-&gt;twchain) {
</span><span class='line'>    tw = inet_twsk(sk2);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    if (INET_TW_MATCH(sk2, net, hash, acookie,
</span><span class='line'>            saddr, daddr, ports, dif)) {
</span><span class='line'>        if (twsk_unique(sk, sk2, twp))
</span><span class='line'>            goto unique;
</span><span class='line'>        else
</span><span class='line'>            goto not_unique;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>tw = NULL;
</span><span class='line'>
</span><span class='line'>/* And established part... */
</span><span class='line'>sk_nulls_for_each(sk2, node, &amp;head-&gt;chain) {
</span><span class='line'>    if (INET_MATCH(sk2, net, hash, acookie,
</span><span class='line'>            saddr, daddr, ports, dif))
</span><span class='line'>        goto not_unique;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>unique:
</span><span class='line'>......
</span><span class='line'>return 0;
</span><span class='line'>
</span><span class='line'>not_unique:
</span><span class='line'>spin_unlock(lock);
</span><span class='line'>return -EADDRNOTAVAIL;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>如果是TCP套接字，twsk_uniqueue()中会调用tcp_twsk_uniqueue()来判断，返回true的条件如下所示：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp)
</span><span class='line'>{
</span><span class='line'>const struct tcp_timewait_sock *tcptw = tcp_twsk(sktw);
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>if (tcptw-&gt;tw_ts_recent_stamp &amp;&amp;
</span><span class='line'>        (twp == NULL || (sysctl_tcp_tw_reuse &amp;&amp;
</span><span class='line'>        get_seconds() - tcptw-&gt;tw_ts_recent_stamp &gt; 1))) {
</span><span class='line'>    ......
</span><span class='line'>    return 1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/*
</span><span class='line'> * Build a SYN and send it off.
</span><span class='line'> */
</span><span class='line'>int tcp_connect(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>struct sk_buff *buff;
</span><span class='line'>/* 初始化连接对应的INET socket结构的参数，为连接做准备 */
</span><span class='line'>tcp_connect_init(sk);
</span><span class='line'>/* 获取一个skb，由于是syn包，没有数据，所以大小是MAX_TCP_HEADER的16位对齐 */
</span><span class='line'>buff = alloc_skb_fclone(MAX_TCP_HEADER + 15, sk-&gt;sk_allocation);
</span><span class='line'>if (unlikely(buff == NULL))
</span><span class='line'>    return -ENOBUFS;
</span><span class='line'>
</span><span class='line'>/* Reserve space for headers. */
</span><span class='line'>skb_reserve(buff, MAX_TCP_HEADER);
</span><span class='line'>
</span><span class='line'>tp-&gt;snd_nxt = tp-&gt;write_seq;
</span><span class='line'>/* 设置skb相关参数 */
</span><span class='line'>tcp_init_nondata_skb(buff, tp-&gt;write_seq++, TCPCB_FLAG_SYN);
</span><span class='line'>/* 设置ECN */
</span><span class='line'>TCP_ECN_send_syn(sk, buff);
</span><span class='line'>
</span><span class='line'>/* Send it off. */
</span><span class='line'>/* 保存该数据包的发送时间*/
</span><span class='line'>TCP_SKB_CB(buff)-&gt;when = tcp_time_stamp;
</span><span class='line'>tp-&gt;retrans_stamp = TCP_SKB_CB(buff)-&gt;when;
</span><span class='line'>skb_header_release(buff);
</span><span class='line'>/* 加入发送队列，待确认后在丢弃*/
</span><span class='line'>__tcp_add_write_queue_tail(sk, buff);
</span><span class='line'>sk-&gt;sk_wmem_queued += buff-&gt;truesize;
</span><span class='line'>sk_mem_charge(sk, buff-&gt;truesize);
</span><span class='line'>tp-&gt;packets_out += tcp_skb_pcount(buff);
</span><span class='line'>tcp_transmit_skb(sk, buff, 1, GFP_KERNEL);
</span><span class='line'>
</span><span class='line'>/* We change tp-&gt;snd_nxt after the tcp_transmit_skb() call
</span><span class='line'> * in order to make this packet get counted in tcpOutSegs.
</span><span class='line'> */
</span><span class='line'>tp-&gt;snd_nxt = tp-&gt;write_seq;
</span><span class='line'>tp-&gt;pushed_seq = tp-&gt;write_seq;
</span><span class='line'>TCP_INC_STATS(sock_net(sk), TCP_MIB_ACTIVEOPENS);
</span><span class='line'>
</span><span class='line'>/* Timer for repeating the SYN until an answer. */
</span><span class='line'>inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
</span><span class='line'>              inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/*
</span><span class='line'> * Do all connect socket setups that can be done AF independent.
</span><span class='line'> */
</span><span class='line'>static void tcp_connect_init(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>struct dst_entry *dst = __sk_dst_get(sk);
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>__u8 rcv_wscale;
</span><span class='line'>
</span><span class='line'>/* We'll fix this up when we get a response from the other end.
</span><span class='line'> * See tcp_input.c:tcp_rcv_state_process case TCP_SYN_SENT.
</span><span class='line'> */
</span><span class='line'>tp-&gt;tcp_header_len = sizeof(struct tcphdr) +
</span><span class='line'>    (sysctl_tcp_timestamps ? TCPOLEN_TSTAMP_ALIGNED : 0);
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_TCP_MD5SIG
</span><span class='line'>if (tp-&gt;af_specific-&gt;md5_lookup(sk, sk) != NULL)
</span><span class='line'>    tp-&gt;tcp_header_len += TCPOLEN_MD5SIG_ALIGNED;
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>/* If user gave his TCP_MAXSEG, record it to clamp */
</span><span class='line'>if (tp-&gt;rx_opt.user_mss)
</span><span class='line'>    tp-&gt;rx_opt.mss_clamp = tp-&gt;rx_opt.user_mss;
</span><span class='line'>tp-&gt;max_window = 0;
</span><span class='line'>/* 初始化MTU probe*/
</span><span class='line'>tcp_mtup_init(sk);
</span><span class='line'>/* 设置mss */
</span><span class='line'>tcp_sync_mss(sk, dst_mtu(dst));
</span><span class='line'>
</span><span class='line'>if (!tp-&gt;window_clamp)
</span><span class='line'>    tp-&gt;window_clamp = dst_metric(dst, RTAX_WINDOW);
</span><span class='line'>tp-&gt;advmss = dst_metric(dst, RTAX_ADVMSS);
</span><span class='line'>if (tp-&gt;rx_opt.user_mss &amp;&amp; tp-&gt;rx_opt.user_mss &lt; tp-&gt;advmss)
</span><span class='line'>    tp-&gt;advmss = tp-&gt;rx_opt.user_mss;
</span><span class='line'>
</span><span class='line'>tcp_initialize_rcv_mss(sk);
</span><span class='line'>/* 根据接收空间大小初始化一个通告窗口 */
</span><span class='line'>tcp_select_initial_window(tcp_full_space(sk),
</span><span class='line'>              tp-&gt;advmss - (tp-&gt;rx_opt.ts_recent_stamp ? tp-&gt;tcp_header_len - sizeof(struct tcphdr) : 0),
</span><span class='line'>              &amp;tp-&gt;rcv_wnd,
</span><span class='line'>              &amp;tp-&gt;window_clamp,
</span><span class='line'>              sysctl_tcp_window_scaling,
</span><span class='line'>              &amp;rcv_wscale);
</span><span class='line'>
</span><span class='line'>tp-&gt;rx_opt.rcv_wscale = rcv_wscale;
</span><span class='line'>tp-&gt;rcv_ssthresh = tp-&gt;rcv_wnd;
</span><span class='line'>
</span><span class='line'>sk-&gt;sk_err = 0;
</span><span class='line'>sock_reset_flag(sk, SOCK_DONE);
</span><span class='line'>tp-&gt;snd_wnd = 0;
</span><span class='line'>/* 更新一些滑动窗口的成员*/
</span><span class='line'>tcp_init_wl(tp, tp-&gt;write_seq, 0);
</span><span class='line'>tp-&gt;snd_una = tp-&gt;write_seq;
</span><span class='line'>tp-&gt;snd_sml = tp-&gt;write_seq;
</span><span class='line'>tp-&gt;snd_up = tp-&gt;write_seq;
</span><span class='line'>tp-&gt;rcv_nxt = 0;
</span><span class='line'>tp-&gt;rcv_wup = 0;
</span><span class='line'>tp-&gt;copied_seq = 0;
</span><span class='line'>
</span><span class='line'>inet_csk(sk)-&gt;icsk_rto = TCP_TIMEOUT_INIT;
</span><span class='line'>inet_csk(sk)-&gt;icsk_retransmits = 0;
</span><span class='line'>tcp_clear_retrans(tp);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>skb发送后，connect并没有返回，因为此时连接还没有建立，tcp进入等待状态，此时回到前面的inet_stream_connect函数
</span><span class='line'>
</span><span class='line'>在发送syn后进入等待状态
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static long inet_wait_for_connect(struct sock *sk, long timeo)
</span><span class='line'>{
</span><span class='line'>DEFINE_WAIT(wait);
</span><span class='line'>/* sk_sleep 保存此INET SOCKET的等待队列 */
</span><span class='line'>prepare_to_wait(sk-&gt;sk_sleep, &amp;wait, TASK_INTERRUPTIBLE);
</span><span class='line'>
</span><span class='line'>/* Basic assumption: if someone sets sk-&gt;sk_err, he _must_
</span><span class='line'> * change state of the socket from TCP_SYN_*.
</span><span class='line'> * Connect() does not allow to get error notifications
</span><span class='line'> * without closing the socket.
</span><span class='line'> */
</span><span class='line'>/* 定时等待知道状态变化 */
</span><span class='line'>while ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
</span><span class='line'>    release_sock(sk);
</span><span class='line'>    timeo = schedule_timeout(timeo);
</span><span class='line'>    lock_sock(sk);
</span><span class='line'>    if (signal_pending(current) || !timeo)
</span><span class='line'>        break;
</span><span class='line'>    prepare_to_wait(sk-&gt;sk_sleep, &amp;wait, TASK_INTERRUPTIBLE);
</span><span class='line'>}
</span><span class='line'>finish_wait(sk-&gt;sk_sleep, &amp;wait);
</span><span class='line'>return timeo;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[udp checksum]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2016/01/21/kernel-net-udp-sum/"/&gt;
</span><span class='line'>&lt;updated&gt;2016-01-21T16:43:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2016/01/21/kernel-net-udp-sum&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://wenx05124561.blog.163.com/blog/static/124000805201242032041268/"&gt;http://wenx05124561.blog.163.com/blog/static/124000805201242032041268/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;a. 网卡设备属性&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    #define NETIF_F_IP_CSUM     2   /* 基于IPv4的L4层checksum. */  
</span><span class='line'>#define NETIF_F_NO_CSUM     4   /* 设备可靠不需要L4层checksum. loopack. */  
</span><span class='line'>#define NETIF_F_HW_CSUM     8   /* 基于所有协议的L4层checksum*/  
</span><span class='line'>#define NETIF_F_IPV6_CSUM   16  /* 基于IPv6的L4层checksum*/  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;通过ethtool -k eth0可以查看网卡是否支持硬件checksum，tx-checksumming: on  表明支持发送hardware checksum。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;b. linux UDP checksum数据结构&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    union {
</span><span class='line'>    __wsum  csum;
</span><span class='line'>    struct {
</span><span class='line'>        __u16   csum_start;
</span><span class='line'>        __u16   csum_offset;
</span><span class='line'>    };
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1） skb-&gt;csum和skb-&gt;ip_summed这两个域也是与4层校验相关的，这两个域的含义依赖于skb表示的是一个输入包还是一个输出包。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2） 当网卡设备能提供硬件checksum并且作为输出包的时候，表示为skb-&gt;csum_start和skb-&gt;csum_offset&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;csum_start: Offset from skb-&gt;head where checksumming should start&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;csum_offset: Offset from csum_start where checksum should be stored&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;当数据包是一个输入包时&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;skb-&gt;ip_summed表示的是四层校验的状态，下面的几个宏定义表示了设备驱动传递给4层的一些信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    #define CHECKSUM_NONE 0
</span><span class='line'>#define CHECKSUM_UNNECESSARY 1
</span><span class='line'>#define CHECKSUM_COMPLETE 2
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;skb-&gt;csum:存放硬件或者软件计算的payload的checksum不包括伪头，但是是否有意义由skb-&gt;ip_summed的值决定。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CHECKSUM_NONE表示csum域中的校验值是无意义的，需要L4层自己校验payload和伪头。有可能是硬件检验出错或者硬件没有校验功能，协议栈软件更改如pskb_trim_rcsum函数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CHECKSUM_UNNECESSARY表示网卡或者协议栈已经计算和验证了L4层的头和校验值。也就是计算了tcp udp的伪头。还有一种情况就是回环，因为在回环中错误发生的概率太低了，因此就不需要计算校验来节省cpu事件。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CHECKSUM_COMPLETE表示网卡已经计算了L4层payload的校验，并且csum已经被赋值，此时L4层的接收者只需要加伪头并验证校验结果。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1) 在L4层发现如果udp-&gt;check位段被设为0，那么skb-&gt;ip_summed直接设为CHECKSUM_UNNECESSARY，放行该报文。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2) 如果skb-&gt;ip_summed为CHECKSUM_COMPLETE，则把skb-&gt;csum加上伪头进行校验，成功则将skb-&gt;ip_summed设为CHECKSUM_UNNECESSARY， 放行该数据包。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;3) 通过上述后skb-&gt;ip_summed还不是CHECKSUM_UNNECESSARY，那么重新计算伪头赋给skb-&gt;csum。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;4) 将还不是CHECKSUM_UNNECESSARY的数据报文的payload加上skb-&gt;csum进行checksum计算，成功将设为CHECKSUM_UNNECESSARY并放行，失败则丢弃。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline int udp4_csum_init(struct sk_buff *skb, struct udphdr *uh, 
</span><span class='line'>                int proto)
</span><span class='line'>{
</span><span class='line'>    const struct iphdr *iph;
</span><span class='line'>    int err; 
</span><span class='line'>
</span><span class='line'>    UDP_SKB_CB(skb)-&gt;partial_cov = 0; 
</span><span class='line'>    UDP_SKB_CB(skb)-&gt;cscov = skb-&gt;len;
</span><span class='line'>
</span><span class='line'>    if (proto == IPPROTO_UDPLITE) {
</span><span class='line'>        err = udplite_checksum_init(skb, uh); 
</span><span class='line'>        if (err)
</span><span class='line'>            return err; 
</span><span class='line'>    }    
</span><span class='line'>
</span><span class='line'>    iph = ip_hdr(skb);
</span><span class='line'>    if (uh-&gt;check == 0) { 
</span><span class='line'>        skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</span><span class='line'>    } else if (skb-&gt;ip_summed == CHECKSUM_COMPLETE) {
</span><span class='line'>        if (!csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr, skb-&gt;len,
</span><span class='line'>                proto, skb-&gt;csum))
</span><span class='line'>            skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</span><span class='line'>    }    
</span><span class='line'>    if (!skb_csum_unnecessary(skb))
</span><span class='line'>        skb-&gt;csum = csum_tcpudp_nofold(iph-&gt;saddr, iph-&gt;daddr,
</span><span class='line'>                            skb-&gt;len, proto, 0);
</span><span class='line'>    /* Probably, we should checksum udp header (it should be in cache
</span><span class='line'>     * in any case) and data in tiny packets (&lt; rx copybreak).
</span><span class='line'>     */
</span><span class='line'>
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    if (udp_lib_checksum_complete(skb))
</span><span class='line'>    goto csum_error;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline int udp_lib_checksum_complete(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    return !skb_csum_unnecessary(skb) &amp;&amp;
</span><span class='line'>        __udp_lib_checksum_complete(skb);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static inline __sum16 __udp_lib_checksum_complete(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    return __skb_checksum_complete_head(skb, UDP_SKB_CB(skb)-&gt;cscov);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>__sum16 __skb_checksum_complete_head(struct sk_buff *skb, int len)
</span><span class='line'>{
</span><span class='line'>    __sum16 sum;
</span><span class='line'>
</span><span class='line'>    sum = csum_fold(skb_checksum(skb, 0, len, skb-&gt;csum));
</span><span class='line'>    if (likely(!sum)) {
</span><span class='line'>        if (unlikely(skb-&gt;ip_summed == CHECKSUM_COMPLETE))
</span><span class='line'>            netdev_rx_csum_fault(skb-&gt;dev);
</span><span class='line'>        skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</span><span class='line'>    }
</span><span class='line'>    return sum;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;当数据包是输出包时&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;skb-&gt;csum表示为csum_start和csum_offset，它表示硬件网卡存放将要计算的校验值的地址，和最后填充的便宜。这个域在输出包时使用，只在校验值在硬件计算的情况下才对于网卡真正有意义。硬件checksum功能只能用于非分片报文。
</span><span class='line'>而此时ip_summed可以被设置的值有下面两种：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    #define CHECKSUM_NONE       0
</span><span class='line'>#define CHECKSUM_PARTIAL    3
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CHECKSUM_NONE 表示协议栈计算好了校验值，设备不需要做任何事。CHECKSUM_PARTIAL表示协议栈算好了伪头需要硬件计算payload checksum。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1）对于UDP socket开启了UDP_CSUM_NOXMIT /&lt;em&gt; UDP csum disabled &lt;/em&gt;/&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    uh-&gt;check = 0；
</span><span class='line'>skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2）软件udp checksum
</span><span class='line'>&lt;code&gt;
</span><span class='line'>struct iphdr *iph = ip_hdr(skb);
</span><span class='line'>struct udphdr *uh = udp_hdr(skb);
</span><span class='line'>uh-&gt;check = 0;
</span><span class='line'>skb-&gt;csum = csum_partial(skb_transport_header (skb), skb-&gt;len, 0);//skb-&gt;data指向传输层头
</span><span class='line'>uh-&gt;check = csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr, skb-&gt;len, iph-&gt;protocol, skb-&gt;csum);
</span><span class='line'>skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>//Todo: scatter and gather
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;3)  硬件checksum: 只能是ip报文长度小于mtu的数据报(没有分片的报文)。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CHECKSUM_PARTIAL表示使用硬件checksum ，L4层的伪头的校验已经完毕，并且已经加入uh-&gt;check字段中，此时只需要设备计算整个头4层头的校验值。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（对于支持scatter and gather的报文必须要传输层头在线性空间才能使用硬件checksum功能）&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    uh-&gt;check = ~csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr, skb-&gt;len, IPPROTO_UDP, 0);
</span><span class='line'>skb-&gt;csum_start = skb_transport_header (skb) - skb-&gt;head;
</span><span class='line'>skb-&gt;csum_offset = offsetof(struct udphdr, check);
</span><span class='line'>skb-&gt;ip_summed = CHECKSUM_PARTIAL;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最后在dev_queue_xmit发送的时候发现设备不支持硬件checksum就会进行软件计算&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,
</span><span class='line'>                struct netdev_queue *txq)
</span><span class='line'>
</span><span class='line'>{
</span><span class='line'>    .......
</span><span class='line'>
</span><span class='line'>            /* If packet is not checksummed and device does not
</span><span class='line'>             * support checksumming for this protocol, complete
</span><span class='line'>             * checksumming here.
</span><span class='line'>             */
</span><span class='line'>            if (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {
</span><span class='line'>                skb_set_transport_header(skb, skb-&gt;csum_start -
</span><span class='line'>                        skb_headroom(skb));
</span><span class='line'>                if (!dev_can_checksum(dev, skb) &amp;&amp;
</span><span class='line'>                        skb_checksum_help(skb))
</span><span class='line'>                    goto out_kfree_skb;
</span><span class='line'>            }
</span><span class='line'>    ........
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[linux 实时时钟（RTC）驱动]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2016/01/12/kernel-base-rtc/"/&gt;
</span><span class='line'>&lt;updated&gt;2016-01-12T15:53:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2016/01/12/kernel-base-rtc&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="/download/kernel/rtc.txt"&gt;Documentation/rtc.txt&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://blog.csdn.net/yaozhenguo2006/article/details/6820218"&gt;http://blog.csdn.net/yaozhenguo2006/article/details/6820218&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这个是linux内核文档关于rtc实时时钟部分的说明，此文档主要描述了rtc实时时钟的作用和编程接口，分别介绍了老的rtc接口和新的rtc类架构。并给出了一个测试rtc驱动的程序。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;linux 实时时钟（RTC）驱动&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;翻译：窗外云天&lt;a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#97;&#x6f;&#122;&#104;&#x65;&#110;&#103;&#x75;&#x6f;&#x32;&#48;&#48;&#x36;&#64;&#x31;&#x32;&#54;&#46;&#x63;&#x6f;&#x6d;"&gt;&#x79;&#x61;&#111;&#x7a;&#x68;&#101;&#x6e;&#103;&#x75;&#x6f;&#50;&#48;&#48;&#x36;&#x40;&#49;&#x32;&#x36;&#x2e;&#99;&#x6f;&#x6d;&lt;/a&gt;  最后矫正时间：2011.9.25&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;当linux开发者提到“实时时钟”的时候，他们通常所指的就是墙钟时间，这个时间是电池供电的，所以在系统掉电的情况下还能正常工作。除非在MS-Windows启动的时候设置，否则这个时钟不会同步于本地时区和夏令时间。事实上，他被设置成格林威治时间。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最新的非pc体系的硬件趋向于记秒数，比如time(2)系统调用的输出，但是实时时钟用公历和24小时表示日期与时间，比如gmtime(3)的输出。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;linux提供两类的rtc兼容性很高的用户空间系统调用接口，如下所示：&lt;br/&gt;
</span><span class='line'>（1） /dev/rtc &hellip; 这个RTC适合pc体系的系统，而并不适合非x86体系的系统&lt;br/&gt;
</span><span class='line'>（2） /dev/rtc0,/dev/rtc1 &hellip; 他们依赖一种架构，这种架构在所有的系统上被RTC芯片广泛的支持。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;程序员必须知道，PC/AT的功能不总是有效，其他的系统可能会有另外的实现。这种情况下，如果在相同的系统结构上使用同样的RTC API，那么硬件会有不同的反应。例如，不是每一个RTC都提供IRQ，所以这些不能处理报警中断；标准的PC系统RTC只能处理未来24小时以内的闹钟，而其他系统的RTC可能处理未来一个世纪的任何时间。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;老的PC/AT驱动：/dev/rtc&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;所有基于PC的系统（甚至Alpha体系的机器）都有一个集成的实时时钟。通常他们集成在计算机的芯片组内，但是也有一些系统是在主板上焊接着摩托罗拉MC146818（或者类似的芯片），他们给系统提供时间和日期，这个时间和日期在系统掉电后仍然会保存。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ACPT(高级配置与电源管理接口)对MC146818的功能进行了标准化，并且在一些方面进行了功能扩展（提供了更长的定时周期，睡眠唤醒功能）。然而这些扩展的功能不适合老的驱动程序。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这个RTC还可以产生频率从 2HZ 到 8192HZ 的信号，以2的乘方增长。这些信号通过中断信号线8报告给系统。这个RTC还可以用作定时限制为24小时的闹钟，当定时时间到时产生8号中断。这个闹钟可以设置成任意一个可编程值的子集，这意味着可以设置成任意小时的任意分钟任意秒，例如，可以将这个时钟设置成在每个clk产生中断，从而产生1hz的信号。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这些中断通过/dev/rtc报告给系统（主设备号10,次设备号135，只读字符设备），中断传回一个无符号整数类型的数据。最低的位包含中断的类型（更新，闹钟，或者期），其他的字节代表了最后一次读到现在中断发生的次数。状态信息由虚拟文件/proc/driver/rtc产生，前提条件是使能了/proc文件系统。驱动应该提供锁机制，保证在同一时刻只有一个进程访问/dev/rtc。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;用户进程通过系统调用read(2)或者select(2)读取/dev/rtc来获取这些中断。当调用这两个系统调用的时候，进程会阻塞或者退出直到下一个中断到来。这个功能用在需要不频繁的获取数据而又不希望通过轮询当前时间而占用CPU时间的情况下。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在高频率中断或者高系统负载下，用户进程应该检查从上次读取到现在发生中断的次数以判断是否有未处理的中断。例如，一个典型的 486-33 对/dev/rtc以大于1024hz的频率进行循环读，偶尔会产生中断积累（从上次读取到现在发生大于一次的中断）。鉴于此你应该检查读取数据的高字节，特别是在频率高于普通定时器中断&ndash;100hz的情况下。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;中断频率是可编程的或可以让他超过64hz，但是只有root权限的用户可以这样做。这样做可能有点保守，但是我们不希望有恶意的用户在一个较慢的386sx-16机器上产生很多中断，这样会严重影响系统的性能。我们可以通过向/proc/sys/dev/rtc/max-user-freq写入值来修改这个64hz的限制。但是注意你一定要这样做，减少中断处理程序的代码才会亡羊补牢，使对系统性能的影响降到最小。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如果内核时间是和外部时钟源同步的，那么内核将每隔11分钟就会将时间写回CMOS时钟。在这个过程中，内核会关闭rtc周期中断，如果你的程序在做一些关键的工作一定要注意到。如果你的内核不和外部时钟源同步，那么内核会一直处理rtc中断，处理方式根据你具体的应用。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;闹钟和中断频率可以通过系统调用ioctl(2)来设置，ioctl的命令定义在./include/linux/rtc.h。与其长篇大论的介绍怎么样使用这个系统调用，还不如写一个实例程序来的方便，这个程序用来演示驱动的功能，对很多人来说用驱动程序提供的功能来进行应用编程他们会更感兴趣。在这个文档的最后有这段程序。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;新接口 “RTC类” 驱动：/dev/rtcn&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;因为linux支持许多非ACPI非PC平台，其中一些平台有不只一个RTC，所以需要更多可移植性的设计，而不是仅仅在每个系统都实现类似MC146818的接口。在这种情况下，新的“RTC类”构架产生了。他提供不同的用户空间接口：
</span><span class='line'>（1） /dev/rtcn 和老的接口一样
</span><span class='line'>（2）/dev/class/rtc/rtcn   sysfs 属性，一些属性是只读的
</span><span class='line'>（3） /dev/driver/rtc 第一个rtc会使用procfs接口。更多的信息会显示在这里而不是sysfs。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;RTC类构架支持很多类型的RTC，从集成在嵌入式SOC处理器内的RTC到通过I2C，SPI和其他总线连接到CPU的芯片。这个架构甚至还支持PC系统的RTC，包括使用ACPI，PC的一些新特性。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;新架构也打破了“每个系统只有一个RTC”的限制。例如，一个低功耗电池供电的RTC是一个分离的I2C接口的芯片，但是系统可能还集成了一个多功能的RTC。系统可能从分离的RTC读取系统时钟，但是对于其他任务用集成的RTC，因为这个RTC提供更多的功能。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;SYSFS 接口&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在/sys/class/rtc/rtcn下面的sysfs接口提供了操作rtc属性的方法，而不用通过Ioclt系统调用。所有的日期时间都是墙钟时间，而不是系统时间。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>date:           RTC提供的日期
</span><span class='line'>hctosys:        如果在内核配置选项中配置了CONFIG_RTC_HCTOSYS，RTC会在系统启动的时候提供系统时间，这种情况下这个位就是1,否则为0
</span><span class='line'>max_user_freq:  非特权用户可以从RTC得到的最大中断频率
</span><span class='line'>name:           RTC的名字，与sysfs目录相关
</span><span class='line'>since_epoch:    从纪元开始所经历的秒数
</span><span class='line'>time:           RTC提供的时间
</span><span class='line'>wakealarm:      唤醒时间的时间事件。 这是一种单次的唤醒事件，所以如果还需要唤醒，在唤醒发生后必须复位。这个域的数据结构或者是从纪元开始经历的妙数，或者是相对的秒数
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;IOCTL 接口&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;/dev/rtc支持的Ioctl系统调用，RTC类构架也支持。然而，因为芯片和系统没有一个统一的标准，一些PC/AT功能可能没有提供。以相同方式工作的一些新特性，&ndash;包括ACPI提供的，&ndash;在RTC类构架中表现出的，在老的驱动上不会工作。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（1） RTC_RD_TIME,RTC_SET_TIME .. 每一个RTC都至少支持读时间这个命令，时间格式为公历和24小时制墙钟时间。最有用的特性是，这个时间可以更新。&lt;br/&gt;
</span><span class='line'>（2） RTC_ATE_ON,RTC_ATE_OFF,RTC_ALM_SET,RTC_ALM_READ &hellip; 当RTC连接了一条IRQ线，他还能处理在未来24小时的报警中断。&lt;br/&gt;
</span><span class='line'>（3） RTC_WKALM_SET，RTC_WKALM_RD 。。。 RTCs 使用一个功能更强大的api,他可以处理超过24小时的报警时间。这个API支持设置更长的报警时间，支持单次请求的IRQ中断。&lt;br/&gt;
</span><span class='line'>（4） RTC_UIE_ON,RTC_UIE_OFF &hellip; 如果RTC提供IRQ，他可能也提供每秒更新的IRQ中断。如果需要，RTC结构可以模仿这个机制。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（5） RTC_PIE_ON,RTC_PIE_OFF,RTC_IRQP_SET,RTC_IRQP_READ &hellip; 如果一个IRQ是周期中断，那么这个IRQ还有可设置频率的特性（频率通常是2的n次方）&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;很多情况下，RTC报警时钟通常是一个系统唤醒事件，用于将Linux从低功耗睡眠模式唤醒到正常的工作模式。例如，系统会处于低功耗的模式下，直到时间到了去执行一些任务。注意这些ioctl的一些功能不必在你的驱动程序中实现。如果一个ioctl调用，你的驱动返回ENOIOCTLCMD，那么这个Ioctl就由通用RTC设备接口处理。下面是一些通用的例子：&lt;br/&gt;
</span><span class='line'>（6） RTC_RD_TIME, RTC_SET_TIME: read_time/set_time 函数会被调用。&lt;br/&gt;
</span><span class='line'>（7） RTC_ALM_SET, RTC_ALM_READ, RTC_WKALM_SET, RTC_WKALM_RD: set_alarm/read_alarm 函数将会被调用.&lt;br/&gt;
</span><span class='line'>（8） RTC_IRQP_SET, RTC_IRQP_READ: irq_set_freq 函数将会调用，用来设置频率，RTC类构架会处理读请求，而频率保存在RTC设备结构中的irq_freq域。你的驱动需要在模块初始化的时候初始化irq_freq，你必须在irq_set_freq函数里检查设置的频率是否在硬件允许的范围。如果不是那么驱动应该返回-EINVAL。如果你不需要改变这个频率，那么不要定义irq_set_freq这个函数。&lt;br/&gt;
</span><span class='line'>（7） RTC_PIE_ON, RTC_PIE_OFF: irq_set_state 函数会被调用。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  如果所有的ioctl都失败了，用下面的rtc-test.c检查一下你的驱动吧！&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    /*
</span><span class='line'> *      Real Time Clock Driver Test/Example Program
</span><span class='line'> *
</span><span class='line'> *      Compile with:
</span><span class='line'> *           gcc -s -Wall -Wstrict-prototypes rtctest.c -o rtctest
</span><span class='line'> *
</span><span class='line'> *      Copyright (C) 1996, Paul Gortmaker.
</span><span class='line'> *
</span><span class='line'> *      Released under the GNU General Public License, version 2,
</span><span class='line'> *      included herein by reference.
</span><span class='line'> *
</span><span class='line'> */
</span><span class='line'>
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;linux/rtc.h&gt;
</span><span class='line'>#include &lt;sys/ioctl.h&gt;
</span><span class='line'>#include &lt;sys/time.h&gt;
</span><span class='line'>#include &lt;sys/types.h&gt;
</span><span class='line'>#include &lt;fcntl.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;errno.h&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>/*
</span><span class='line'> * This expects the new RTC class driver framework, working with
</span><span class='line'> * clocks that will often not be clones of what the PC-AT had.
</span><span class='line'> * Use the command line to specify another RTC if you need one.
</span><span class='line'> */
</span><span class='line'>static const char default_rtc[] = "/dev/rtc0";
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>    int i, fd, retval, irqcount = 0;
</span><span class='line'>    unsigned long tmp, data;
</span><span class='line'>    struct rtc_time rtc_tm;
</span><span class='line'>    const char *rtc = default_rtc;
</span><span class='line'>
</span><span class='line'>    switch (argc) {
</span><span class='line'>    case 2:
</span><span class='line'>        rtc = argv[1];
</span><span class='line'>        /* FALLTHROUGH */
</span><span class='line'>    case 1:
</span><span class='line'>        break;
</span><span class='line'>    default:
</span><span class='line'>        fprintf(stderr, "usage:  rtctest [rtcdev]\n");
</span><span class='line'>        return 1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    fd = open(rtc, O_RDONLY);
</span><span class='line'>
</span><span class='line'>    if (fd ==  -1) {
</span><span class='line'>        perror(rtc);
</span><span class='line'>        exit(errno);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    fprintf(stderr, "\n\t\t\tRTC Driver Test Example.\n\n");
</span><span class='line'>
</span><span class='line'>    /* Turn on update interrupts (one per second) */
</span><span class='line'>    retval = ioctl(fd, RTC_UIE_ON, 0);
</span><span class='line'>    if (retval == -1) {
</span><span class='line'>        if (errno == ENOTTY) {
</span><span class='line'>            fprintf(stderr,
</span><span class='line'>                "\n...Update IRQs not supported.\n");
</span><span class='line'>            goto test_READ;
</span><span class='line'>        }
</span><span class='line'>        perror("RTC_UIE_ON ioctl");
</span><span class='line'>        exit(errno);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    fprintf(stderr, "Counting 5 update (1/sec) interrupts from reading %s:",
</span><span class='line'>            rtc);
</span><span class='line'>    fflush(stderr);
</span><span class='line'>    for (i=1; i&lt;6; i++) {
</span><span class='line'>        /* This read will block */
</span><span class='line'>        retval = read(fd, &amp;data, sizeof(unsigned long));
</span><span class='line'>        if (retval == -1) {
</span><span class='line'>            perror("read");
</span><span class='line'>            exit(errno);
</span><span class='line'>        }
</span><span class='line'>        fprintf(stderr, " %d",i);
</span><span class='line'>        fflush(stderr);
</span><span class='line'>        irqcount++;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    fprintf(stderr, "\nAgain, from using select(2) on /dev/rtc:");
</span><span class='line'>    fflush(stderr);
</span><span class='line'>    for (i=1; i&lt;6; i++) {
</span><span class='line'>        struct timeval tv = {5, 0};     /* 5 second timeout on select */
</span><span class='line'>        fd_set readfds;
</span><span class='line'>
</span><span class='line'>        FD_ZERO(&amp;readfds);
</span><span class='line'>        FD_SET(fd, &amp;readfds);
</span><span class='line'>        /* The select will wait until an RTC interrupt happens. */
</span><span class='line'>        retval = select(fd+1, &amp;readfds, NULL, NULL, &amp;tv);
</span><span class='line'>        if (retval == -1) {
</span><span class='line'>                perror("select");
</span><span class='line'>                exit(errno);
</span><span class='line'>        }
</span><span class='line'>        /* This read won't block unlike the select-less case above. */
</span><span class='line'>        retval = read(fd, &amp;data, sizeof(unsigned long));
</span><span class='line'>        if (retval == -1) {
</span><span class='line'>                perror("read");
</span><span class='line'>                exit(errno);
</span><span class='line'>        }
</span><span class='line'>        fprintf(stderr, " %d",i);
</span><span class='line'>        fflush(stderr);
</span><span class='line'>        irqcount++;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Turn off update interrupts */
</span><span class='line'>    retval = ioctl(fd, RTC_UIE_OFF, 0);
</span><span class='line'>    if (retval == -1) {
</span><span class='line'>        perror("RTC_UIE_OFF ioctl");
</span><span class='line'>        exit(errno);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>test_READ:
</span><span class='line'>    /* Read the RTC time/date */
</span><span class='line'>    retval = ioctl(fd, RTC_RD_TIME, &amp;rtc_tm);
</span><span class='line'>    if (retval == -1) {
</span><span class='line'>        perror("RTC_RD_TIME ioctl");
</span><span class='line'>        exit(errno);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    fprintf(stderr, "\n\nCurrent RTC date/time is %d-%d-%d, %02d:%02d:%02d.\n",
</span><span class='line'>        rtc_tm.tm_mday, rtc_tm.tm_mon + 1, rtc_tm.tm_year + 1900,
</span><span class='line'>        rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec);
</span><span class='line'>
</span><span class='line'>    /* Set the alarm to 5 sec in the future, and check for rollover */
</span><span class='line'>    rtc_tm.tm_sec += 5;
</span><span class='line'>    if (rtc_tm.tm_sec &gt;= 60) {
</span><span class='line'>        rtc_tm.tm_sec %= 60;
</span><span class='line'>        rtc_tm.tm_min++;
</span><span class='line'>    }
</span><span class='line'>    if (rtc_tm.tm_min == 60) {
</span><span class='line'>        rtc_tm.tm_min = 0;
</span><span class='line'>        rtc_tm.tm_hour++;
</span><span class='line'>    }
</span><span class='line'>    if (rtc_tm.tm_hour == 24)
</span><span class='line'>        rtc_tm.tm_hour = 0;
</span><span class='line'>
</span><span class='line'>    retval = ioctl(fd, RTC_ALM_SET, &amp;rtc_tm);
</span><span class='line'>    if (retval == -1) {
</span><span class='line'>        if (errno == ENOTTY) {
</span><span class='line'>            fprintf(stderr,
</span><span class='line'>                "\n...Alarm IRQs not supported.\n");
</span><span class='line'>            goto test_PIE;
</span><span class='line'>        }
</span><span class='line'>        perror("RTC_ALM_SET ioctl");
</span><span class='line'>        exit(errno);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Read the current alarm settings */
</span><span class='line'>    retval = ioctl(fd, RTC_ALM_READ, &amp;rtc_tm);
</span><span class='line'>    if (retval == -1) {
</span><span class='line'>        perror("RTC_ALM_READ ioctl");
</span><span class='line'>        exit(errno);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    fprintf(stderr, "Alarm time now set to %02d:%02d:%02d.\n",
</span><span class='line'>        rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec);
</span><span class='line'>
</span><span class='line'>    /* Enable alarm interrupts */
</span><span class='line'>    retval = ioctl(fd, RTC_AIE_ON, 0);
</span><span class='line'>    if (retval == -1) {
</span><span class='line'>        perror("RTC_AIE_ON ioctl");
</span><span class='line'>        exit(errno);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    fprintf(stderr, "Waiting 5 seconds for alarm...");
</span><span class='line'>    fflush(stderr);
</span><span class='line'>    /* This blocks until the alarm ring causes an interrupt */
</span><span class='line'>    retval = read(fd, &amp;data, sizeof(unsigned long));
</span><span class='line'>    if (retval == -1) {
</span><span class='line'>        perror("read");
</span><span class='line'>        exit(errno);
</span><span class='line'>    }
</span><span class='line'>    irqcount++;
</span><span class='line'>    fprintf(stderr, " okay. Alarm rang.\n");
</span><span class='line'>
</span><span class='line'>    /* Disable alarm interrupts */
</span><span class='line'>    retval = ioctl(fd, RTC_AIE_OFF, 0);
</span><span class='line'>    if (retval == -1) {
</span><span class='line'>        perror("RTC_AIE_OFF ioctl");
</span><span class='line'>        exit(errno);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>test_PIE:
</span><span class='line'>    /* Read periodic IRQ rate */
</span><span class='line'>    retval = ioctl(fd, RTC_IRQP_READ, &amp;tmp);
</span><span class='line'>    if (retval == -1) {
</span><span class='line'>        /* not all RTCs support periodic IRQs */
</span><span class='line'>        if (errno == ENOTTY) {
</span><span class='line'>            fprintf(stderr, "\nNo periodic IRQ support\n");
</span><span class='line'>            goto done;
</span><span class='line'>        }
</span><span class='line'>        perror("RTC_IRQP_READ ioctl");
</span><span class='line'>        exit(errno);
</span><span class='line'>    }
</span><span class='line'>    fprintf(stderr, "\nPeriodic IRQ rate is %ldHz.\n", tmp);
</span><span class='line'>
</span><span class='line'>    fprintf(stderr, "Counting 20 interrupts at:");
</span><span class='line'>    fflush(stderr);
</span><span class='line'>
</span><span class='line'>    /* The frequencies 128Hz, 256Hz, ... 8192Hz are only allowed for root. */
</span><span class='line'>    for (tmp=2; tmp&lt;=64; tmp*=2) {
</span><span class='line'>
</span><span class='line'>        retval = ioctl(fd, RTC_IRQP_SET, tmp);
</span><span class='line'>        if (retval == -1) {
</span><span class='line'>            /* not all RTCs can change their periodic IRQ rate */
</span><span class='line'>            if (errno == ENOTTY) {
</span><span class='line'>                fprintf(stderr,
</span><span class='line'>                    "\n...Periodic IRQ rate is fixed\n");
</span><span class='line'>                goto done;
</span><span class='line'>            }
</span><span class='line'>            perror("RTC_IRQP_SET ioctl");
</span><span class='line'>            exit(errno);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        fprintf(stderr, "\n%ldHz:\t", tmp);
</span><span class='line'>        fflush(stderr);
</span><span class='line'>
</span><span class='line'>        /* Enable periodic interrupts */
</span><span class='line'>        retval = ioctl(fd, RTC_PIE_ON, 0);
</span><span class='line'>        if (retval == -1) {
</span><span class='line'>            perror("RTC_PIE_ON ioctl");
</span><span class='line'>            exit(errno);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        for (i=1; i&lt;21; i++) {
</span><span class='line'>            /* This blocks */
</span><span class='line'>            retval = read(fd, &amp;data, sizeof(unsigned long));
</span><span class='line'>            if (retval == -1) {
</span><span class='line'>                perror("read");
</span><span class='line'>                exit(errno);
</span><span class='line'>            }
</span><span class='line'>            fprintf(stderr, " %d",i);
</span><span class='line'>            fflush(stderr);
</span><span class='line'>            irqcount++;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        /* Disable periodic interrupts */
</span><span class='line'>        retval = ioctl(fd, RTC_PIE_OFF, 0);
</span><span class='line'>        if (retval == -1) {
</span><span class='line'>            perror("RTC_PIE_OFF ioctl");
</span><span class='line'>            exit(errno);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>done:
</span><span class='line'>    fprintf(stderr, "\n\n\t\t\t *** Test complete ***\n");
</span><span class='line'>
</span><span class='line'>    close(fd);
</span><span class='line'>
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[Web压力测试工具]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/12/27/kernel-net-test-tool/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-12-27T02:51:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/12/27/kernel-net-test-tool&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://297020555.blog.51cto.com/1396304/592386"&gt;http://297020555.blog.51cto.com/1396304/592386&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;一、http_load&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;http_load以并行复用的方式运行，用以测试web服务器的吞吐量与负载。但是它不同于大多数压力测试工具，它可以以一个单一的进程运行，一般不会把客户机搞死。还可以测试HTTPS类的网站请求。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;下载地址：&lt;a href="http://www.acme.com/software/http_load/"&gt;http://www.acme.com/software/http_load/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    ./http_load -verbose -proxy 192.168.99.6:80 -parallel 24 -seconds 1000 url.txt
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;二、webbench&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;webbench是Linux下的一个网站压力测试工具，最多可以模拟3万个并发连接去测试网站的负载能力。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>用法：webbench -c 并发数 -t 运行测试时间 URL
</span><span class='line'>如：webbench -c 5000 -t 120 http://www.163.com
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;三、ab&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ab是apache自带的一款功能强大的测试工具。安装了apache一般就自带了，用法可以查看它的说明&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;参数众多，一般我们用到的是-n 和-c&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;例如：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>./ab -c 1000 -n 100 http://www.vpser.net/index.php
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>这个表示同时处理1000个请求并运行100次index.php文件.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;四、Siege&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;一款开源的压力测试工具，可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。
</span><span class='line'>官方：&lt;a href="http://www.joedog.org/"&gt;http://www.joedog.org/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;使用
</span><span class='line'>&lt;code&gt;
</span><span class='line'>siege -c 200 -r 10 -f example.url
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;-c是并发量，-r是重复次数。 url文件就是一个文本，每行都是一个url，它会从里面随机访问的。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[TCP拥塞控制窗口有效性验证机制]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/12/08/kernel-net-cwnd-test/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-12-08T15:49:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/12/08/kernel-net-cwnd-test&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;blog.csdn.net/zhangskd/article/details/7609465&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;概述&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;问题1：当发送方长时间受到应用程序的限制，不能发送数据时，会使拥塞窗口无效。TCP是根据拥塞窗口来动态地估计网络带宽的。发送方受到应用程序的限制后，没有数据可以发送。那么此时的拥塞窗口就不能准确的反应网络状况，因为这个拥塞窗口是很早之前的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;问题2：当发送方受到应用程序限制，不能利用完拥塞窗口，会使拥塞窗口的增长无效。TCP不断调整cwnd来测试网络带宽。如果不能完全使用掉cwnd，就不知道网络能否承受得了cwnd的数据量，这种情况下的cwnd增长是无效的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;原理&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;TCP sender受到的两种限制&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;(1) application-limited ：when the sender sends less than is allowed by the congestion or receiver window.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;(2) network-limited：when the sender is limited by the TCP window. More precisely, we define a network-limited period as any period when the sender is sending a full window of data.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;问题1描述&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;TCP&rsquo;s congestion window controls the number of packets a TCP flow may have in the
</span><span class='line'>network at any time. However, long periods when the sender is idle or application-limited
</span><span class='line'>can lead to the invalidation of the congestion window, in that the congestion window no longer
</span><span class='line'>reflects current information about the state of the network.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;The congestion window is set using an Additive-Increase, Multiplicative-Decrease(AIMD) mechanism
</span><span class='line'>that probes for available bandwidth, dynamically adapting to changing network conditions. This AIMD
</span><span class='line'>works well when the sender continually has data to send, as is typically the case for TCP used for
</span><span class='line'>bulk-data transfer. In contrast, for TCP used with telnet applications, the data sender often has little
</span><span class='line'>or no data to send, and the sending rate is often determined by the rate at which data is generated
</span><span class='line'>by the user.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;问题2描述&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;An invalid congestion window also results when the congestion window is increased (i.e.,
</span><span class='line'>in TCP&rsquo;s slow-start or congestion avoidance phases) during application-limited periods, when the
</span><span class='line'>previous value of the congestion window might never have been fully utilized. As far as we know, all
</span><span class='line'>current TCP implementations increase the congestion window when an acknowledgement arrives,
</span><span class='line'>if allowed by the receiver&rsquo;s advertised window and the slow-start or congestion avoidance window
</span><span class='line'>increase algorithm, without checking to see if the previous value of the congestion window has in
</span><span class='line'>fact been used.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;This document proposes that the window increase algorithm not be invoked during application-
</span><span class='line'>limited periods. This restriction prevents the congestion window from growing arbitrarily large,
</span><span class='line'>in the absence of evidence that the congestion window can be supported by the network.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;实现(1)&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;发送方在发送数据包时，如果发送的数据包有负载，则会检测拥塞窗口是否超时。如果超时，则会使拥塞窗口失效并重新计算拥塞窗口。然后根据最近接收段的时间，确定是否进入pingpong模式。</span></code></pre></td></tr></table></div></figure>
    /<em> Congestion state accounting after a packet has been sent. </em>/<br/>
    static void tcp_event_data_sent (struct tcp_sock <em>tp, struct sock </em>sk)<br/>
    {<br/>
        struct inet_connection_sock *icsk = inet_csk(sk);<br/>
        const u32 now = tcp_time_stamp;</p>

<pre><code>    if (sysctl_tcp_slow_start_after_idle &amp;&amp;   
        (!tp-&gt;packets_out &amp;&amp; (s32) (now - tp-&gt;lsndtime) &gt; icsk-&gt;icsk_rto))  
        tcp_cwnd_restart(sk, __sk_dst_get(sk)); /* 重置cnwd */  

    tp-&gt;lsndtime = now; /* 更新最近发包的时间*/  

    /* If it is a reply for ato after last received packets,  
     * enter pingpong mode. */  
    if ((u32)(now - icsk-&gt;icsk_ack.lrcvtime) &lt; icsk.icsk_ack.ato)  
        icsk-&gt;icsk_ack.pingpong = 1;  
}  
</code></pre>

<pre><code>
tcp_event_data_sent()中，符合三个条件才重置cwnd：

（1）tcp_slow_start_after_idle选项设置，这个内核默认置为1
（2）tp-&gt;packets_out == 0，表示网络中没有未确认数据包
（3）now - tp-&gt;lsndtime &gt; icsk-&gt;icsk_rto，距离上次发送数据包的时间超过了RTO
</code></pre>

<pre><code>/* RFC2861. Reset CWND after idle period longer RTO to "restart window". 
 * This is the first part of cnwd validation mechanism. 
 */  
static void tcp_cwnd_restart (struct sock *sk, const struct dst_entry *dst)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    s32 delta = tcp_time_stamp - tp-&gt;lsndtime;  

    /* 关于tcp_init_cwnd()可见上一篇blog.*/  
    u32 restart_cwnd = tcp_init_cwnd(tp, dst);  
    u32 cwnd = tp-&gt;snd_cwnd;  

    /* 触发拥塞窗口重置事件*/  
    tcp_ca_event(sk, CA_EVENT_CWND_RESTART);  

    /* 阈值保存下来，并没有重置。*/  
    tp-&gt;snd_ssthresh = tcp_current_ssthresh(sk);  
    restart_cwnd = min(restart_cwnd, cwnd);  

    /* 闲置时间每超过一个RTO且cwnd比重置后的大时，cwnd减半。*/  
    while((delta -= inet_csk(sk)-&gt;icsk_rto) &gt; 0 &amp;&amp; cwnd &gt; restart_cwnd)  
        cwnd &gt;&gt; 1;  

    tp-&gt;snd_cwnd = max(cwnd, restart_cwnd); /* 取其大者！*/  
    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;  
    tp-&gt;snd_cwnd_used = 0;  
}  
</code></pre>

<pre><code>
那么调用tcp_cwnd_restart()后，tp-&gt;snd_cwnd是多少呢？这个是不确定的，要看闲置时间delta、闲置前的cwnd、路由器中设置的initcwnd。当然，最大概率的是：拥塞窗口降为闲置前cwnd的一半。

#### 实现(2)

在发送方成功发送一个数据包后，会检查从发送队列发出而未确认的数据包是否用完拥塞窗口。
如果拥塞窗口被用完了，说明发送方收到网络限制；
如果拥塞窗口没被用完，且距离上次检查时间超过了RTO，说明发送方收到应用程序限制。
</code></pre>

<pre><code>/* Congestion window validation.(RFC2861) */  
static void tcp_cwnd_validate(struct sock *sk) {  
    struct tcp_sock *tp = tcp_sk(sk);  

    if (tp-&gt;packets_out &gt;= tp-&gt;snd_cwnd) {  
        /* Network is feed fully. */  
        tp-&gt;snd_cwnd_used = 0; /*不用这个变量*/  
        tp-&gt;snd_cwnd_stamp = tcp_time_stamp; /* 更新检测时间*/  

    } else {  
        /* Network starves. */  
        if (tp-&gt;packets_out &gt; tp-&gt;snd_cwnd_used)  
            tp-&gt;snd_cwnd_used = tp-&gt;packets_out; /* 更新已使用窗口*/  

            /* 如果距离上次检测的时间，即距离上次发包时间已经超过RTO*/  
            if (sysctl_tcp_slow_start_after_idle &amp;&amp;  
                (s32) (tcp_time_stamp - tp-&gt;snd_cwnd_stamp) &gt;= inet_csk(sk)-&gt;icsk_rto)  
                tcp_cwnd_application_limited(sk);  
    }  
}  
</code></pre>

<pre><code>
在发送方收到应用程序的限制期间，每隔RTO时间，都会调用tcp_cwnd_application_limited()来重新设置sshresh和cwnd，具体如下：
</code></pre>

<pre><code>/* RFC2861, slow part. Adjust cwnd, after it was not full during one rto. 
 * As additional protections, we do not touch cwnd in retransmission phases, 
 * and if application hit its sndbuf limit recently. 
 */  
void tcp_cwnd_application_limited(struct sock *sk)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  

    /* 只有处于Open态，应用程序没受到sndbuf限制时，才进行 
     * ssthresh和cwnd的重置。 
     */  
    if (inet_csk(sk)-&gt;icsk_ca_state == TCP_CA_Open &amp;&amp;   
        sk-&gt;sk_socket &amp;&amp; !test_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags)) {  

        /* Limited by application or receiver window. */  
        u32 init_win = tcp_init_cwnd(tp, __sk_dst_get(sk));  
        u32 win_used = max(tp-&gt;snd_cwnd_used, init_win);  

        /* 没用完拥塞窗口*/  
        if (win_used &lt; tp-&gt;snd_cwnd) {  
            /* 并没有减小ssthresh，反而增大，保留了过去的信息，以便之后有数据发送 
              * 时能快速增大到接近此时的窗口。 
              */  
            tp-&gt;snd_ssthresh = tcp_current_ssthresh(sk);   
            /* 减小了snd_cwnd */  
            tp-&gt;snd_cwnd = (tp-&gt;snd_cwnd + win_used) &gt;&gt; 1;  
        }  
        tp-&gt;snd_cwnd_used = 0;  
    }  
    tp-&gt;snd_cwnd_stamp = tcp_time_stamp; /* 更新最近的数据包发送时间*/  
}  
</code></pre>

<p>```</p>

<p>发送方受到应用程序限制，且限制的时间每经过RTO后，就会调用以上函数来处理snd_ssthresh和snd_cwnd：</p>

<p>（1）snd_ssthresh = max(snd_ssthresh, &frac34; cwnd)</p>

<p>慢启动阈值并没有减小，相反，如果此时cwnd较大，ssthresh会相应的增大。ssthresh是一个很重要的参数，它保留了旧的信息。这样一来，如果应用程序产生了大量的数据，发送方不再受到限制后，经过慢启动阶段，拥塞窗口就能快速恢复到接近以前的值了。</p>

<p>（2）snd_cwnd = (snd_cwnd + snd_cwnd_used) / 2</p>

<p>因为snd_cwnd_used &lt; snd_cwnd，所以snd_cwnd是减小了的。减小snd_cwnd是为了不让它盲目的增长。因为发送方没有利用完拥塞窗口，并不能检测到网络是否能承受该拥塞窗口，这时的增长是无根据的。</p>

<h4>结论</h4>

<p>在发送完数据包后，通过对拥塞窗口有效性的检验，能够避免使用不合理的拥塞窗口。</p>

<p>拥塞窗口代表着网络的状况，通过避免使用不合理的拥塞窗口，就能得到正确的网络状况，而不会采取一些不恰当的措施。</p>

<p>在上文的两种情况下，通过TCP的拥塞窗口有效性验证机制（TCP congestion window validationmechanism），能够更合理的利用网络、避免丢包，从而提高传输效率。</p>

<h4>Reference</h4>

<p>RFC2861</p>
]]></content>
  </entry>
  
</feed>
