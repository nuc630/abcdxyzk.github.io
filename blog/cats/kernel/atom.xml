<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-07-15T20:09:33+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LVS详解]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/15/kernel-net-lvs-detail/"/>
    <updated>2015-07-15T14:42:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/15/kernel-net-lvs-detail</id>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/xiaocen/p/3709869.html">http://www.cnblogs.com/xiaocen/p/3709869.html</a></p>

<h3>简介：</h3>

<p>Linux 虚拟服务器(Linux Virtual Server. LVS),是一个由章文松开发的自由软件.利用KVS可以实现高可用的、可伸缩缩的Web, Mail, Cache和Medial等网络股务..井在此基 础上开发支持庞大用户数的，可伸缩的，高可用的电子商务应用。LVS1998年发展到现在，已经变得比较成熟，目前广泛应用在各种网络服务和电了商务应用 中.</p>

<p>LVS具有很好的伸缩缩性、可靠性和管埋性，通过LVS要实现的最终目标是：利用linux 操作系统和LVS集群软件实现一个高可用、高性能，低成本的服务器应用集群。</p>

<h3>LVS集群的组成</h3>

<p>利用LVS架设的服务器群系统由3个部分组成：最前端的是负栽均衡层（这里用 Lo ad Balancer表示），中间是服务器集群层(用Server Array表示).
LVS体系结构如下图所示：</p>

<p><img src="/images/kernel/2015-07-15-1.jpg" alt="" /></p>

<p>下面对LVS的各个组成部分进行详细介绍</p>

<p>负栽均衡层：位于整个集群系统的最前端，由一台或多台负栽调度器（Dircctm Server)组成.LVS核心模块IPVS就安装在director Server上，而director的主要作用类似于一个路由器，它含有为完成LVS功能所设定的路由表，通过这些路由表把用户的请求分发给服务器群组层 的应用服务器(real Server)。同时，在director server上还要安装队real server的监控模块Ldirectord，此模块用于监测各个real server 服务的健康状况。在real server 不可同时可以讲其从LVS路由表中剔除，在恢复时重新加入。</p>

<p>服务器群组层：由一组实际运行应用服务的机器组成，real Server可以是Web服务器、Mail服务器、FTP服务器、DNS服务器、视颊服务器中的一个或多个，每个Real Server之间通过高速的LAN或分布在</p>

<p>各地的WAN相连接:实际的应用中， Director Server也可以同时兼任Real Server的角色</p>

<p>共字存储层是为所有Real Server提供共亨存储空问和内容一致性的存储区域，一般由磁盘阵列设备组成。为了提俱内容的一致性，一般可以通过NFS网络义件系统共 亨数据，但是NFS在繁忙的业务系统中，性能并不是很好，此时可以采用集群文件 系统，例如Red Hat的GFS文件系统，Oracle提供的OS2文件系统等。</p>

<p>从整个LVS结构可以看出，Director Server是整个LVS的核心。目前，用干Director Server 的操作系统只有Linux和FreeBSD, Linux 2.6内核完全内置了LVS的各个模块，不用任何 设置就可以支持LVS功能。</p>

<p>对于 Real.Server,几乎所有的系统平台，如 Linux、.. Windows、Solaris、AIX、BSD 系列等都能很好地支持它</p>

<h3>LVS集群的特点</h3>

<h4>1. IP负载均衡与负载调度</h4>

<p>负栽均衡技术有很多实现方案，有基于DNS.域名轮流解析的方法，有基于客户端调度访问的方法，还有基于应用层系统负栽的调度方法，还有基于p地址的调度方法。在这些负栽 调度算法中，执行效率最卨的是IP负栽均衡技术。</p>

<p>LVS 的IP负栽均衡技术是通过IPVS模块来实现的。IPVS是LVS集群系统的核心软件， 它的主要作用是:安装在Director Server上，同时在Director Server ..上虚拟出一个IP地址， 用户必须通过这个虚拟的IP地址访问服务器，这个虚拟IP —般称为LVS的VIP,即Virtual IP  访问的请求首先经过VIP到达负栽调度器，然后由负栽调度器从Real Server列表中选取 一个服务节点响应用户的请求。
在用户的清求到达负栽调度器后，调度器如何将请求发送到提供服务的Real Server节 点，而Real Server节点如何返回数据给用户，是IPVS实现的重点技术。IPVS实现负栽均 衡的方式有4种.分别是NAT|Full NAT、TUN和DR。下面进行详细介绍。</p>

<h5>IPVS/NAT ：</h5>

<p>即 Virtual Server via Network Address Translation,也就是网络地址翻译技术实现虚拟服务器。当用户请求到达调度器时，调度器将请求报文的目标地址（即 虚拟IP地址）改写成选定的Real Server地址，同时将报文的目标端口也改成选定的 Real Server的相应端口，最后将报文请求发送到选定的Real Server。在服务器端得到数据后，Real Server将数据返回给用户时，需要再次经过负栽调度器将报文的源地址和源端口改成虚拟IP地址和相应端口,然后把数据发送给用户，完成整个负栽调度过 程。可以看出，在NAT方式下，用户请求和响应报文都必须经过Director Server地址重写， 当用户请求越来越多时，调度器的处理能力将成为瓶颈. 如下图所示：IPVS/NAT 架构图</p>

<p>NAT：多目标的DNAT</p>

<p>特性：<br/>
  RS应该使用私有地址；<br/>
  RS的网关必须指向DIP；<br/>
  RIP和DIP必须在同一网段内；<br/>
  请求和响应的报文都得经过Director；（在高负载应用场景中，Director很可能成为系统性能瓶颈）<br/>
  支持端口映射；<br/>
  RS可以使用任意支持集群服务的OS(如Windows)</p>

<p>适用场景：非高并发请求场景，10个RS以内；可隐藏内部的DIP和RIP地址；</p>

<p>结构图:</p>

<p><img src="/images/kernel/2015-07-15-2.jpg" alt="" /></p>

<h5>LVS/TUN ：</h5>

<p>即Virtual Server via IP Tunneling,也就是通过IP隧道技术实现虚拟服务器。这种方式的连接调度度和管理与VS/NAT方式一样，只是报文转发方法不同。在 VS/TUN方式中，调度器采用IP隧道技术将用户清求转发到某个Real Server,而这 个Real Server 将直接响应用户的请求，不再经过前端调度器。此外，对Real Server 的地域位置没有要求，可以和Director Server位于同一个网段，也可以在独立的一个 网络中。因此，在TUN方式中，调度器将只处理用户的报文请求，从而使集群系统 的吞吐量大大提高。如下图所示VS/TUN 架构图：</p>

<p>TUN：IP隧道，即含有多个IP报头</p>

<p>特性：<br/>
  RIP、DIP、VIP都得是公网地址；<br/>
  RS的网关不会指向也不可能指向DIP；<br/>
  请求报文经过Director，但响应报文一定不经过Director；<br/>
  不支持端口映射；<br/>
  RS的操作系统必须得支持隧道功能，即部署ipip模块</p>

<p>适用场景：跨互联网的请求转发</p>

<p>结构图：</p>

<p><img src="/images/kernel/2015-07-15-3.jpg" alt="" /></p>

<h5>FULLNAT是一种新的转发模式</h5>

<p>– 主要思想：引入local address（内网ip地址），cip-vip转
换为lip->rip，而 lip和rip均为IDC内网ip，可以跨vlan通
讯；</p>

<p>FULLNAT：NAT模型的改进版</p>

<p>特性：<br/>
  实现RS间跨VLAN通信，是NAT模式的改进版；<br/>
  默认内核不支持，需重新编译内核，才能使用；</p>

<p>适用场景：内网服务器跨VLAN的负载分担</p>

<p>结构图：</p>

<p><img src="/images/kernel/2015-07-15-4.jpg" alt="" /></p>

<h5>LVS/DR：</h5>

<p>即Virtual Server via Direct Routing,也就是用直接路由技术实现虚拟服务器。 这种方式的连按调度和管理与前两种一样，但它的报文转发方法又有所不同，VS/DR 通过改写请求报文的MAC地址，将请求发送到Real Server,而Real Server将响应直接返回给客户.免去了VS/TUN中的IP隧道开销，这种方式是3种负莪调度方式中 性能最好的，但是要求Director Server与Real Server必须由一块网卡连在同一物理网段上。</p>

<p>如下图所示：VS/DR 架构图</p>

<p>DR：Direct Routing</p>

<p>需解决的关键问题： 让前端路由将请求发往VIP时，只能是Director上的VIP进行响应；实现方式是修改RS上的Linux内核参数，将RS上的VIP配置为lo接口的别名，并限制Linux仅对对应接口的ARP请求做响应</p>

<p>特性：<br/>
  RS可以使用私有地址，但也可以使用公网地址，此时可以直接通过互联网连入RS以实现配置，监控等；<br/>
  RS的网关一定不能指向DIP；<br/>
  RS和Director要在同一物理网络(即不能由路由器分隔)<br/>
  请求报文经过Director，但响应报文一定不进过Director；<br/>
  不支持端口映射；<br/>
  RS可以使用大多数的操作系统</p>

<p>适用场景：因为响应报文不经过Director，极大的减轻了Director的负载压力，故Director可以支持更大的并发访问，一般RS在100台以内；</p>

<p>结构图：</p>

<p>LVS-DR配置架构根据其VIP与RIP是否在同一个网段内又分为两种模型:</p>

<p><img src="/images/kernel/2015-07-15-5.jpg" alt="" /></p>

<h4>LVS调度算法</h4>

<p>静态方法：仅根据算法本身进行调度
<code>
    rr：Round Robin # 即轮询
    wrr：Weighted RR # 即加权轮询
    sh：Source Hashing # 即来源IP地址hash
    dh：Destination Hashing # 即目标地址hash（不常用，仅用于前端多防火墙的场景，保证防火墙的连接追踪功能有效）
</code></p>

<p>动态方法：根据算法及RS当前的负载情况
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
<span class='line-number'>571</span>
<span class='line-number'>572</span>
<span class='line-number'>573</span>
<span class='line-number'>574</span>
<span class='line-number'>575</span>
<span class='line-number'>576</span>
<span class='line-number'>577</span>
<span class='line-number'>578</span>
<span class='line-number'>579</span>
<span class='line-number'>580</span>
<span class='line-number'>581</span>
<span class='line-number'>582</span>
<span class='line-number'>583</span>
<span class='line-number'>584</span>
<span class='line-number'>585</span>
<span class='line-number'>586</span>
<span class='line-number'>587</span>
<span class='line-number'>588</span>
<span class='line-number'>589</span>
<span class='line-number'>590</span>
<span class='line-number'>591</span>
<span class='line-number'>592</span>
<span class='line-number'>593</span>
<span class='line-number'>594</span>
<span class='line-number'>595</span>
<span class='line-number'>596</span>
<span class='line-number'>597</span>
<span class='line-number'>598</span>
<span class='line-number'>599</span>
<span class='line-number'>600</span>
<span class='line-number'>601</span>
<span class='line-number'>602</span>
<span class='line-number'>603</span>
<span class='line-number'>604</span>
<span class='line-number'>605</span>
<span class='line-number'>606</span>
<span class='line-number'>607</span>
<span class='line-number'>608</span>
<span class='line-number'>609</span>
<span class='line-number'>610</span>
<span class='line-number'>611</span>
<span class='line-number'>612</span>
<span class='line-number'>613</span>
<span class='line-number'>614</span>
<span class='line-number'>615</span>
<span class='line-number'>616</span>
<span class='line-number'>617</span>
<span class='line-number'>618</span>
<span class='line-number'>619</span>
<span class='line-number'>620</span>
<span class='line-number'>621</span>
<span class='line-number'>622</span>
<span class='line-number'>623</span>
<span class='line-number'>624</span>
<span class='line-number'>625</span>
<span class='line-number'>626</span>
<span class='line-number'>627</span>
<span class='line-number'>628</span>
<span class='line-number'>629</span>
<span class='line-number'>630</span>
<span class='line-number'>631</span>
<span class='line-number'>632</span>
<span class='line-number'>633</span>
<span class='line-number'>634</span>
<span class='line-number'>635</span>
<span class='line-number'>636</span>
<span class='line-number'>637</span>
<span class='line-number'>638</span>
<span class='line-number'>639</span>
<span class='line-number'>640</span>
<span class='line-number'>641</span>
<span class='line-number'>642</span>
<span class='line-number'>643</span>
<span class='line-number'>644</span>
<span class='line-number'>645</span>
<span class='line-number'>646</span>
<span class='line-number'>647</span>
<span class='line-number'>648</span>
<span class='line-number'>649</span>
<span class='line-number'>650</span>
<span class='line-number'>651</span>
<span class='line-number'>652</span>
<span class='line-number'>653</span>
<span class='line-number'>654</span>
<span class='line-number'>655</span>
<span class='line-number'>656</span>
<span class='line-number'>657</span>
<span class='line-number'>658</span>
<span class='line-number'>659</span>
<span class='line-number'>660</span>
<span class='line-number'>661</span>
<span class='line-number'>662</span>
<span class='line-number'>663</span>
<span class='line-number'>664</span>
<span class='line-number'>665</span>
<span class='line-number'>666</span>
<span class='line-number'>667</span>
<span class='line-number'>668</span>
<span class='line-number'>669</span>
<span class='line-number'>670</span>
<span class='line-number'>671</span>
<span class='line-number'>672</span>
<span class='line-number'>673</span>
<span class='line-number'>674</span>
<span class='line-number'>675</span>
<span class='line-number'>676</span>
<span class='line-number'>677</span>
<span class='line-number'>678</span>
<span class='line-number'>679</span>
<span class='line-number'>680</span>
<span class='line-number'>681</span>
<span class='line-number'>682</span>
<span class='line-number'>683</span>
<span class='line-number'>684</span>
<span class='line-number'>685</span>
<span class='line-number'>686</span>
<span class='line-number'>687</span>
<span class='line-number'>688</span>
<span class='line-number'>689</span>
<span class='line-number'>690</span>
<span class='line-number'>691</span>
<span class='line-number'>692</span>
<span class='line-number'>693</span>
<span class='line-number'>694</span>
<span class='line-number'>695</span>
<span class='line-number'>696</span>
<span class='line-number'>697</span>
<span class='line-number'>698</span>
<span class='line-number'>699</span>
<span class='line-number'>700</span>
<span class='line-number'>701</span>
<span class='line-number'>702</span>
<span class='line-number'>703</span>
<span class='line-number'>704</span>
<span class='line-number'>705</span>
<span class='line-number'>706</span>
<span class='line-number'>707</span>
<span class='line-number'>708</span>
<span class='line-number'>709</span>
<span class='line-number'>710</span>
<span class='line-number'>711</span>
<span class='line-number'>712</span>
<span class='line-number'>713</span>
<span class='line-number'>714</span>
<span class='line-number'>715</span>
<span class='line-number'>716</span>
<span class='line-number'>717</span>
<span class='line-number'>718</span>
<span class='line-number'>719</span>
<span class='line-number'>720</span>
<span class='line-number'>721</span>
<span class='line-number'>722</span>
<span class='line-number'>723</span>
<span class='line-number'>724</span>
<span class='line-number'>725</span>
<span class='line-number'>726</span>
<span class='line-number'>727</span>
<span class='line-number'>728</span>
<span class='line-number'>729</span>
<span class='line-number'>730</span>
<span class='line-number'>731</span>
<span class='line-number'>732</span>
<span class='line-number'>733</span>
<span class='line-number'>734</span>
<span class='line-number'>735</span>
<span class='line-number'>736</span>
<span class='line-number'>737</span>
<span class='line-number'>738</span>
<span class='line-number'>739</span>
<span class='line-number'>740</span>
<span class='line-number'>741</span>
<span class='line-number'>742</span>
<span class='line-number'>743</span>
<span class='line-number'>744</span>
<span class='line-number'>745</span>
<span class='line-number'>746</span>
<span class='line-number'>747</span>
<span class='line-number'>748</span>
<span class='line-number'>749</span>
<span class='line-number'>750</span>
<span class='line-number'>751</span>
<span class='line-number'>752</span>
<span class='line-number'>753</span>
<span class='line-number'>754</span>
<span class='line-number'>755</span>
<span class='line-number'>756</span>
<span class='line-number'>757</span>
<span class='line-number'>758</span>
<span class='line-number'>759</span>
<span class='line-number'>760</span>
<span class='line-number'>761</span>
<span class='line-number'>762</span>
<span class='line-number'>763</span>
<span class='line-number'>764</span>
<span class='line-number'>765</span>
<span class='line-number'>766</span>
<span class='line-number'>767</span>
<span class='line-number'>768</span>
<span class='line-number'>769</span>
<span class='line-number'>770</span>
<span class='line-number'>771</span>
<span class='line-number'>772</span>
<span class='line-number'>773</span>
<span class='line-number'>774</span>
<span class='line-number'>775</span>
<span class='line-number'>776</span>
<span class='line-number'>777</span>
<span class='line-number'>778</span>
<span class='line-number'>779</span>
<span class='line-number'>780</span>
<span class='line-number'>781</span>
<span class='line-number'>782</span>
<span class='line-number'>783</span>
<span class='line-number'>784</span>
<span class='line-number'>785</span>
<span class='line-number'>786</span>
<span class='line-number'>787</span>
<span class='line-number'>788</span>
<span class='line-number'>789</span>
<span class='line-number'>790</span>
<span class='line-number'>791</span>
<span class='line-number'>792</span>
<span class='line-number'>793</span>
<span class='line-number'>794</span>
<span class='line-number'>795</span>
<span class='line-number'>796</span>
<span class='line-number'>797</span>
<span class='line-number'>798</span>
<span class='line-number'>799</span>
<span class='line-number'>800</span>
<span class='line-number'>801</span>
<span class='line-number'>802</span>
<span class='line-number'>803</span>
<span class='line-number'>804</span>
<span class='line-number'>805</span>
<span class='line-number'>806</span>
<span class='line-number'>807</span>
<span class='line-number'>808</span>
<span class='line-number'>809</span>
<span class='line-number'>810</span>
<span class='line-number'>811</span>
<span class='line-number'>812</span>
<span class='line-number'>813</span>
<span class='line-number'>814</span>
<span class='line-number'>815</span>
<span class='line-number'>816</span>
<span class='line-number'>817</span>
<span class='line-number'>818</span>
<span class='line-number'>819</span>
<span class='line-number'>820</span>
<span class='line-number'>821</span>
<span class='line-number'>822</span>
<span class='line-number'>823</span>
<span class='line-number'>824</span>
<span class='line-number'>825</span>
<span class='line-number'>826</span>
<span class='line-number'>827</span>
<span class='line-number'>828</span>
<span class='line-number'>829</span>
<span class='line-number'>830</span>
<span class='line-number'>831</span>
<span class='line-number'>832</span>
<span class='line-number'>833</span>
<span class='line-number'>834</span>
<span class='line-number'>835</span>
<span class='line-number'>836</span>
<span class='line-number'>837</span>
<span class='line-number'>838</span>
<span class='line-number'>839</span>
<span class='line-number'>840</span>
<span class='line-number'>841</span>
<span class='line-number'>842</span>
<span class='line-number'>843</span>
<span class='line-number'>844</span>
<span class='line-number'>845</span>
<span class='line-number'>846</span>
<span class='line-number'>847</span>
<span class='line-number'>848</span>
<span class='line-number'>849</span>
<span class='line-number'>850</span>
<span class='line-number'>851</span>
<span class='line-number'>852</span>
<span class='line-number'>853</span>
<span class='line-number'>854</span>
<span class='line-number'>855</span>
<span class='line-number'>856</span>
<span class='line-number'>857</span>
<span class='line-number'>858</span>
<span class='line-number'>859</span>
<span class='line-number'>860</span>
<span class='line-number'>861</span>
<span class='line-number'>862</span>
<span class='line-number'>863</span>
<span class='line-number'>864</span>
<span class='line-number'>865</span>
<span class='line-number'>866</span>
<span class='line-number'>867</span>
<span class='line-number'>868</span>
<span class='line-number'>869</span>
<span class='line-number'>870</span>
<span class='line-number'>871</span>
<span class='line-number'>872</span>
<span class='line-number'>873</span>
<span class='line-number'>874</span>
<span class='line-number'>875</span>
<span class='line-number'>876</span>
<span class='line-number'>877</span>
<span class='line-number'>878</span>
<span class='line-number'>879</span>
<span class='line-number'>880</span>
<span class='line-number'>881</span>
<span class='line-number'>882</span>
<span class='line-number'>883</span>
<span class='line-number'>884</span>
<span class='line-number'>885</span>
<span class='line-number'>886</span>
<span class='line-number'>887</span>
<span class='line-number'>888</span>
<span class='line-number'>889</span>
<span class='line-number'>890</span>
<span class='line-number'>891</span>
<span class='line-number'>892</span>
<span class='line-number'>893</span>
<span class='line-number'>894</span>
<span class='line-number'>895</span>
<span class='line-number'>896</span>
<span class='line-number'>897</span>
<span class='line-number'>898</span>
<span class='line-number'>899</span>
<span class='line-number'>900</span>
<span class='line-number'>901</span>
<span class='line-number'>902</span>
<span class='line-number'>903</span>
<span class='line-number'>904</span>
<span class='line-number'>905</span>
<span class='line-number'>906</span>
<span class='line-number'>907</span>
<span class='line-number'>908</span>
<span class='line-number'>909</span>
<span class='line-number'>910</span>
<span class='line-number'>911</span>
<span class='line-number'>912</span>
<span class='line-number'>913</span>
<span class='line-number'>914</span>
<span class='line-number'>915</span>
<span class='line-number'>916</span>
<span class='line-number'>917</span>
<span class='line-number'>918</span>
<span class='line-number'>919</span>
<span class='line-number'>920</span>
<span class='line-number'>921</span>
<span class='line-number'>922</span>
<span class='line-number'>923</span>
<span class='line-number'>924</span>
<span class='line-number'>925</span>
<span class='line-number'>926</span>
<span class='line-number'>927</span>
<span class='line-number'>928</span>
<span class='line-number'>929</span>
<span class='line-number'>930</span>
<span class='line-number'>931</span>
<span class='line-number'>932</span>
<span class='line-number'>933</span>
<span class='line-number'>934</span>
<span class='line-number'>935</span>
<span class='line-number'>936</span>
<span class='line-number'>937</span>
<span class='line-number'>938</span>
<span class='line-number'>939</span>
<span class='line-number'>940</span>
<span class='line-number'>941</span>
<span class='line-number'>942</span>
<span class='line-number'>943</span>
<span class='line-number'>944</span>
<span class='line-number'>945</span>
<span class='line-number'>946</span>
<span class='line-number'>947</span>
<span class='line-number'>948</span>
<span class='line-number'>949</span>
<span class='line-number'>950</span>
<span class='line-number'>951</span>
<span class='line-number'>952</span>
<span class='line-number'>953</span>
<span class='line-number'>954</span>
<span class='line-number'>955</span>
<span class='line-number'>956</span>
<span class='line-number'>957</span>
<span class='line-number'>958</span>
<span class='line-number'>959</span>
<span class='line-number'>960</span>
<span class='line-number'>961</span>
<span class='line-number'>962</span>
<span class='line-number'>963</span>
<span class='line-number'>964</span>
<span class='line-number'>965</span>
<span class='line-number'>966</span>
<span class='line-number'>967</span>
<span class='line-number'>968</span>
<span class='line-number'>969</span>
<span class='line-number'>970</span>
<span class='line-number'>971</span>
<span class='line-number'>972</span>
<span class='line-number'>973</span>
<span class='line-number'>974</span>
<span class='line-number'>975</span>
<span class='line-number'>976</span>
<span class='line-number'>977</span>
<span class='line-number'>978</span>
<span class='line-number'>979</span>
<span class='line-number'>980</span>
<span class='line-number'>981</span>
<span class='line-number'>982</span>
<span class='line-number'>983</span>
<span class='line-number'>984</span>
<span class='line-number'>985</span>
<span class='line-number'>986</span>
<span class='line-number'>987</span>
<span class='line-number'>988</span>
<span class='line-number'>989</span>
<span class='line-number'>990</span>
<span class='line-number'>991</span>
<span class='line-number'>992</span>
<span class='line-number'>993</span>
<span class='line-number'>994</span>
<span class='line-number'>995</span>
<span class='line-number'>996</span>
<span class='line-number'>997</span>
<span class='line-number'>998</span>
<span class='line-number'>999</span>
<span class='line-number'>1000</span>
<span class='line-number'>1001</span>
<span class='line-number'>1002</span>
<span class='line-number'>1003</span>
<span class='line-number'>1004</span>
<span class='line-number'>1005</span>
<span class='line-number'>1006</span>
<span class='line-number'>1007</span>
<span class='line-number'>1008</span>
<span class='line-number'>1009</span>
<span class='line-number'>1010</span>
<span class='line-number'>1011</span>
<span class='line-number'>1012</span>
<span class='line-number'>1013</span>
<span class='line-number'>1014</span>
<span class='line-number'>1015</span>
<span class='line-number'>1016</span>
<span class='line-number'>1017</span>
<span class='line-number'>1018</span>
<span class='line-number'>1019</span>
<span class='line-number'>1020</span>
<span class='line-number'>1021</span>
<span class='line-number'>1022</span>
<span class='line-number'>1023</span>
<span class='line-number'>1024</span>
<span class='line-number'>1025</span>
<span class='line-number'>1026</span>
<span class='line-number'>1027</span>
<span class='line-number'>1028</span>
<span class='line-number'>1029</span>
<span class='line-number'>1030</span>
<span class='line-number'>1031</span>
<span class='line-number'>1032</span>
<span class='line-number'>1033</span>
<span class='line-number'>1034</span>
<span class='line-number'>1035</span>
<span class='line-number'>1036</span>
<span class='line-number'>1037</span>
<span class='line-number'>1038</span>
<span class='line-number'>1039</span>
<span class='line-number'>1040</span>
<span class='line-number'>1041</span>
<span class='line-number'>1042</span>
<span class='line-number'>1043</span>
<span class='line-number'>1044</span>
<span class='line-number'>1045</span>
<span class='line-number'>1046</span>
<span class='line-number'>1047</span>
<span class='line-number'>1048</span>
<span class='line-number'>1049</span>
<span class='line-number'>1050</span>
<span class='line-number'>1051</span>
<span class='line-number'>1052</span>
<span class='line-number'>1053</span>
<span class='line-number'>1054</span>
<span class='line-number'>1055</span>
<span class='line-number'>1056</span>
<span class='line-number'>1057</span>
<span class='line-number'>1058</span>
<span class='line-number'>1059</span>
<span class='line-number'>1060</span>
<span class='line-number'>1061</span>
<span class='line-number'>1062</span>
<span class='line-number'>1063</span>
<span class='line-number'>1064</span>
<span class='line-number'>1065</span>
<span class='line-number'>1066</span>
<span class='line-number'>1067</span>
<span class='line-number'>1068</span>
<span class='line-number'>1069</span>
<span class='line-number'>1070</span>
<span class='line-number'>1071</span>
<span class='line-number'>1072</span>
<span class='line-number'>1073</span>
<span class='line-number'>1074</span>
<span class='line-number'>1075</span>
<span class='line-number'>1076</span>
<span class='line-number'>1077</span>
<span class='line-number'>1078</span>
<span class='line-number'>1079</span>
<span class='line-number'>1080</span>
<span class='line-number'>1081</span>
<span class='line-number'>1082</span>
<span class='line-number'>1083</span>
<span class='line-number'>1084</span>
<span class='line-number'>1085</span>
<span class='line-number'>1086</span>
<span class='line-number'>1087</span>
<span class='line-number'>1088</span>
<span class='line-number'>1089</span>
<span class='line-number'>1090</span>
<span class='line-number'>1091</span>
<span class='line-number'>1092</span>
<span class='line-number'>1093</span>
<span class='line-number'>1094</span>
<span class='line-number'>1095</span>
<span class='line-number'>1096</span>
<span class='line-number'>1097</span>
<span class='line-number'>1098</span>
<span class='line-number'>1099</span>
<span class='line-number'>1100</span>
<span class='line-number'>1101</span>
<span class='line-number'>1102</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lc：Least Connection
</span><span class='line'># 评判标准：Overhead=Active*256+Inactive
</span><span class='line'># Overhead最小者胜出&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;wlc：Weighted LC
</span><span class='line'># 评判标准：Overhead=(Active*256+Inactive)/weight
</span><span class='line'># Overhead最小者胜出
</span><span class='line'>
</span><span class='line'>sed：Shortest Expect Delay
</span><span class='line'># 评判标准：Overhead=(Active+1)*256/weight
</span><span class='line'># Overhead最小者胜出
</span><span class='line'>
</span><span class='line'>nq：Never Queue # 集群开始时工作时，每台服务器都至少分配一个连接请求，然后再根据sed算法调度；
</span><span class='line'>
</span><span class='line'>lblc：Locality-based Least Connection # 类似于dh+lc
</span><span class='line'>
</span><span class='line'>lblcr：Relicated and Locality-based Least Connection # 主要用于后端服务器是缓存服务器时
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>前面介绍过，负载调度器是根据各个服务器的负栽情况，动态地选择一台Real Server响 应用户请求。那么动态选择是如何实现呢？其实就是通过这里要说的负栽调度算法。根据不同的网络眼务需求和眼务器配IPVS实现T8种负栽调度算法。这里详 细讲述最常用的4 种调度算法。
</span><span class='line'>
</span><span class='line'>1、 轮询（round robin, rr),加权轮询(Weighted round robin, wrr)——新的连接请求被轮流分配至各RealServer；算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。轮叫调度 算法假设所有服务器处理性能均相同，不管服务器的当前连接数和响应速度。该算法相对简单，不适用于服务器组中处理性能不一的情况，而且当请求服务时间变化 比较大时，轮叫调度算法容易导致服务器间的负载不平衡。
</span><span class='line'>
</span><span class='line'>2、 最少连接(least connected, lc)， 加权最少连接(weighted least connection, wlc)——新的连接请求将被分配至当前连接数最少的RealServer；最小连接调度是一种动态调度算法，它通过服务器当前所活跃的连接数来估计服务 器的负载情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中止或超时，其连接数减一。
</span><span class='line'>
</span><span class='line'>3、 基于局部性的最少链接调度（Locality-Based Least Connections Scheduling，lblc）——针对请求报文的目标IP地址的负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群中客户请求报文 的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同 一台服务器，来提高各台服务器的访问局部性和主存Cache命中率，从而整个集群系统的处理能力。LBLC调度算法先根据请求的目标IP地址找出该目标 IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于其一半的工作负载，则 用“最少链接”的原则选出一个可用的服务器，将请求发送到该服务器。
</span><span class='line'>
</span><span class='line'>4、 带复制的基于局部性最少链接调度（Locality-Based Least Connections with Replication Scheduling，lblcr）——也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。它与LBLC算法的不同之处是它要维护从一个 目标IP地址到一组服务器的映射，而 LBLC算法维护从一个目标IP地址到一台服务器的映射。对于一个“热门”站点的服务请求，一台Cache 服务器可能会忙不过来处理这些请求。这时，LBLC调度算法会从所有的Cache服务器中按“最小连接”原则选出一台Cache服务器，映射该“热门”站 点到这台Cache服务器，很快这台Cache服务器也会超载，就会重复上述过程选出新的Cache服务器。这样，可能会导致该“热门”站点的映像会出现 在所有的Cache服务器上，降低了Cache服务器的使用效率。LBLCR调度算法将“热门”站点映射到一组Cache服务器（服务器集合），当该“热 门”站点的请求负载增加时，会增加集合里的Cache服务器，来处理不断增长的负载；当该“热门”站点的请求负载降低时，会减少集合里的Cache服务器 数目。这样，该“热门”站点的映像不太可能出现在所有的Cache服务器上，从而提供Cache集群系统的使用效率。LBLCR算法先根据请求的目标IP 地址找出该目标IP地址对应的服务器组；按“最小连接”原则从该服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载；则按 “最小连接”原则从整个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服 务器从服务器组中删除，以降低复制的程度。
</span><span class='line'>
</span><span class='line'>5、 目标地址散列调度（Destination Hashing，dh）算法也是针对目标IP地址的负载均衡，但它是一种静态映射算法，通过一个散列（Hash）函数将一个目标IP地址映射到一台服务 器。目标地址散列调度算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。
</span><span class='line'>
</span><span class='line'>6、 源地址散列调度（Source Hashing，sh）算法正好与目标地址散列调度算法相反，它根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法 的相同。除了将请求的目标IP地址换成请求的源IP地址外，它的算法流程与目标地址散列调度算法的基本相似。在实际应用中，源地址散列调度和目标地址散列 调度可以结合使用在防火墙集群中，它们可以保证整个系统的唯一出入口。
</span><span class='line'>
</span><span class='line'>7、加权最少连接调度（Weighted Least Connections)。
</span><span class='line'>“加 权最少连接调度”是“最少连接调度”的超集。每个服务节点可以用相应的权值表示其处理能力，而系统管理员可以动态地设置相应的权值，默认权值为1。加权最 小连接调 度在分新连接请求时尽可能使服务节点的已建立连接数和其权值成正比。算法： overhead=active*256+inactive/weight   overhead最小值胜出；
</span><span class='line'>
</span><span class='line'>8、sed：shorttest expect delay  最小期望延迟(改进的wlc) 算法：overhead=(active+1)*256/weight，案例：假如DFG三台机器分别权重123，连接数也分别是123.那么如果使用WLC算法的话一个新请求进入时它可能会分给DFG中的任意一个。使用sed算法后会进行这样一个运算：  
</span><span class='line'>D(1+1)/1  
</span><span class='line'>F(1+2)/2  
</span><span class='line'>G(1+3)/3  
</span><span class='line'>
</span><span class='line'>9、nq：nerver queue        增强改进的sed算法.如果有台real Server的连接数=0直接分配,不需要再进行sed运算
</span><span class='line'>
</span><span class='line'>#### 2.高可用性
</span><span class='line'>
</span><span class='line'>LVS 是一个基于内核级别的应用软件，因此具有很髙的处理性能。由LVS构建的负载 均衡集群系统具有优秀的处理能力，每个服务节点的故障不会影响整个系统的正常使用，又能够实现负载的合理均衡，使应用具有超高负荷的服务能力，可支持上百 万个并发连接请 求。如配置百兆网卡，采用VS/TUN或VS/DR调度技术，整个集群系统的吞吐量可高达 1 Gbit/s；又如配置千兆网卡，系统的最大吞吐量可接近10Gbit/s。
</span><span class='line'>
</span><span class='line'>#### 3.高可靠性
</span><span class='line'>
</span><span class='line'>LVS负载均衡集群软件已经在 企业和学校中得到了很好的普及，国内外很多大型的、关键性的Web站点也都采用了 LVS集群软件，所以它的可靠性在实践中得到了很好印证。有 很多由LVS构成的负载均衡系统，运行很长时间，从未进行过重新启动。这些都说明了 LVS 的髙稳定性和高可靠性。
</span><span class='line'>
</span><span class='line'>#### 4、配置LVS
</span><span class='line'>
</span><span class='line'>1、定义在Director上进行dispatching的服务(service)，以及哪此服务器(server)用来提供此服务；
</span><span class='line'>
</span><span class='line'>2、为每台同时提供某一种服务的服务器定义其权重（即概据服务器性能确定的其承担负载的能力）；
</span><span class='line'>
</span><span class='line'>注：权重用整数来表示，有时候也可以将其设置为atomic_t；其有效表示值范围为24bit整数空间，即（2^24-1）；
</span><span class='line'>
</span><span class='line'>因此，ipvsadm命令的主要作用表现在以下方面：  
</span><span class='line'>1、添加服务（通过设定其权重&gt;0）；  
</span><span class='line'>2、关闭服务（通过设定其权重&gt;0）；此应用场景中，已经连接的用户将可以继续使用此服务，直到其退出或超时；新的连接请求将被拒绝；  
</span><span class='line'>3、保存ipvs设置，通过使用“ipvsadm-sav &gt; ipvsadm.sav”命令实现；  
</span><span class='line'>4、恢复ipvs设置，通过使用“ipvsadm-sav &lt; ipvsadm.sav”命令实现；  
</span><span class='line'>5、显示ip_vs的版本号，下面的命令显示ipvs的hash表的大小为4k；  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# ipvsadm  
</span><span class='line'>IP Virtual Server version 1.2.1 (size=4096)  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;6、显示ipvsadm的版本号  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# ipvsadm --version  
</span><span class='line'>ipvsadm v1.24 2003/06/07 (compiled with popt and IPVS v1.2.0)  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### 二、ipvsadm使用中应注意的问题
</span><span class='line'>
</span><span class='line'>默认情况下，ipvsadm在输出主机信息时使用其主机名而非IP地址，因此，Director需要使用名称解析服务。如果没有设置名称解析服务、服务不可 用或设置错误，ipvsadm将会一直等到名称解析超时后才返回。当然，ipvsadm需要解析的名称仅限于RealServer，考虑到DNS提供名称 解析服务效率不高的情况，建议将所有RealServer的名称解析通过/etc/hosts文件来实现；
</span><span class='line'>
</span><span class='line'>##### 三、调度算法
</span><span class='line'>
</span><span class='line'>Director在接收到来自于Client的请求时，会基于"schedule"从RealServer中选择一个响应给Client。ipvs支持以下调度算法：
</span><span class='line'>
</span><span class='line'>##### 四、关于LVS追踪标记fwmark：
</span><span class='line'>
</span><span class='line'>如果LVS放置于多防火墙的网络中，并且每个防火墙都用到了状态追踪的机制，那么在回应一个针对于LVS的连接请求时必须经过此请求连接进来时的防火墙，否则，这个响应的数据包将会被丢弃。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>常用命令：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;查看LVS上当前的所有连接
</span><span class='line'># ipvsadm -Lcn   
</span><span class='line'>或者
</span><span class='line'>#cat /proc/net/ip_vs_conn
</span><span class='line'>
</span><span class='line'>查看虚拟服务和RealServer上当前的连接数、数据包数和字节数的统计值，则可以使用下面的命令实现：
</span><span class='line'># ipvsadm -l --stats
</span><span class='line'>
</span><span class='line'>查看包传递速率的近似精确值，可以使用下面的命令：
</span><span class='line'># ipvsadm -l --rate
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### VS/NAT
</span><span class='line'>
</span><span class='line'>LVS- NAT基于cisco的LocalDirector。VS/NAT不需要在RealServer上做任何设置，其只要能提供一个tcp/ip的协议栈即 可，甚至其无论基于什么OS。基于VS/NAT，所有的入站数据包均由Director进行目标地址转换后转发至内部的 RealServer，RealServer响应的数据包再由Director转换源地址后发回客户端。 
</span><span class='line'>
</span><span class='line'>VS/NAT模式不能与netfilter兼容，因此，不能将VS/NAT模式的Director运行在netfilter的保护范围之中。现在已经有补丁可以解决此问题，但尚未被整合进ip_vs code。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  　　　&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;
</span><span class='line'>  |            |
</span><span class='line'>  |  client    |
</span><span class='line'>  |&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;|                  &lt;br/&gt;
</span><span class='line'>CIP=192.168.0.253 (eth0)          &lt;br/&gt;
</span><span class='line'>         |                        &lt;br/&gt;
</span><span class='line'>         |                        &lt;br/&gt;
</span><span class='line'>VIP=192.168.0.220 (eth0)          &lt;br/&gt;
</span><span class='line'>   &lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;                    &lt;br/&gt;
</span><span class='line'>  |            |                  &lt;br/&gt;
</span><span class='line'>  |  director  |                  &lt;br/&gt;
</span><span class='line'>  |&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;|                  &lt;br/&gt;
</span><span class='line'>DIP=192.168.10.10 (eth1)      &lt;br/&gt;
</span><span class='line'>         |                        &lt;br/&gt;
</span><span class='line'>      (switch)&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
</span><span class='line'>         |                           |
</span><span class='line'>RIP=192.168.10.2 (eth0)       RIP=192.168.10.3 (eth0)
</span><span class='line'>   &lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;em&gt;               &lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;
</span><span class='line'>  |             |             |             |
</span><span class='line'>  | realserver1 |             | realserver2 |
</span><span class='line'>  |&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;em&gt;|             |&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;__|&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code class=""&gt;
</span><span class='line'>设置VS/NAT模式的LVS(这里以web服务为例)
</span><span class='line'>Director:
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;建立服务
</span><span class='line'># ipvsadm -A -t VIP:PORT -s rr
</span><span class='line'>如:
</span><span class='line'># ipvsadm -A -t 192.168.0.220:80 -s rr
</span><span class='line'>设置转发：
</span><span class='line'># ipvsadm -a -t VIP:PORT -r RIP_N:PORT -m -w N
</span><span class='line'>如：
</span><span class='line'># ipvsadm -a -t 192.168.0.220:80 -r 192.168.10.2 -m -w 1
</span><span class='line'># ipvsadm -a -t 192.168.0.220:80 -r 192.168.10.3 -m -w 1
</span><span class='line'>打开路由转发功能
</span><span class='line'># echo "1" &gt; /proc/sys/net/ipv4/ip_forward
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>服务控制脚本：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#!/bin/bash
</span><span class='line'>#
</span><span class='line'># chkconfig: - 88 12
</span><span class='line'># description: LVS script for VS/NAT
</span><span class='line'>#
</span><span class='line'>. /etc/rc.d/init.d/functions
</span><span class='line'>#
</span><span class='line'>VIP=192.168.0.219
</span><span class='line'>DIP=192.168.10.10
</span><span class='line'>RIP1=192.168.10.11
</span><span class='line'>RIP2=192.168.10.12
</span><span class='line'>#
</span><span class='line'>case "$1" in
</span><span class='line'>start)  
</span><span class='line'>/sbin/ifconfig eth0:1 $VIP netmask 255.255.255.0 up
</span><span class='line'># Since this is the Director we must be able to forward packets
</span><span class='line'>echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</span><span class='line'># Clear all iptables rules.
</span><span class='line'>/sbin/iptables -F
</span><span class='line'># Reset iptables counters.
</span><span class='line'>/sbin/iptables -Z
</span><span class='line'># Clear all ipvsadm rules/services.
</span><span class='line'>/sbin/ipvsadm -C
</span><span class='line'># Add an IP virtual service for VIP 192.168.0.219 port 80
</span><span class='line'># In this recipe, we will use the round-robin scheduling method.
</span><span class='line'># In production, however, you should use a weighted, dynamic scheduling method.
</span><span class='line'>/sbin/ipvsadm -A -t $VIP:80 -s rr
</span><span class='line'># Now direct packets for this VIP to
</span><span class='line'># the real server IP (RIP) inside the cluster
</span><span class='line'>/sbin/ipvsadm -a -t $VIP:80 -r $RIP1 -m
</span><span class='line'>/sbin/ipvsadm -a -t $VIP:80 -r $RIP2 -m
</span><span class='line'>/bin/touch /var/lock/subsys/ipvsadm.lock
</span><span class='line'>;;
</span><span class='line'>stop)
</span><span class='line'># Stop forwarding packets
</span><span class='line'>echo 0 &gt; /proc/sys/net/ipv4/ip_forward
</span><span class='line'># Reset ipvsadm
</span><span class='line'>/sbin/ipvsadm -C
</span><span class='line'># Bring down the VIP interface
</span><span class='line'>ifconfig eth0:1 down
</span><span class='line'>
</span><span class='line'>rm -rf /var/lock/subsys/ipvsadm.lock
</span><span class='line'>;;
</span><span class='line'>status)
</span><span class='line'>[ -e /var/lock/subsys/ipvsadm.lock ] &amp;&amp; echo "ipvs is running..." || echo "ipvsadm is stopped..."
</span><span class='line'>;;
</span><span class='line'>*)
</span><span class='line'>echo "Usage: $0 {start|stop}"
</span><span class='line'>;;
</span><span class='line'>esac
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>Real Server：
</span><span class='line'>
</span><span class='line'>   route add default gw 192.168.10.10  注释：在real server 上网关一定要指向director服务器的DIP，不然用户请求的数据报文，在LVS/NAT模型中将无法发送出去.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#!/bin/bash
</span><span class='line'>VIP=192.168.0.219
</span><span class='line'>chmod  755 /etc/rc.d/init.d/functions
</span><span class='line'>/etc/rc.d/init.d/functions
</span><span class='line'>case "$1" in
</span><span class='line'>start)
</span><span class='line'>echo " start LVS of REALServer"
</span><span class='line'>/sbin/ifconfig lo:0 $VIP broadcast $VIP netmask 255.255.255.255 up
</span><span class='line'>/sbin/route add -host $VIP dev lo:0
</span><span class='line'>echo "1" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
</span><span class='line'>echo "2" &gt;/proc/sys/net/ipv4/conf/lo/arp_announce
</span><span class='line'>echo "1" &gt;/proc/sys/net/ipv4/conf/all/arp_ignore
</span><span class='line'>echo "2" &gt;/proc/sys/net/ipv4/conf/all/arp_announce
</span><span class='line'>sysctl -p &gt;/dev/null 2&gt;&amp;1
</span><span class='line'>;;
</span><span class='line'>stop)
</span><span class='line'>/sbin/ifconfig lo:0 down
</span><span class='line'>echo "close LVS Directorserver"
</span><span class='line'>echo "0" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
</span><span class='line'>echo "0" &gt;/proc/sys/net/ipv4/conf/lo/arp_announce
</span><span class='line'>echo "0" &gt;/proc/sys/net/ipv4/conf/all/arp_ignore
</span><span class='line'>echo "0" &gt;/proc/sys/net/ipv4/conf/all/arp_announce
</span><span class='line'>;;
</span><span class='line'>*)
</span><span class='line'>echo "Usage: $0 {start|stop}"
</span><span class='line'>exit 1
</span><span class='line'>esac
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>ARP问题：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;                    __________
</span><span class='line'>                |        |
</span><span class='line'>                | client |
</span><span class='line'>                |________|
</span><span class='line'>                       |
</span><span class='line'>                    |
</span><span class='line'>                 (router)
</span><span class='line'>                    |
</span><span class='line'>                    |
</span><span class='line'>                    |       __________
</span><span class='line'>                    |  DIP |          |
</span><span class='line'>                    |------| director |
</span><span class='line'>                    |  VIP |__________|
</span><span class='line'>                    |
</span><span class='line'>                    |
</span><span class='line'>                    |
</span><span class='line'>  ------------------------------------
</span><span class='line'>  |                 |                |
</span><span class='line'>  |                 |                |
</span><span class='line'>  RIP1, VIP         RIP2, VIP        RIP3, VIP
</span><span class='line'>______________    ______________    ______________
</span><span class='line'>|              |  |              |  |              |
</span><span class='line'>| realserver1  |  | realserver2  |  | realserver3  |
</span><span class='line'>|______________|  |______________|  |______________|
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>
</span><span class='line'>在如上图的VS/DR或VS/TUN 应用的一种模型中（所有机器都在同一个物理网络），所有机器（包括Director和RealServer）都使用了一个额外的IP地址，即VIP。当一 个客户端向VIP发出一个连接请求时，此请求必须要连接至Director的VIP，而不能是RealServer的。因为，LVS的主要目标就是要 Director负责调度这些连接请求至RealServer的。
</span><span class='line'>
</span><span class='line'>因此，在Client发出至VIP的连接请求后，只能由Director将其 MAC地址响应给客户端（也可能是直接与Director连接的路由设备），而Director则会相应的更新其ipvsadm table以追踪此连接，而后将其转发至后端的RealServer之一。
</span><span class='line'>
</span><span class='line'>如果Client在请求建立至VIP的连接时由某RealServer 响应了其请求，则Client会在其MAC table中建立起一个VIP至RealServer的对就关系，并以至进行后面的通信。此时，在Client看来只有一个RealServer而无法意 识到其它服务器的存在。
</span><span class='line'>
</span><span class='line'>为了解决此问题，可以通过在路由器上设置其转发规则来实现。当然，如果没有权限访问路由器并做出相应的设置，则只能通过传统的本地方式来解决此问题了。这些方法包括：
</span><span class='line'>
</span><span class='line'>1、禁止RealServer响应对VIP的ARP请求；  
</span><span class='line'>2、在RealServer上隐藏VIP，以使得它们无法获知网络上的ARP请求；  
</span><span class='line'>3、基于“透明代理（Transparent Proxy）”或者“fwmark （firewall mark）”；  
</span><span class='line'>4、禁止ARP请求发往RealServers；  
</span><span class='line'>
</span><span class='line'>传统认为，解决ARP问题可以基于网络接口，也可以基于主机来实现。Linux采用了基于主机的方式，因为其可以在大多场景中工作良好，但LVS却并不属于 这些场景之一，因此，过去实现此功能相当麻烦。现在可以通过设置arp_ignore和arp_announce，这变得相对简单的多了。
</span><span class='line'>
</span><span class='line'>Linux 2.2和2.4（2.4.26之前的版本）的内核解决“ARP问题”的方法各不相同，且比较麻烦。幸运的是，2.4.26和2.6的内核中引入了两个新的 调整ARP栈的标志（device flags）：arp_announce和arp_ignore。基于此，在DR/TUN的环境中，所有IPVS相关的设定均可使用 arp_announce=2和arp_ignore=1/2/3来解决“ARP问题”了。
</span><span class='line'>
</span><span class='line'>arp_annouce：Define different restriction levels for announcing the local source IP address from IP packets in ARP requests sent on interface；  
</span><span class='line'>   0 - (default) Use any local address, configured on any interface.  
</span><span class='line'>   1 - Try to avoid local addresses that are not in the target's subnet for this interface.   
</span><span class='line'>   2 - Always use the best local address for this target.  
</span><span class='line'>
</span><span class='line'>arp_ignore: Define different modes for sending replies in response to received ARP requests that resolve local target IP address.  
</span><span class='line'>   0 - (default): reply for any local target IP address, configured on any interface.  
</span><span class='line'>   1 - reply only if the target IP address is local address configured on the incoming interface.  
</span><span class='line'>   2 - reply only if the target IP address is local address configured on the incoming interface and both with the sender's IP address are part from same subnet on this interface.  
</span><span class='line'>   3 - do not reply for local address configured with scope host, only resolutions for golbal and link addresses are replied.  
</span><span class='line'>   4-7 - reserved  
</span><span class='line'>   8 - do not reply for all local addresses  
</span><span class='line'>
</span><span class='line'>在RealServers上，VIP配置在本地回环接口lo上。如果回应给Client的数据包路由到了eth0接口上，则arp通告或请应该通过eth0实现，因此，需要在sysctl.conf文件中定义如下配置：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#vim /etc/sysctl.conf
</span><span class='line'>net.ipv4.conf.eth0.arp_ignore = 1
</span><span class='line'>net.ipv4.conf.eth0.arp_announce = 2
</span><span class='line'>net.ipv4.conf.all.arp_ignore = 1
</span><span class='line'>net.ipv4.conf.all.arp_announce = 2
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'> 以上选项需要在启用VIP之前进行，否则，则需要在Drector上清空arp表才能正常使用LVS。
</span><span class='line'>
</span><span class='line'>到 达Director的数据包首先会经过PREROUTING，而后经过路由发现其目标地址为本地某接口的地址，因此，接着就会将数据包发往 INPUT(LOCAL_IN HOOK)。此时，正在运行内核中的ipvs（始终监控着LOCAL_IN HOOK）进程会发现此数据包请求的是一个集群服务，因为其目标地址是VIP。于是，此数据包的本来到达本机(Director)目标行程被改变为经由 POSTROUTING HOOK发往RealServer。这种改变数据包正常行程的过程是根据IPVS表(由管理员通过ipvsadm定义)来实现的。
</span><span class='line'>
</span><span class='line'>如果有 多台Realserver，在某些应用场景中，Director还需要基于“连接追踪”实现将由同一个客户机的请求始终发往其第一次被分配至的 Realserver，以保证其请求的完整性等。其连接追踪的功能由Hash table实现。Hash table的大小等属性可通过下面的命令查看：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# ipvsadm -lcn
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>为了保证其时效性，Hash table中“连接追踪”信息被定义了“生存时间”。LVS为记录“连接超时”定义了三个计时器：
</span><span class='line'> 1、空闲TCP会话；  
</span><span class='line'> 2、客户端正常断开连接后的TCP会话；  
</span><span class='line'> 3、无连接的UDP数据包（记录其两次发送数据包的时间间隔）；  
</span><span class='line'>
</span><span class='line'>上面三个计时器的默认值可以由类似下面的命令修改，其后面的值依次对应于上述的三个计时器：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# ipvsadm --set 28800 30 600
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>数据包在由Direcotr发往 Realserver时，只有目标MAC地址发生了改变(变成了Realserver的MAC地址)。Realserver在接收到数据包后会根据本地路 由表将数据包路由至本地回环设备，接着，监听于本地回环设备VIP上的服务则对进来的数据库进行相应的处理，而后将处理结果回应至RIP，但数据包的原地 址依然是VIP。
</span><span class='line'>
</span><span class='line'>##### ipvs的持久连接：
</span><span class='line'>
</span><span class='line'>无论基于什么样的算法，只要期望源于同一个客户端的请求都由同一台Realserver响应时，就需要用到持久连接。比如，某一用户连续打开了三个telnet连接请求时，根据RR算法，其请求很可能会被分配至不同的Realserver，这通常不符合使用要求。
</span><span class='line'>
</span><span class='line'>2、IPVS/DR
</span><span class='line'>
</span><span class='line'>Director:
</span><span class='line'>
</span><span class='line'>IP分配  
</span><span class='line'>VIP=192.168.0.210  
</span><span class='line'>RIP1=192.168.0.221  
</span><span class='line'>RIP2=192.168.0.222  
</span><span class='line'>
</span><span class='line'> 1、下载安装ipvsadm
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;yum install ipvsadm
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'> 2、编写并运行脚本（LVS服务器的脚本）
</span><span class='line'>
</span><span class='line'> vim director.sh
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#!/bin/bash
</span><span class='line'>#
</span><span class='line'># LVS script for VS/DR
</span><span class='line'>#
</span><span class='line'>. /etc/rc.d/init.d/functions
</span><span class='line'>#
</span><span class='line'>VIP=192.168.0.210
</span><span class='line'>RIP1=192.168.0.221
</span><span class='line'>RIP2=192.168.0.222
</span><span class='line'>PORT=80
</span><span class='line'>#
</span><span class='line'>case "$1" in
</span><span class='line'>start)  
</span><span class='line'>/sbin/ifconfig eth0:1 $VIP broadcast $VIP netmask 255.255.255.255 up
</span><span class='line'>/sbin/route add -host $VIP dev eth0:1
</span><span class='line'># Since this is the Director we must be able to forward packets
</span><span class='line'>echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</span><span class='line'># Clear all iptables rules.
</span><span class='line'>/sbin/iptables -F
</span><span class='line'># Reset iptables counters.
</span><span class='line'>/sbin/iptables -Z
</span><span class='line'># Clear all ipvsadm rules/services.
</span><span class='line'>/sbin/ipvsadm -C
</span><span class='line'># Add an IP virtual service for VIP 192.168.0.219 port 80
</span><span class='line'># In this recipe, we will use the round-robin scheduling method.
</span><span class='line'># In production, however, you should use a weighted, dynamic scheduling method.
</span><span class='line'>/sbin/ipvsadm -A -t $VIP:80 -s wlc
</span><span class='line'># Now direct packets for this VIP to
</span><span class='line'># the real server IP (RIP) inside the cluster
</span><span class='line'>/sbin/ipvsadm -a -t $VIP:80 -r $RIP1 -g -w 1
</span><span class='line'>/sbin/ipvsadm -a -t $VIP:80 -r $RIP2 -g -w 2
</span><span class='line'>/bin/touch /var/lock/subsys/ipvsadm &amp;&gt; /dev/null
</span><span class='line'>;;
</span><span class='line'>stop)
</span><span class='line'># Stop forwarding packets
</span><span class='line'>echo 0 &gt; /proc/sys/net/ipv4/ip_forward
</span><span class='line'># Reset ipvsadm
</span><span class='line'>/sbin/ipvsadm -C
</span><span class='line'># Bring down the VIP interface
</span><span class='line'>/sbin/ifconfig eth0:1 down
</span><span class='line'>/sbin/route del $VIP                              
</span><span class='line'>/bin/rm -f /var/lock/subsys/ipvsadm                                                                   
</span><span class='line'>echo "ipvs is stopped..."
</span><span class='line'>;;
</span><span class='line'>status)
</span><span class='line'>if [ ! -e /var/lock/subsys/ipvsadm ]; then
</span><span class='line'>    echo "ipvsadm is stopped ..."
</span><span class='line'>else
</span><span class='line'>    echo "ipvs is running ..."
</span><span class='line'>    ipvsadm -L -n
</span><span class='line'>fi
</span><span class='line'>;;
</span><span class='line'>*)
</span><span class='line'>echo "Usage: $0 {start|stop|status}"
</span><span class='line'>;;
</span><span class='line'>esac
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>3、给脚本加权限，并执行
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;chmod 755  /etc/rc.d/init.d/functions
</span><span class='line'>chmod +x director.sh
</span><span class='line'>./director.sh start
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>4、配置后端的WEB服务器脚本
</span><span class='line'>
</span><span class='line'>vim realserver.sh
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#!/bin/bash
</span><span class='line'>#
</span><span class='line'># Script to start LVS DR real server.
</span><span class='line'># description: LVS DR real server
</span><span class='line'>#
</span><span class='line'>.  /etc/rc.d/init.d/functions
</span><span class='line'>VIP=192.168.0.210
</span><span class='line'>host=`/bin/hostname`
</span><span class='line'>case "$1" in
</span><span class='line'>start)
</span><span class='line'># Start LVS-DR real server on this machine.
</span><span class='line'>/sbin/ifconfig lo down
</span><span class='line'>/sbin/ifconfig lo up
</span><span class='line'>echo 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
</span><span class='line'>echo 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce
</span><span class='line'>echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore
</span><span class='line'>echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce
</span><span class='line'>/sbin/ifconfig lo:0 $VIP broadcast $VIP netmask 255.255.255.255 up
</span><span class='line'>/sbin/route add -host $VIP dev lo:0
</span><span class='line'>;;
</span><span class='line'>stop)
</span><span class='line'># Stop LVS-DR real server loopback device(s).
</span><span class='line'>/sbin/ifconfig lo:0 down
</span><span class='line'>echo 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
</span><span class='line'>echo 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce
</span><span class='line'>echo 0 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore
</span><span class='line'>echo 0 &gt; /proc/sys/net/ipv4/conf/all/arp_announce
</span><span class='line'>;;
</span><span class='line'>status)
</span><span class='line'># Status of LVS-DR real server.
</span><span class='line'>islothere=`/sbin/ifconfig lo:0 | grep $VIP`
</span><span class='line'>isrothere=`netstat -rn | grep "lo:0" | grep $VIP`
</span><span class='line'>if [ ! "$islothere" -o ! "isrothere" ];then
</span><span class='line'>    # Either the route or the lo:0 device
</span><span class='line'>    # not found.
</span><span class='line'>    echo "LVS-DR real server Stopped."
</span><span class='line'>else
</span><span class='line'>    echo "LVS-DR real server Running."
</span><span class='line'>fi
</span><span class='line'>;;
</span><span class='line'>*)
</span><span class='line'># Invalid entry.
</span><span class='line'>echo "$0: Usage: $0 {start|status|stop}"
</span><span class='line'>exit 1
</span><span class='line'>;;
</span><span class='line'>esac
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>5、给脚本加权限，并执行
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;chmod 755  /etc/rc.d/init.d/functions
</span><span class='line'>chmod +x realserver.sh
</span><span class='line'>./realserver.sh start
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>IPvsadm 的用法和格式如下：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;ipvsadm -A|E -t|u|f virutal-service-address:port [-s scheduler] [-p [timeout]] [-M netmask]
</span><span class='line'>ipvsadm -D -t|u|f virtual-service-address
</span><span class='line'>ipvsadm -C
</span><span class='line'>ipvsadm -R
</span><span class='line'>ipvsadm -S [-n]
</span><span class='line'>ipvsadm -a|e -t|u|f service-address:port -r real-server-address:port [-g|i|m] [-w weight]
</span><span class='line'>ipvsadm -d -t|u|f service-address -r server-address
</span><span class='line'>ipvsadm -L|l [options]
</span><span class='line'>ipvsadm -Z [-t|u|f service-address]
</span><span class='line'>ipvsadm --set tcp tcpfin udp
</span><span class='line'>ipvsadm --start-daemon state [--mcast-interface interface]
</span><span class='line'>ipvsadm --stop-daemon
</span><span class='line'>ipvsadm -h
</span><span class='line'>命令选项解释：
</span><span class='line'>有两种命令选项格式，长的和短的，具有相同的意思。在实际使用时，两种都可以。
</span><span class='line'>-A --add-service 在内核的虚拟服务器表中添加一条新的虚拟服务器记录。也就是增加一台新的虚拟服务器。
</span><span class='line'>-E --edit-service 编辑内核虚拟服务器表中的一条虚拟服务器记录。  修改定义过的集群服务
</span><span class='line'>-D --delete-service 删除内核虚拟服务器表中的一条虚拟服务器记录。
</span><span class='line'>-C --clear 清除内核虚拟服务器表中的所有记录。
</span><span class='line'>-R --restore 恢复虚拟服务器规则
</span><span class='line'>-S --save 保存虚拟服务器规则，输出为-R 选项可读的格式
</span><span class='line'>-a --add-server 在内核虚拟服务器表的一条记录里添加一条新的真实服务器记录。也就是在一个虚拟服务器中增加一台新的真实服务器
</span><span class='line'>-e --edit-server 编辑一条虚拟服务器记录中的某条真实服务器记录
</span><span class='line'>-d --delete-server 删除一条虚拟服务器记录中的某条真实服务器记录
</span><span class='line'>-L|-l --list 显示内核虚拟服务器表 userver 列表；
</span><span class='line'>-Z --zero 虚拟服务表计数器清零（清空当前的连接数量等）
</span><span class='line'>--set tcp tcpfin udp 设置连接超时值
</span><span class='line'>--start-daemon 启动同步守护进程。他后面可以是master 或backup，用来说明LVS Router 是master 或是backup。在这个功能上也可以采用keepalived 的VRRP 功能。
</span><span class='line'>--stop-daemon 停止同步守护进程
</span><span class='line'>-h --help 显示帮助信息
</span><span class='line'>其他的选项:
</span><span class='line'>-t --tcp-service service-address 说明虚拟服务器提供的是tcp 的服务[vip:port] or [real-server-ip:port]
</span><span class='line'>-u --udp-service service-address 说明虚拟服务器提供的是udp 的服务[vip:port] or [real-server-ip:port]
</span><span class='line'>-f --fwmark-service fwmark 说明是经过iptables 标记过的服务类型。通常用于将两个或两个以上的服务绑定为一个服务进行处理时使用；
</span><span class='line'>-s --scheduler scheduler 使用的调度算法，有这样几个选项 rr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq,默认的调度算法是：wlc.
</span><span class='line'>-p --persistent [timeout] 持久稳固的服务。这个选项的意思是来自同一个客户的多次请求，将被同一台真实的服务器处理。timeout 的默认值为300 秒。 持久连接；
</span><span class='line'>-M --netmask netmask persistent granularity mask
</span><span class='line'>-r --real-server server-address 真实的服务器[Real-Server:port]
</span><span class='line'>-g --gatewaying 指定LVS 的工作模式为直接路由模式（也是LVS 默认的模式） DR模型
</span><span class='line'>-i --ipip 指定LVS 的工作模式为隧道模式
</span><span class='line'>-m --masquerading 指定LVS 的工作模式为NAT 模式
</span><span class='line'>-w --weight weight 真实服务器的权值
</span><span class='line'>--mcast-interface interface 指定组播的同步接口
</span><span class='line'>-c --connection 显示LVS 目前的连接 如：ipvsadm -L -c
</span><span class='line'>--timeout 显示tcp tcpfin udp 的timeout 值 如：ipvsadm -L --timeout
</span><span class='line'>--daemon 显示同步守护进程状态
</span><span class='line'>--stats 显示统计信息 ipvsadm –Ln  --state 总共的数量
</span><span class='line'>--rate 显示速率信息 ipvsadm –Ln  --rete 平均值
</span><span class='line'>--sort 对虚拟服务器和真实服务器排序输出
</span><span class='line'>--numeric -n 输出IP 地址和端口的数字形式
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'> 集群相关的命令参数：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;-A --add-service 在内核的虚拟服务器表中添加一条新的虚拟服务器记录。也就是增加一台新的虚拟服务器。
</span><span class='line'>-t --tcp-service service-address 说明虚拟服务器提供的是tcp 的服务[vip:port] or [real-server-ip:port]
</span><span class='line'>-u --udp-service service-address 说明虚拟服务器提供的是udp 的服务[vip:port] or [real-server-ip:port]
</span><span class='line'>-s --scheduler scheduler 使用的调度算法，有这样几个选项 rr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq,默认的调度算法是：wlc.
</span><span class='line'>-p --persistent [timeout] 持久稳固的服务。这个选项的意思是来自同一个客户的多次请求，将被同一台真实的服务器处理。timeout 的默认值为300 秒。 持久连接；
</span><span class='line'>-E --edit-service 编辑内核虚拟服务器表中的一条虚拟服务器记录。  修改定义过的集群服务
</span><span class='line'>-D ：删除指定集群服务
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>RS相关的命令参数：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;-a --add-server 在内核虚拟服务器表的一条记录里添加一条新的真实服务器记录。也就是在一个虚拟服务器中增加一台新的真实服务器         向指定的CS中添加RS
</span><span class='line'>-r --real-server server-address 真实的服务器[Real-Server:port]，只有支持端口映射的LVS类型才允许此处使用跟集群服务中不同的端口
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>LVS 类型：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;-g ： gateway，DR # 指定集群类型为LVS/DR
</span><span class='line'>-i ipip，TUN  # 指定集群类型为LVS/TUN
</span><span class='line'>-m：masquerade，NAT # 指定集群类型为 NAT
</span><span class='line'>-w：指定RS权重：
</span><span class='line'>-e：修改指定的RS属性
</span><span class='line'>-d ：从指定的集群服务中删除某RS
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code class=""&gt;
</span><span class='line'>##### LVS的持久连接：
</span><span class='line'>
</span><span class='line'>持久连接即是不考虑LVS的转发方法，确保所有来自同一个用户的连接转发到同一个RealServer上
</span><span class='line'>
</span><span class='line'>lvs持久连接适用于大部分调度算法。当某一种请求需要定向到一个real  server 时，就要用到持久连接
</span><span class='line'>一般应用到：ssl（http.https等），ftp。。
</span><span class='line'>
</span><span class='line'>-p  //表示此连接为持久连接  
</span><span class='line'>N  //表示维持此持久连接的时间。默认6分钟。当超过这个时间后，如果网页还没有关掉，仍处于激活状态，重新复位时间为2分钟。  
</span><span class='line'>持久连接的类型：  
</span><span class='line'>1.PCC(persistent client connector,持久用户连接)同一个用户所有的请求在超时范围之内都被定位到同一个RealServer上，这个时候在指定端口的时候使用的是0端口，就是所有的请求都转发出去。  
</span><span class='line'>2.PPC(persistent port connector)用户的所有请求在超时范围内按照端口定位到不同的RS上。  
</span><span class='line'>3.防火墙标记：把相关联的端口在防火墙上打上同样的标记，用户在访问两个相关联的服务的时候，就会定位到同一个RealServer上。  
</span><span class='line'>4.FTP connection：由于ftp使用的是两个端口号，所以需要单独列出来。  
</span><span class='line'>
</span><span class='line'>A.PCC实例：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;Directory-------RealServer1(192.168.1.11)
</span><span class='line'>   |
</span><span class='line'>   |____RealServer2(192.168.1.12)
</span><span class='line'>VIP=192.168.1.10
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>Directory上的配置：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;ifconfig eth0 192.168.1.9/24
</span><span class='line'>ifconfig eth0:0 192.168.1.10 broadcast 192.168.1.10 netmask 255.255.255.255 up
</span><span class='line'>route add -host 192.168.1.10 dev eth0:0
</span><span class='line'>echo 1 &gt;/proc/sys/net/ipv4/ip_forward
</span><span class='line'>ipvsadm -A　-t 192.168.1.10:0 -s rr -p 600
</span><span class='line'>ipvsadm -a -t 192.168.1.10:0 -r 192.168.1.11:0 -g
</span><span class='line'>ipvsadm -a -t 192.168.1.10:0 -r 192.168.1.12:0 -g
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>RealServer1上的配置：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;ifconfig eth0 192.168.1.11/24
</span><span class='line'>ifconfig lo:0 192.168.1.10 broadcast 192.168.1.10 netmask 255.255.255.255 up
</span><span class='line'>route add -host 192.168.1.10 dev lo:0
</span><span class='line'>echo 1 &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
</span><span class='line'>echo 1 &gt;/proc/sys/net/ipv4/conf/all/arp_ignore
</span><span class='line'>echo 2 &gt;/proc/sys/net/ipv4/conf/lo/arp_announce
</span><span class='line'>echo 2 &gt;/proc/sys/net/ipv4/conf/all/arp_announce
</span><span class='line'>yum install httpd
</span><span class='line'>echo "rs1" &gt; /var/www/html/index.html
</span><span class='line'>service httpd start
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>RealServer2上的配置：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;ifconfig eth0 192.168.1.12/24
</span><span class='line'>ifconfig lo:0 192.168.1.10 broadcast 192.168.1.10 netmask 255.255.255.255 up
</span><span class='line'>route add -host 192.168.1.10 dev lo:0
</span><span class='line'>echo 1 &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
</span><span class='line'>echo 1 &gt;/proc/sys/net/ipv4/conf/all/arp_ignore
</span><span class='line'>echo 2 &gt;/proc/sys/net/ipv4/conf/lo/arp_announce
</span><span class='line'>echo 2 &gt;/proc/sys/net/ipv4/conf/all/arp_announce
</span><span class='line'>yum install httpd
</span><span class='line'>echo "rs2" &gt; /var/www/html/index.html
</span><span class='line'>service httpd start
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>在浏览其中输入 http://192.168.1.80 然后刷新页面，可以看到页面一直不变,然后我们再使用ssh登录到192.168.1.10，使用ifconfig查看，和网页所在的RealServer同样，实验完成！
</span><span class='line'>
</span><span class='line'>B.PPC就是根据服务的不同，定向到不同的RealServer上，在Directory上多写几个ipvsadm指向，注意端口要区分开来就行了
</span><span class='line'>
</span><span class='line'>C.防火墙标记的持久连接
</span><span class='line'>
</span><span class='line'>依然是上面的图
</span><span class='line'>两个RealServer配置不变
</span><span class='line'>在Directory上重新配置：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;ipvsadm -C　／／清空ipvs表
</span><span class='line'>iptables -t mangle -A PREROUTING -d 192.168.1.10 -p tcp --dport 80 -j MARK --set-mark 10  把目的地为1982.168.1.10:80标记为10
</span><span class='line'>ipvsadm -A -f 10 -s rr -p 60  //使用上面标记的10定义集群服务
</span><span class='line'>ipvsadm -a -f 10 -r 192.168.1.11 -g //为集群定义RealServer
</span><span class='line'>ipvsadm -a -f 10 -r 192.168.1.12 -g
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>测试：
</span><span class='line'>在浏览其中输入 http://192.168.1.10 可以访问到网页，但是如果使用ssh连接192.168.1.10的话，就只能呗定向到192.168.1.12上也就是Directory上，实验完成
</span><span class='line'>
</span><span class='line'>D.使用防火墙标记实现http&amp;&amp;https姻亲关系：
</span><span class='line'>
</span><span class='line'>依然使用上面的拓扑图：
</span><span class='line'>
</span><span class='line'>![](/images/kernel/2015-07-15-6.png)  
</span><span class='line'>
</span><span class='line'>1.首先在RS上做证书
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;yum install mod_ssl
</span><span class='line'>cd /etc/pki/tls/certs
</span><span class='line'>make httpd.pem  //在设置的时候，Common Name设置和Directory的主机名一样就行了
</span><span class='line'>mkdir /etc/httpd/ssl
</span><span class='line'>cp httpd.pem /etc/httpd/ssl
</span><span class='line'>vim /etc/httpd/conf.d/ssl.conf
</span><span class='line'>SSLCertificateFile /etc/httpd/ssl/httpd.pem
</span><span class='line'>SSLCertificateKeyFile /etc/httpd/ssl/httpd.pem
</span><span class='line'>ServerName node1.a.org:443  //我的Directory的主机名是node1.a.org
</span><span class='line'>service httpd restart
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>2.其他的配置和上面一样，同样RealServer2上也采取同样的配置，我这里就不演示了
</span><span class='line'>
</span><span class='line'>3.Directory上的配置如下：
</span><span class='line'>
</span><span class='line'>只需要在iptables上多添加一条命令如下
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# iptables -t mangle -A PREROUTING -d 192.168.1.10 -p tcp --dport 443 -j MARK --set-mark 10 
</span><span class='line'>//这里的标记和http的80端口的标记是一样的，这个时候在访问的时候，就会建立姻亲关系，其他的配置和C的配置一样，不多演示了
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;测试：在浏览器中输入 http://192.168.1.80 和 https://192.168.1.80 发现访问的是同一个页面，就证明成功啦！
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>因为LVS自身本没有多后端real server 做健康状态检测的功能所以： 
</span><span class='line'>### 编写健康状态监测脚本：
</span><span class='line'>
</span><span class='line'>LVS负载均衡器本身是没有对后端服务器做健康状态监测的功能的；所以我们可以编写一个小小的脚本来完成这个功能; 注释：这些脚本的列子很粗糙，只是让你们了解整个过程是怎样的；
</span><span class='line'>
</span><span class='line'>健康状态监测脚本实例：
</span><span class='line'>
</span><span class='line'>RS健康状态检查脚本示例第一版：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#!/bin/bash
</span><span class='line'>#
</span><span class='line'>VIP=192.168.10.3
</span><span class='line'>CPORT=80
</span><span class='line'>FAIL_BACK=127.0.0.1
</span><span class='line'>FBSTATUS=0
</span><span class='line'>RS=("192.168.10.7" "192.168.10.8")
</span><span class='line'>RSTATUS=("1" "1")
</span><span class='line'>RW=("2" "1")
</span><span class='line'>RPORT=80
</span><span class='line'>TYPE=g
</span><span class='line'>add() {
</span><span class='line'>ipvsadm -a -t $VIP:$CPORT -r $1:$RPORT -$TYPE -w $2
</span><span class='line'>[ $? -eq 0 ] &amp;&amp; return 0 || return 1
</span><span class='line'>}
</span><span class='line'>del() {
</span><span class='line'>ipvsadm -d -t $VIP:$CPORT -r $1:$RPORT
</span><span class='line'>[ $? -eq 0 ] &amp;&amp; return 0 || return 1
</span><span class='line'>}
</span><span class='line'>while :; do
</span><span class='line'>let COUNT=0
</span><span class='line'>for I in ${RS[*]}; do
</span><span class='line'>    if curl --connect-timeout 1 http://$I &amp;&gt; /dev/null; then
</span><span class='line'>        if [ ${RSTATUS[$COUNT]} -eq 0 ]; then
</span><span class='line'> add $I ${RW[$COUNT]}
</span><span class='line'> [ $? -eq 0 ] &amp;&amp; RSTATUS[$COUNT]=1
</span><span class='line'>        fi
</span><span class='line'>    else
</span><span class='line'>        if [ ${RSTATUS[$COUNT]} -eq 1 ]; then
</span><span class='line'> del $I
</span><span class='line'> [ $? -eq 0 ] &amp;&amp; RSTATUS[$COUNT]=0
</span><span class='line'>        fi
</span><span class='line'>    fi
</span><span class='line'>    let COUNT++
</span><span class='line'>done
</span><span class='line'>sleep 5
</span><span class='line'>done
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>RS健康状态检查脚本示例第二版：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#!/bin/bash
</span><span class='line'>#
</span><span class='line'>VIP=192.168.10.3
</span><span class='line'>CPORT=80
</span><span class='line'>FAIL_BACK=127.0.0.1
</span><span class='line'>RS=("192.168.10.7" "192.168.10.8")
</span><span class='line'>declare -a RSSTATUS
</span><span class='line'>RW=("2" "1")
</span><span class='line'>RPORT=80
</span><span class='line'>TYPE=g
</span><span class='line'>CHKLOOP=3
</span><span class='line'>LOG=/var/log/ipvsmonitor.log
</span><span class='line'>addrs() {
</span><span class='line'>ipvsadm -a -t $VIP:$CPORT -r $1:$RPORT -$TYPE -w $2
</span><span class='line'>[ $? -eq 0 ] &amp;&amp; return 0 || return 1
</span><span class='line'>}
</span><span class='line'>delrs() {
</span><span class='line'>ipvsadm -d -t $VIP:$CPORT -r $1:$RPORT
</span><span class='line'>[ $? -eq 0 ] &amp;&amp; return 0 || return 1
</span><span class='line'>}
</span><span class='line'>checkrs() {
</span><span class='line'>local I=1
</span><span class='line'>while [ $I -le $CHKLOOP ]; do
</span><span class='line'>    if curl --connect-timeout 1 http://$1 &amp;&gt; /dev/null; then
</span><span class='line'>        return 0
</span><span class='line'>    fi
</span><span class='line'>    let I++
</span><span class='line'>done
</span><span class='line'>return 1
</span><span class='line'>}
</span><span class='line'>initstatus() {
</span><span class='line'>local I
</span><span class='line'>local COUNT=0;
</span><span class='line'>for I in ${RS[*]}; do
</span><span class='line'>    if ipvsadm -L -n | grep "$I:$RPORT" &amp;&amp; &gt; /dev/null ; then
</span><span class='line'>        RSSTATUS[$COUNT]=1
</span><span class='line'>    else
</span><span class='line'>        RSSTATUS[$COUNT]=0
</span><span class='line'>    fi
</span><span class='line'>let COUNT++
</span><span class='line'>done
</span><span class='line'>}
</span><span class='line'>initstatus
</span><span class='line'>while :; do
</span><span class='line'>let COUNT=0
</span><span class='line'>for I in ${RS[*]}; do
</span><span class='line'>    if checkrs $I; then
</span><span class='line'>        if [ ${RSSTATUS[$COUNT]} -eq 0 ]; then
</span><span class='line'> addrs $I ${RW[$COUNT]}
</span><span class='line'> [ $? -eq 0 ] &amp;&amp; RSSTATUS[$COUNT]=1 &amp;&amp; echo "`date +'%F %H:%M:%S'`, $I is back." &gt;&gt; $LOG
</span><span class='line'>        fi
</span><span class='line'>    else
</span><span class='line'>        if [ ${RSSTATUS[$COUNT]} -eq 1 ]; then
</span><span class='line'> delrs $I
</span><span class='line'> [ $? -eq 0 ] &amp;&amp; RSSTATUS[$COUNT]=0 &amp;&amp; echo "`date +'%F %H:%M:%S'`, $I is gone." &gt;&gt; $LOG
</span><span class='line'>        fi
</span><span class='line'>    fi
</span><span class='line'>    let COUNT++
</span><span class='line'>done
</span><span class='line'>sleep 5
</span><span class='line'>done
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[LVS简介及使用]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/07/15/kernel-net-lvs-start/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-07-15T14:39:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/07/15/kernel-net-lvs-start&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://www.cnblogs.com/codebean/archive/2011/07/25/2116043.html"&gt;http://www.cnblogs.com/codebean/archive/2011/07/25/2116043.html&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;一、LVS是什么？&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;LVS的英文全称是Linux Virtual Server，即Linux虚拟服务器。它是我们国家的章文嵩博士的一个开源项目。在linux内存2.6中，它已经成为内核的一部分，在此之前的内核版本则需要重新编译内核。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;二、LVS能干什么？&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;LVS主要用于多服务器的负载均衡。它工作在网络层，可以实现高性能，高可用的服务器集群技术。它廉价，可把许多低性能的服务器组合在一起形成一个超级服务器。它易用，配置非常简单，且有多种负载均衡的方法。它稳定可靠，即使在集群的服务器中某台服务器无法正常工作，也不影响整体效果。另外可扩展性也非常好。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;三、工作原理&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;img src="/images/kernel/2015-07-15.png" alt="" /&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如上图，LVS可分为三部分：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1.Load Balancer：这是LVS的核心部分，它好比我们网站MVC模型的Controller。它负责将客户的请求按照一定的算法分发到下一层不同的服务器进行处理，自己本身不做具体业务的处理。另外该层还可用监控下一层的状态，如果下一层的某台服务器不能正常工作了，它会自动把其剔除，恢复后又可用加上。该层由一台或者几台Director Server组成。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2.Server Array：该层负责具体业务。可有WEB Server、mail Server、FTP Server、DNS Server等组成。注意，其实上层的Director Server也可以当Real server用的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;3.Shared Storage：主要是提高上一层数据和为上一层保持数据一致。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;四、负载均衡机制&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;前面我们说了LVS是工作在网络层。相对于其它负载均衡的解决办法，比如DNS域名轮流解析、应用层负载的调度、客户端的调度等，它的效率是非常高的。LVS的通过控制IP来实现负载均衡。IPVS是其具体的实现模块。IPVS的主要作用：安装在Director Server上面，在Director Server虚拟一个对外访问的IP（VIP）。用户访问VIP，到达Director Server，Director Server根据一定的规则选择一个Real Server，处理完成后然后返回给客户端数据。这些步骤产生了一些具体的问题，比如如何选择具体的Real Server，Real Server如果返回给客户端数据等等。IPVS为此有三种机制：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1.VS/NAT(Virtual Server via Network Address Translation)，即网络地址翻转技术实现虚拟服务器。当请求来到时，Diretor server上处理的程序将数据报文中的目标地址（即虚拟IP地址）改成具体的某台Real Server,端口也改成Real Server的端口，然后把报文发给Real Server。Real Server处理完数据后，需要返回给Diretor Server，然后Diretor server将数据包中的源地址和源端口改成VIP的地址和端口，最后把数据发送出去。由此可以看出，用户的请求和返回都要经过Diretor Server，如果数据过多，Diretor Server肯定会不堪重负。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2.VS/TUN（Virtual Server via IP Tunneling）,即IP隧道技术实现虚拟服务器。它跟VS/NAT基本一样，但是Real server是直接返回数据给客户端，不需要经过Diretor server,这大大降低了Diretor server的压力。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;3.VS/DR（Virtual Server via Direct Routing），即用直接路由技术实现虚拟服务器。跟前面两种方式，它的报文转发方法有所不同，VS/DR通过改写请求报文的MAC地址，将请求发送到Real Server，而Real Server将响应直接返回给客户，免去了VS/TUN中的IP隧道开销。这种方式是三种负载调度机制中性能最高最好的，但是必须要求Director Server与Real Server都有一块网卡连在同一物理网段上。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;五、负载调度算法&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;前面我们都知道Director Server要选择不同的Real server，那么它具体的如果选择Real Server以达到负载均衡的呢，IPVS实现了八种调度方法,具体算法可以查看官网或者百度，这里就不一一列出
</span><span class='line'>了。官网：www.linuxvirtualserver.org。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;六、具体配置操作&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;首先我们这里有三台机子，IP分别是192.168.132.30（Diretor server）,192.168.132.64(Real server 1)，192.168.132.68(real server 2)。在real server 1和2上面，已经配置好了web服务，并且我们假设还有一个对外访问的虚拟IP是192.168.132.254（VIP）。另外在Diretor server上面已经安装好了ipvsadm。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;下面我们VS/DR介绍详细的配置过程。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Diretor server上面的配置：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    //首先在Director Server上绑定一个虚拟IP（也叫VIP），此IP用于对外提供服务：
</span><span class='line'>ifconfig eth0:0 192.168.132.254 broadcast 192.168.132.254 netmask 255.255.255.255 up
</span><span class='line'>
</span><span class='line'>//给设备eth0:0指定一条路由
</span><span class='line'>route add -host 192.168.132.254 dev eth0:0
</span><span class='line'>
</span><span class='line'>//启用系统的包转发功能
</span><span class='line'>echo "1"&gt;/proc/sys/net/ipv4/ip_forward
</span><span class='line'>
</span><span class='line'>//清楚ipvsadm以前的设置
</span><span class='line'>ipvsadm -C
</span><span class='line'>
</span><span class='line'>//添加一个新的虚拟IP记录192.168.132.254，其持续服务之间是120秒 
</span><span class='line'>ipvsadm -A -t 192.168.132.254:80 -s rr -p 120
</span><span class='line'>
</span><span class='line'>//在新增的虚拟IP记录中新增两天real server记录，-g即为使用VS/DR模式
</span><span class='line'>ipvsadm -a -t 192.168.132.254:80 -r 192.168.132.64:80 -g 
</span><span class='line'>ipvsadm -a -t 192.168.132.254:80 -r 192.168.132.68:80 -g
</span><span class='line'>
</span><span class='line'>//启用LVS服务
</span><span class='line'>ipvsadm
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;两台real server上的配置：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    /*在回环设备上绑定了一个虚拟IP地址，并设定其子网掩码为255.255.255.255，与Director Server上的虚拟IP保持互通*/
</span><span class='line'>ifconfig lo:0 192.168.132.254 broadcast 192.168.132.254 netmask 255.255.255.255 up
</span><span class='line'>route add -host 192.168.132.254 dev lo:0
</span><span class='line'>
</span><span class='line'>//禁用本机的ARP请求
</span><span class='line'>echo "1" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
</span><span class='line'>echo "1" &gt;/proc/sys/net/ipv4/conf/all/arp_ignore
</span><span class='line'>echo "2" &gt;/proc/sys/net/ipv4/conf/lo/arp_announce
</span><span class='line'>echo "2" &gt;/proc/sys/net/ipv4/conf/all/arp_announce
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;之后在其他客户端机子上面，访问&lt;a href="http://192.168.132.254/%EF%BC%8C%E5%88%99%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%BB%93%E6%9E%9C%E4%BA%86%E3%80%82"&gt;http://192.168.132.254/%EF%BC%8C%E5%88%99%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%BB%93%E6%9E%9C%E4%BA%86%E3%80%82&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[ethtool命令]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/07/15/kernel-net-ethtool/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-07-15T14:19:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/07/15/kernel-net-ethtool&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_71f38909010128yf.html"&gt;http://blog.sina.com.cn/s/blog_71f38909010128yf.html&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;用途&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;显示或修改以太网卡的配置信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;语法&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    ethtool [ -a | -c | -g | -i | -d | -k | -r | -S |] ethX
</span><span class='line'>
</span><span class='line'>ethtool [-A] ethX [autoneg on|off] [rx on|off] [tx on|off]
</span><span class='line'>
</span><span class='line'>ethtool [-C] ethX [adaptive-rx on|off] [adaptive-tx on|off] [rx-usecs N] [rx-frames N] [rx-usecs-irq N] [rx-frames-irq N] [tx-usecs N] [tx-frames N] [tx-usecs-irq N] [tx-frames-irq N] [stats-block-usecs N][pkt-rate-low N][rx-usecs-low N] [rx-frames-low N] [tx-usecs-low N] [tx-frames-low N] [pkt-rate-high N] [rx-usecs-high N] [rx-frames-high N] [tx-usecs-high N] [tx-frames-high N] [sample-interval N]
</span><span class='line'>
</span><span class='line'>ethtool [-G] ethX [rx N] [rx-mini N] [rx-jumbo N] [tx N]
</span><span class='line'>
</span><span class='line'>ethtool [-e] ethX [raw on|off] [offset N] [length N]
</span><span class='line'>
</span><span class='line'>ethtool [-E] ethX [magic N] [offset N] [value N]
</span><span class='line'>
</span><span class='line'>ethtool [-K] ethX [rx on|off] [tx on|off] [sg on|off] [tso on|off]
</span><span class='line'>
</span><span class='line'>ethtool [-p] ethX [N]
</span><span class='line'>
</span><span class='line'>ethtool [-t] ethX [offline|online]
</span><span class='line'>
</span><span class='line'>ethtool [-s] ethX [speed 10|100|1000] [duplex half|full] [autoneg on|off] [port tp|aui|bnc|mii] [phyad N] [xcvr internal|external]
</span><span class='line'>
</span><span class='line'>[wol p|u|m|b|a|g|s|d...] [sopass xx:yy:zz:aa:bb:cc] [msglvl N]
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;描述&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Ethtool命令用于获取以太网卡的配置信息，或者修改这些配置。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ethX是以太网卡的名称，Linux系统将检测到的第一块以太网卡命名为eth0, 第二块为eth1,…….。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;标志&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    -a  查看网卡中 接收模块RX、发送模块TX和Autonegotiate模块的状态：启动on 或 停用off
</span><span class='line'>-A  修改网卡中 接收模块RX、发送模块TX和Autonegotiate模块的状态：启动on 或 停用off
</span><span class='line'>-c  display the Coalesce information of the specified ethernet card
</span><span class='line'>-C  Change the Coalesce setting of the specified ethernet card
</span><span class='line'>-g  Display the rx/tx ring parameter information of the specified ethernet card
</span><span class='line'>-G  change the rx/tx ring setting of the specified ethernet card
</span><span class='line'>-i  显示网卡驱动的信息，如驱动的名称、版本等
</span><span class='line'>-d  显示register dump信息, 部分网卡驱动不支持该选项
</span><span class='line'>-e  显示EEPROM dump信息，部分网卡驱动不支持该选项
</span><span class='line'>-E  修改网卡EEPROM byte
</span><span class='line'>-k  显示网卡Offload参数的状态：on 或 off，包括rx-checksumming、tx-checksumming等。
</span><span class='line'>-K  修改网卡Offload参数的状态
</span><span class='line'>-p  用于区别不同ethX对应网卡的物理位置，常用的方法是使网卡port上的led不断的闪；N指示了网卡闪的持续时间，以秒为单位。
</span><span class='line'>-r  如果auto-negotiation模块的状态为on，则restarts auto-negotiation
</span><span class='line'>-S  显示NIC- and driver-specific 的统计参数，如网卡接收/发送的字节数、接收/发送的广播包个数等。
</span><span class='line'>-t  让网卡执行自我检测，有两种模式：offline or online
</span><span class='line'>-s  修改网卡的部分配置，包括网卡速度、单工/全双工模式、mac地址等
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;示例&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;查看机器上网卡的速度：百兆还是千兆，请输入：&lt;code&gt;ethool eth0&lt;/code&gt; 操作完毕后，输出信息中‘Speed:’ 这一项就指示了网卡的速度。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;停止网卡的发送模块TX，请输入：&lt;code&gt;ethtool -A tx off eth0&lt;/code&gt; 操作完毕后，可输入：ethtool -a eth0，查看tx模块是否已被停止。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;查看网卡eth0采用了何种驱动，请输入：&lt;code&gt;ethtool -i eth0&lt;/code&gt; 操作完毕后，显示 driver: bnx2；version: 1.4.30 等信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;关闭网卡对收到的数据包的校验功能，请输入：&lt;code&gt;ethtool -K eth0 rx off&lt;/code&gt; 操作完毕后，可输入：ethtool –k eth0，查看校验功能是否已被停止。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如果机器上安装了两块网卡，那么eth0对应着哪块网卡呢？输入：&lt;code&gt;ethtool -p eth0 10&lt;/code&gt; 操作完毕后，看哪块网卡的led灯在闪，eth0就对应着哪块网卡。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;查看网卡，在接收/发送数据时，有没有出错？请输入：&lt;code&gt;ethtool -S eth0&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;将千兆网卡的速度降为百兆，请输入：&lt;code&gt;ethtool -s eth0 speed 100&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;数据来源&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ethtool命令显示的信息来源于网卡驱动层，即TCP/IP协议的链路层。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;该命令在Linux内核中实现的逻辑层次为：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最重要的结构体struct ethtool_ops，该结构体成员为用于显示或修改以太网卡配置的一系列函数指针，见下表中的第二列。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;网卡驱动负责实现(部分)这些函数，并将其封装入ethtool_ops结构体，为网络核心层提供统一的调用接口。因此，不同的网卡驱动会给应用层返回不同的信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ethtool命令选项、struct ethtool_ops成员函数、ethtool命令显示参数的来源，三者间的对应关系如下表所示。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    命令选项    struct ethtool_ops成员函数      ethtool命令显示参数的来源(以网卡驱动BNX2为例)
</span><span class='line'>
</span><span class='line'>-s      get_settingsget_wol             从网卡寄存器中获得网卡速度等信息，可配置
</span><span class='line'>        get_msglevel
</span><span class='line'>        get_link
</span><span class='line'>        set_settings
</span><span class='line'>        set_wol
</span><span class='line'>        set_msglevel
</span><span class='line'>
</span><span class='line'>-a -A   get_pauseparam set_pauseparam   从网卡寄存器中获得 Autonegotiate/RX/TX模块的状态：on or off，可配置
</span><span class='line'>
</span><span class='line'>-c -C   get_coalesceset_coalesce        从网卡寄存器中获得coalescing参数：TX/RX一个数据包后，推迟发生TX/RX中断的时间(us)/数据包个数。—减小该值可以提高网卡的响应时间。
</span><span class='line'>                                        当rx-usecs&amp;rx-frames同时被设为0时，RX中断停止。
</span><span class='line'>                                        当tx-usecs&amp;tx-frames同时被设为0时，TX中断停止。
</span><span class='line'>-g -G   get_ringparam set_ringparam     除当前TX/RX ring的值(从网卡寄存器中读取得到，可配置)外，其它为网卡bnx2自己固定的信息。
</span><span class='line'>
</span><span class='line'>-k -K   get_rx_csumget_tx_csum          显示信息从保存该状态的变量中读取得到，没有对应的寄存器。因此，TX/RX校验等模块一直处于on状态，实际上是无法修改的。
</span><span class='line'>        get_sg
</span><span class='line'>        get_tso
</span><span class='line'>        set_rx_csum
</span><span class='line'>        set_tx_csum
</span><span class='line'>        set_sg
</span><span class='line'>        set_tso
</span><span class='line'>
</span><span class='line'>-i      get_drvinfo[self_test_count,    网卡bnx2自己固定的信息，如
</span><span class='line'>        get_stats_coun,t                ——————————————————–
</span><span class='line'>        get_regs_len,                   driver: bnx2
</span><span class='line'>        get_eeprom_len]                 version: 1.4.30
</span><span class='line'>                                        firmware-version: 1.8.0.5
</span><span class='line'>                                        bus-info: 0000:09:00.0
</span><span class='line'>                                        ——————————————————–
</span><span class='line'>-d      get_drvinfoget_regs             不支持，即bnx2中没有实现函数get_regs
</span><span class='line'>-e -E   get_eepromset_eeprom            不支持，即bnx2中没有实现函数get_eeprom
</span><span class='line'>-r      nway_reset                      配置网卡MII_BMCR寄存器，重启Auto negotiation模块
</span><span class='line'>-p      phys_id                         配置网卡BNX2_EMAC_LED寄存器，实现LED闪功能
</span><span class='line'>-t      self_test                       通过配置网卡寄存器，逐一测试网卡的硬件模块：registers，memory，loopback，Link stat，interrupt
</span><span class='line'>-S      get_ethtool_stats               显示信息来源于网卡驱动中的结构体变量stats_blk。（网卡通过DMA方式，将寄存器BNX2_HC_STATISTICS _ADDR_L和
</span><span class='line'>                                        BNX2_HC_STATISTICS_ADDR_H中的数据实时地读取到结构体变量struct statistics_block *stats_blk中。）
</span><span class='line'>                                        —显示的数据都是从网卡寄存器中统计得到的，各项的含义需查询网卡(芯片)手册。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;由上可见，ethtool命令用于显示/配置网卡硬件(寄存器)。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[查看所有tcp连接]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/07/02/kernel-net-info/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-07-02T10:06:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/07/02/kernel-net-info&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://roclinux.cn/?p=2418"&gt;http://roclinux.cn/?p=2418&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://blog.csdn.net/justlinux2010/article/details/21028797"&gt;http://blog.csdn.net/justlinux2010/article/details/21028797&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;一、查看连接&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    netstat -an
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;或
</span><span class='line'>&lt;code&gt;
</span><span class='line'>ss
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;二、查看连接详细信息&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;上面的命令也是从&lt;code&gt;/proc/net/tcp&lt;/code&gt;和&lt;code&gt;/proc/net/tcp6&lt;/code&gt;中读取的&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;/proc/net/tcp中的内容由tcp4_seq_show()函数打印，该函数中有三种打印形式，我们这里这只列出状态是TCP_SEQ_STATE_LISTENING或TCP_SEQ_STATE_ESTABLISHED的情况，如下所示：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;img src="/images/kernel/2015-07-02.png" alt="" /&gt;&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[IPV6 实现]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/06/18/kernel-net-ipv6-code/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-06-18T10:44:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/06/18/kernel-net-ipv6-code&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://www.cnblogs.com/super-king/p/ipv6_implement.html"&gt;http://www.cnblogs.com/super-king/p/ipv6_implement.html&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;code extract from 2.6.24.
</span><span class='line'>在文件 net/ipv6/af_inet6.c 中包含了ipv6协议初始化的主函数。</span></code></pre></td></tr></table></div></figure>
    static int __init inet6_init(void)
    {
        struct sk_buff <em>dummy_skb;
        struct list_head </em>r;
        int err;
        //inet6_skb_parm必须小于等于skb中的cb
        BUILD_BUG_ON(sizeof(struct inet6_skb_parm) > sizeof(dummy_skb->cb));</p>

<pre><code>    //初始化tcpv6_prot结构中的一些与slab相关的字段，然后添加到 proto_list 全局连表
    err = proto_register(&amp;tcpv6_prot, 1);
    if (err)
        goto out;
    //udp协议同上
    err = proto_register(&amp;udpv6_prot, 1);
    if (err)
        goto out_unregister_tcp_proto;
    //udp-lite传输协议，主要用于多媒体传输，参考kernel中的 Documentation/networking/udplite.txt
    err = proto_register(&amp;udplitev6_prot, 1);
    if (err)
        goto out_unregister_udp_proto;
    //原始套接字同上
    err = proto_register(&amp;rawv6_prot, 1);
    if (err)
        goto out_unregister_udplite_proto;

    /* Register the socket-side information for inet6_create.  */
    for(r = &amp;inetsw6[0]; r &lt; &amp;inetsw6[SOCK_MAX]; ++r) //初始化一个协议连表数组
        INIT_LIST_HEAD(r);
    /* We MUST register RAW sockets before we create the ICMP6, IGMP6, or NDISC control sockets. */
    //根据参数数据结构中标识的协议类型，把这数据结构添加到上面的协议连表数组中
    inet6_register_protosw(&amp;rawv6_protosw);

    /* Register the family here so that the init calls below will be able to create sockets. (?? is this dangerous ??) */
    //注册ipv6协议族，主要是注册socket创建函数
    err = sock_register(&amp;inet6_family_ops);
    if (err)
        goto out_unregister_raw_proto;

    /* Initialise ipv6 mibs */
    err = init_ipv6_mibs(); //所有ipv6相关的统计信息
    if (err)
        goto out_unregister_sock;
    /* ipngwg API draft makes clear that the correct semantics for TCP and UDP is to consider one TCP and UDP instance 
     * in a host availiable by both INET and INET6 APIs and able to communicate via both network protocols.
     */
#ifdef CONFIG_SYSCTL
    ipv6_sysctl_register(); // ipv6协议proc条件项初始化
#endif
    //icmp协议注册
    err = icmpv6_init(&amp;inet6_family_ops);
    if (err)
        goto icmp_fail;
    //邻居协议（arp）初始化       
    err = ndisc_init(&amp;inet6_family_ops);
    if (err)
        goto ndisc_fail;
    //igmp协议初始化       
    err = igmp6_init(&amp;inet6_family_ops);
    if (err)
        goto igmp_fail;
    //ipv6协议相关的 netfilter 初始化     
    err = ipv6_netfilter_init();
    if (err)
        goto netfilter_fail;

    /* Create /proc/foo6 entries. */
#ifdef CONFIG_PROC_FS //注册/proc/中协议统计输出项
    err = -ENOMEM;
    if (raw6_proc_init())
        goto proc_raw6_fail;
    if (tcp6_proc_init())
        goto proc_tcp6_fail;
    if (udp6_proc_init())
        goto proc_udp6_fail;
    if (udplite6_proc_init())
        goto proc_udplite6_fail;
    if (ipv6_misc_proc_init())
        goto proc_misc6_fail;
    if (ac6_proc_init())
        goto proc_anycast6_fail;
    if (if6_proc_init())
        goto proc_if6_fail;
#endif
    ip6_route_init(); //ipv6 路由初始化
    ip6_flowlabel_init();//ipv6 中流标记，注册了输出流标记的 proc

    //rtnetlink相关部分和路由模板中一些字段和其他一些功能的初始化
    err = addrconf_init();
    if (err)
        goto addrconf_fail;
    /* Init v6 extension headers. */
    //ipv6 新添加的扩展头初始化，参考ipv6介绍
    ipv6_rthdr_init();
    ipv6_frag_init();
    ipv6_nodata_init();
    ipv6_destopt_init();

    /* Init v6 transport protocols. */
    //最主要的传输层协议初始化
    udpv6_init();
    udplitev6_init();
    tcpv6_init();

    //最后注册ipv6协议，注册协议处理函数
    ipv6_packet_init();
    err = 0;
out:
    return err;
    ...... //下面就是错误处理的过程
}
</code></pre>

<pre><code>
下面我们主要看ipv6协议部分流程，其他部分在各自相关文章中介绍。

ipv6扩展头，路由包头注册
</code></pre>

<pre><code>void __init ipv6_rthdr_init(void)
{
    if (inet6_add_protocol(&amp;rthdr_protocol, IPPROTO_ROUTING) &lt; 0)
        printk(KERN_ERR "ipv6_rthdr_init: Could not register protocol\n");
};
</code></pre>

<pre><code>
ipv6扩展头，分片包头注册
</code></pre>

<pre><code>void __init ipv6_frag_init(void)
{
    if (inet6_add_protocol(&amp;frag_protocol, IPPROTO_FRAGMENT) &lt; 0)
        printk(KERN_ERR "ipv6_frag_init: Could not register protocol\n");

    ip6_frags.ctl = &amp;ip6_frags_ctl;
    ip6_frags.hashfn = ip6_hashfn;
    ip6_frags.constructor = ip6_frag_init;
    ip6_frags.destructor = NULL;
    ip6_frags.skb_free = NULL;
    ip6_frags.qsize = sizeof(struct frag_queue);
    ip6_frags.match = ip6_frag_match;
    ip6_frags.frag_expire = ip6_frag_expire;
    inet_frags_init(&amp;ip6_frags);
}
void __init ipv6_nodata_init(void)
{
    if (inet6_add_protocol(&amp;nodata_protocol, IPPROTO_NONE) &lt; 0)
        printk(KERN_ERR "ipv6_nodata_init: Could not register protocol\n");
}
</code></pre>

<pre><code>
ipv6扩展头，目的选项包头注册
</code></pre>

<pre><code>void __init ipv6_destopt_init(void)
{
    if (inet6_add_protocol(&amp;destopt_protocol, IPPROTO_DSTOPTS) &lt; 0)
        printk(KERN_ERR "ipv6_destopt_init: Could not register protocol\n");
}
    注册ipv6协议处理函数
void __init ipv6_packet_init(void)
{
    dev_add_pack(&amp;ipv6_packet_type);
}
</code></pre>

<pre><code>
当netif_receive_skb函数向上层递交skb时会根据协议类型调用相关的协议处理函数，那么就会调用到 ipv6_rcv函数了。
</code></pre>

<pre><code>static struct packet_type ipv6_packet_type = {
    .type = __constant_htons(ETH_P_IPV6),
    .func = ipv6_rcv,
    .gso_send_check = ipv6_gso_send_check,
    .gso_segment = ipv6_gso_segment,
};
</code></pre>

<pre><code>
ipv6协议处理函数
</code></pre>

<pre><code>int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
{
    struct ipv6hdr *hdr;
    u32             pkt_len;
    struct inet6_dev *idev;

    if (dev-&gt;nd_net != &amp;init_net) {
        kfree_skb(skb);
        return 0;
    }
    //mac地址是其他主机的包
    if (skb-&gt;pkt_type == PACKET_OTHERHOST) {
        kfree_skb(skb);
        return 0;
    }
    rcu_read_lock();
    //获取ipv6相关的配置结构
    idev = __in6_dev_get(skb-&gt;dev);

    IP6_INC_STATS_BH(idev, IPSTATS_MIB_INRECEIVES);
    //是否共享，如果是，新clone一个
    if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL) {
        IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDISCARDS);
        rcu_read_unlock();
        goto out;
    }
    //清空保存扩展头解析结果的数据结构
    memset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));

    //保存接收这个数据包的设备索引
    IP6CB(skb)-&gt;iif = skb-&gt;dst ? ip6_dst_idev(skb-&gt;dst)-&gt;dev-&gt;ifindex : dev-&gt;ifindex;

    //有足够的头长度，ipv6是40字节
    if (unlikely(!pskb_may_pull(skb, sizeof(*hdr))))
        goto err;

    hdr = ipv6_hdr(skb); //获取头

    if (hdr-&gt;version != 6) //验证版本
        goto err;

    //传输头（扩展头）在网络头后面
    skb-&gt;transport_header = skb-&gt;network_header + sizeof(*hdr);
    //保存下一个扩展头协议在ipv6头结构中的偏移
    IP6CB(skb)-&gt;nhoff = offsetof(struct ipv6hdr, nexthdr);
    pkt_len = ntohs(hdr-&gt;payload_len); //ipv6负载数据长度

    /* pkt_len may be zero if Jumbo payload option is present */
    if (pkt_len || hdr-&gt;nexthdr != NEXTHDR_HOP) { //没有使用扩展头逐个跳段选项
        if (pkt_len + sizeof(struct ipv6hdr) &gt; skb-&gt;len) { //数据长度不对
            IP6_INC_STATS_BH(idev, IPSTATS_MIB_INTRUNCATEDPKTS);
            goto drop;
        }
        //如果skb-&gt;len &gt; (pkt_len + sizeof(struct ipv6hdr))试着缩小skb-&gt;len的长度
        //相对ipv4来说简单多了，自己看吧
        if (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr))) {
            IP6_INC_STATS_BH(idev, IPSTATS_MIB_INHDRERRORS);
            goto drop;
        }
        hdr = ipv6_hdr(skb); //重新获取ip头
    }
    if (hdr-&gt;nexthdr == NEXTHDR_HOP) { //使用了扩展头逐个跳段选项
        if (ipv6_parse_hopopts(skb) &lt; 0) {//处理这个选项
            IP6_INC_STATS_BH(idev, IPSTATS_MIB_INHDRERRORS);
            rcu_read_unlock();
            return 0;
        }
    }
    rcu_read_unlock();
    //进入ipv6的netfilter然后调用ip6_rcv_finish
    return NF_HOOK(PF_INET6,NF_IP6_PRE_ROUTING, skb, dev, NULL, ip6_rcv_finish);
err:
    IP6_INC_STATS_BH(idev, IPSTATS_MIB_INHDRERRORS);
drop:
    rcu_read_unlock();
    kfree_skb(skb);
out:
    return 0;
}
</code></pre>

<pre><code>
解析扩展头逐个跳段中的巨量负载选项
</code></pre>

<pre><code>int ipv6_parse_hopopts(struct sk_buff *skb)
{
    struct inet6_skb_parm *opt = IP6CB(skb); //获取扩展头结果结构
    /* skb_network_header(skb) is equal to skb-&gt;data, and skb_network_header_len(skb) is always equal to
     * sizeof(struct ipv6hdr) by definition of hop-by-hop options.
     */
    //验证数据有足够的长度
    if (!pskb_may_pull(skb, sizeof(struct ipv6hdr) + 8) || !pskb_may_pull(skb, (sizeof(struct ipv6hdr) +
                    //下面的意思是取得扩展首部中的长度
                    ((skb_transport_header(skb)[1] + 1) &lt;&lt; 3)))) {
        kfree_skb(skb);
        return -1;
    }
    opt-&gt;hop = sizeof(struct ipv6hdr); //40字节
    if (ip6_parse_tlv(tlvprochopopt_lst, skb)) { //实际的解析工作
        //把传输头移动到扩展首部之后
        skb-&gt;transport_header += (skb_transport_header(skb)[1] + 1) &lt;&lt; 3;
        opt = IP6CB(skb);
        opt-&gt;nhoff = sizeof(struct ipv6hdr); //进行了ipv6扩展头解析，保存下一个扩展头协议字段的偏移
        return 1;
    }
    return -1;
}
</code></pre>

<pre><code>
解析tlv编码的扩展选项头
</code></pre>

<pre><code>static int ip6_parse_tlv(struct tlvtype_proc *procs, struct sk_buff *skb)
{
    struct tlvtype_proc *curr;
    const unsigned char *nh = skb_network_header(skb); //获取网络头
    int off = skb_network_header_len(skb); //获取网络头长度
    int len = (skb_transport_header(skb)[1] + 1) &lt;&lt; 3; //首部扩展头长度

    if (skb_transport_offset(skb) + len &gt; skb_headlen(skb)) //长度错误
        goto bad;
    off += 2; //跳过下一个首部和首部扩展长度这两个字节
    len -= 2;

    while (len &gt; 0) {
        int optlen = nh[off + 1] + 2; //获取选项数据长度 + 2 (2是选项类型和选项数据长度两字节)
        switch (nh[off]) { //选项类型
            case IPV6_TLV_PAD0: //Pad1选项
                optlen = 1;
                break;
            case IPV6_TLV_PADN://PadN选项
                break;
            default: //其他选项
                if (optlen &gt; len)
                    goto bad;

                for (curr = procs; curr-&gt;type &gt;= 0; curr++) {
                    if (curr-&gt;type == nh[off]) { //类型匹配，调用参数函数处理，参考下面ipv6选项处理
                        /* type specific length/alignment checks will be performed in the func(). */
                        if (curr-&gt;func(skb, off) == 0)
                            return 0;
                        break;
                    }
                }
                if (curr-&gt;type &lt; 0) {
                    if (ip6_tlvopt_unknown(skb, off) == 0) //处理未知选项
                        return 0;
                }
                break;
        }
        off += optlen; //偏移增加，这样到下一个选项
        len -= optlen; //长度递减
    }
    if (len == 0)
        return 1; //正确解析完毕
bad:
    kfree_skb(skb);
    return 0;
}
</code></pre>

<pre><code>
处理未知的选项
</code></pre>

<pre><code>static int ip6_tlvopt_unknown(struct sk_buff *skb, int optoff)
{
    //根据选项类型标识符的要求进行处理
    switch ((skb_network_header(skb)[optoff] &amp; 0xC0) &gt;&gt; 6) {
        case 0: /* ignore */
            return 1;
        case 1: /* drop packet */
            break;
        case 3: /* Send ICMP if not a multicast address and drop packet */
            /* Actually, it is redundant check. icmp_send will recheck in any case. */
            if (ipv6_addr_is_multicast(&amp;ipv6_hdr(skb)-&gt;daddr)) //目的是多播地址
                break;
        case 2: /* send ICMP PARM PROB regardless and drop packet */
            //给包的源地址发送一个 ICMP "参数存在问题", 编码 2 的报文, 指针指向无法识别的选项类型
            icmpv6_param_prob(skb, ICMPV6_UNK_OPTION, optoff);
            return 0;
    }
    kfree_skb(skb);
    return 0;
}
</code></pre>

<pre><code>
到这需要解释一下，上面解析ipv6选项只是解析了第一层的扩展头，在后面可能还有其他扩展头会在后面解析。
</code></pre>

<pre><code>inline int ip6_rcv_finish( struct sk_buff *skb)
{
    if (skb-&gt;dst == NULL) //没有路由，进行路由查找
        ip6_route_input(skb); //路由部分将在路由实现文章中介绍

    return dst_input(skb);
}
static inline int dst_input(struct sk_buff *skb)
{
    int err;
    for (;;) {
        err = skb-&gt;dst-&gt;input(skb); //调用路由的输入函数
        if (likely(err == 0))
            return err;

        /* Oh, Jamal... Seems, I will not forgive you this mess. :-) */
        if (unlikely(err != NET_XMIT_BYPASS))
            return err;
    }
}
</code></pre>

<pre><code>
现在我们假设包是到本地的，那么上面的input函数就是
</code></pre>

<pre><code>int ip6_input(struct sk_buff *skb)
{
    //进入ipv6 netfilter NF_IP6_LOCAL_IN hook 然后调用 ip6_input_finish
    return NF_HOOK(PF_INET6, NF_IP6_LOCAL_IN, skb, skb-&gt;dev, NULL, ip6_input_finish);
}
static int ip6_input_finish(struct sk_buff *skb)
{
    struct inet6_protocol *ipprot;
    struct sock *raw_sk;
    unsigned int nhoff;
    int nexthdr;
    u8 hash;
    struct inet6_dev *idev;

    /* Parse extension headers */
    rcu_read_lock();
resubmit:
    idev = ip6_dst_idev(skb-&gt;dst);
    //将skb-&gt;data指针移动到传输层头
    if (!pskb_pull(skb, skb_transport_offset(skb)))
        goto discard;

    nhoff = IP6CB(skb)-&gt;nhoff;
    nexthdr = skb_network_header(skb)[nhoff];//下一个扩展头协议

    //处理原始sock
    raw_sk = sk_head(&amp;raw_v6_htable[nexthdr &amp; (MAX_INET_PROTOS - 1)]);
    if (raw_sk &amp;&amp; !ipv6_raw_deliver(skb, nexthdr))
        raw_sk = NULL;

    //向上层协议栈递交数据，看初始化时注册的一些协议，主要是tcp，udp等，还包括一些ip扩展头的处理
    hash = nexthdr &amp; (MAX_INET_PROTOS - 1);
    if ((ipprot = rcu_dereference(inet6_protos[hash])) != NULL) {
        int ret;
        if (ipprot-&gt;flags &amp; INET6_PROTO_FINAL) {
            struct ipv6hdr *hdr;
            /* Free reference early: we don't need it any more,                        
               and it may hold ip_conntrack module loaded indefinitely. */
            nf_reset(skb);

            skb_postpull_rcsum(skb, skb_network_header(skb), skb_network_header_len(skb));
            hdr = ipv6_hdr(skb);
            if (ipv6_addr_is_multicast(&amp;hdr-&gt;daddr) &amp;&amp; !ipv6_chk_mcast_addr(skb-&gt;dev, &amp;hdr-&gt;daddr, &amp;hdr-&gt;saddr)
                    &amp;&amp; !ipv6_is_mld(skb, nexthdr))
                goto discard;
        }
        //处理 IPSEC v6 的相关部分
        if (!(ipprot-&gt;flags &amp; INET6_PROTO_NOPOLICY) &amp;&amp; !xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))
            goto discard;

        ret = ipprot-&gt;handler(skb); //上层协议处理，看下面ipv6扩展头处理
        if (ret &gt; 0)
            goto resubmit; //重新处理
        else if (ret == 0)
            IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDELIVERS);
    } else { //没有找到上层处理函数
        if (!raw_sk) {
            if (xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {
                IP6_INC_STATS_BH(idev, IPSTATS_MIB_INUNKNOWNPROTOS);
                icmpv6_send(skb, ICMPV6_PARAMPROB, ICMPV6_UNK_NEXTHDR, nhoff, skb-&gt;dev);
            }
        } else
            IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDELIVERS);
        kfree_skb(skb);
    }
    rcu_read_unlock();
    return 0;
discard:
    IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDISCARDS);
    rcu_read_unlock();
    kfree_skb(skb);
    return 0;
}
</code></pre>

<pre><code>
#### ipv6选项处理
</code></pre>

<pre><code>static struct tlvtype_proc tlvprochopopt_lst[] = {
    {
        .type   = IPV6_TLV_ROUTERALERT,
        .func   = ipv6_hop_ra,
    },
    {
        .type   = IPV6_TLV_JUMBO,
        .func   = ipv6_hop_jumbo,
    },
    { -1, }
};
</code></pre>

<pre><code>
解析路由警告选项
</code></pre>

<pre><code>static int ipv6_hop_ra(struct sk_buff *skb, int optoff)
{
    const unsigned char *nh = skb_network_header(skb); //获取网络头

    if (nh[optoff + 1] == 2) { //路由警告选项长度必须是2 ? rfc 要求是 4
        IP6CB(skb)-&gt;ra = optoff; //记录警告类型
        return 1;
    }
    LIMIT_NETDEBUG(KERN_DEBUG "ipv6_hop_ra: wrong RA length %d\n", nh[optoff + 1]);
    kfree_skb(skb);
    return 0;
}
</code></pre>

<pre><code>
解析jumbo frame选项
</code></pre>

<pre><code>static int ipv6_hop_jumbo(struct sk_buff *skb, int optoff)
{
    const unsigned char *nh = skb_network_header(skb);
    u32 pkt_len;
    //选项数据长度必须是4，选项类型必须是 0xc2， ＆3 后必须是2
    if (nh[optoff + 1] != 4 || (optoff &amp; 3) != 2) {
        LIMIT_NETDEBUG(KERN_DEBUG "ipv6_hop_jumbo: wrong jumbo opt length/alignment %d\n", nh[optoff+1]);
        IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);
        goto drop;
    }
    pkt_len = ntohl(*(__be32 *)(nh + optoff + 2)); //获取整个负载长度
    if (pkt_len &lt;= IPV6_MAXPLEN) { //小于65535 是不对地
        IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);
        icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff+2);
        return 0;
    }
    if (ipv6_hdr(skb)-&gt;payload_len) { //原ipv6头中就不应该有负载长度了
        IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);
        icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff);
        return 0;
    }
    if (pkt_len &gt; skb-&gt;len - sizeof(struct ipv6hdr)) { //长度超出了 skb 的实际长度
        IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INTRUNCATEDPKTS);
        goto drop;
    }
    //如果必要试图缩减 skb 的长度
    if (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))
        goto drop;

    return 1;
drop:
    kfree_skb(skb);
    return 0;
}
</code></pre>

<pre><code>
目的选项处理
</code></pre>

<pre><code>static struct tlvtype_proc tlvprocdestopt_lst[] = {
#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
    {
        .type   = IPV6_TLV_HAO,
        .func   = ipv6_dest_hao,
    },
#endif
    {-1,    NULL}
};
</code></pre>

<pre><code>
解析目的选项
</code></pre>

<pre><code>static int ipv6_dest_hao(struct sk_buff *skb, int optoff)
{
    struct ipv6_destopt_hao *hao;
    struct inet6_skb_parm *opt = IP6CB(skb);
    struct ipv6hdr *ipv6h = ipv6_hdr(skb);
    struct in6_addr tmp_addr;
    int ret;

    if (opt-&gt;dsthao) { //已经处理
        LIMIT_NETDEBUG(KERN_DEBUG "hao duplicated\n");
        goto discard;
    }
    opt-&gt;dsthao = opt-&gt;dst1;
    opt-&gt;dst1 = 0;

    //获取网络头后面的选项部分
    hao = (struct ipv6_destopt_hao *)(skb_network_header(skb) + optoff);

    if (hao-&gt;length != 16) { //长度要求
        LIMIT_NETDEBUG(KERN_DEBUG "hao invalid option length = %d\n", hao-&gt;length);
        goto discard;
    }
    if (!(ipv6_addr_type(&amp;hao-&gt;addr) &amp; IPV6_ADDR_UNICAST)) { //地址不是单播
        LIMIT_NETDEBUG(KERN_DEBUG "hao is not an unicast addr: " NIP6_FMT "\n", NIP6(hao-&gt;addr));
        goto discard;
    }
    //IPSEC相关
    ret = xfrm6_input_addr(skb, (xfrm_address_t *)&amp;ipv6h-&gt;daddr, (xfrm_address_t *)&amp;hao-&gt;addr, IPPROTO_DSTOPTS);
    if (unlikely(ret &lt; 0))
        goto discard;

    if (skb_cloned(skb)) { //如果包是cloned
        //分配新的内存数据
        if (pskb_expand_head(skb, 0, 0, GFP_ATOMIC))
            goto discard;

        //重新指向各头
        hao = (struct ipv6_destopt_hao *)(skb_network_header(skb) + optoff);
        ipv6h = ipv6_hdr(skb);
    }
    if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)
        skb-&gt;ip_summed = CHECKSUM_NONE;

    //把ip头中的源地址与选项中的地址交换
    ipv6_addr_copy(&amp;tmp_addr, &amp;ipv6h-&gt;saddr);
    ipv6_addr_copy(&amp;ipv6h-&gt;saddr, &amp;hao-&gt;addr);
    ipv6_addr_copy(&amp;hao-&gt;addr, &amp;tmp_addr);

    if (skb-&gt;tstamp.tv64 == 0)
        __net_timestamp(skb); //记录时间截

    return 1;
discard:
    kfree_skb(skb);
    return 0;
}
</code></pre>

<pre><code>
#### ipv6扩展头处理

我们只介绍根ipv6扩展头相关的实现，像其他的扩展头(tcp, udp)等虽然也是叫扩展头但实际是传输层的内容，将在其他文章中介绍。

路由扩展首部
</code></pre>

<pre><code>struct ipv6_rt_hdr {
    __u8            nexthdr;
    __u8            hdrlen;
    __u8            type;
    __u8            segments_left;

    /* type specific data variable length field */
};
</code></pre>

<pre><code>
路由扩展首部处理结构
</code></pre>

<pre><code>static struct inet6_protocol rthdr_protocol = {
    .handler        =       ipv6_rthdr_rcv,
    .flags          =       INET6_PROTO_NOPOLICY | INET6_PROTO_GSO_EXTHDR,
};
static int ipv6_rthdr_rcv(struct sk_buff *skb)
{
    struct inet6_skb_parm *opt = IP6CB(skb);
    struct in6_addr *addr = NULL;
    struct in6_addr daddr;
    struct inet6_dev *idev;
    int n, i;
    struct ipv6_rt_hdr *hdr;
    struct rt0_hdr *rthdr;
    int accept_source_route = ipv6_devconf.accept_source_route;

    idev = in6_dev_get(skb-&gt;dev); //包进入设备
    if (idev) {
        if (accept_source_route &gt; idev-&gt;cnf.accept_source_route) //默认数量大于了手动调节(proc中）的数量
            accept_source_route = idev-&gt;cnf.accept_source_route;
        in6_dev_put(idev);
    }
    //skb长度和内存空间正确
    if (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) || !pskb_may_pull(skb, (skb_transport_offset(skb) +
                    ((skb_transport_header(skb)[1] + 1) &lt;&lt; 3)))) {
        IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
        kfree_skb(skb);
        return -1;
    }
    hdr = (struct ipv6_rt_hdr *)skb_transport_header(skb); //路由扩展头
    //是到多播地址或硬件地址不是到本机的地址
    if (ipv6_addr_is_multicast(&amp;ipv6_hdr(skb)-&gt;daddr) || skb-&gt;pkt_type != PACKET_HOST) {
        IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
        kfree_skb(skb);
        return -1;
    }
looped_back:
    if (hdr-&gt;segments_left == 0) { //根据rfc要求 分段剩余为0
        switch (hdr-&gt;type) {
#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
            case IPV6_SRCRT_TYPE_2:
                /* Silently discard type 2 header unless it was processed by own */
                if (!addr) {
                    IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
                    kfree_skb(skb);
                    return -1;
                }
                break;
#endif
            default:
                break;

        }
        opt-&gt;lastopt = opt-&gt;srcrt = skb_network_header_len(skb);
        skb-&gt;transport_header += (hdr-&gt;hdrlen + 1) &lt;&lt; 3; //下一个传输头的位置
        opt-&gt;dst0 = opt-&gt;dst1;
        opt-&gt;dst1 = 0;
        opt-&gt;nhoff = (&amp;hdr-&gt;nexthdr) - skb_network_header(skb); //记录下一个头数据相对网络头的偏移量
        return 1;
    }
    switch (hdr-&gt;type) {
#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
        case IPV6_SRCRT_TYPE_2:
            if (accept_source_route &lt; 0)
                goto unknown_rh;
            /* Silently discard invalid RTH type 2 */
            if (hdr-&gt;hdrlen != 2 || hdr-&gt;segments_left != 1) {
                IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
                kfree_skb(skb);
                return -1;
            }
            break;
#endif
        default:
            goto unknown_rh;
    }
    /* This is the routing header forwarding algorithm from RFC 2460, page 16. */

    n = hdr-&gt;hdrlen &gt;&gt; 1; //计算路由首部中的地址数量
    if (hdr-&gt;segments_left &gt; n) {
        IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
        icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, ((&amp;hdr-&gt;segments_left) - skb_network_header(skb)));
        return -1;
    }
    /* We are about to mangle packet header. Be careful!                                       
       Do not damage packets queued somewhere.  */
    if (skb_cloned(skb)) {
        /* the copy is a forwarded packet */
        if (pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {
            IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_OUTDISCARDS);
            kfree_skb(skb);
            return -1;
        }
        hdr = (struct ipv6_rt_hdr *)skb_transport_header(skb);
    }
    if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)
        skb-&gt;ip_summed = CHECKSUM_NONE;

    i = n - --hdr-&gt;segments_left; //计算地址向量(地址列表)中要"访问"的下一个地址

    rthdr = (struct rt0_hdr *) hdr;
    addr = rthdr-&gt;addr; //指向地址列表首部
    addr += i - 1; //移动到下一个地址

    switch (hdr-&gt;type) {
#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
        case IPV6_SRCRT_TYPE_2:
            if (xfrm6_input_addr(skb, (xfrm_address_t *)addr, (xfrm_address_t *)&amp;ipv6_hdr(skb)-&gt;saddr, IPPROTO_ROUTING) &lt; 0) {
                IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
                kfree_skb(skb);
                return -1;
            }
            if (!ipv6_chk_home_addr(addr)) {
                IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
                kfree_skb(skb);
                return -1;
            }
            break;
#endif
        default:
            break;
    }
    if (ipv6_addr_is_multicast(addr)) { //这个地址是多播地址
        IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
        kfree_skb(skb);
        return -1;
    }
    //交换 IPv6 目的地址和这个地址
    ipv6_addr_copy(&amp;daddr, addr);
    ipv6_addr_copy(addr, &amp;ipv6_hdr(skb)-&gt;daddr);
    ipv6_addr_copy(&amp;ipv6_hdr(skb)-&gt;daddr, &amp;daddr);
    dst_release(xchg(&amp;skb-&gt;dst, NULL));

    ip6_route_input(skb); //路由查找处理，将在其他文章中介绍

    if (skb-&gt;dst-&gt;error) {
        skb_push(skb, skb-&gt;data - skb_network_header(skb));
        dst_input(skb);
        return -1;
    }

    if (skb-&gt;dst-&gt;dev-&gt;flags &amp; IFF_LOOPBACK) { //路由查找后要发送到的目的设备是回环
        if (ipv6_hdr(skb)-&gt;hop_limit &lt;= 1) { //跳数限制小于1
            IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
            //给源地址发送一个 ICMP "超时 – 传输超过跳数限制" 的报文, 并且抛弃此包
            icmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0, skb-&gt;dev);
            kfree_skb(skb);
            return -1;
        }
        ipv6_hdr(skb)-&gt;hop_limit--;
        goto looped_back;
    }
    //将data之中移动到网络头
    skb_push(skb, skb-&gt;data - skb_network_header(skb));
    dst_input(skb); //这时包应该被转发了
    return -1;
unknown_rh:
    IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
    icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, (&amp;hdr-&gt;type) - skb_network_header(skb));
    return -1;
}
</code></pre>

<pre><code>
ipv6分配包扩展首部处理
</code></pre>

<pre><code>static struct inet6_protocol frag_protocol =
{
    .handler        =       ipv6_frag_rcv,
    .flags          =       INET6_PROTO_NOPOLICY,
};
static int ipv6_frag_rcv(struct sk_buff *skb)
{
    struct frag_hdr *fhdr;
    struct frag_queue *fq;
    struct ipv6hdr *hdr = ipv6_hdr(skb);

    IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMREQDS);

    /* Jumbo payload inhibits frag. header */
    if (hdr-&gt;payload_len == 0) { //是Jumbo payload，不是分片包
        IP6_INC_STATS(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
        icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, skb_network_header_len(skb));
        return -1;
    }
    //有碎片头空间
    if (!pskb_may_pull(skb, (skb_transport_offset(skb) + sizeof(struct frag_hdr)))) {
        IP6_INC_STATS(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
        icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, skb_network_header_len(skb));
        return -1;
    }
    hdr = ipv6_hdr(skb);
    fhdr = (struct frag_hdr *)skb_transport_header(skb); //分片头

    if (!(fhdr-&gt;frag_off &amp; htons(0xFFF9))) { //没有分片偏移，不是分片包
        /* It is not a fragmented frame */
        skb-&gt;transport_header += sizeof(struct frag_hdr); //传输头向后移动到下一个头
        IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMOKS);
        IP6CB(skb)-&gt;nhoff = (u8 *)fhdr - skb_network_header(skb);
        return 1;
    }
    if (atomic_read(&amp;ip6_frags.mem) &gt; ip6_frags_ctl.high_thresh) //内存使用超过限制
        ip6_evictor(ip6_dst_idev(skb-&gt;dst));

    //查找或创建分片队列头
    if ((fq = fq_find(fhdr-&gt;identification, &amp;hdr-&gt;saddr, &amp;hdr-&gt;daddr, ip6_dst_idev(skb-&gt;dst))) != NULL) {
        int ret;
        spin_lock(&amp;fq-&gt;q.lock);
        ret = ip6_frag_queue(fq, skb, fhdr, IP6CB(skb)-&gt;nhoff); //入队重组
        spin_unlock(&amp;fq-&gt;q.lock);
        fq_put(fq);
        return ret;
    }
    IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMFAILS);
    kfree_skb(skb);
    return -1;
}
static __inline__ struct frag_queue * fq_find(__be32 id, struct in6_addr *src, struct in6_addr *dst, struct inet6_dev *idev)
{
    struct inet_frag_queue *q;
    struct ip6_create_arg arg;
    unsigned int hash;

    arg.id = id;
    arg.src = src;
    arg.dst = dst;
    hash = ip6qhashfn(id, src, dst); //id，源，目的进行 hash

    q = inet_frag_find(&amp;ip6_frags, &amp;arg, hash); //查找或创建
    if (q == NULL)
        goto oom;

    return container_of(q, struct frag_queue, q); //成功返回
oom: //没内存了
    IP6_INC_STATS_BH(idev, IPSTATS_MIB_REASMFAILS);
    return NULL;
}
struct inet_frag_queue *inet_frag_find(struct inet_frags *f, void *key, unsigned int hash)
{
    struct inet_frag_queue *q;
    struct hlist_node *n;

    read_lock(&amp;f-&gt;lock);
    hlist_for_each_entry(q, n, &amp;f-&gt;hash[hash], list) { //在hash桶中查找

        if (f-&gt;match(q, key)) { //调用匹配函数进行匹配，具体函数很简单参考初始化时的ipv6_frag_init函数
            atomic_inc(&amp;q-&gt;refcnt);
            read_unlock(&amp;f-&gt;lock);
            return q;
        }
    }
    //没有找到就创建一个
    return inet_frag_create(f, key, hash);
}
</code></pre>

<pre><code>
创建分片队列
</code></pre>

<pre><code>static struct inet_frag_queue *inet_frag_create(struct inet_frags *f, void *arg, unsigned int hash)
{
    struct inet_frag_queue *q;

    q = inet_frag_alloc(f, arg); //分配一个
    if (q == NULL)
        return NULL;
    //添加到 hash 表
    return inet_frag_intern(q, f, hash, arg);
}
static struct inet_frag_queue *inet_frag_alloc(struct inet_frags *f, void *arg)
{
    struct inet_frag_queue *q;

    q = kzalloc(f-&gt;qsize, GFP_ATOMIC); //分配一个队列头，大小是 sizeof(struct frag_queue)
    if (q == NULL)
        return NULL;

    f-&gt;constructor(q, arg); //拷贝地址和 id 到队列头结构中
    atomic_add(f-&gt;qsize, &amp;f-&gt;mem);
    setup_timer(&amp;q-&gt;timer, f-&gt;frag_expire, (unsigned long)q);
    spin_lock_init(&amp;q-&gt;lock);
    atomic_set(&amp;q-&gt;refcnt, 1);
    return q;
}
static struct inet_frag_queue *inet_frag_intern(struct inet_frag_queue *qp_in, struct inet_frags *f, unsigned int hash, void *arg)
{
    struct inet_frag_queue *qp;
#ifdef CONFIG_SMP
    struct hlist_node *n;
#endif

    write_lock(&amp;f-&gt;lock);
#ifdef CONFIG_SMP
    //其他cpu可能已经创建了一个，所以要再次检查
    hlist_for_each_entry(qp, n, &amp;f-&gt;hash[hash], list) {
        if (f-&gt;match(qp, arg)) { //已经创建
            atomic_inc(&amp;qp-&gt;refcnt);
            write_unlock(&amp;f-&gt;lock);
            qp_in-&gt;last_in |= COMPLETE;
            inet_frag_put(qp_in, f); //释放新分配的
            return qp;

        }
    }
#endif
    qp = qp_in;
    if (!mod_timer(&amp;qp-&gt;timer, jiffies + f-&gt;ctl-&gt;timeout)) //启动定时器
        atomic_inc(&amp;qp-&gt;refcnt);

    //增加引用计数，然后添加到hash表
    atomic_inc(&amp;qp-&gt;refcnt);
    hlist_add_head(&amp;qp-&gt;list, &amp;f-&gt;hash[hash]);
    list_add_tail(&amp;qp-&gt;lru_list, &amp;f-&gt;lru_list);
    f-&gt;nqueues++;
    write_unlock(&amp;f-&gt;lock);
    return qp;
}
</code></pre>

<pre><code>
入队重组
</code></pre>

<pre><code>static int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb, struct frag_hdr *fhdr, int nhoff)
{
    struct sk_buff *prev, *next;
    struct net_device *dev;
    int offset, end;

    if (fq-&gt;q.last_in &amp; COMPLETE) //重组已经完成
        goto err;

    //分片开始位置
    offset = ntohs(fhdr-&gt;frag_off) &amp; ~0x7;//偏移必须8字节对齐
    //分片在整个包中的结束位置 包负载长度 - 分片头长度
    end = offset + (ntohs(ipv6_hdr(skb)-&gt;payload_len) -  ((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));

    //结束位置 &gt; 65535
    if ((unsigned int)end &gt; IPV6_MAXPLEN) {
        IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
        icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, ((u8 *)&amp;fhdr-&gt;frag_off - skb_network_header(skb)));
        return -1;
    }
    //校验和已经完成
    if (skb-&gt;ip_summed == CHECKSUM_COMPLETE) {
        const unsigned char *nh = skb_network_header(skb);
        //减去分片包头的校验和
        skb-&gt;csum = csum_sub(skb-&gt;csum, csum_partial(nh, (u8 *)(fhdr + 1) - nh, 0));
    }
    //最后一个碎片包
    if (!(fhdr-&gt;frag_off &amp; htons(IP6_MF))) {
        /* If we already have some bits beyond end or have different end, the segment is corrupted. */
        if (end &lt; fq-&gt;q.len || ((fq-&gt;q.last_in &amp; LAST_IN) &amp;&amp; end != fq-&gt;q.len)) //分片出现错误
            goto err;

        fq-&gt;q.last_in |= LAST_IN; //标识最后一个分片
        fq-&gt;q.len = end; //记录包总长度
    } else {
        /* Check if the fragment is rounded to 8 bytes. Required by the RFC. */
        if (end &amp; 0x7) { //碎片结尾也需要8字节对齐
            /* RFC2460 says always send parameter problem in this case. -DaveM */
            IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), PSTATS_MIB_INHDRERRORS);
            icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, offsetof(struct ipv6hdr, payload_len));
            return -1;
        }
        if (end &gt; fq-&gt;q.len) {
            /* Some bits beyond end -&gt; corruption. */
            if (fq-&gt;q.last_in &amp; LAST_IN)
                goto err;
            fq-&gt;q.len = end; //记录已经得到的碎片的最大长度
        }
    }
    if (end == offset) //开始 = 结束
        goto err;

    //skb-&gt;data 指向碎片首部头后数据部分
    if (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb-&gt;data))
        goto err;
    //如果需要缩短skb的内存长度
    if (pskb_trim_rcsum(skb, end - offset))
        goto err;

    //找出碎片所在位置
    prev = NULL;
    for(next = fq-&gt;q.fragments; next != NULL; next = next-&gt;next) {
        if (FRAG6_CB(next)-&gt;offset &gt;= offset)
            break;  /* bingo! */
        prev = next;
    }
    if (prev) { //有前一个碎片
        //前一个碎片 (开始 + 长度) - 这个碎片的开始. 计算出重叠部分
        int i = (FRAG6_CB(prev)-&gt;offset + prev-&gt;len) - offset;
        if (i &gt; 0) { //有重叠
            offset += i; //调整这个碎片的开始位置
            if (end &lt;= offset) //调整后出错
                goto err;
            if (!pskb_pull(skb, i))//skb-&gt;data += i;
                goto err;
            if (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)
                skb-&gt;ip_summed = CHECKSUM_NONE;
        }
    }
    //有下一个碎片，且开始位置 &lt; 这个碎片的结束位置
    while (next &amp;&amp; FRAG6_CB(next)-&gt;offset &lt; end) {
        //这个碎片的结束位置  - 下一个碎片的开始位置，计算重叠
        int i = end - FRAG6_CB(next)-&gt;offset; /* overlap is 'i' bytes */
        if (i &lt; next-&gt;len) { //重叠长度 &lt; 下一个碎片的长度
            if (!pskb_pull(next, i)) //next-&gt;data += i;
                goto err;

            FRAG6_CB(next)-&gt;offset += i;    //下一个碎片开始位置调整
            fq-&gt;q.meat -= i; //总长度减少
            if (next-&gt;ip_summed != CHECKSUM_UNNECESSARY)
                next-&gt;ip_summed = CHECKSUM_NONE;
            break;

        } else { //这个碎片完全复盖了下一个碎片
            struct sk_buff *free_it = next; //释放这个碎片
            next = next-&gt;next;//调整下一个碎片指针
            //调整队列指针
            if (prev)
                prev-&gt;next = next;
            else
                fq-&gt;q.fragments = next;

            fq-&gt;q.meat -= free_it-&gt;len;
            frag_kfree_skb(free_it, NULL); //释放被复盖的包
        }
    }
    FRAG6_CB(skb)-&gt;offset = offset; //这个碎片包记录自己的开始位置

    //插入这个碎片到队列
    skb-&gt;next = next;
    if (prev)
        prev-&gt;next = skb;
    else
        fq-&gt;q.fragments = skb;

    dev = skb-&gt;dev;
    if (dev) {
        fq-&gt;iif = dev-&gt;ifindex;
        skb-&gt;dev = NULL;
    }
    fq-&gt;q.stamp = skb-&gt;tstamp;
    fq-&gt;q.meat += skb-&gt;len; //累加总长度
    atomic_add(skb-&gt;truesize, &amp;ip6_frags.mem);

    if (offset == 0) { //偏移为0
        fq-&gt;nhoffset = nhoff;
        fq-&gt;q.last_in |= FIRST_IN; //标识开始碎片
    }
    //碎片已经聚齐，记录长度 = 包中标识的长度
    if (fq-&gt;q.last_in == (FIRST_IN | LAST_IN) &amp;&amp; fq-&gt;q.meat == fq-&gt;q.len)
        return ip6_frag_reasm(fq, prev, dev); //重组
    //没有聚齐，移动队列连表到lru连表尾部
    write_lock(&amp;ip6_frags.lock);
    list_move_tail(&amp;fq-&gt;q.lru_list, &amp;ip6_frags.lru_list);
    write_unlock(&amp;ip6_frags.lock);
    return -1;
err:
    IP6_INC_STATS(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMFAILS);
    kfree_skb(skb);
    return -1;
}
</code></pre>

<pre><code>
重组ip头
</code></pre>

<pre><code>static int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev, struct net_device *dev)
{
    struct sk_buff *fp, *head = fq-&gt;q.fragments;
    int    payload_len;
    unsigned int nhoff;

    fq_kill(fq); //把这个重组队列出队

    /* Make the one we just received the head. */
    if (prev) {
        //下面是把head指向的skb复制到fp，然后把fp插入到head指向的位置
        head = prev-&gt;next;
        fp = skb_clone(head, GFP_ATOMIC);

        if (!fp)
            goto out_oom;


        fp-&gt;next = head-&gt;next;
        prev-&gt;next = fp;
        //把真正的头skb复制到head指针的skb
        skb_morph(head, fq-&gt;q.fragments);
        head-&gt;next = fq-&gt;q.fragments-&gt;next;

        kfree_skb(fq-&gt;q.fragments);//释放原来的头
        fq-&gt;q.fragments = head;
    }
    /* Unfragmented part is taken from the first segment. */
    //计算负载总长度
    payload_len = ((head-&gt;data - skb_network_header(head)) - sizeof(struct ipv6hdr) + fq-&gt;q.len -  sizeof(struct frag_hdr));
    if (payload_len &gt; IPV6_MAXPLEN) //超过65535
        goto out_oversize;

    /* Head of list must not be cloned. */
    //如果skb被克隆，从新分配他的data
    if (skb_cloned(head) &amp;&amp; pskb_expand_head(head, 0, 0, GFP_ATOMIC))
        goto out_oom;

    /* If the first fragment is fragmented itself, we split it to two chunks: the first with data and paged part
     * and the second, holding only fragments.
     */
    if (skb_shinfo(head)-&gt;frag_list) {//如果头自己已经被分片
        struct sk_buff *clone;
        int i, plen = 0;

        if ((clone = alloc_skb(0, GFP_ATOMIC)) == NULL)
            goto out_oom;

        //把这个clone插入到头后               
        clone-&gt;next = head-&gt;next;
        head-&gt;next = clone;
        //把头的分片给这个clone
        skb_shinfo(clone)-&gt;frag_list = skb_shinfo(head)-&gt;frag_list;
        skb_shinfo(head)-&gt;frag_list = NULL;
        //头使用了页面，计算总长度
        for (i = 0; i &lt; skb_shinfo(head)-&gt;nr_frags; i++)
            plen += skb_shinfo(head)-&gt;frags[i].size;

        clone-&gt;len = clone-&gt;data_len = head-&gt;data_len - plen;
        head-&gt;data_len -= clone-&gt;len;
        head-&gt;len -= clone-&gt;len;
        clone-&gt;csum = 0;
        clone-&gt;ip_summed = head-&gt;ip_summed;
        atomic_add(clone-&gt;truesize, &amp;ip6_frags.mem);
    }
    /* We have to remove fragment header from datagram and to relocate                         
     * header in order to calculate ICV correctly. */
    nhoff = fq-&gt;nhoffset;
    //把传输头（分片头）中的下一个头字段值赋给网络头中的下一个头字段
    skb_network_header(head)[nhoff] = skb_transport_header(head)[0];
    //把分片首部复盖掉
    memmove(head-&gt;head + sizeof(struct frag_hdr), head-&gt;head, (head-&gt;data - head-&gt;head) - sizeof(struct frag_hdr));
    //调整相应的各个层的头位置
    head-&gt;mac_header += sizeof(struct frag_hdr);
    head-&gt;network_header += sizeof(struct frag_hdr);

    skb_shinfo(head)-&gt;frag_list = head-&gt;next; //保存碎片连表
    skb_reset_transport_header(head);//重新调整网络头，现在指向分片头后的头
    skb_push(head, head-&gt;data - skb_network_header(head));//使head-&gt;data指向网络头
    atomic_sub(head-&gt;truesize, &amp;ip6_frags.mem);

    for (fp = head-&gt;next; fp; fp = fp-&gt;next) { //统计分片总长度
        head-&gt;data_len += fp-&gt;len;
        head-&gt;len += fp-&gt;len;
        if (head-&gt;ip_summed != fp-&gt;ip_summed)
            head-&gt;ip_summed = CHECKSUM_NONE;
        else if (head-&gt;ip_summed == CHECKSUM_COMPLETE)
            head-&gt;csum = csum_add(head-&gt;csum, fp-&gt;csum); //添加各分片的累加和

        head-&gt;truesize += fp-&gt;truesize;
        atomic_sub(fp-&gt;truesize, &amp;ip6_frags.mem);
    }
    head-&gt;next = NULL;
    head-&gt;dev = dev;
    head-&gt;tstamp = fq-&gt;q.stamp;
    ipv6_hdr(head)-&gt;payload_len = htons(payload_len); //总长度
    IP6CB(head)-&gt;nhoff = nhoff;

    /* Yes, and fold redundant checksum back. 8) */
    if (head-&gt;ip_summed == CHECKSUM_COMPLETE) //添加网络头累加和
        head-&gt;csum = csum_partial(skb_network_header(head), skb_network_header_len(head), head-&gt;csum);

    rcu_read_lock();
    IP6_INC_STATS_BH(__in6_dev_get(dev), IPSTATS_MIB_REASMOKS);
    rcu_read_unlock();
    fq-&gt;q.fragments = NULL;
    return 1;
    ...... //下面是错误处理
}
</code></pre>

<pre><code>
#### 无数据扩展头
</code></pre>

<pre><code>static struct inet6_protocol nodata_protocol = {
    .handler        =       ipv6_nodata_rcv,
    .flags          =       INET6_PROTO_NOPOLICY,
};
static int ipv6_nodata_rcv(struct sk_buff *skb)
{
    kfree_skb(skb);
    return 0;
}
</code></pre>

<pre><code>
#### 目的选项首部处理
</code></pre>

<pre><code>static struct inet6_protocol destopt_protocol = {
    .handler        =       ipv6_destopt_rcv,
    .flags          =       INET6_PROTO_NOPOLICY | INET6_PROTO_GSO_EXTHDR,
};
static int ipv6_destopt_rcv(struct sk_buff *skb)
{
    struct inet6_skb_parm *opt = IP6CB(skb);
#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
    __u16 dstbuf;
#endif
    struct dst_entry *dst;
    //长度验证
    if (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) || !pskb_may_pull(skb, (skb_transport_offset(skb) +
                    ((skb_transport_header(skb)[1] + 1) &lt;&lt; 3)))) {
        IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
        kfree_skb(skb);
        return -1;
    }
    opt-&gt;lastopt = opt-&gt;dst1 = skb_network_header_len(skb); //网络头长度
#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
    dstbuf = opt-&gt;dst1;
#endif
    dst = dst_clone(skb-&gt;dst); //增加dst的引用计数
    //解析tlv，上面已经看到过了
    if (ip6_parse_tlv(tlvprocdestopt_lst, skb)) {
        dst_release(dst);
        skb-&gt;transport_header += (skb_transport_header(skb)[1] + 1) &lt;&lt; 3; //调整网络头位置
        opt = IP6CB(skb);
#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
        opt-&gt;nhoff = dstbuf;
#else
        opt-&gt;nhoff = opt-&gt;dst1;
#endif
        return 1;
    }
    IP6_INC_STATS_BH(ip6_dst_idev(dst), IPSTATS_MIB_INHDRERRORS);
    dst_release(dst);
    return -1;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
