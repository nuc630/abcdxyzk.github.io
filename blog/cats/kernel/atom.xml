<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-07-14T22:08:34+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[查看所有tcp连接]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/02/kernel-net-info/"/>
    <updated>2015-07-02T10:06:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/02/kernel-net-info</id>
    <content type="html"><![CDATA[<p><a href="http://roclinux.cn/?p=2418">http://roclinux.cn/?p=2418</a></p>

<p><a href="http://blog.csdn.net/justlinux2010/article/details/21028797">http://blog.csdn.net/justlinux2010/article/details/21028797</a></p>

<h4>一、查看连接</h4>

<pre><code>    netstat -an
</code></pre>

<p>或
<code>
    ss
</code></p>

<h4>二、查看连接详细信息</h4>

<p>上面的命令也是从<code>/proc/net/tcp</code>和<code>/proc/net/tcp6</code>中读取的</p>

<p>/proc/net/tcp中的内容由tcp4_seq_show()函数打印，该函数中有三种打印形式，我们这里这只列出状态是TCP_SEQ_STATE_LISTENING或TCP_SEQ_STATE_ESTABLISHED的情况，如下所示：</p>

<p><img src="/images/kernel/2015-07-02.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IPV6 实现]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/06/18/kernel-net-ipv6-code/"/>
    <updated>2015-06-18T10:44:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/06/18/kernel-net-ipv6-code</id>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/super-king/p/ipv6_implement.html">http://www.cnblogs.com/super-king/p/ipv6_implement.html</a></p>

<p>code extract from 2.6.24.
在文件 net/ipv6/af_inet6.c 中包含了ipv6协议初始化的主函数。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
<span class='line-number'>571</span>
<span class='line-number'>572</span>
<span class='line-number'>573</span>
<span class='line-number'>574</span>
<span class='line-number'>575</span>
<span class='line-number'>576</span>
<span class='line-number'>577</span>
<span class='line-number'>578</span>
<span class='line-number'>579</span>
<span class='line-number'>580</span>
<span class='line-number'>581</span>
<span class='line-number'>582</span>
<span class='line-number'>583</span>
<span class='line-number'>584</span>
<span class='line-number'>585</span>
<span class='line-number'>586</span>
<span class='line-number'>587</span>
<span class='line-number'>588</span>
<span class='line-number'>589</span>
<span class='line-number'>590</span>
<span class='line-number'>591</span>
<span class='line-number'>592</span>
<span class='line-number'>593</span>
<span class='line-number'>594</span>
<span class='line-number'>595</span>
<span class='line-number'>596</span>
<span class='line-number'>597</span>
<span class='line-number'>598</span>
<span class='line-number'>599</span>
<span class='line-number'>600</span>
<span class='line-number'>601</span>
<span class='line-number'>602</span>
<span class='line-number'>603</span>
<span class='line-number'>604</span>
<span class='line-number'>605</span>
<span class='line-number'>606</span>
<span class='line-number'>607</span>
<span class='line-number'>608</span>
<span class='line-number'>609</span>
<span class='line-number'>610</span>
<span class='line-number'>611</span>
<span class='line-number'>612</span>
<span class='line-number'>613</span>
<span class='line-number'>614</span>
<span class='line-number'>615</span>
<span class='line-number'>616</span>
<span class='line-number'>617</span>
<span class='line-number'>618</span>
<span class='line-number'>619</span>
<span class='line-number'>620</span>
<span class='line-number'>621</span>
<span class='line-number'>622</span>
<span class='line-number'>623</span>
<span class='line-number'>624</span>
<span class='line-number'>625</span>
<span class='line-number'>626</span>
<span class='line-number'>627</span>
<span class='line-number'>628</span>
<span class='line-number'>629</span>
<span class='line-number'>630</span>
<span class='line-number'>631</span>
<span class='line-number'>632</span>
<span class='line-number'>633</span>
<span class='line-number'>634</span>
<span class='line-number'>635</span>
<span class='line-number'>636</span>
<span class='line-number'>637</span>
<span class='line-number'>638</span>
<span class='line-number'>639</span>
<span class='line-number'>640</span>
<span class='line-number'>641</span>
<span class='line-number'>642</span>
<span class='line-number'>643</span>
<span class='line-number'>644</span>
<span class='line-number'>645</span>
<span class='line-number'>646</span>
<span class='line-number'>647</span>
<span class='line-number'>648</span>
<span class='line-number'>649</span>
<span class='line-number'>650</span>
<span class='line-number'>651</span>
<span class='line-number'>652</span>
<span class='line-number'>653</span>
<span class='line-number'>654</span>
<span class='line-number'>655</span>
<span class='line-number'>656</span>
<span class='line-number'>657</span>
<span class='line-number'>658</span>
<span class='line-number'>659</span>
<span class='line-number'>660</span>
<span class='line-number'>661</span>
<span class='line-number'>662</span>
<span class='line-number'>663</span>
<span class='line-number'>664</span>
<span class='line-number'>665</span>
<span class='line-number'>666</span>
<span class='line-number'>667</span>
<span class='line-number'>668</span>
<span class='line-number'>669</span>
<span class='line-number'>670</span>
<span class='line-number'>671</span>
<span class='line-number'>672</span>
<span class='line-number'>673</span>
<span class='line-number'>674</span>
<span class='line-number'>675</span>
<span class='line-number'>676</span>
<span class='line-number'>677</span>
<span class='line-number'>678</span>
<span class='line-number'>679</span>
<span class='line-number'>680</span>
<span class='line-number'>681</span>
<span class='line-number'>682</span>
<span class='line-number'>683</span>
<span class='line-number'>684</span>
<span class='line-number'>685</span>
<span class='line-number'>686</span>
<span class='line-number'>687</span>
<span class='line-number'>688</span>
<span class='line-number'>689</span>
<span class='line-number'>690</span>
<span class='line-number'>691</span>
<span class='line-number'>692</span>
<span class='line-number'>693</span>
<span class='line-number'>694</span>
<span class='line-number'>695</span>
<span class='line-number'>696</span>
<span class='line-number'>697</span>
<span class='line-number'>698</span>
<span class='line-number'>699</span>
<span class='line-number'>700</span>
<span class='line-number'>701</span>
<span class='line-number'>702</span>
<span class='line-number'>703</span>
<span class='line-number'>704</span>
<span class='line-number'>705</span>
<span class='line-number'>706</span>
<span class='line-number'>707</span>
<span class='line-number'>708</span>
<span class='line-number'>709</span>
<span class='line-number'>710</span>
<span class='line-number'>711</span>
<span class='line-number'>712</span>
<span class='line-number'>713</span>
<span class='line-number'>714</span>
<span class='line-number'>715</span>
<span class='line-number'>716</span>
<span class='line-number'>717</span>
<span class='line-number'>718</span>
<span class='line-number'>719</span>
<span class='line-number'>720</span>
<span class='line-number'>721</span>
<span class='line-number'>722</span>
<span class='line-number'>723</span>
<span class='line-number'>724</span>
<span class='line-number'>725</span>
<span class='line-number'>726</span>
<span class='line-number'>727</span>
<span class='line-number'>728</span>
<span class='line-number'>729</span>
<span class='line-number'>730</span>
<span class='line-number'>731</span>
<span class='line-number'>732</span>
<span class='line-number'>733</span>
<span class='line-number'>734</span>
<span class='line-number'>735</span>
<span class='line-number'>736</span>
<span class='line-number'>737</span>
<span class='line-number'>738</span>
<span class='line-number'>739</span>
<span class='line-number'>740</span>
<span class='line-number'>741</span>
<span class='line-number'>742</span>
<span class='line-number'>743</span>
<span class='line-number'>744</span>
<span class='line-number'>745</span>
<span class='line-number'>746</span>
<span class='line-number'>747</span>
<span class='line-number'>748</span>
<span class='line-number'>749</span>
<span class='line-number'>750</span>
<span class='line-number'>751</span>
<span class='line-number'>752</span>
<span class='line-number'>753</span>
<span class='line-number'>754</span>
<span class='line-number'>755</span>
<span class='line-number'>756</span>
<span class='line-number'>757</span>
<span class='line-number'>758</span>
<span class='line-number'>759</span>
<span class='line-number'>760</span>
<span class='line-number'>761</span>
<span class='line-number'>762</span>
<span class='line-number'>763</span>
<span class='line-number'>764</span>
<span class='line-number'>765</span>
<span class='line-number'>766</span>
<span class='line-number'>767</span>
<span class='line-number'>768</span>
<span class='line-number'>769</span>
<span class='line-number'>770</span>
<span class='line-number'>771</span>
<span class='line-number'>772</span>
<span class='line-number'>773</span>
<span class='line-number'>774</span>
<span class='line-number'>775</span>
<span class='line-number'>776</span>
<span class='line-number'>777</span>
<span class='line-number'>778</span>
<span class='line-number'>779</span>
<span class='line-number'>780</span>
<span class='line-number'>781</span>
<span class='line-number'>782</span>
<span class='line-number'>783</span>
<span class='line-number'>784</span>
<span class='line-number'>785</span>
<span class='line-number'>786</span>
<span class='line-number'>787</span>
<span class='line-number'>788</span>
<span class='line-number'>789</span>
<span class='line-number'>790</span>
<span class='line-number'>791</span>
<span class='line-number'>792</span>
<span class='line-number'>793</span>
<span class='line-number'>794</span>
<span class='line-number'>795</span>
<span class='line-number'>796</span>
<span class='line-number'>797</span>
<span class='line-number'>798</span>
<span class='line-number'>799</span>
<span class='line-number'>800</span>
<span class='line-number'>801</span>
<span class='line-number'>802</span>
<span class='line-number'>803</span>
<span class='line-number'>804</span>
<span class='line-number'>805</span>
<span class='line-number'>806</span>
<span class='line-number'>807</span>
<span class='line-number'>808</span>
<span class='line-number'>809</span>
<span class='line-number'>810</span>
<span class='line-number'>811</span>
<span class='line-number'>812</span>
<span class='line-number'>813</span>
<span class='line-number'>814</span>
<span class='line-number'>815</span>
<span class='line-number'>816</span>
<span class='line-number'>817</span>
<span class='line-number'>818</span>
<span class='line-number'>819</span>
<span class='line-number'>820</span>
<span class='line-number'>821</span>
<span class='line-number'>822</span>
<span class='line-number'>823</span>
<span class='line-number'>824</span>
<span class='line-number'>825</span>
<span class='line-number'>826</span>
<span class='line-number'>827</span>
<span class='line-number'>828</span>
<span class='line-number'>829</span>
<span class='line-number'>830</span>
<span class='line-number'>831</span>
<span class='line-number'>832</span>
<span class='line-number'>833</span>
<span class='line-number'>834</span>
<span class='line-number'>835</span>
<span class='line-number'>836</span>
<span class='line-number'>837</span>
<span class='line-number'>838</span>
<span class='line-number'>839</span>
<span class='line-number'>840</span>
<span class='line-number'>841</span>
<span class='line-number'>842</span>
<span class='line-number'>843</span>
<span class='line-number'>844</span>
<span class='line-number'>845</span>
<span class='line-number'>846</span>
<span class='line-number'>847</span>
<span class='line-number'>848</span>
<span class='line-number'>849</span>
<span class='line-number'>850</span>
<span class='line-number'>851</span>
<span class='line-number'>852</span>
<span class='line-number'>853</span>
<span class='line-number'>854</span>
<span class='line-number'>855</span>
<span class='line-number'>856</span>
<span class='line-number'>857</span>
<span class='line-number'>858</span>
<span class='line-number'>859</span>
<span class='line-number'>860</span>
<span class='line-number'>861</span>
<span class='line-number'>862</span>
<span class='line-number'>863</span>
<span class='line-number'>864</span>
<span class='line-number'>865</span>
<span class='line-number'>866</span>
<span class='line-number'>867</span>
<span class='line-number'>868</span>
<span class='line-number'>869</span>
<span class='line-number'>870</span>
<span class='line-number'>871</span>
<span class='line-number'>872</span>
<span class='line-number'>873</span>
<span class='line-number'>874</span>
<span class='line-number'>875</span>
<span class='line-number'>876</span>
<span class='line-number'>877</span>
<span class='line-number'>878</span>
<span class='line-number'>879</span>
<span class='line-number'>880</span>
<span class='line-number'>881</span>
<span class='line-number'>882</span>
<span class='line-number'>883</span>
<span class='line-number'>884</span>
<span class='line-number'>885</span>
<span class='line-number'>886</span>
<span class='line-number'>887</span>
<span class='line-number'>888</span>
<span class='line-number'>889</span>
<span class='line-number'>890</span>
<span class='line-number'>891</span>
<span class='line-number'>892</span>
<span class='line-number'>893</span>
<span class='line-number'>894</span>
<span class='line-number'>895</span>
<span class='line-number'>896</span>
<span class='line-number'>897</span>
<span class='line-number'>898</span>
<span class='line-number'>899</span>
<span class='line-number'>900</span>
<span class='line-number'>901</span>
<span class='line-number'>902</span>
<span class='line-number'>903</span>
<span class='line-number'>904</span>
<span class='line-number'>905</span>
<span class='line-number'>906</span>
<span class='line-number'>907</span>
<span class='line-number'>908</span>
<span class='line-number'>909</span>
<span class='line-number'>910</span>
<span class='line-number'>911</span>
<span class='line-number'>912</span>
<span class='line-number'>913</span>
<span class='line-number'>914</span>
<span class='line-number'>915</span>
<span class='line-number'>916</span>
<span class='line-number'>917</span>
<span class='line-number'>918</span>
<span class='line-number'>919</span>
<span class='line-number'>920</span>
<span class='line-number'>921</span>
<span class='line-number'>922</span>
<span class='line-number'>923</span>
<span class='line-number'>924</span>
<span class='line-number'>925</span>
<span class='line-number'>926</span>
<span class='line-number'>927</span>
<span class='line-number'>928</span>
<span class='line-number'>929</span>
<span class='line-number'>930</span>
<span class='line-number'>931</span>
<span class='line-number'>932</span>
<span class='line-number'>933</span>
<span class='line-number'>934</span>
<span class='line-number'>935</span>
<span class='line-number'>936</span>
<span class='line-number'>937</span>
<span class='line-number'>938</span>
<span class='line-number'>939</span>
<span class='line-number'>940</span>
<span class='line-number'>941</span>
<span class='line-number'>942</span>
<span class='line-number'>943</span>
<span class='line-number'>944</span>
<span class='line-number'>945</span>
<span class='line-number'>946</span>
<span class='line-number'>947</span>
<span class='line-number'>948</span>
<span class='line-number'>949</span>
<span class='line-number'>950</span>
<span class='line-number'>951</span>
<span class='line-number'>952</span>
<span class='line-number'>953</span>
<span class='line-number'>954</span>
<span class='line-number'>955</span>
<span class='line-number'>956</span>
<span class='line-number'>957</span>
<span class='line-number'>958</span>
<span class='line-number'>959</span>
<span class='line-number'>960</span>
<span class='line-number'>961</span>
<span class='line-number'>962</span>
<span class='line-number'>963</span>
<span class='line-number'>964</span>
<span class='line-number'>965</span>
<span class='line-number'>966</span>
<span class='line-number'>967</span>
<span class='line-number'>968</span>
<span class='line-number'>969</span>
<span class='line-number'>970</span>
<span class='line-number'>971</span>
<span class='line-number'>972</span>
<span class='line-number'>973</span>
<span class='line-number'>974</span>
<span class='line-number'>975</span>
<span class='line-number'>976</span>
<span class='line-number'>977</span>
<span class='line-number'>978</span>
<span class='line-number'>979</span>
<span class='line-number'>980</span>
<span class='line-number'>981</span>
<span class='line-number'>982</span>
<span class='line-number'>983</span>
<span class='line-number'>984</span>
<span class='line-number'>985</span>
<span class='line-number'>986</span>
<span class='line-number'>987</span>
<span class='line-number'>988</span>
<span class='line-number'>989</span>
<span class='line-number'>990</span>
<span class='line-number'>991</span>
<span class='line-number'>992</span>
<span class='line-number'>993</span>
<span class='line-number'>994</span>
<span class='line-number'>995</span>
<span class='line-number'>996</span>
<span class='line-number'>997</span>
<span class='line-number'>998</span>
<span class='line-number'>999</span>
<span class='line-number'>1000</span>
<span class='line-number'>1001</span>
<span class='line-number'>1002</span>
<span class='line-number'>1003</span>
<span class='line-number'>1004</span>
<span class='line-number'>1005</span>
<span class='line-number'>1006</span>
<span class='line-number'>1007</span>
<span class='line-number'>1008</span>
<span class='line-number'>1009</span>
<span class='line-number'>1010</span>
<span class='line-number'>1011</span>
<span class='line-number'>1012</span>
<span class='line-number'>1013</span>
<span class='line-number'>1014</span>
<span class='line-number'>1015</span>
<span class='line-number'>1016</span>
<span class='line-number'>1017</span>
<span class='line-number'>1018</span>
<span class='line-number'>1019</span>
<span class='line-number'>1020</span>
<span class='line-number'>1021</span>
<span class='line-number'>1022</span>
<span class='line-number'>1023</span>
<span class='line-number'>1024</span>
<span class='line-number'>1025</span>
<span class='line-number'>1026</span>
<span class='line-number'>1027</span>
<span class='line-number'>1028</span>
<span class='line-number'>1029</span>
<span class='line-number'>1030</span>
<span class='line-number'>1031</span>
<span class='line-number'>1032</span>
<span class='line-number'>1033</span>
<span class='line-number'>1034</span>
<span class='line-number'>1035</span>
<span class='line-number'>1036</span>
<span class='line-number'>1037</span>
<span class='line-number'>1038</span>
<span class='line-number'>1039</span>
<span class='line-number'>1040</span>
<span class='line-number'>1041</span>
<span class='line-number'>1042</span>
<span class='line-number'>1043</span>
<span class='line-number'>1044</span>
<span class='line-number'>1045</span>
<span class='line-number'>1046</span>
<span class='line-number'>1047</span>
<span class='line-number'>1048</span>
<span class='line-number'>1049</span>
<span class='line-number'>1050</span>
<span class='line-number'>1051</span>
<span class='line-number'>1052</span>
<span class='line-number'>1053</span>
<span class='line-number'>1054</span>
<span class='line-number'>1055</span>
<span class='line-number'>1056</span>
<span class='line-number'>1057</span>
<span class='line-number'>1058</span>
<span class='line-number'>1059</span>
<span class='line-number'>1060</span>
<span class='line-number'>1061</span>
<span class='line-number'>1062</span>
<span class='line-number'>1063</span>
<span class='line-number'>1064</span>
<span class='line-number'>1065</span>
<span class='line-number'>1066</span>
<span class='line-number'>1067</span>
<span class='line-number'>1068</span>
<span class='line-number'>1069</span>
<span class='line-number'>1070</span>
<span class='line-number'>1071</span>
<span class='line-number'>1072</span>
<span class='line-number'>1073</span>
<span class='line-number'>1074</span>
<span class='line-number'>1075</span>
<span class='line-number'>1076</span>
<span class='line-number'>1077</span>
<span class='line-number'>1078</span>
<span class='line-number'>1079</span>
<span class='line-number'>1080</span>
<span class='line-number'>1081</span>
<span class='line-number'>1082</span>
<span class='line-number'>1083</span>
<span class='line-number'>1084</span>
<span class='line-number'>1085</span>
<span class='line-number'>1086</span>
<span class='line-number'>1087</span>
<span class='line-number'>1088</span>
<span class='line-number'>1089</span>
<span class='line-number'>1090</span>
<span class='line-number'>1091</span>
<span class='line-number'>1092</span>
<span class='line-number'>1093</span>
<span class='line-number'>1094</span>
<span class='line-number'>1095</span>
<span class='line-number'>1096</span>
<span class='line-number'>1097</span>
<span class='line-number'>1098</span>
<span class='line-number'>1099</span>
<span class='line-number'>1100</span>
<span class='line-number'>1101</span>
<span class='line-number'>1102</span>
<span class='line-number'>1103</span>
<span class='line-number'>1104</span>
<span class='line-number'>1105</span>
<span class='line-number'>1106</span>
<span class='line-number'>1107</span>
<span class='line-number'>1108</span>
<span class='line-number'>1109</span>
<span class='line-number'>1110</span>
<span class='line-number'>1111</span>
<span class='line-number'>1112</span>
<span class='line-number'>1113</span>
<span class='line-number'>1114</span>
<span class='line-number'>1115</span>
<span class='line-number'>1116</span>
<span class='line-number'>1117</span>
<span class='line-number'>1118</span>
<span class='line-number'>1119</span>
<span class='line-number'>1120</span>
<span class='line-number'>1121</span>
<span class='line-number'>1122</span>
<span class='line-number'>1123</span>
<span class='line-number'>1124</span>
<span class='line-number'>1125</span>
<span class='line-number'>1126</span>
<span class='line-number'>1127</span>
<span class='line-number'>1128</span>
<span class='line-number'>1129</span>
<span class='line-number'>1130</span>
<span class='line-number'>1131</span>
<span class='line-number'>1132</span>
<span class='line-number'>1133</span>
<span class='line-number'>1134</span>
<span class='line-number'>1135</span>
<span class='line-number'>1136</span>
<span class='line-number'>1137</span>
<span class='line-number'>1138</span>
<span class='line-number'>1139</span>
<span class='line-number'>1140</span>
<span class='line-number'>1141</span>
<span class='line-number'>1142</span>
<span class='line-number'>1143</span>
<span class='line-number'>1144</span>
<span class='line-number'>1145</span>
<span class='line-number'>1146</span>
<span class='line-number'>1147</span>
<span class='line-number'>1148</span>
<span class='line-number'>1149</span>
<span class='line-number'>1150</span>
<span class='line-number'>1151</span>
<span class='line-number'>1152</span>
<span class='line-number'>1153</span>
<span class='line-number'>1154</span>
<span class='line-number'>1155</span>
<span class='line-number'>1156</span>
<span class='line-number'>1157</span>
<span class='line-number'>1158</span>
<span class='line-number'>1159</span>
<span class='line-number'>1160</span>
<span class='line-number'>1161</span>
<span class='line-number'>1162</span>
<span class='line-number'>1163</span>
<span class='line-number'>1164</span>
<span class='line-number'>1165</span>
<span class='line-number'>1166</span>
<span class='line-number'>1167</span>
<span class='line-number'>1168</span>
<span class='line-number'>1169</span>
<span class='line-number'>1170</span>
<span class='line-number'>1171</span>
<span class='line-number'>1172</span>
<span class='line-number'>1173</span>
<span class='line-number'>1174</span>
<span class='line-number'>1175</span>
<span class='line-number'>1176</span>
<span class='line-number'>1177</span>
<span class='line-number'>1178</span>
<span class='line-number'>1179</span>
<span class='line-number'>1180</span>
<span class='line-number'>1181</span>
<span class='line-number'>1182</span>
<span class='line-number'>1183</span>
<span class='line-number'>1184</span>
<span class='line-number'>1185</span>
<span class='line-number'>1186</span>
<span class='line-number'>1187</span>
<span class='line-number'>1188</span>
<span class='line-number'>1189</span>
<span class='line-number'>1190</span>
<span class='line-number'>1191</span>
<span class='line-number'>1192</span>
<span class='line-number'>1193</span>
<span class='line-number'>1194</span>
<span class='line-number'>1195</span>
<span class='line-number'>1196</span>
<span class='line-number'>1197</span>
<span class='line-number'>1198</span>
<span class='line-number'>1199</span>
<span class='line-number'>1200</span>
<span class='line-number'>1201</span>
<span class='line-number'>1202</span>
<span class='line-number'>1203</span>
<span class='line-number'>1204</span>
<span class='line-number'>1205</span>
<span class='line-number'>1206</span>
<span class='line-number'>1207</span>
<span class='line-number'>1208</span>
<span class='line-number'>1209</span>
<span class='line-number'>1210</span>
<span class='line-number'>1211</span>
<span class='line-number'>1212</span>
<span class='line-number'>1213</span>
<span class='line-number'>1214</span>
<span class='line-number'>1215</span>
<span class='line-number'>1216</span>
<span class='line-number'>1217</span>
<span class='line-number'>1218</span>
<span class='line-number'>1219</span>
<span class='line-number'>1220</span>
<span class='line-number'>1221</span>
<span class='line-number'>1222</span>
<span class='line-number'>1223</span>
<span class='line-number'>1224</span>
<span class='line-number'>1225</span>
<span class='line-number'>1226</span>
<span class='line-number'>1227</span>
<span class='line-number'>1228</span>
<span class='line-number'>1229</span>
<span class='line-number'>1230</span>
<span class='line-number'>1231</span>
<span class='line-number'>1232</span>
<span class='line-number'>1233</span>
<span class='line-number'>1234</span>
<span class='line-number'>1235</span>
<span class='line-number'>1236</span>
<span class='line-number'>1237</span>
<span class='line-number'>1238</span>
<span class='line-number'>1239</span>
<span class='line-number'>1240</span>
<span class='line-number'>1241</span>
<span class='line-number'>1242</span>
<span class='line-number'>1243</span>
<span class='line-number'>1244</span>
<span class='line-number'>1245</span>
<span class='line-number'>1246</span>
<span class='line-number'>1247</span>
<span class='line-number'>1248</span>
<span class='line-number'>1249</span>
<span class='line-number'>1250</span>
<span class='line-number'>1251</span>
<span class='line-number'>1252</span>
<span class='line-number'>1253</span>
<span class='line-number'>1254</span>
<span class='line-number'>1255</span>
<span class='line-number'>1256</span>
<span class='line-number'>1257</span>
<span class='line-number'>1258</span>
<span class='line-number'>1259</span>
<span class='line-number'>1260</span>
<span class='line-number'>1261</span>
<span class='line-number'>1262</span>
<span class='line-number'>1263</span>
<span class='line-number'>1264</span>
<span class='line-number'>1265</span>
<span class='line-number'>1266</span>
<span class='line-number'>1267</span>
<span class='line-number'>1268</span>
<span class='line-number'>1269</span>
<span class='line-number'>1270</span>
<span class='line-number'>1271</span>
<span class='line-number'>1272</span>
<span class='line-number'>1273</span>
<span class='line-number'>1274</span>
<span class='line-number'>1275</span>
<span class='line-number'>1276</span>
<span class='line-number'>1277</span>
<span class='line-number'>1278</span>
<span class='line-number'>1279</span>
<span class='line-number'>1280</span>
<span class='line-number'>1281</span>
<span class='line-number'>1282</span>
<span class='line-number'>1283</span>
<span class='line-number'>1284</span>
<span class='line-number'>1285</span>
<span class='line-number'>1286</span>
<span class='line-number'>1287</span>
<span class='line-number'>1288</span>
<span class='line-number'>1289</span>
<span class='line-number'>1290</span>
<span class='line-number'>1291</span>
<span class='line-number'>1292</span>
<span class='line-number'>1293</span>
<span class='line-number'>1294</span>
<span class='line-number'>1295</span>
<span class='line-number'>1296</span>
<span class='line-number'>1297</span>
<span class='line-number'>1298</span>
<span class='line-number'>1299</span>
<span class='line-number'>1300</span>
<span class='line-number'>1301</span>
<span class='line-number'>1302</span>
<span class='line-number'>1303</span>
<span class='line-number'>1304</span>
<span class='line-number'>1305</span>
<span class='line-number'>1306</span>
<span class='line-number'>1307</span>
<span class='line-number'>1308</span>
<span class='line-number'>1309</span>
<span class='line-number'>1310</span>
<span class='line-number'>1311</span>
<span class='line-number'>1312</span>
<span class='line-number'>1313</span>
<span class='line-number'>1314</span>
<span class='line-number'>1315</span>
<span class='line-number'>1316</span>
<span class='line-number'>1317</span>
<span class='line-number'>1318</span>
<span class='line-number'>1319</span>
<span class='line-number'>1320</span>
<span class='line-number'>1321</span>
<span class='line-number'>1322</span>
<span class='line-number'>1323</span>
<span class='line-number'>1324</span>
<span class='line-number'>1325</span>
<span class='line-number'>1326</span>
<span class='line-number'>1327</span>
<span class='line-number'>1328</span>
<span class='line-number'>1329</span>
<span class='line-number'>1330</span>
<span class='line-number'>1331</span>
<span class='line-number'>1332</span>
<span class='line-number'>1333</span>
<span class='line-number'>1334</span>
<span class='line-number'>1335</span>
<span class='line-number'>1336</span>
<span class='line-number'>1337</span>
<span class='line-number'>1338</span>
<span class='line-number'>1339</span>
<span class='line-number'>1340</span>
<span class='line-number'>1341</span>
<span class='line-number'>1342</span>
<span class='line-number'>1343</span>
<span class='line-number'>1344</span>
<span class='line-number'>1345</span>
<span class='line-number'>1346</span>
<span class='line-number'>1347</span>
<span class='line-number'>1348</span>
<span class='line-number'>1349</span>
<span class='line-number'>1350</span>
<span class='line-number'>1351</span>
<span class='line-number'>1352</span>
<span class='line-number'>1353</span>
<span class='line-number'>1354</span>
<span class='line-number'>1355</span>
<span class='line-number'>1356</span>
<span class='line-number'>1357</span>
<span class='line-number'>1358</span>
<span class='line-number'>1359</span>
<span class='line-number'>1360</span>
<span class='line-number'>1361</span>
<span class='line-number'>1362</span>
<span class='line-number'>1363</span>
<span class='line-number'>1364</span>
<span class='line-number'>1365</span>
<span class='line-number'>1366</span>
<span class='line-number'>1367</span>
<span class='line-number'>1368</span>
<span class='line-number'>1369</span>
<span class='line-number'>1370</span>
<span class='line-number'>1371</span>
<span class='line-number'>1372</span>
<span class='line-number'>1373</span>
<span class='line-number'>1374</span>
<span class='line-number'>1375</span>
<span class='line-number'>1376</span>
<span class='line-number'>1377</span>
<span class='line-number'>1378</span>
<span class='line-number'>1379</span>
<span class='line-number'>1380</span>
<span class='line-number'>1381</span>
<span class='line-number'>1382</span>
<span class='line-number'>1383</span>
<span class='line-number'>1384</span>
<span class='line-number'>1385</span>
<span class='line-number'>1386</span>
<span class='line-number'>1387</span>
<span class='line-number'>1388</span>
<span class='line-number'>1389</span>
<span class='line-number'>1390</span>
<span class='line-number'>1391</span>
<span class='line-number'>1392</span>
<span class='line-number'>1393</span>
<span class='line-number'>1394</span>
<span class='line-number'>1395</span>
<span class='line-number'>1396</span>
<span class='line-number'>1397</span>
<span class='line-number'>1398</span>
<span class='line-number'>1399</span>
<span class='line-number'>1400</span>
<span class='line-number'>1401</span>
<span class='line-number'>1402</span>
<span class='line-number'>1403</span>
<span class='line-number'>1404</span>
<span class='line-number'>1405</span>
<span class='line-number'>1406</span>
<span class='line-number'>1407</span>
<span class='line-number'>1408</span>
<span class='line-number'>1409</span>
<span class='line-number'>1410</span>
<span class='line-number'>1411</span>
<span class='line-number'>1412</span>
<span class='line-number'>1413</span>
<span class='line-number'>1414</span>
<span class='line-number'>1415</span>
<span class='line-number'>1416</span>
<span class='line-number'>1417</span>
<span class='line-number'>1418</span>
<span class='line-number'>1419</span>
<span class='line-number'>1420</span>
<span class='line-number'>1421</span>
<span class='line-number'>1422</span>
<span class='line-number'>1423</span>
<span class='line-number'>1424</span>
<span class='line-number'>1425</span>
<span class='line-number'>1426</span>
<span class='line-number'>1427</span>
<span class='line-number'>1428</span>
<span class='line-number'>1429</span>
<span class='line-number'>1430</span>
<span class='line-number'>1431</span>
<span class='line-number'>1432</span>
<span class='line-number'>1433</span>
<span class='line-number'>1434</span>
<span class='line-number'>1435</span>
<span class='line-number'>1436</span>
<span class='line-number'>1437</span>
<span class='line-number'>1438</span>
<span class='line-number'>1439</span>
<span class='line-number'>1440</span>
<span class='line-number'>1441</span>
<span class='line-number'>1442</span>
<span class='line-number'>1443</span>
<span class='line-number'>1444</span>
<span class='line-number'>1445</span>
<span class='line-number'>1446</span>
<span class='line-number'>1447</span>
<span class='line-number'>1448</span>
<span class='line-number'>1449</span>
<span class='line-number'>1450</span>
<span class='line-number'>1451</span>
<span class='line-number'>1452</span>
<span class='line-number'>1453</span>
<span class='line-number'>1454</span>
<span class='line-number'>1455</span>
<span class='line-number'>1456</span>
<span class='line-number'>1457</span>
<span class='line-number'>1458</span>
<span class='line-number'>1459</span>
<span class='line-number'>1460</span>
<span class='line-number'>1461</span>
<span class='line-number'>1462</span>
<span class='line-number'>1463</span>
<span class='line-number'>1464</span>
<span class='line-number'>1465</span>
<span class='line-number'>1466</span>
<span class='line-number'>1467</span>
<span class='line-number'>1468</span>
<span class='line-number'>1469</span>
<span class='line-number'>1470</span>
<span class='line-number'>1471</span>
<span class='line-number'>1472</span>
<span class='line-number'>1473</span>
<span class='line-number'>1474</span>
<span class='line-number'>1475</span>
<span class='line-number'>1476</span>
<span class='line-number'>1477</span>
<span class='line-number'>1478</span>
<span class='line-number'>1479</span>
<span class='line-number'>1480</span>
<span class='line-number'>1481</span>
<span class='line-number'>1482</span>
<span class='line-number'>1483</span>
<span class='line-number'>1484</span>
<span class='line-number'>1485</span>
<span class='line-number'>1486</span>
<span class='line-number'>1487</span>
<span class='line-number'>1488</span>
<span class='line-number'>1489</span>
<span class='line-number'>1490</span>
<span class='line-number'>1491</span>
<span class='line-number'>1492</span>
<span class='line-number'>1493</span>
<span class='line-number'>1494</span>
<span class='line-number'>1495</span>
<span class='line-number'>1496</span>
<span class='line-number'>1497</span>
<span class='line-number'>1498</span>
<span class='line-number'>1499</span>
<span class='line-number'>1500</span>
<span class='line-number'>1501</span>
<span class='line-number'>1502</span>
<span class='line-number'>1503</span>
<span class='line-number'>1504</span>
<span class='line-number'>1505</span>
<span class='line-number'>1506</span>
<span class='line-number'>1507</span>
<span class='line-number'>1508</span>
<span class='line-number'>1509</span>
<span class='line-number'>1510</span>
<span class='line-number'>1511</span>
<span class='line-number'>1512</span>
<span class='line-number'>1513</span>
<span class='line-number'>1514</span>
<span class='line-number'>1515</span>
<span class='line-number'>1516</span>
<span class='line-number'>1517</span>
<span class='line-number'>1518</span>
<span class='line-number'>1519</span>
<span class='line-number'>1520</span>
<span class='line-number'>1521</span>
<span class='line-number'>1522</span>
<span class='line-number'>1523</span>
<span class='line-number'>1524</span>
<span class='line-number'>1525</span>
<span class='line-number'>1526</span>
<span class='line-number'>1527</span>
<span class='line-number'>1528</span>
<span class='line-number'>1529</span>
<span class='line-number'>1530</span>
<span class='line-number'>1531</span>
<span class='line-number'>1532</span>
<span class='line-number'>1533</span>
<span class='line-number'>1534</span>
<span class='line-number'>1535</span>
<span class='line-number'>1536</span>
<span class='line-number'>1537</span>
<span class='line-number'>1538</span>
<span class='line-number'>1539</span>
<span class='line-number'>1540</span>
<span class='line-number'>1541</span>
<span class='line-number'>1542</span>
<span class='line-number'>1543</span>
<span class='line-number'>1544</span>
<span class='line-number'>1545</span>
<span class='line-number'>1546</span>
<span class='line-number'>1547</span>
<span class='line-number'>1548</span>
<span class='line-number'>1549</span>
<span class='line-number'>1550</span>
<span class='line-number'>1551</span>
<span class='line-number'>1552</span>
<span class='line-number'>1553</span>
<span class='line-number'>1554</span>
<span class='line-number'>1555</span>
<span class='line-number'>1556</span>
<span class='line-number'>1557</span>
<span class='line-number'>1558</span>
<span class='line-number'>1559</span>
<span class='line-number'>1560</span>
<span class='line-number'>1561</span>
<span class='line-number'>1562</span>
<span class='line-number'>1563</span>
<span class='line-number'>1564</span>
<span class='line-number'>1565</span>
<span class='line-number'>1566</span>
<span class='line-number'>1567</span>
<span class='line-number'>1568</span>
<span class='line-number'>1569</span>
<span class='line-number'>1570</span>
<span class='line-number'>1571</span>
<span class='line-number'>1572</span>
<span class='line-number'>1573</span>
<span class='line-number'>1574</span>
<span class='line-number'>1575</span>
<span class='line-number'>1576</span>
<span class='line-number'>1577</span>
<span class='line-number'>1578</span>
<span class='line-number'>1579</span>
<span class='line-number'>1580</span>
<span class='line-number'>1581</span>
<span class='line-number'>1582</span>
<span class='line-number'>1583</span>
<span class='line-number'>1584</span>
<span class='line-number'>1585</span>
<span class='line-number'>1586</span>
<span class='line-number'>1587</span>
<span class='line-number'>1588</span>
<span class='line-number'>1589</span>
<span class='line-number'>1590</span>
<span class='line-number'>1591</span>
<span class='line-number'>1592</span>
<span class='line-number'>1593</span>
<span class='line-number'>1594</span>
<span class='line-number'>1595</span>
<span class='line-number'>1596</span>
<span class='line-number'>1597</span>
<span class='line-number'>1598</span>
<span class='line-number'>1599</span>
<span class='line-number'>1600</span>
<span class='line-number'>1601</span>
<span class='line-number'>1602</span>
<span class='line-number'>1603</span>
<span class='line-number'>1604</span>
<span class='line-number'>1605</span>
<span class='line-number'>1606</span>
<span class='line-number'>1607</span>
<span class='line-number'>1608</span>
<span class='line-number'>1609</span>
<span class='line-number'>1610</span>
<span class='line-number'>1611</span>
<span class='line-number'>1612</span>
<span class='line-number'>1613</span>
<span class='line-number'>1614</span>
<span class='line-number'>1615</span>
<span class='line-number'>1616</span>
<span class='line-number'>1617</span>
<span class='line-number'>1618</span>
<span class='line-number'>1619</span>
<span class='line-number'>1620</span>
<span class='line-number'>1621</span>
<span class='line-number'>1622</span>
<span class='line-number'>1623</span>
<span class='line-number'>1624</span>
<span class='line-number'>1625</span>
<span class='line-number'>1626</span>
<span class='line-number'>1627</span>
<span class='line-number'>1628</span>
<span class='line-number'>1629</span>
<span class='line-number'>1630</span>
<span class='line-number'>1631</span>
<span class='line-number'>1632</span>
<span class='line-number'>1633</span>
<span class='line-number'>1634</span>
<span class='line-number'>1635</span>
<span class='line-number'>1636</span>
<span class='line-number'>1637</span>
<span class='line-number'>1638</span>
<span class='line-number'>1639</span>
<span class='line-number'>1640</span>
<span class='line-number'>1641</span>
<span class='line-number'>1642</span>
<span class='line-number'>1643</span>
<span class='line-number'>1644</span>
<span class='line-number'>1645</span>
<span class='line-number'>1646</span>
<span class='line-number'>1647</span>
<span class='line-number'>1648</span>
<span class='line-number'>1649</span>
<span class='line-number'>1650</span>
<span class='line-number'>1651</span>
<span class='line-number'>1652</span>
<span class='line-number'>1653</span>
<span class='line-number'>1654</span>
<span class='line-number'>1655</span>
<span class='line-number'>1656</span>
<span class='line-number'>1657</span>
<span class='line-number'>1658</span>
<span class='line-number'>1659</span>
<span class='line-number'>1660</span>
<span class='line-number'>1661</span>
<span class='line-number'>1662</span>
<span class='line-number'>1663</span>
<span class='line-number'>1664</span>
<span class='line-number'>1665</span>
<span class='line-number'>1666</span>
<span class='line-number'>1667</span>
<span class='line-number'>1668</span>
<span class='line-number'>1669</span>
<span class='line-number'>1670</span>
<span class='line-number'>1671</span>
<span class='line-number'>1672</span>
<span class='line-number'>1673</span>
<span class='line-number'>1674</span>
<span class='line-number'>1675</span>
<span class='line-number'>1676</span>
<span class='line-number'>1677</span>
<span class='line-number'>1678</span>
<span class='line-number'>1679</span>
<span class='line-number'>1680</span>
<span class='line-number'>1681</span>
<span class='line-number'>1682</span>
<span class='line-number'>1683</span>
<span class='line-number'>1684</span>
<span class='line-number'>1685</span>
<span class='line-number'>1686</span>
<span class='line-number'>1687</span>
<span class='line-number'>1688</span>
<span class='line-number'>1689</span>
<span class='line-number'>1690</span>
<span class='line-number'>1691</span>
<span class='line-number'>1692</span>
<span class='line-number'>1693</span>
<span class='line-number'>1694</span>
<span class='line-number'>1695</span>
<span class='line-number'>1696</span>
<span class='line-number'>1697</span>
<span class='line-number'>1698</span>
<span class='line-number'>1699</span>
<span class='line-number'>1700</span>
<span class='line-number'>1701</span>
<span class='line-number'>1702</span>
<span class='line-number'>1703</span>
<span class='line-number'>1704</span>
<span class='line-number'>1705</span>
<span class='line-number'>1706</span>
<span class='line-number'>1707</span>
<span class='line-number'>1708</span>
<span class='line-number'>1709</span>
<span class='line-number'>1710</span>
<span class='line-number'>1711</span>
<span class='line-number'>1712</span>
<span class='line-number'>1713</span>
<span class='line-number'>1714</span>
<span class='line-number'>1715</span>
<span class='line-number'>1716</span>
<span class='line-number'>1717</span>
<span class='line-number'>1718</span>
<span class='line-number'>1719</span>
<span class='line-number'>1720</span>
<span class='line-number'>1721</span>
<span class='line-number'>1722</span>
<span class='line-number'>1723</span>
<span class='line-number'>1724</span>
<span class='line-number'>1725</span>
<span class='line-number'>1726</span>
<span class='line-number'>1727</span>
<span class='line-number'>1728</span>
<span class='line-number'>1729</span>
<span class='line-number'>1730</span>
<span class='line-number'>1731</span>
<span class='line-number'>1732</span>
<span class='line-number'>1733</span>
<span class='line-number'>1734</span>
<span class='line-number'>1735</span>
<span class='line-number'>1736</span>
<span class='line-number'>1737</span>
<span class='line-number'>1738</span>
<span class='line-number'>1739</span>
<span class='line-number'>1740</span>
<span class='line-number'>1741</span>
<span class='line-number'>1742</span>
<span class='line-number'>1743</span>
<span class='line-number'>1744</span>
<span class='line-number'>1745</span>
<span class='line-number'>1746</span>
<span class='line-number'>1747</span>
<span class='line-number'>1748</span>
<span class='line-number'>1749</span>
<span class='line-number'>1750</span>
<span class='line-number'>1751</span>
<span class='line-number'>1752</span>
<span class='line-number'>1753</span>
<span class='line-number'>1754</span>
<span class='line-number'>1755</span>
<span class='line-number'>1756</span>
<span class='line-number'>1757</span>
<span class='line-number'>1758</span>
<span class='line-number'>1759</span>
<span class='line-number'>1760</span>
<span class='line-number'>1761</span>
<span class='line-number'>1762</span>
<span class='line-number'>1763</span>
<span class='line-number'>1764</span>
<span class='line-number'>1765</span>
<span class='line-number'>1766</span>
<span class='line-number'>1767</span>
<span class='line-number'>1768</span>
<span class='line-number'>1769</span>
<span class='line-number'>1770</span>
<span class='line-number'>1771</span>
<span class='line-number'>1772</span>
<span class='line-number'>1773</span>
<span class='line-number'>1774</span>
<span class='line-number'>1775</span>
<span class='line-number'>1776</span>
<span class='line-number'>1777</span>
<span class='line-number'>1778</span>
<span class='line-number'>1779</span>
<span class='line-number'>1780</span>
<span class='line-number'>1781</span>
<span class='line-number'>1782</span>
<span class='line-number'>1783</span>
<span class='line-number'>1784</span>
<span class='line-number'>1785</span>
<span class='line-number'>1786</span>
<span class='line-number'>1787</span>
<span class='line-number'>1788</span>
<span class='line-number'>1789</span>
<span class='line-number'>1790</span>
<span class='line-number'>1791</span>
<span class='line-number'>1792</span>
<span class='line-number'>1793</span>
<span class='line-number'>1794</span>
<span class='line-number'>1795</span>
<span class='line-number'>1796</span>
<span class='line-number'>1797</span>
<span class='line-number'>1798</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int __init inet6_init(void)
</span><span class='line'>{
</span><span class='line'>    struct sk_buff &lt;em&gt;dummy_skb;
</span><span class='line'>    struct list_head &lt;/em&gt;r;
</span><span class='line'>    int err;
</span><span class='line'>    //inet6_skb_parm必须小于等于skb中的cb
</span><span class='line'>    BUILD_BUG_ON(sizeof(struct inet6_skb_parm) &gt; sizeof(dummy_skb-&gt;cb));&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    //初始化tcpv6_prot结构中的一些与slab相关的字段，然后添加到 proto_list 全局连表
</span><span class='line'>err = proto_register(&amp;tcpv6_prot, 1);
</span><span class='line'>if (err)
</span><span class='line'>    goto out;
</span><span class='line'>//udp协议同上
</span><span class='line'>err = proto_register(&amp;udpv6_prot, 1);
</span><span class='line'>if (err)
</span><span class='line'>    goto out_unregister_tcp_proto;
</span><span class='line'>//udp-lite传输协议，主要用于多媒体传输，参考kernel中的 Documentation/networking/udplite.txt
</span><span class='line'>err = proto_register(&amp;udplitev6_prot, 1);
</span><span class='line'>if (err)
</span><span class='line'>    goto out_unregister_udp_proto;
</span><span class='line'>//原始套接字同上
</span><span class='line'>err = proto_register(&amp;rawv6_prot, 1);
</span><span class='line'>if (err)
</span><span class='line'>    goto out_unregister_udplite_proto;
</span><span class='line'>
</span><span class='line'>/* Register the socket-side information for inet6_create.  */
</span><span class='line'>for(r = &amp;inetsw6[0]; r &lt; &amp;inetsw6[SOCK_MAX]; ++r) //初始化一个协议连表数组
</span><span class='line'>    INIT_LIST_HEAD(r);
</span><span class='line'>/* We MUST register RAW sockets before we create the ICMP6, IGMP6, or NDISC control sockets. */
</span><span class='line'>//根据参数数据结构中标识的协议类型，把这数据结构添加到上面的协议连表数组中
</span><span class='line'>inet6_register_protosw(&amp;rawv6_protosw);
</span><span class='line'>
</span><span class='line'>/* Register the family here so that the init calls below will be able to create sockets. (?? is this dangerous ??) */
</span><span class='line'>//注册ipv6协议族，主要是注册socket创建函数
</span><span class='line'>err = sock_register(&amp;inet6_family_ops);
</span><span class='line'>if (err)
</span><span class='line'>    goto out_unregister_raw_proto;
</span><span class='line'>
</span><span class='line'>/* Initialise ipv6 mibs */
</span><span class='line'>err = init_ipv6_mibs(); //所有ipv6相关的统计信息
</span><span class='line'>if (err)
</span><span class='line'>    goto out_unregister_sock;
</span><span class='line'>/* ipngwg API draft makes clear that the correct semantics for TCP and UDP is to consider one TCP and UDP instance 
</span><span class='line'> * in a host availiable by both INET and INET6 APIs and able to communicate via both network protocols.
</span><span class='line'> */
</span><span class='line'>#ifdef CONFIG_SYSCTL
</span><span class='line'>ipv6_sysctl_register(); // ipv6协议proc条件项初始化
</span><span class='line'>#endif
</span><span class='line'>//icmp协议注册
</span><span class='line'>err = icmpv6_init(&amp;inet6_family_ops);
</span><span class='line'>if (err)
</span><span class='line'>    goto icmp_fail;
</span><span class='line'>//邻居协议（arp）初始化       
</span><span class='line'>err = ndisc_init(&amp;inet6_family_ops);
</span><span class='line'>if (err)
</span><span class='line'>    goto ndisc_fail;
</span><span class='line'>//igmp协议初始化       
</span><span class='line'>err = igmp6_init(&amp;inet6_family_ops);
</span><span class='line'>if (err)
</span><span class='line'>    goto igmp_fail;
</span><span class='line'>//ipv6协议相关的 netfilter 初始化     
</span><span class='line'>err = ipv6_netfilter_init();
</span><span class='line'>if (err)
</span><span class='line'>    goto netfilter_fail;
</span><span class='line'>
</span><span class='line'>/* Create /proc/foo6 entries. */
</span><span class='line'>#ifdef CONFIG_PROC_FS //注册/proc/中协议统计输出项
</span><span class='line'>err = -ENOMEM;
</span><span class='line'>if (raw6_proc_init())
</span><span class='line'>    goto proc_raw6_fail;
</span><span class='line'>if (tcp6_proc_init())
</span><span class='line'>    goto proc_tcp6_fail;
</span><span class='line'>if (udp6_proc_init())
</span><span class='line'>    goto proc_udp6_fail;
</span><span class='line'>if (udplite6_proc_init())
</span><span class='line'>    goto proc_udplite6_fail;
</span><span class='line'>if (ipv6_misc_proc_init())
</span><span class='line'>    goto proc_misc6_fail;
</span><span class='line'>if (ac6_proc_init())
</span><span class='line'>    goto proc_anycast6_fail;
</span><span class='line'>if (if6_proc_init())
</span><span class='line'>    goto proc_if6_fail;
</span><span class='line'>#endif
</span><span class='line'>ip6_route_init(); //ipv6 路由初始化
</span><span class='line'>ip6_flowlabel_init();//ipv6 中流标记，注册了输出流标记的 proc
</span><span class='line'>
</span><span class='line'>//rtnetlink相关部分和路由模板中一些字段和其他一些功能的初始化
</span><span class='line'>err = addrconf_init();
</span><span class='line'>if (err)
</span><span class='line'>    goto addrconf_fail;
</span><span class='line'>/* Init v6 extension headers. */
</span><span class='line'>//ipv6 新添加的扩展头初始化，参考ipv6介绍
</span><span class='line'>ipv6_rthdr_init();
</span><span class='line'>ipv6_frag_init();
</span><span class='line'>ipv6_nodata_init();
</span><span class='line'>ipv6_destopt_init();
</span><span class='line'>
</span><span class='line'>/* Init v6 transport protocols. */
</span><span class='line'>//最主要的传输层协议初始化
</span><span class='line'>udpv6_init();
</span><span class='line'>udplitev6_init();
</span><span class='line'>tcpv6_init();
</span><span class='line'>
</span><span class='line'>//最后注册ipv6协议，注册协议处理函数
</span><span class='line'>ipv6_packet_init();
</span><span class='line'>err = 0;
</span><span class='line'>out:
</span><span class='line'>return err;
</span><span class='line'>...... //下面就是错误处理的过程
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>下面我们主要看ipv6协议部分流程，其他部分在各自相关文章中介绍。
</span><span class='line'>
</span><span class='line'>ipv6扩展头，路由包头注册
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void __init ipv6_rthdr_init(void)
</span><span class='line'>{
</span><span class='line'>if (inet6_add_protocol(&amp;rthdr_protocol, IPPROTO_ROUTING) &lt; 0)
</span><span class='line'>    printk(KERN_ERR "ipv6_rthdr_init: Could not register protocol\n");
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>ipv6扩展头，分片包头注册
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void __init ipv6_frag_init(void)
</span><span class='line'>{
</span><span class='line'>if (inet6_add_protocol(&amp;frag_protocol, IPPROTO_FRAGMENT) &lt; 0)
</span><span class='line'>    printk(KERN_ERR "ipv6_frag_init: Could not register protocol\n");
</span><span class='line'>
</span><span class='line'>ip6_frags.ctl = &amp;ip6_frags_ctl;
</span><span class='line'>ip6_frags.hashfn = ip6_hashfn;
</span><span class='line'>ip6_frags.constructor = ip6_frag_init;
</span><span class='line'>ip6_frags.destructor = NULL;
</span><span class='line'>ip6_frags.skb_free = NULL;
</span><span class='line'>ip6_frags.qsize = sizeof(struct frag_queue);
</span><span class='line'>ip6_frags.match = ip6_frag_match;
</span><span class='line'>ip6_frags.frag_expire = ip6_frag_expire;
</span><span class='line'>inet_frags_init(&amp;ip6_frags);
</span><span class='line'>}
</span><span class='line'>void __init ipv6_nodata_init(void)
</span><span class='line'>{
</span><span class='line'>if (inet6_add_protocol(&amp;nodata_protocol, IPPROTO_NONE) &lt; 0)
</span><span class='line'>    printk(KERN_ERR "ipv6_nodata_init: Could not register protocol\n");
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>ipv6扩展头，目的选项包头注册
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void __init ipv6_destopt_init(void)
</span><span class='line'>{
</span><span class='line'>if (inet6_add_protocol(&amp;destopt_protocol, IPPROTO_DSTOPTS) &lt; 0)
</span><span class='line'>    printk(KERN_ERR "ipv6_destopt_init: Could not register protocol\n");
</span><span class='line'>}
</span><span class='line'>注册ipv6协议处理函数
</span><span class='line'>void __init ipv6_packet_init(void)
</span><span class='line'>{
</span><span class='line'>dev_add_pack(&amp;ipv6_packet_type);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>当netif_receive_skb函数向上层递交skb时会根据协议类型调用相关的协议处理函数，那么就会调用到 ipv6_rcv函数了。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static struct packet_type ipv6_packet_type = {
</span><span class='line'>.type = __constant_htons(ETH_P_IPV6),
</span><span class='line'>.func = ipv6_rcv,
</span><span class='line'>.gso_send_check = ipv6_gso_send_check,
</span><span class='line'>.gso_segment = ipv6_gso_segment,
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>ipv6协议处理函数
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
</span><span class='line'>{
</span><span class='line'>struct ipv6hdr *hdr;
</span><span class='line'>u32             pkt_len;
</span><span class='line'>struct inet6_dev *idev;
</span><span class='line'>
</span><span class='line'>if (dev-&gt;nd_net != &amp;init_net) {
</span><span class='line'>    kfree_skb(skb);
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>//mac地址是其他主机的包
</span><span class='line'>if (skb-&gt;pkt_type == PACKET_OTHERHOST) {
</span><span class='line'>    kfree_skb(skb);
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>rcu_read_lock();
</span><span class='line'>//获取ipv6相关的配置结构
</span><span class='line'>idev = __in6_dev_get(skb-&gt;dev);
</span><span class='line'>
</span><span class='line'>IP6_INC_STATS_BH(idev, IPSTATS_MIB_INRECEIVES);
</span><span class='line'>//是否共享，如果是，新clone一个
</span><span class='line'>if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL) {
</span><span class='line'>    IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDISCARDS);
</span><span class='line'>    rcu_read_unlock();
</span><span class='line'>    goto out;
</span><span class='line'>}
</span><span class='line'>//清空保存扩展头解析结果的数据结构
</span><span class='line'>memset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));
</span><span class='line'>
</span><span class='line'>//保存接收这个数据包的设备索引
</span><span class='line'>IP6CB(skb)-&gt;iif = skb-&gt;dst ? ip6_dst_idev(skb-&gt;dst)-&gt;dev-&gt;ifindex : dev-&gt;ifindex;
</span><span class='line'>
</span><span class='line'>//有足够的头长度，ipv6是40字节
</span><span class='line'>if (unlikely(!pskb_may_pull(skb, sizeof(*hdr))))
</span><span class='line'>    goto err;
</span><span class='line'>
</span><span class='line'>hdr = ipv6_hdr(skb); //获取头
</span><span class='line'>
</span><span class='line'>if (hdr-&gt;version != 6) //验证版本
</span><span class='line'>    goto err;
</span><span class='line'>
</span><span class='line'>//传输头（扩展头）在网络头后面
</span><span class='line'>skb-&gt;transport_header = skb-&gt;network_header + sizeof(*hdr);
</span><span class='line'>//保存下一个扩展头协议在ipv6头结构中的偏移
</span><span class='line'>IP6CB(skb)-&gt;nhoff = offsetof(struct ipv6hdr, nexthdr);
</span><span class='line'>pkt_len = ntohs(hdr-&gt;payload_len); //ipv6负载数据长度
</span><span class='line'>
</span><span class='line'>/* pkt_len may be zero if Jumbo payload option is present */
</span><span class='line'>if (pkt_len || hdr-&gt;nexthdr != NEXTHDR_HOP) { //没有使用扩展头逐个跳段选项
</span><span class='line'>    if (pkt_len + sizeof(struct ipv6hdr) &gt; skb-&gt;len) { //数据长度不对
</span><span class='line'>        IP6_INC_STATS_BH(idev, IPSTATS_MIB_INTRUNCATEDPKTS);
</span><span class='line'>        goto drop;
</span><span class='line'>    }
</span><span class='line'>    //如果skb-&gt;len &gt; (pkt_len + sizeof(struct ipv6hdr))试着缩小skb-&gt;len的长度
</span><span class='line'>    //相对ipv4来说简单多了，自己看吧
</span><span class='line'>    if (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr))) {
</span><span class='line'>        IP6_INC_STATS_BH(idev, IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>        goto drop;
</span><span class='line'>    }
</span><span class='line'>    hdr = ipv6_hdr(skb); //重新获取ip头
</span><span class='line'>}
</span><span class='line'>if (hdr-&gt;nexthdr == NEXTHDR_HOP) { //使用了扩展头逐个跳段选项
</span><span class='line'>    if (ipv6_parse_hopopts(skb) &lt; 0) {//处理这个选项
</span><span class='line'>        IP6_INC_STATS_BH(idev, IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>        rcu_read_unlock();
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>rcu_read_unlock();
</span><span class='line'>//进入ipv6的netfilter然后调用ip6_rcv_finish
</span><span class='line'>return NF_HOOK(PF_INET6,NF_IP6_PRE_ROUTING, skb, dev, NULL, ip6_rcv_finish);
</span><span class='line'>err:
</span><span class='line'>IP6_INC_STATS_BH(idev, IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>drop:
</span><span class='line'>rcu_read_unlock();
</span><span class='line'>kfree_skb(skb);
</span><span class='line'>out:
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>解析扩展头逐个跳段中的巨量负载选项
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int ipv6_parse_hopopts(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>struct inet6_skb_parm *opt = IP6CB(skb); //获取扩展头结果结构
</span><span class='line'>/* skb_network_header(skb) is equal to skb-&gt;data, and skb_network_header_len(skb) is always equal to
</span><span class='line'> * sizeof(struct ipv6hdr) by definition of hop-by-hop options.
</span><span class='line'> */
</span><span class='line'>//验证数据有足够的长度
</span><span class='line'>if (!pskb_may_pull(skb, sizeof(struct ipv6hdr) + 8) || !pskb_may_pull(skb, (sizeof(struct ipv6hdr) +
</span><span class='line'>                //下面的意思是取得扩展首部中的长度
</span><span class='line'>                ((skb_transport_header(skb)[1] + 1) &lt;&lt; 3)))) {
</span><span class='line'>    kfree_skb(skb);
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>opt-&gt;hop = sizeof(struct ipv6hdr); //40字节
</span><span class='line'>if (ip6_parse_tlv(tlvprochopopt_lst, skb)) { //实际的解析工作
</span><span class='line'>    //把传输头移动到扩展首部之后
</span><span class='line'>    skb-&gt;transport_header += (skb_transport_header(skb)[1] + 1) &lt;&lt; 3;
</span><span class='line'>    opt = IP6CB(skb);
</span><span class='line'>    opt-&gt;nhoff = sizeof(struct ipv6hdr); //进行了ipv6扩展头解析，保存下一个扩展头协议字段的偏移
</span><span class='line'>    return 1;
</span><span class='line'>}
</span><span class='line'>return -1;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>解析tlv编码的扩展选项头
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int ip6_parse_tlv(struct tlvtype_proc *procs, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>struct tlvtype_proc *curr;
</span><span class='line'>const unsigned char *nh = skb_network_header(skb); //获取网络头
</span><span class='line'>int off = skb_network_header_len(skb); //获取网络头长度
</span><span class='line'>int len = (skb_transport_header(skb)[1] + 1) &lt;&lt; 3; //首部扩展头长度
</span><span class='line'>
</span><span class='line'>if (skb_transport_offset(skb) + len &gt; skb_headlen(skb)) //长度错误
</span><span class='line'>    goto bad;
</span><span class='line'>off += 2; //跳过下一个首部和首部扩展长度这两个字节
</span><span class='line'>len -= 2;
</span><span class='line'>
</span><span class='line'>while (len &gt; 0) {
</span><span class='line'>    int optlen = nh[off + 1] + 2; //获取选项数据长度 + 2 (2是选项类型和选项数据长度两字节)
</span><span class='line'>    switch (nh[off]) { //选项类型
</span><span class='line'>        case IPV6_TLV_PAD0: //Pad1选项
</span><span class='line'>            optlen = 1;
</span><span class='line'>            break;
</span><span class='line'>        case IPV6_TLV_PADN://PadN选项
</span><span class='line'>            break;
</span><span class='line'>        default: //其他选项
</span><span class='line'>            if (optlen &gt; len)
</span><span class='line'>                goto bad;
</span><span class='line'>
</span><span class='line'>            for (curr = procs; curr-&gt;type &gt;= 0; curr++) {
</span><span class='line'>                if (curr-&gt;type == nh[off]) { //类型匹配，调用参数函数处理，参考下面ipv6选项处理
</span><span class='line'>                    /* type specific length/alignment checks will be performed in the func(). */
</span><span class='line'>                    if (curr-&gt;func(skb, off) == 0)
</span><span class='line'>                        return 0;
</span><span class='line'>                    break;
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>            if (curr-&gt;type &lt; 0) {
</span><span class='line'>                if (ip6_tlvopt_unknown(skb, off) == 0) //处理未知选项
</span><span class='line'>                    return 0;
</span><span class='line'>            }
</span><span class='line'>            break;
</span><span class='line'>    }
</span><span class='line'>    off += optlen; //偏移增加，这样到下一个选项
</span><span class='line'>    len -= optlen; //长度递减
</span><span class='line'>}
</span><span class='line'>if (len == 0)
</span><span class='line'>    return 1; //正确解析完毕
</span><span class='line'>bad:
</span><span class='line'>kfree_skb(skb);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>处理未知的选项
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int ip6_tlvopt_unknown(struct sk_buff *skb, int optoff)
</span><span class='line'>{
</span><span class='line'>//根据选项类型标识符的要求进行处理
</span><span class='line'>switch ((skb_network_header(skb)[optoff] &amp; 0xC0) &gt;&gt; 6) {
</span><span class='line'>    case 0: /* ignore */
</span><span class='line'>        return 1;
</span><span class='line'>    case 1: /* drop packet */
</span><span class='line'>        break;
</span><span class='line'>    case 3: /* Send ICMP if not a multicast address and drop packet */
</span><span class='line'>        /* Actually, it is redundant check. icmp_send will recheck in any case. */
</span><span class='line'>        if (ipv6_addr_is_multicast(&amp;ipv6_hdr(skb)-&gt;daddr)) //目的是多播地址
</span><span class='line'>            break;
</span><span class='line'>    case 2: /* send ICMP PARM PROB regardless and drop packet */
</span><span class='line'>        //给包的源地址发送一个 ICMP "参数存在问题", 编码 2 的报文, 指针指向无法识别的选项类型
</span><span class='line'>        icmpv6_param_prob(skb, ICMPV6_UNK_OPTION, optoff);
</span><span class='line'>        return 0;
</span><span class='line'>}
</span><span class='line'>kfree_skb(skb);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>到这需要解释一下，上面解析ipv6选项只是解析了第一层的扩展头，在后面可能还有其他扩展头会在后面解析。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;inline int ip6_rcv_finish( struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>if (skb-&gt;dst == NULL) //没有路由，进行路由查找
</span><span class='line'>    ip6_route_input(skb); //路由部分将在路由实现文章中介绍
</span><span class='line'>
</span><span class='line'>return dst_input(skb);
</span><span class='line'>}
</span><span class='line'>static inline int dst_input(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>int err;
</span><span class='line'>for (;;) {
</span><span class='line'>    err = skb-&gt;dst-&gt;input(skb); //调用路由的输入函数
</span><span class='line'>    if (likely(err == 0))
</span><span class='line'>        return err;
</span><span class='line'>
</span><span class='line'>    /* Oh, Jamal... Seems, I will not forgive you this mess. :-) */
</span><span class='line'>    if (unlikely(err != NET_XMIT_BYPASS))
</span><span class='line'>        return err;
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>现在我们假设包是到本地的，那么上面的input函数就是
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int ip6_input(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>//进入ipv6 netfilter NF_IP6_LOCAL_IN hook 然后调用 ip6_input_finish
</span><span class='line'>return NF_HOOK(PF_INET6, NF_IP6_LOCAL_IN, skb, skb-&gt;dev, NULL, ip6_input_finish);
</span><span class='line'>}
</span><span class='line'>static int ip6_input_finish(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>struct inet6_protocol *ipprot;
</span><span class='line'>struct sock *raw_sk;
</span><span class='line'>unsigned int nhoff;
</span><span class='line'>int nexthdr;
</span><span class='line'>u8 hash;
</span><span class='line'>struct inet6_dev *idev;
</span><span class='line'>
</span><span class='line'>/* Parse extension headers */
</span><span class='line'>rcu_read_lock();
</span><span class='line'>resubmit:
</span><span class='line'>idev = ip6_dst_idev(skb-&gt;dst);
</span><span class='line'>//将skb-&gt;data指针移动到传输层头
</span><span class='line'>if (!pskb_pull(skb, skb_transport_offset(skb)))
</span><span class='line'>    goto discard;
</span><span class='line'>
</span><span class='line'>nhoff = IP6CB(skb)-&gt;nhoff;
</span><span class='line'>nexthdr = skb_network_header(skb)[nhoff];//下一个扩展头协议
</span><span class='line'>
</span><span class='line'>//处理原始sock
</span><span class='line'>raw_sk = sk_head(&amp;raw_v6_htable[nexthdr &amp; (MAX_INET_PROTOS - 1)]);
</span><span class='line'>if (raw_sk &amp;&amp; !ipv6_raw_deliver(skb, nexthdr))
</span><span class='line'>    raw_sk = NULL;
</span><span class='line'>
</span><span class='line'>//向上层协议栈递交数据，看初始化时注册的一些协议，主要是tcp，udp等，还包括一些ip扩展头的处理
</span><span class='line'>hash = nexthdr &amp; (MAX_INET_PROTOS - 1);
</span><span class='line'>if ((ipprot = rcu_dereference(inet6_protos[hash])) != NULL) {
</span><span class='line'>    int ret;
</span><span class='line'>    if (ipprot-&gt;flags &amp; INET6_PROTO_FINAL) {
</span><span class='line'>        struct ipv6hdr *hdr;
</span><span class='line'>        /* Free reference early: we don't need it any more,                        
</span><span class='line'>           and it may hold ip_conntrack module loaded indefinitely. */
</span><span class='line'>        nf_reset(skb);
</span><span class='line'>
</span><span class='line'>        skb_postpull_rcsum(skb, skb_network_header(skb), skb_network_header_len(skb));
</span><span class='line'>        hdr = ipv6_hdr(skb);
</span><span class='line'>        if (ipv6_addr_is_multicast(&amp;hdr-&gt;daddr) &amp;&amp; !ipv6_chk_mcast_addr(skb-&gt;dev, &amp;hdr-&gt;daddr, &amp;hdr-&gt;saddr)
</span><span class='line'>                &amp;&amp; !ipv6_is_mld(skb, nexthdr))
</span><span class='line'>            goto discard;
</span><span class='line'>    }
</span><span class='line'>    //处理 IPSEC v6 的相关部分
</span><span class='line'>    if (!(ipprot-&gt;flags &amp; INET6_PROTO_NOPOLICY) &amp;&amp; !xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))
</span><span class='line'>        goto discard;
</span><span class='line'>
</span><span class='line'>    ret = ipprot-&gt;handler(skb); //上层协议处理，看下面ipv6扩展头处理
</span><span class='line'>    if (ret &gt; 0)
</span><span class='line'>        goto resubmit; //重新处理
</span><span class='line'>    else if (ret == 0)
</span><span class='line'>        IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDELIVERS);
</span><span class='line'>} else { //没有找到上层处理函数
</span><span class='line'>    if (!raw_sk) {
</span><span class='line'>        if (xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {
</span><span class='line'>            IP6_INC_STATS_BH(idev, IPSTATS_MIB_INUNKNOWNPROTOS);
</span><span class='line'>            icmpv6_send(skb, ICMPV6_PARAMPROB, ICMPV6_UNK_NEXTHDR, nhoff, skb-&gt;dev);
</span><span class='line'>        }
</span><span class='line'>    } else
</span><span class='line'>        IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDELIVERS);
</span><span class='line'>    kfree_skb(skb);
</span><span class='line'>}
</span><span class='line'>rcu_read_unlock();
</span><span class='line'>return 0;
</span><span class='line'>discard:
</span><span class='line'>IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDISCARDS);
</span><span class='line'>rcu_read_unlock();
</span><span class='line'>kfree_skb(skb);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### ipv6选项处理
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static struct tlvtype_proc tlvprochopopt_lst[] = {
</span><span class='line'>{
</span><span class='line'>    .type   = IPV6_TLV_ROUTERALERT,
</span><span class='line'>    .func   = ipv6_hop_ra,
</span><span class='line'>},
</span><span class='line'>{
</span><span class='line'>    .type   = IPV6_TLV_JUMBO,
</span><span class='line'>    .func   = ipv6_hop_jumbo,
</span><span class='line'>},
</span><span class='line'>{ -1, }
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>解析路由警告选项
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int ipv6_hop_ra(struct sk_buff *skb, int optoff)
</span><span class='line'>{
</span><span class='line'>const unsigned char *nh = skb_network_header(skb); //获取网络头
</span><span class='line'>
</span><span class='line'>if (nh[optoff + 1] == 2) { //路由警告选项长度必须是2 ? rfc 要求是 4
</span><span class='line'>    IP6CB(skb)-&gt;ra = optoff; //记录警告类型
</span><span class='line'>    return 1;
</span><span class='line'>}
</span><span class='line'>LIMIT_NETDEBUG(KERN_DEBUG "ipv6_hop_ra: wrong RA length %d\n", nh[optoff + 1]);
</span><span class='line'>kfree_skb(skb);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>解析jumbo frame选项
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int ipv6_hop_jumbo(struct sk_buff *skb, int optoff)
</span><span class='line'>{
</span><span class='line'>const unsigned char *nh = skb_network_header(skb);
</span><span class='line'>u32 pkt_len;
</span><span class='line'>//选项数据长度必须是4，选项类型必须是 0xc2， ＆3 后必须是2
</span><span class='line'>if (nh[optoff + 1] != 4 || (optoff &amp; 3) != 2) {
</span><span class='line'>    LIMIT_NETDEBUG(KERN_DEBUG "ipv6_hop_jumbo: wrong jumbo opt length/alignment %d\n", nh[optoff+1]);
</span><span class='line'>    IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>    goto drop;
</span><span class='line'>}
</span><span class='line'>pkt_len = ntohl(*(__be32 *)(nh + optoff + 2)); //获取整个负载长度
</span><span class='line'>if (pkt_len &lt;= IPV6_MAXPLEN) { //小于65535 是不对地
</span><span class='line'>    IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>    icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff+2);
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>if (ipv6_hdr(skb)-&gt;payload_len) { //原ipv6头中就不应该有负载长度了
</span><span class='line'>    IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>    icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff);
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>if (pkt_len &gt; skb-&gt;len - sizeof(struct ipv6hdr)) { //长度超出了 skb 的实际长度
</span><span class='line'>    IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INTRUNCATEDPKTS);
</span><span class='line'>    goto drop;
</span><span class='line'>}
</span><span class='line'>//如果必要试图缩减 skb 的长度
</span><span class='line'>if (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))
</span><span class='line'>    goto drop;
</span><span class='line'>
</span><span class='line'>return 1;
</span><span class='line'>drop:
</span><span class='line'>kfree_skb(skb);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>目的选项处理
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static struct tlvtype_proc tlvprocdestopt_lst[] = {
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>{
</span><span class='line'>    .type   = IPV6_TLV_HAO,
</span><span class='line'>    .func   = ipv6_dest_hao,
</span><span class='line'>},
</span><span class='line'>#endif
</span><span class='line'>{-1,    NULL}
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>解析目的选项
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int ipv6_dest_hao(struct sk_buff *skb, int optoff)
</span><span class='line'>{
</span><span class='line'>struct ipv6_destopt_hao *hao;
</span><span class='line'>struct inet6_skb_parm *opt = IP6CB(skb);
</span><span class='line'>struct ipv6hdr *ipv6h = ipv6_hdr(skb);
</span><span class='line'>struct in6_addr tmp_addr;
</span><span class='line'>int ret;
</span><span class='line'>
</span><span class='line'>if (opt-&gt;dsthao) { //已经处理
</span><span class='line'>    LIMIT_NETDEBUG(KERN_DEBUG "hao duplicated\n");
</span><span class='line'>    goto discard;
</span><span class='line'>}
</span><span class='line'>opt-&gt;dsthao = opt-&gt;dst1;
</span><span class='line'>opt-&gt;dst1 = 0;
</span><span class='line'>
</span><span class='line'>//获取网络头后面的选项部分
</span><span class='line'>hao = (struct ipv6_destopt_hao *)(skb_network_header(skb) + optoff);
</span><span class='line'>
</span><span class='line'>if (hao-&gt;length != 16) { //长度要求
</span><span class='line'>    LIMIT_NETDEBUG(KERN_DEBUG "hao invalid option length = %d\n", hao-&gt;length);
</span><span class='line'>    goto discard;
</span><span class='line'>}
</span><span class='line'>if (!(ipv6_addr_type(&amp;hao-&gt;addr) &amp; IPV6_ADDR_UNICAST)) { //地址不是单播
</span><span class='line'>    LIMIT_NETDEBUG(KERN_DEBUG "hao is not an unicast addr: " NIP6_FMT "\n", NIP6(hao-&gt;addr));
</span><span class='line'>    goto discard;
</span><span class='line'>}
</span><span class='line'>//IPSEC相关
</span><span class='line'>ret = xfrm6_input_addr(skb, (xfrm_address_t *)&amp;ipv6h-&gt;daddr, (xfrm_address_t *)&amp;hao-&gt;addr, IPPROTO_DSTOPTS);
</span><span class='line'>if (unlikely(ret &lt; 0))
</span><span class='line'>    goto discard;
</span><span class='line'>
</span><span class='line'>if (skb_cloned(skb)) { //如果包是cloned
</span><span class='line'>    //分配新的内存数据
</span><span class='line'>    if (pskb_expand_head(skb, 0, 0, GFP_ATOMIC))
</span><span class='line'>        goto discard;
</span><span class='line'>
</span><span class='line'>    //重新指向各头
</span><span class='line'>    hao = (struct ipv6_destopt_hao *)(skb_network_header(skb) + optoff);
</span><span class='line'>    ipv6h = ipv6_hdr(skb);
</span><span class='line'>}
</span><span class='line'>if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)
</span><span class='line'>    skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>
</span><span class='line'>//把ip头中的源地址与选项中的地址交换
</span><span class='line'>ipv6_addr_copy(&amp;tmp_addr, &amp;ipv6h-&gt;saddr);
</span><span class='line'>ipv6_addr_copy(&amp;ipv6h-&gt;saddr, &amp;hao-&gt;addr);
</span><span class='line'>ipv6_addr_copy(&amp;hao-&gt;addr, &amp;tmp_addr);
</span><span class='line'>
</span><span class='line'>if (skb-&gt;tstamp.tv64 == 0)
</span><span class='line'>    __net_timestamp(skb); //记录时间截
</span><span class='line'>
</span><span class='line'>return 1;
</span><span class='line'>discard:
</span><span class='line'>kfree_skb(skb);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### ipv6扩展头处理
</span><span class='line'>
</span><span class='line'>我们只介绍根ipv6扩展头相关的实现，像其他的扩展头(tcp, udp)等虽然也是叫扩展头但实际是传输层的内容，将在其他文章中介绍。
</span><span class='line'>
</span><span class='line'>路由扩展首部
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct ipv6_rt_hdr {
</span><span class='line'>__u8            nexthdr;
</span><span class='line'>__u8            hdrlen;
</span><span class='line'>__u8            type;
</span><span class='line'>__u8            segments_left;
</span><span class='line'>
</span><span class='line'>/* type specific data variable length field */
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>路由扩展首部处理结构
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static struct inet6_protocol rthdr_protocol = {
</span><span class='line'>.handler        =       ipv6_rthdr_rcv,
</span><span class='line'>.flags          =       INET6_PROTO_NOPOLICY | INET6_PROTO_GSO_EXTHDR,
</span><span class='line'>};
</span><span class='line'>static int ipv6_rthdr_rcv(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>struct inet6_skb_parm *opt = IP6CB(skb);
</span><span class='line'>struct in6_addr *addr = NULL;
</span><span class='line'>struct in6_addr daddr;
</span><span class='line'>struct inet6_dev *idev;
</span><span class='line'>int n, i;
</span><span class='line'>struct ipv6_rt_hdr *hdr;
</span><span class='line'>struct rt0_hdr *rthdr;
</span><span class='line'>int accept_source_route = ipv6_devconf.accept_source_route;
</span><span class='line'>
</span><span class='line'>idev = in6_dev_get(skb-&gt;dev); //包进入设备
</span><span class='line'>if (idev) {
</span><span class='line'>    if (accept_source_route &gt; idev-&gt;cnf.accept_source_route) //默认数量大于了手动调节(proc中）的数量
</span><span class='line'>        accept_source_route = idev-&gt;cnf.accept_source_route;
</span><span class='line'>    in6_dev_put(idev);
</span><span class='line'>}
</span><span class='line'>//skb长度和内存空间正确
</span><span class='line'>if (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) || !pskb_may_pull(skb, (skb_transport_offset(skb) +
</span><span class='line'>                ((skb_transport_header(skb)[1] + 1) &lt;&lt; 3)))) {
</span><span class='line'>    IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>    kfree_skb(skb);
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>hdr = (struct ipv6_rt_hdr *)skb_transport_header(skb); //路由扩展头
</span><span class='line'>//是到多播地址或硬件地址不是到本机的地址
</span><span class='line'>if (ipv6_addr_is_multicast(&amp;ipv6_hdr(skb)-&gt;daddr) || skb-&gt;pkt_type != PACKET_HOST) {
</span><span class='line'>    IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
</span><span class='line'>    kfree_skb(skb);
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>looped_back:
</span><span class='line'>if (hdr-&gt;segments_left == 0) { //根据rfc要求 分段剩余为0
</span><span class='line'>    switch (hdr-&gt;type) {
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>        case IPV6_SRCRT_TYPE_2:
</span><span class='line'>            /* Silently discard type 2 header unless it was processed by own */
</span><span class='line'>            if (!addr) {
</span><span class='line'>                IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
</span><span class='line'>                kfree_skb(skb);
</span><span class='line'>                return -1;
</span><span class='line'>            }
</span><span class='line'>            break;
</span><span class='line'>#endif
</span><span class='line'>        default:
</span><span class='line'>            break;
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>    opt-&gt;lastopt = opt-&gt;srcrt = skb_network_header_len(skb);
</span><span class='line'>    skb-&gt;transport_header += (hdr-&gt;hdrlen + 1) &lt;&lt; 3; //下一个传输头的位置
</span><span class='line'>    opt-&gt;dst0 = opt-&gt;dst1;
</span><span class='line'>    opt-&gt;dst1 = 0;
</span><span class='line'>    opt-&gt;nhoff = (&amp;hdr-&gt;nexthdr) - skb_network_header(skb); //记录下一个头数据相对网络头的偏移量
</span><span class='line'>    return 1;
</span><span class='line'>}
</span><span class='line'>switch (hdr-&gt;type) {
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>    case IPV6_SRCRT_TYPE_2:
</span><span class='line'>        if (accept_source_route &lt; 0)
</span><span class='line'>            goto unknown_rh;
</span><span class='line'>        /* Silently discard invalid RTH type 2 */
</span><span class='line'>        if (hdr-&gt;hdrlen != 2 || hdr-&gt;segments_left != 1) {
</span><span class='line'>            IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>            kfree_skb(skb);
</span><span class='line'>            return -1;
</span><span class='line'>        }
</span><span class='line'>        break;
</span><span class='line'>#endif
</span><span class='line'>    default:
</span><span class='line'>        goto unknown_rh;
</span><span class='line'>}
</span><span class='line'>/* This is the routing header forwarding algorithm from RFC 2460, page 16. */
</span><span class='line'>
</span><span class='line'>n = hdr-&gt;hdrlen &gt;&gt; 1; //计算路由首部中的地址数量
</span><span class='line'>if (hdr-&gt;segments_left &gt; n) {
</span><span class='line'>    IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>    icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, ((&amp;hdr-&gt;segments_left) - skb_network_header(skb)));
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>/* We are about to mangle packet header. Be careful!                                       
</span><span class='line'>   Do not damage packets queued somewhere.  */
</span><span class='line'>if (skb_cloned(skb)) {
</span><span class='line'>    /* the copy is a forwarded packet */
</span><span class='line'>    if (pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {
</span><span class='line'>        IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_OUTDISCARDS);
</span><span class='line'>        kfree_skb(skb);
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>    hdr = (struct ipv6_rt_hdr *)skb_transport_header(skb);
</span><span class='line'>}
</span><span class='line'>if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)
</span><span class='line'>    skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>
</span><span class='line'>i = n - --hdr-&gt;segments_left; //计算地址向量(地址列表)中要"访问"的下一个地址
</span><span class='line'>
</span><span class='line'>rthdr = (struct rt0_hdr *) hdr;
</span><span class='line'>addr = rthdr-&gt;addr; //指向地址列表首部
</span><span class='line'>addr += i - 1; //移动到下一个地址
</span><span class='line'>
</span><span class='line'>switch (hdr-&gt;type) {
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>    case IPV6_SRCRT_TYPE_2:
</span><span class='line'>        if (xfrm6_input_addr(skb, (xfrm_address_t *)addr, (xfrm_address_t *)&amp;ipv6_hdr(skb)-&gt;saddr, IPPROTO_ROUTING) &lt; 0) {
</span><span class='line'>            IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
</span><span class='line'>            kfree_skb(skb);
</span><span class='line'>            return -1;
</span><span class='line'>        }
</span><span class='line'>        if (!ipv6_chk_home_addr(addr)) {
</span><span class='line'>            IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
</span><span class='line'>            kfree_skb(skb);
</span><span class='line'>            return -1;
</span><span class='line'>        }
</span><span class='line'>        break;
</span><span class='line'>#endif
</span><span class='line'>    default:
</span><span class='line'>        break;
</span><span class='line'>}
</span><span class='line'>if (ipv6_addr_is_multicast(addr)) { //这个地址是多播地址
</span><span class='line'>    IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
</span><span class='line'>    kfree_skb(skb);
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>//交换 IPv6 目的地址和这个地址
</span><span class='line'>ipv6_addr_copy(&amp;daddr, addr);
</span><span class='line'>ipv6_addr_copy(addr, &amp;ipv6_hdr(skb)-&gt;daddr);
</span><span class='line'>ipv6_addr_copy(&amp;ipv6_hdr(skb)-&gt;daddr, &amp;daddr);
</span><span class='line'>dst_release(xchg(&amp;skb-&gt;dst, NULL));
</span><span class='line'>
</span><span class='line'>ip6_route_input(skb); //路由查找处理，将在其他文章中介绍
</span><span class='line'>
</span><span class='line'>if (skb-&gt;dst-&gt;error) {
</span><span class='line'>    skb_push(skb, skb-&gt;data - skb_network_header(skb));
</span><span class='line'>    dst_input(skb);
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>if (skb-&gt;dst-&gt;dev-&gt;flags &amp; IFF_LOOPBACK) { //路由查找后要发送到的目的设备是回环
</span><span class='line'>    if (ipv6_hdr(skb)-&gt;hop_limit &lt;= 1) { //跳数限制小于1
</span><span class='line'>        IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>        //给源地址发送一个 ICMP "超时 – 传输超过跳数限制" 的报文, 并且抛弃此包
</span><span class='line'>        icmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0, skb-&gt;dev);
</span><span class='line'>        kfree_skb(skb);
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>    ipv6_hdr(skb)-&gt;hop_limit--;
</span><span class='line'>    goto looped_back;
</span><span class='line'>}
</span><span class='line'>//将data之中移动到网络头
</span><span class='line'>skb_push(skb, skb-&gt;data - skb_network_header(skb));
</span><span class='line'>dst_input(skb); //这时包应该被转发了
</span><span class='line'>return -1;
</span><span class='line'>unknown_rh:
</span><span class='line'>IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, (&amp;hdr-&gt;type) - skb_network_header(skb));
</span><span class='line'>return -1;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>ipv6分配包扩展首部处理
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static struct inet6_protocol frag_protocol =
</span><span class='line'>{
</span><span class='line'>.handler        =       ipv6_frag_rcv,
</span><span class='line'>.flags          =       INET6_PROTO_NOPOLICY,
</span><span class='line'>};
</span><span class='line'>static int ipv6_frag_rcv(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>struct frag_hdr *fhdr;
</span><span class='line'>struct frag_queue *fq;
</span><span class='line'>struct ipv6hdr *hdr = ipv6_hdr(skb);
</span><span class='line'>
</span><span class='line'>IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMREQDS);
</span><span class='line'>
</span><span class='line'>/* Jumbo payload inhibits frag. header */
</span><span class='line'>if (hdr-&gt;payload_len == 0) { //是Jumbo payload，不是分片包
</span><span class='line'>    IP6_INC_STATS(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>    icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, skb_network_header_len(skb));
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>//有碎片头空间
</span><span class='line'>if (!pskb_may_pull(skb, (skb_transport_offset(skb) + sizeof(struct frag_hdr)))) {
</span><span class='line'>    IP6_INC_STATS(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>    icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, skb_network_header_len(skb));
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>hdr = ipv6_hdr(skb);
</span><span class='line'>fhdr = (struct frag_hdr *)skb_transport_header(skb); //分片头
</span><span class='line'>
</span><span class='line'>if (!(fhdr-&gt;frag_off &amp; htons(0xFFF9))) { //没有分片偏移，不是分片包
</span><span class='line'>    /* It is not a fragmented frame */
</span><span class='line'>    skb-&gt;transport_header += sizeof(struct frag_hdr); //传输头向后移动到下一个头
</span><span class='line'>    IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMOKS);
</span><span class='line'>    IP6CB(skb)-&gt;nhoff = (u8 *)fhdr - skb_network_header(skb);
</span><span class='line'>    return 1;
</span><span class='line'>}
</span><span class='line'>if (atomic_read(&amp;ip6_frags.mem) &gt; ip6_frags_ctl.high_thresh) //内存使用超过限制
</span><span class='line'>    ip6_evictor(ip6_dst_idev(skb-&gt;dst));
</span><span class='line'>
</span><span class='line'>//查找或创建分片队列头
</span><span class='line'>if ((fq = fq_find(fhdr-&gt;identification, &amp;hdr-&gt;saddr, &amp;hdr-&gt;daddr, ip6_dst_idev(skb-&gt;dst))) != NULL) {
</span><span class='line'>    int ret;
</span><span class='line'>    spin_lock(&amp;fq-&gt;q.lock);
</span><span class='line'>    ret = ip6_frag_queue(fq, skb, fhdr, IP6CB(skb)-&gt;nhoff); //入队重组
</span><span class='line'>    spin_unlock(&amp;fq-&gt;q.lock);
</span><span class='line'>    fq_put(fq);
</span><span class='line'>    return ret;
</span><span class='line'>}
</span><span class='line'>IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMFAILS);
</span><span class='line'>kfree_skb(skb);
</span><span class='line'>return -1;
</span><span class='line'>}
</span><span class='line'>static __inline__ struct frag_queue * fq_find(__be32 id, struct in6_addr *src, struct in6_addr *dst, struct inet6_dev *idev)
</span><span class='line'>{
</span><span class='line'>struct inet_frag_queue *q;
</span><span class='line'>struct ip6_create_arg arg;
</span><span class='line'>unsigned int hash;
</span><span class='line'>
</span><span class='line'>arg.id = id;
</span><span class='line'>arg.src = src;
</span><span class='line'>arg.dst = dst;
</span><span class='line'>hash = ip6qhashfn(id, src, dst); //id，源，目的进行 hash
</span><span class='line'>
</span><span class='line'>q = inet_frag_find(&amp;ip6_frags, &amp;arg, hash); //查找或创建
</span><span class='line'>if (q == NULL)
</span><span class='line'>    goto oom;
</span><span class='line'>
</span><span class='line'>return container_of(q, struct frag_queue, q); //成功返回
</span><span class='line'>oom: //没内存了
</span><span class='line'>IP6_INC_STATS_BH(idev, IPSTATS_MIB_REASMFAILS);
</span><span class='line'>return NULL;
</span><span class='line'>}
</span><span class='line'>struct inet_frag_queue *inet_frag_find(struct inet_frags *f, void *key, unsigned int hash)
</span><span class='line'>{
</span><span class='line'>struct inet_frag_queue *q;
</span><span class='line'>struct hlist_node *n;
</span><span class='line'>
</span><span class='line'>read_lock(&amp;f-&gt;lock);
</span><span class='line'>hlist_for_each_entry(q, n, &amp;f-&gt;hash[hash], list) { //在hash桶中查找
</span><span class='line'>
</span><span class='line'>    if (f-&gt;match(q, key)) { //调用匹配函数进行匹配，具体函数很简单参考初始化时的ipv6_frag_init函数
</span><span class='line'>        atomic_inc(&amp;q-&gt;refcnt);
</span><span class='line'>        read_unlock(&amp;f-&gt;lock);
</span><span class='line'>        return q;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>//没有找到就创建一个
</span><span class='line'>return inet_frag_create(f, key, hash);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>创建分片队列
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static struct inet_frag_queue *inet_frag_create(struct inet_frags *f, void *arg, unsigned int hash)
</span><span class='line'>{
</span><span class='line'>struct inet_frag_queue *q;
</span><span class='line'>
</span><span class='line'>q = inet_frag_alloc(f, arg); //分配一个
</span><span class='line'>if (q == NULL)
</span><span class='line'>    return NULL;
</span><span class='line'>//添加到 hash 表
</span><span class='line'>return inet_frag_intern(q, f, hash, arg);
</span><span class='line'>}
</span><span class='line'>static struct inet_frag_queue *inet_frag_alloc(struct inet_frags *f, void *arg)
</span><span class='line'>{
</span><span class='line'>struct inet_frag_queue *q;
</span><span class='line'>
</span><span class='line'>q = kzalloc(f-&gt;qsize, GFP_ATOMIC); //分配一个队列头，大小是 sizeof(struct frag_queue)
</span><span class='line'>if (q == NULL)
</span><span class='line'>    return NULL;
</span><span class='line'>
</span><span class='line'>f-&gt;constructor(q, arg); //拷贝地址和 id 到队列头结构中
</span><span class='line'>atomic_add(f-&gt;qsize, &amp;f-&gt;mem);
</span><span class='line'>setup_timer(&amp;q-&gt;timer, f-&gt;frag_expire, (unsigned long)q);
</span><span class='line'>spin_lock_init(&amp;q-&gt;lock);
</span><span class='line'>atomic_set(&amp;q-&gt;refcnt, 1);
</span><span class='line'>return q;
</span><span class='line'>}
</span><span class='line'>static struct inet_frag_queue *inet_frag_intern(struct inet_frag_queue *qp_in, struct inet_frags *f, unsigned int hash, void *arg)
</span><span class='line'>{
</span><span class='line'>struct inet_frag_queue *qp;
</span><span class='line'>#ifdef CONFIG_SMP
</span><span class='line'>struct hlist_node *n;
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>write_lock(&amp;f-&gt;lock);
</span><span class='line'>#ifdef CONFIG_SMP
</span><span class='line'>//其他cpu可能已经创建了一个，所以要再次检查
</span><span class='line'>hlist_for_each_entry(qp, n, &amp;f-&gt;hash[hash], list) {
</span><span class='line'>    if (f-&gt;match(qp, arg)) { //已经创建
</span><span class='line'>        atomic_inc(&amp;qp-&gt;refcnt);
</span><span class='line'>        write_unlock(&amp;f-&gt;lock);
</span><span class='line'>        qp_in-&gt;last_in |= COMPLETE;
</span><span class='line'>        inet_frag_put(qp_in, f); //释放新分配的
</span><span class='line'>        return qp;
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>#endif
</span><span class='line'>qp = qp_in;
</span><span class='line'>if (!mod_timer(&amp;qp-&gt;timer, jiffies + f-&gt;ctl-&gt;timeout)) //启动定时器
</span><span class='line'>    atomic_inc(&amp;qp-&gt;refcnt);
</span><span class='line'>
</span><span class='line'>//增加引用计数，然后添加到hash表
</span><span class='line'>atomic_inc(&amp;qp-&gt;refcnt);
</span><span class='line'>hlist_add_head(&amp;qp-&gt;list, &amp;f-&gt;hash[hash]);
</span><span class='line'>list_add_tail(&amp;qp-&gt;lru_list, &amp;f-&gt;lru_list);
</span><span class='line'>f-&gt;nqueues++;
</span><span class='line'>write_unlock(&amp;f-&gt;lock);
</span><span class='line'>return qp;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>入队重组
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb, struct frag_hdr *fhdr, int nhoff)
</span><span class='line'>{
</span><span class='line'>struct sk_buff *prev, *next;
</span><span class='line'>struct net_device *dev;
</span><span class='line'>int offset, end;
</span><span class='line'>
</span><span class='line'>if (fq-&gt;q.last_in &amp; COMPLETE) //重组已经完成
</span><span class='line'>    goto err;
</span><span class='line'>
</span><span class='line'>//分片开始位置
</span><span class='line'>offset = ntohs(fhdr-&gt;frag_off) &amp; ~0x7;//偏移必须8字节对齐
</span><span class='line'>//分片在整个包中的结束位置 包负载长度 - 分片头长度
</span><span class='line'>end = offset + (ntohs(ipv6_hdr(skb)-&gt;payload_len) -  ((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));
</span><span class='line'>
</span><span class='line'>//结束位置 &gt; 65535
</span><span class='line'>if ((unsigned int)end &gt; IPV6_MAXPLEN) {
</span><span class='line'>    IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>    icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, ((u8 *)&amp;fhdr-&gt;frag_off - skb_network_header(skb)));
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>//校验和已经完成
</span><span class='line'>if (skb-&gt;ip_summed == CHECKSUM_COMPLETE) {
</span><span class='line'>    const unsigned char *nh = skb_network_header(skb);
</span><span class='line'>    //减去分片包头的校验和
</span><span class='line'>    skb-&gt;csum = csum_sub(skb-&gt;csum, csum_partial(nh, (u8 *)(fhdr + 1) - nh, 0));
</span><span class='line'>}
</span><span class='line'>//最后一个碎片包
</span><span class='line'>if (!(fhdr-&gt;frag_off &amp; htons(IP6_MF))) {
</span><span class='line'>    /* If we already have some bits beyond end or have different end, the segment is corrupted. */
</span><span class='line'>    if (end &lt; fq-&gt;q.len || ((fq-&gt;q.last_in &amp; LAST_IN) &amp;&amp; end != fq-&gt;q.len)) //分片出现错误
</span><span class='line'>        goto err;
</span><span class='line'>
</span><span class='line'>    fq-&gt;q.last_in |= LAST_IN; //标识最后一个分片
</span><span class='line'>    fq-&gt;q.len = end; //记录包总长度
</span><span class='line'>} else {
</span><span class='line'>    /* Check if the fragment is rounded to 8 bytes. Required by the RFC. */
</span><span class='line'>    if (end &amp; 0x7) { //碎片结尾也需要8字节对齐
</span><span class='line'>        /* RFC2460 says always send parameter problem in this case. -DaveM */
</span><span class='line'>        IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), PSTATS_MIB_INHDRERRORS);
</span><span class='line'>        icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, offsetof(struct ipv6hdr, payload_len));
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>    if (end &gt; fq-&gt;q.len) {
</span><span class='line'>        /* Some bits beyond end -&gt; corruption. */
</span><span class='line'>        if (fq-&gt;q.last_in &amp; LAST_IN)
</span><span class='line'>            goto err;
</span><span class='line'>        fq-&gt;q.len = end; //记录已经得到的碎片的最大长度
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>if (end == offset) //开始 = 结束
</span><span class='line'>    goto err;
</span><span class='line'>
</span><span class='line'>//skb-&gt;data 指向碎片首部头后数据部分
</span><span class='line'>if (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb-&gt;data))
</span><span class='line'>    goto err;
</span><span class='line'>//如果需要缩短skb的内存长度
</span><span class='line'>if (pskb_trim_rcsum(skb, end - offset))
</span><span class='line'>    goto err;
</span><span class='line'>
</span><span class='line'>//找出碎片所在位置
</span><span class='line'>prev = NULL;
</span><span class='line'>for(next = fq-&gt;q.fragments; next != NULL; next = next-&gt;next) {
</span><span class='line'>    if (FRAG6_CB(next)-&gt;offset &gt;= offset)
</span><span class='line'>        break;  /* bingo! */
</span><span class='line'>    prev = next;
</span><span class='line'>}
</span><span class='line'>if (prev) { //有前一个碎片
</span><span class='line'>    //前一个碎片 (开始 + 长度) - 这个碎片的开始. 计算出重叠部分
</span><span class='line'>    int i = (FRAG6_CB(prev)-&gt;offset + prev-&gt;len) - offset;
</span><span class='line'>    if (i &gt; 0) { //有重叠
</span><span class='line'>        offset += i; //调整这个碎片的开始位置
</span><span class='line'>        if (end &lt;= offset) //调整后出错
</span><span class='line'>            goto err;
</span><span class='line'>        if (!pskb_pull(skb, i))//skb-&gt;data += i;
</span><span class='line'>            goto err;
</span><span class='line'>        if (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)
</span><span class='line'>            skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>//有下一个碎片，且开始位置 &lt; 这个碎片的结束位置
</span><span class='line'>while (next &amp;&amp; FRAG6_CB(next)-&gt;offset &lt; end) {
</span><span class='line'>    //这个碎片的结束位置  - 下一个碎片的开始位置，计算重叠
</span><span class='line'>    int i = end - FRAG6_CB(next)-&gt;offset; /* overlap is 'i' bytes */
</span><span class='line'>    if (i &lt; next-&gt;len) { //重叠长度 &lt; 下一个碎片的长度
</span><span class='line'>        if (!pskb_pull(next, i)) //next-&gt;data += i;
</span><span class='line'>            goto err;
</span><span class='line'>
</span><span class='line'>        FRAG6_CB(next)-&gt;offset += i;    //下一个碎片开始位置调整
</span><span class='line'>        fq-&gt;q.meat -= i; //总长度减少
</span><span class='line'>        if (next-&gt;ip_summed != CHECKSUM_UNNECESSARY)
</span><span class='line'>            next-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>        break;
</span><span class='line'>
</span><span class='line'>    } else { //这个碎片完全复盖了下一个碎片
</span><span class='line'>        struct sk_buff *free_it = next; //释放这个碎片
</span><span class='line'>        next = next-&gt;next;//调整下一个碎片指针
</span><span class='line'>        //调整队列指针
</span><span class='line'>        if (prev)
</span><span class='line'>            prev-&gt;next = next;
</span><span class='line'>        else
</span><span class='line'>            fq-&gt;q.fragments = next;
</span><span class='line'>
</span><span class='line'>        fq-&gt;q.meat -= free_it-&gt;len;
</span><span class='line'>        frag_kfree_skb(free_it, NULL); //释放被复盖的包
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>FRAG6_CB(skb)-&gt;offset = offset; //这个碎片包记录自己的开始位置
</span><span class='line'>
</span><span class='line'>//插入这个碎片到队列
</span><span class='line'>skb-&gt;next = next;
</span><span class='line'>if (prev)
</span><span class='line'>    prev-&gt;next = skb;
</span><span class='line'>else
</span><span class='line'>    fq-&gt;q.fragments = skb;
</span><span class='line'>
</span><span class='line'>dev = skb-&gt;dev;
</span><span class='line'>if (dev) {
</span><span class='line'>    fq-&gt;iif = dev-&gt;ifindex;
</span><span class='line'>    skb-&gt;dev = NULL;
</span><span class='line'>}
</span><span class='line'>fq-&gt;q.stamp = skb-&gt;tstamp;
</span><span class='line'>fq-&gt;q.meat += skb-&gt;len; //累加总长度
</span><span class='line'>atomic_add(skb-&gt;truesize, &amp;ip6_frags.mem);
</span><span class='line'>
</span><span class='line'>if (offset == 0) { //偏移为0
</span><span class='line'>    fq-&gt;nhoffset = nhoff;
</span><span class='line'>    fq-&gt;q.last_in |= FIRST_IN; //标识开始碎片
</span><span class='line'>}
</span><span class='line'>//碎片已经聚齐，记录长度 = 包中标识的长度
</span><span class='line'>if (fq-&gt;q.last_in == (FIRST_IN | LAST_IN) &amp;&amp; fq-&gt;q.meat == fq-&gt;q.len)
</span><span class='line'>    return ip6_frag_reasm(fq, prev, dev); //重组
</span><span class='line'>//没有聚齐，移动队列连表到lru连表尾部
</span><span class='line'>write_lock(&amp;ip6_frags.lock);
</span><span class='line'>list_move_tail(&amp;fq-&gt;q.lru_list, &amp;ip6_frags.lru_list);
</span><span class='line'>write_unlock(&amp;ip6_frags.lock);
</span><span class='line'>return -1;
</span><span class='line'>err:
</span><span class='line'>IP6_INC_STATS(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMFAILS);
</span><span class='line'>kfree_skb(skb);
</span><span class='line'>return -1;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>重组ip头
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev, struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>struct sk_buff *fp, *head = fq-&gt;q.fragments;
</span><span class='line'>int    payload_len;
</span><span class='line'>unsigned int nhoff;
</span><span class='line'>
</span><span class='line'>fq_kill(fq); //把这个重组队列出队
</span><span class='line'>
</span><span class='line'>/* Make the one we just received the head. */
</span><span class='line'>if (prev) {
</span><span class='line'>    //下面是把head指向的skb复制到fp，然后把fp插入到head指向的位置
</span><span class='line'>    head = prev-&gt;next;
</span><span class='line'>    fp = skb_clone(head, GFP_ATOMIC);
</span><span class='line'>
</span><span class='line'>    if (!fp)
</span><span class='line'>        goto out_oom;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    fp-&gt;next = head-&gt;next;
</span><span class='line'>    prev-&gt;next = fp;
</span><span class='line'>    //把真正的头skb复制到head指针的skb
</span><span class='line'>    skb_morph(head, fq-&gt;q.fragments);
</span><span class='line'>    head-&gt;next = fq-&gt;q.fragments-&gt;next;
</span><span class='line'>
</span><span class='line'>    kfree_skb(fq-&gt;q.fragments);//释放原来的头
</span><span class='line'>    fq-&gt;q.fragments = head;
</span><span class='line'>}
</span><span class='line'>/* Unfragmented part is taken from the first segment. */
</span><span class='line'>//计算负载总长度
</span><span class='line'>payload_len = ((head-&gt;data - skb_network_header(head)) - sizeof(struct ipv6hdr) + fq-&gt;q.len -  sizeof(struct frag_hdr));
</span><span class='line'>if (payload_len &gt; IPV6_MAXPLEN) //超过65535
</span><span class='line'>    goto out_oversize;
</span><span class='line'>
</span><span class='line'>/* Head of list must not be cloned. */
</span><span class='line'>//如果skb被克隆，从新分配他的data
</span><span class='line'>if (skb_cloned(head) &amp;&amp; pskb_expand_head(head, 0, 0, GFP_ATOMIC))
</span><span class='line'>    goto out_oom;
</span><span class='line'>
</span><span class='line'>/* If the first fragment is fragmented itself, we split it to two chunks: the first with data and paged part
</span><span class='line'> * and the second, holding only fragments.
</span><span class='line'> */
</span><span class='line'>if (skb_shinfo(head)-&gt;frag_list) {//如果头自己已经被分片
</span><span class='line'>    struct sk_buff *clone;
</span><span class='line'>    int i, plen = 0;
</span><span class='line'>
</span><span class='line'>    if ((clone = alloc_skb(0, GFP_ATOMIC)) == NULL)
</span><span class='line'>        goto out_oom;
</span><span class='line'>
</span><span class='line'>    //把这个clone插入到头后               
</span><span class='line'>    clone-&gt;next = head-&gt;next;
</span><span class='line'>    head-&gt;next = clone;
</span><span class='line'>    //把头的分片给这个clone
</span><span class='line'>    skb_shinfo(clone)-&gt;frag_list = skb_shinfo(head)-&gt;frag_list;
</span><span class='line'>    skb_shinfo(head)-&gt;frag_list = NULL;
</span><span class='line'>    //头使用了页面，计算总长度
</span><span class='line'>    for (i = 0; i &lt; skb_shinfo(head)-&gt;nr_frags; i++)
</span><span class='line'>        plen += skb_shinfo(head)-&gt;frags[i].size;
</span><span class='line'>
</span><span class='line'>    clone-&gt;len = clone-&gt;data_len = head-&gt;data_len - plen;
</span><span class='line'>    head-&gt;data_len -= clone-&gt;len;
</span><span class='line'>    head-&gt;len -= clone-&gt;len;
</span><span class='line'>    clone-&gt;csum = 0;
</span><span class='line'>    clone-&gt;ip_summed = head-&gt;ip_summed;
</span><span class='line'>    atomic_add(clone-&gt;truesize, &amp;ip6_frags.mem);
</span><span class='line'>}
</span><span class='line'>/* We have to remove fragment header from datagram and to relocate                         
</span><span class='line'> * header in order to calculate ICV correctly. */
</span><span class='line'>nhoff = fq-&gt;nhoffset;
</span><span class='line'>//把传输头（分片头）中的下一个头字段值赋给网络头中的下一个头字段
</span><span class='line'>skb_network_header(head)[nhoff] = skb_transport_header(head)[0];
</span><span class='line'>//把分片首部复盖掉
</span><span class='line'>memmove(head-&gt;head + sizeof(struct frag_hdr), head-&gt;head, (head-&gt;data - head-&gt;head) - sizeof(struct frag_hdr));
</span><span class='line'>//调整相应的各个层的头位置
</span><span class='line'>head-&gt;mac_header += sizeof(struct frag_hdr);
</span><span class='line'>head-&gt;network_header += sizeof(struct frag_hdr);
</span><span class='line'>
</span><span class='line'>skb_shinfo(head)-&gt;frag_list = head-&gt;next; //保存碎片连表
</span><span class='line'>skb_reset_transport_header(head);//重新调整网络头，现在指向分片头后的头
</span><span class='line'>skb_push(head, head-&gt;data - skb_network_header(head));//使head-&gt;data指向网络头
</span><span class='line'>atomic_sub(head-&gt;truesize, &amp;ip6_frags.mem);
</span><span class='line'>
</span><span class='line'>for (fp = head-&gt;next; fp; fp = fp-&gt;next) { //统计分片总长度
</span><span class='line'>    head-&gt;data_len += fp-&gt;len;
</span><span class='line'>    head-&gt;len += fp-&gt;len;
</span><span class='line'>    if (head-&gt;ip_summed != fp-&gt;ip_summed)
</span><span class='line'>        head-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>    else if (head-&gt;ip_summed == CHECKSUM_COMPLETE)
</span><span class='line'>        head-&gt;csum = csum_add(head-&gt;csum, fp-&gt;csum); //添加各分片的累加和
</span><span class='line'>
</span><span class='line'>    head-&gt;truesize += fp-&gt;truesize;
</span><span class='line'>    atomic_sub(fp-&gt;truesize, &amp;ip6_frags.mem);
</span><span class='line'>}
</span><span class='line'>head-&gt;next = NULL;
</span><span class='line'>head-&gt;dev = dev;
</span><span class='line'>head-&gt;tstamp = fq-&gt;q.stamp;
</span><span class='line'>ipv6_hdr(head)-&gt;payload_len = htons(payload_len); //总长度
</span><span class='line'>IP6CB(head)-&gt;nhoff = nhoff;
</span><span class='line'>
</span><span class='line'>/* Yes, and fold redundant checksum back. 8) */
</span><span class='line'>if (head-&gt;ip_summed == CHECKSUM_COMPLETE) //添加网络头累加和
</span><span class='line'>    head-&gt;csum = csum_partial(skb_network_header(head), skb_network_header_len(head), head-&gt;csum);
</span><span class='line'>
</span><span class='line'>rcu_read_lock();
</span><span class='line'>IP6_INC_STATS_BH(__in6_dev_get(dev), IPSTATS_MIB_REASMOKS);
</span><span class='line'>rcu_read_unlock();
</span><span class='line'>fq-&gt;q.fragments = NULL;
</span><span class='line'>return 1;
</span><span class='line'>...... //下面是错误处理
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### 无数据扩展头
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static struct inet6_protocol nodata_protocol = {
</span><span class='line'>.handler        =       ipv6_nodata_rcv,
</span><span class='line'>.flags          =       INET6_PROTO_NOPOLICY,
</span><span class='line'>};
</span><span class='line'>static int ipv6_nodata_rcv(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>kfree_skb(skb);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### 目的选项首部处理
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static struct inet6_protocol destopt_protocol = {
</span><span class='line'>.handler        =       ipv6_destopt_rcv,
</span><span class='line'>.flags          =       INET6_PROTO_NOPOLICY | INET6_PROTO_GSO_EXTHDR,
</span><span class='line'>};
</span><span class='line'>static int ipv6_destopt_rcv(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>struct inet6_skb_parm *opt = IP6CB(skb);
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>__u16 dstbuf;
</span><span class='line'>#endif
</span><span class='line'>struct dst_entry *dst;
</span><span class='line'>//长度验证
</span><span class='line'>if (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) || !pskb_may_pull(skb, (skb_transport_offset(skb) +
</span><span class='line'>                ((skb_transport_header(skb)[1] + 1) &lt;&lt; 3)))) {
</span><span class='line'>    IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>    kfree_skb(skb);
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>opt-&gt;lastopt = opt-&gt;dst1 = skb_network_header_len(skb); //网络头长度
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>dstbuf = opt-&gt;dst1;
</span><span class='line'>#endif
</span><span class='line'>dst = dst_clone(skb-&gt;dst); //增加dst的引用计数
</span><span class='line'>//解析tlv，上面已经看到过了
</span><span class='line'>if (ip6_parse_tlv(tlvprocdestopt_lst, skb)) {
</span><span class='line'>    dst_release(dst);
</span><span class='line'>    skb-&gt;transport_header += (skb_transport_header(skb)[1] + 1) &lt;&lt; 3; //调整网络头位置
</span><span class='line'>    opt = IP6CB(skb);
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>    opt-&gt;nhoff = dstbuf;
</span><span class='line'>#else
</span><span class='line'>    opt-&gt;nhoff = opt-&gt;dst1;
</span><span class='line'>#endif
</span><span class='line'>    return 1;
</span><span class='line'>}
</span><span class='line'>IP6_INC_STATS_BH(ip6_dst_idev(dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>dst_release(dst);
</span><span class='line'>return -1;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[linux内核中tcp连接的断开处理]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/06/12/kernel-net-tcp-close/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-06-12T17:21:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/06/12/kernel-net-tcp-close&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://simohayha.iteye.com/blog/503856"&gt;http://simohayha.iteye.com/blog/503856&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;我们这次主要来分析相关的两个断开函数close和shotdown以及相关的套接口选项SO_LINGER。这里要注意SO_LINGER对shutdown无任何影响。它只对close起作用。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;先来坎SO_LINGER所对应的数据结构：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    struct linger {
</span><span class='line'>    //linger的开关
</span><span class='line'>    int     l_onoff;    /* Linger active        */
</span><span class='line'>    //所等待的时间。
</span><span class='line'>    int     l_linger;   /* How long to linger for   */
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这里对这个套接口选项就不详细介绍了，在unix网络编程中有详细的介绍，我们这里只会分析内核的处理代码。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;首先来看close函数，我们知道缺醒情况下,close是立即返回，但是如果套接口的发送缓冲区还有未发送的数据，系统将会试着把这些数据发送给对端。而这个缺醒情况我们是可以通过SO_LINGER来改变的。还有一个要注意就是close调用并不一定会引发tcp的断开连接。因为close只是将这个socket的引用计数减一(主要是针对多个进程)，而真正要直接引发断开，则需要用shutdown函数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内核中socket的close的系统调用是sock_close，而在sock_close中，直接调用sock_release来实现功能，因此这里我们直接看sock_release的源码：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    void sock_release(struct socket *sock)
</span><span class='line'>{
</span><span class='line'>    if (sock-&gt;ops) {
</span><span class='line'>        struct module *owner = sock-&gt;ops-&gt;owner;
</span><span class='line'>
</span><span class='line'>        //调用inet_stream_ops的inet_release函数
</span><span class='line'>        sock-&gt;ops-&gt;release(sock);
</span><span class='line'>        //将ops致空。
</span><span class='line'>        sock-&gt;ops = NULL;
</span><span class='line'>        module_put(owner);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //这个域貌似是26.31新加的，具体做什么的还不知道。
</span><span class='line'>    if (sock-&gt;fasync_list)
</span><span class='line'>        printk(KERN_ERR "sock_release: fasync list not empty!\n");
</span><span class='line'>
</span><span class='line'>    //更新全局的socket数目
</span><span class='line'>    percpu_sub(sockets_in_use, 1);
</span><span class='line'>    if (!sock-&gt;file) {
</span><span class='line'>        //更新inode的引用计数
</span><span class='line'>        iput(SOCK_INODE(sock));
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    sock-&gt;file = NULL;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;然后来看inet_release的实现，这个函数主要用来通过SO_LINGER套接字来得到超时时间，然后调用tcp_close来关闭sock。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    int inet_release(struct socket *sock)
</span><span class='line'>{
</span><span class='line'>    struct sock *sk = sock-&gt;sk;
</span><span class='line'>
</span><span class='line'>    if (sk) {
</span><span class='line'>        long timeout;
</span><span class='line'>
</span><span class='line'>        /* Applications forget to leave groups before exiting */
</span><span class='line'>        ip_mc_drop_socket(sk);
</span><span class='line'>
</span><span class='line'>        timeout = 0;
</span><span class='line'>        //判断是否设置SO_LINGER并且不是处于正在shutdowning，则设置timeout为l_linger(也就是我们设置的值).
</span><span class='line'>        if (sock_flag(sk, SOCK_LINGER) &amp;&amp;
</span><span class='line'>            !(current-&gt;flags &amp; PF_EXITING))
</span><span class='line'>            timeout = sk-&gt;sk_lingertime;
</span><span class='line'>        sock-&gt;sk = NULL;
</span><span class='line'>        //调用tcp_close.
</span><span class='line'>        sk-&gt;sk_prot-&gt;close(sk, timeout);
</span><span class='line'>    }
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;tcp_close函数比较长我们这里分段来分析它,首先来看第一部分。这里要注意几点：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1 当close掉一个服务端的父socket的时候，内核会先处理半连接队列然后是已经accept了的队列，最后才会处理父sock。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2 处理接收缓冲区的数据的时候，直接遍历receive_queue(前面blog有介绍)，然后统计未发送的socket。我们知道close是不管接收buf的，也就是他会把接收buf释放掉，然后发送rst给对端的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;3 当so_linger有设置并且超时时间为0,则发送rst给对端，并且清空发送和接收buf。这个也不会引起最终的四分组终止序列。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;4 当接收缓冲区有未读数据，则直接发送rst给对端。这个也不会引起最终的四分组终止序列。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;5 当so_linger有设置，并且超时不为0,或者so_linger没有设置，此时都会引起最终的四分组终止序列来终止连接。(通过send_fin来发送fin,并引发四分组终止序列).而在send_fin中会发送掉发送缓冲区中的数据。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;来看代码：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    void tcp_close(struct sock *sk, long timeout)
</span><span class='line'>{
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>    int data_was_unread = 0;
</span><span class='line'>    int state;
</span><span class='line'>
</span><span class='line'>    lock_sock(sk);
</span><span class='line'>    sk-&gt;sk_shutdown = SHUTDOWN_MASK;
</span><span class='line'>
</span><span class='line'>    //如果处于tcp_listen说明将要关闭的这个socket是一个服务端的主socket。
</span><span class='line'>    if (sk-&gt;sk_state == TCP_LISTEN) {
</span><span class='line'>        //设置sock状态.
</span><span class='line'>        tcp_set_state(sk, TCP_CLOSE);
</span><span class='line'>
</span><span class='line'>        //这个函数主要用来清理半连接队列(下面会简要分析这个函数)
</span><span class='line'>        /* Special case. */
</span><span class='line'>        inet_csk_listen_stop(sk);
</span><span class='line'>        //处理要关闭的sock
</span><span class='line'>        goto adjudge_to_death;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //遍历sk_receive_queue也就是输入buf队列。然后统计还没有读取的数据。
</span><span class='line'>    while ((skb = __skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != NULL) {
</span><span class='line'>        u32 len = TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq -
</span><span class='line'>              tcp_hdr(skb)-&gt;fin;
</span><span class='line'>        data_was_unread += len;
</span><span class='line'>        //free这个skb
</span><span class='line'>        __kfree_skb(skb);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    sk_mem_reclaim(sk);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    //第一个if主要是实现了rfc2525的2.17,也就是关闭的时候，如果接收buf中有未读数据，则发送一个rst给对端。(下面有摘抄相关内容)
</span><span class='line'>    if (data_was_unread) {
</span><span class='line'>        /* Unread data was tossed, zap the connection. */
</span><span class='line'>        NET_INC_STATS_USER(sock_net(sk), LINUX_MIB_TCPABORTONCLOSE);
</span><span class='line'>        //设置状态
</span><span class='line'>        tcp_set_state(sk, TCP_CLOSE);
</span><span class='line'>        //发送rst
</span><span class='line'>        tcp_send_active_reset(sk, GFP_KERNEL);
</span><span class='line'>    }
</span><span class='line'>    //第二个if主要是判断so_linger套接字,并且超时时间为0。此时我们就直接丢掉所有的发送缓冲区中的数据
</span><span class='line'>    else if (sock_flag(sk, SOCK_LINGER) &amp;&amp; !sk-&gt;sk_lingertime) {
</span><span class='line'>        /* Check zero linger _after_ checking for unread data. */
</span><span class='line'>        //调用tcp_disconnect，这个函数主要用来断开和对端的连接，这个函数下面会介绍。
</span><span class='line'>        sk-&gt;sk_prot-&gt;disconnect(sk, 0);
</span><span class='line'>        NET_INC_STATS_USER(sock_net(sk), LINUX_MIB_TCPABORTONDATA);
</span><span class='line'>    }
</span><span class='line'>    //这个函数主要用来判断是否需要发送fin，也就是判断状态。下面我会详细介绍这个函数。
</span><span class='line'>    else if (tcp_close_state(sk)) {
</span><span class='line'>
</span><span class='line'>        //发送fin.
</span><span class='line'>        tcp_send_fin(sk);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //等待一段时间。这里的timeout，如果有设置so_linger的话就是l_linger.这里主要是等待发送缓冲区的buf发送(如果超时时间不为0).
</span><span class='line'>    sk_stream_wait_close(sk, timeout);
</span><span class='line'>    ........................
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;rfc2525的2.17的介绍：&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    When an application closes a connection in such a way that it can no longer read any received data, 
</span><span class='line'>the TCP SHOULD, per section 4.2.2.13 of RFC 1122, send a RST if there is any unread received data, 
</span><span class='line'>or if any new data is received. A TCP that fails to do so exhibits "Failure to RST on close with data pending".
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ok，现在来看上面遇到的3个函数，一个是inet_csk_listen_stop,一个是tcp_close_state,一个是tcp_disconnect.我们一个个来看他们。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;首先是inet_csk_listen_stop函数。我们知道这个函数主要用来清理所有的半连接队列。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    void inet_csk_listen_stop(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    struct request_sock *acc_req;
</span><span class='line'>    struct request_sock *req;
</span><span class='line'>
</span><span class='line'>    //首先删除keepalive定时器。
</span><span class='line'>    inet_csk_delete_keepalive_timer(sk);
</span><span class='line'>
</span><span class='line'>    /* make all the listen_opt local to us */
</span><span class='line'>    //得到accept 队列。
</span><span class='line'>    acc_req = reqsk_queue_yank_acceptq(&amp;icsk-&gt;icsk_accept_queue);
</span><span class='line'>
</span><span class='line'>    //然后销毁掉所有的半连接队列，也就是listen_sock队列
</span><span class='line'>    reqsk_queue_destroy(&amp;icsk-&gt;icsk_accept_queue);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    //遍历accept队列断开与对端的连接。
</span><span class='line'>    while ((req = acc_req) != NULL) {
</span><span class='line'>    ...............................................
</span><span class='line'>
</span><span class='line'>        //调用tcp_disconnect来断开与对端的连接。这里注意是非阻塞的。
</span><span class='line'>        sk-&gt;sk_prot-&gt;disconnect(child, O_NONBLOCK);
</span><span class='line'>
</span><span class='line'>        sock_orphan(child);
</span><span class='line'>
</span><span class='line'>        percpu_counter_inc(sk-&gt;sk_prot-&gt;orphan_count);
</span><span class='line'>
</span><span class='line'>        //销毁这个sock。
</span><span class='line'>        inet_csk_destroy_sock(child);
</span><span class='line'>
</span><span class='line'>        ........................................
</span><span class='line'>    }
</span><span class='line'>    WARN_ON(sk-&gt;sk_ack_backlog);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接下来来看tcp_disconnect函数。这个函数主要用来断开和对端的连接.它会释放读写队列，发送rst，清除定时器等等一系列操作。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    int tcp_disconnect(struct sock *sk, int flags)
</span><span class='line'>{
</span><span class='line'>    struct inet_sock *inet = inet_sk(sk);
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    int err = 0;
</span><span class='line'>    int old_state = sk-&gt;sk_state;
</span><span class='line'>
</span><span class='line'>    if (old_state != TCP_CLOSE)
</span><span class='line'>        tcp_set_state(sk, TCP_CLOSE);
</span><span class='line'>    ...................
</span><span class='line'>
</span><span class='line'>    //清除定时器，重传，delack等。
</span><span class='line'>    tcp_clear_xmit_timers(sk);
</span><span class='line'>    //直接free掉接收buf。
</span><span class='line'>    __skb_queue_purge(&amp;sk-&gt;sk_receive_queue);
</span><span class='line'>    //free掉写buf。
</span><span class='line'>    tcp_write_queue_purge(sk);
</span><span class='line'>    __skb_queue_purge(&amp;tp-&gt;out_of_order_queue);
</span><span class='line'>#ifdef CONFIG_NET_DMA
</span><span class='line'>    __skb_queue_purge(&amp;sk-&gt;sk_async_wait_queue);
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>    inet-&gt;dport = 0;
</span><span class='line'>
</span><span class='line'>    if (!(sk-&gt;sk_userlocks &amp; SOCK_BINDADDR_LOCK))
</span><span class='line'>        inet_reset_saddr(sk);
</span><span class='line'>        ..........................................
</span><span class='line'>    //设置状态。
</span><span class='line'>    tcp_set_ca_state(sk, TCP_CA_Open);
</span><span class='line'>    //清理掉重传的一些标记
</span><span class='line'>    tcp_clear_retrans(tp);
</span><span class='line'>    inet_csk_delack_init(sk);
</span><span class='line'>    tcp_init_send_head(sk);
</span><span class='line'>    memset(&amp;tp-&gt;rx_opt, 0, sizeof(tp-&gt;rx_opt));
</span><span class='line'>    __sk_dst_reset(sk);
</span><span class='line'>
</span><span class='line'>    WARN_ON(inet-&gt;num &amp;&amp; !icsk-&gt;icsk_bind_hash);
</span><span class='line'>
</span><span class='line'>    sk-&gt;sk_error_report(sk);
</span><span class='line'>    return err;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;紧接着是tcp_close_state函数这个函数就是用来判断是否应该发送fin:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    //这个数组表示了当close后，tcp的状态变化，可以看到注释很清楚，包含了3部分。这里也就是通过current也就是tcp的状态取得new state也就是close的状态，然后再和TCP_ACTION_FIN按位于，得到action
</span><span class='line'>static const unsigned char new_state[16] = {
</span><span class='line'>  /* current state:        new state:      action:  */
</span><span class='line'>  /* (Invalid)      */ TCP_CLOSE,
</span><span class='line'>  /* TCP_ESTABLISHED    */ TCP_FIN_WAIT1 | TCP_ACTION_FIN,
</span><span class='line'>  /* TCP_SYN_SENT   */ TCP_CLOSE,
</span><span class='line'>  /* TCP_SYN_RECV   */ TCP_FIN_WAIT1 | TCP_ACTION_FIN,
</span><span class='line'>  /* TCP_FIN_WAIT1  */ TCP_FIN_WAIT1,
</span><span class='line'>  /* TCP_FIN_WAIT2  */ TCP_FIN_WAIT2,
</span><span class='line'>  /* TCP_TIME_WAIT  */ TCP_CLOSE,
</span><span class='line'>  /* TCP_CLOSE      */ TCP_CLOSE,
</span><span class='line'>  /* TCP_CLOSE_WAIT */ TCP_LAST_ACK  | TCP_ACTION_FIN,
</span><span class='line'>  /* TCP_LAST_ACK   */ TCP_LAST_ACK,
</span><span class='line'>  /* TCP_LISTEN     */ TCP_CLOSE,
</span><span class='line'>  /* TCP_CLOSING    */ TCP_CLOSING,
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static int tcp_close_state(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    //取得new state
</span><span class='line'>    int next = (int)new_state[sk-&gt;sk_state];
</span><span class='line'>    int ns = next &amp; TCP_STATE_MASK;
</span><span class='line'>
</span><span class='line'>    tcp_set_state(sk, ns);
</span><span class='line'>
</span><span class='line'>    //得到action
</span><span class='line'>    return next &amp; TCP_ACTION_FIN;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接下来来看tcp_close的剩余部分的代码，剩下的部分就是处理一些状态以及通知这里只有一个要注意的就是TCP_LINGER2这个套接字，这个套接字能够设置等待fin的超时时间，也就是tcp_sock的域linger2.我们知道系统还有一个sysctl_tcp_fin_timeout，也就是提供了一个sys文件系统的接口来修改这个值，不过我们如果设置linger2为一个大于0的值的话，内核就会取linger2这个值。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    adjudge_to_death:
</span><span class='line'>
</span><span class='line'>    //得到sock的状态。
</span><span class='line'>    state = sk-&gt;sk_state;
</span><span class='line'>    sock_hold(sk);
</span><span class='line'>    sock_orphan(sk);
</span><span class='line'>
</span><span class='line'>    //唤醒阻塞在这个sock的队列(前面有详细介绍这个函数)
</span><span class='line'>    release_sock(sk);
</span><span class='line'>
</span><span class='line'>    local_bh_disable();
</span><span class='line'>    bh_lock_sock(sk);
</span><span class='line'>    WARN_ON(sock_owned_by_user(sk));
</span><span class='line'>
</span><span class='line'>    //全局的cpu变量引用计数减一。
</span><span class='line'>    percpu_counter_inc(sk-&gt;sk_prot-&gt;orphan_count);
</span><span class='line'>
</span><span class='line'>    /* Have we already been destroyed by a softirq or backlog? */
</span><span class='line'>    if (state != TCP_CLOSE &amp;&amp; sk-&gt;sk_state == TCP_CLOSE)
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    //如果状态为TCP_FIN_WAIT2,说明接收了ack，在等待对端的fin。
</span><span class='line'>    if (sk-&gt;sk_state == TCP_FIN_WAIT2) {
</span><span class='line'>        struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>        //超时时间小于0,则说明马上超时，设置状态为tcp_close,然后发送rst给对端。
</span><span class='line'>        if (tp-&gt;linger2 &lt; 0) {
</span><span class='line'>            tcp_set_state(sk, TCP_CLOSE);
</span><span class='line'>            tcp_send_active_reset(sk, GFP_ATOMIC);
</span><span class='line'>            NET_INC_STATS_BH(sock_net(sk),
</span><span class='line'>                    LINUX_MIB_TCPABORTONLINGER);
</span><span class='line'>        } else {
</span><span class='line'>            //得到等待fin的超时时间。这里主要也就是在linger2和sysctl_tcp_fin_timeout中来取得。
</span><span class='line'>            const int tmo = tcp_fin_time(sk);
</span><span class='line'>            //如果超时时间太长，则启动keepalive定时器发送探测报。
</span><span class='line'>            if (tmo &gt; TCP_TIMEWAIT_LEN) {
</span><span class='line'>                inet_csk_reset_keepalive_timer(sk,
</span><span class='line'>                        tmo - TCP_TIMEWAIT_LEN);
</span><span class='line'>            } else {
</span><span class='line'>                //否则进入time_wait状态。
</span><span class='line'>                tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);
</span><span class='line'>                goto out;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    ......................................
</span><span class='line'>
</span><span class='line'>    //如果sk的状态为tcp_close则destroy掉这个sk
</span><span class='line'>    if (sk-&gt;sk_state == TCP_CLOSE)
</span><span class='line'>        inet_csk_destroy_sock(sk);
</span><span class='line'>    /* Otherwise, socket is reprieved until protocol close. */
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>    bh_unlock_sock(sk);
</span><span class='line'>    local_bh_enable();
</span><span class='line'>    sock_put(sk);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;然后来看send_fin的实现，这个函数用来发送一个fin，并且尽量发送完发送缓冲区中的数据：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    void tcp_send_fin(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    //取得写bufer的尾部。
</span><span class='line'>    struct sk_buff *skb = tcp_write_queue_tail(sk);
</span><span class='line'>    int mss_now;
</span><span class='line'>
</span><span class='line'>    /* Optimization, tack on the FIN if we have a queue of
</span><span class='line'>     * unsent frames.  But be careful about outgoing SACKS
</span><span class='line'>     * and IP options.
</span><span class='line'>     */
</span><span class='line'>    mss_now = tcp_current_mss(sk);
</span><span class='line'>    //如果发送队列不为空，此时我们只需要设置sk buffer的标记位(也就是tcp报文的控制位为fin)，可以看到我们是加到写buffer的尾部，这里是为了能尽量将写buffer中的数据全部传出)
</span><span class='line'>    if (tcp_send_head(sk) != NULL) {
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;flags |= TCPCB_FLAG_FIN;
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;end_seq++;
</span><span class='line'>        tp-&gt;write_seq++;
</span><span class='line'>    } else {
</span><span class='line'>    ..................................
</span><span class='line'>        //到这里标明发送缓冲区位空，因此我们需要新建一个sk buffer，然后设置标记位，并加入到写buffer。
</span><span class='line'>        skb_reserve(skb, MAX_TCP_HEADER);
</span><span class='line'>        /* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */
</span><span class='line'>        tcp_init_nondata_skb(skb, tp-&gt;write_seq,
</span><span class='line'>                     TCPCB_FLAG_ACK | TCPCB_FLAG_FIN);
</span><span class='line'>        tcp_queue_skb(sk, skb);
</span><span class='line'>    }
</span><span class='line'>    //发送写缓冲区中的数据。
</span><span class='line'>    __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_OFF);
</span><span class='line'>}
</span><span class='line'>void __tcp_push_pending_frames(struct sock *sk, unsigned int cur_mss,
</span><span class='line'>                   int nonagle)
</span><span class='line'>{
</span><span class='line'>    struct sk_buff *skb = tcp_send_head(sk);
</span><span class='line'>
</span><span class='line'>    if (!skb)
</span><span class='line'>        return;
</span><span class='line'>
</span><span class='line'>    /* If we are closed, the bytes will have to remain here.
</span><span class='line'>     * In time closedown will finish, we empty the write queue and
</span><span class='line'>     * all will be happy.
</span><span class='line'>     */
</span><span class='line'>    if (unlikely(sk-&gt;sk_state == TCP_CLOSE))
</span><span class='line'>        return;
</span><span class='line'>    //发送数据，这里关闭了nagle。也就是立即将数据全部发送出去(我前面的blog有详细解释这个函数).
</span><span class='line'>    if (tcp_write_xmit(sk, cur_mss, nonagle, 0, GFP_ATOMIC))
</span><span class='line'>        tcp_check_probe_timer(sk);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;接下来来看shutdown的实现。在2.26.31中，系统调用的实现有些变化。&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这里我们要知道shutdown会将写缓冲区的数据发出，然后唤醒阻塞的进程，来读取读缓冲区中的数据。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这个系统调用所对应的内核函数就是os_shutdown_socket。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    #define SHUT_RD 0
</span><span class='line'>#define SHUT_WR 1
</span><span class='line'>#define SHUT_RDWR 2
</span><span class='line'>
</span><span class='line'>int os_shutdown_socket(int fd, int r, int w)
</span><span class='line'>{
</span><span class='line'>    int what, err;
</span><span class='line'>
</span><span class='line'>    if (r &amp;&amp; w)
</span><span class='line'>        what = SHUT_RDWR;
</span><span class='line'>    else if (r)
</span><span class='line'>        what = SHUT_RD;
</span><span class='line'>    else if (w)
</span><span class='line'>        what = SHUT_WR;
</span><span class='line'>    else
</span><span class='line'>        return -EINVAL;
</span><span class='line'>
</span><span class='line'>    //调用socket的shutdown也就是kernel_sock_shutdown
</span><span class='line'>    err = shutdown(fd, what);
</span><span class='line'>    if (err &lt; 0)
</span><span class='line'>        return -errno;
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how)
</span><span class='line'>{
</span><span class='line'>    //他最终会调用inet_shutdown
</span><span class='line'>    return sock-&gt;ops-&gt;shutdown(sock, how);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;来看inet_shutdown的实现.这个函数的主要工作就是通过判断sock的状态不同来调用相关的函数：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    int inet_shutdown(struct socket *sock, int how)
</span><span class='line'>{
</span><span class='line'>    struct sock *sk = sock-&gt;sk;
</span><span class='line'>    int err = 0;
</span><span class='line'>
</span><span class='line'>    /* This should really check to make sure
</span><span class='line'>     * the socket is a TCP socket. (WHY AC...)
</span><span class='line'>     */
</span><span class='line'>    //这里要注意每个how都是加1的，这说明在内核里读写是为1,2,3
</span><span class='line'>    how++; /* maps 0-&gt;1 has the advantage of making bit 1 rcvs and
</span><span class='line'>               1-&gt;2 bit 2 snds.
</span><span class='line'>               2-&gt;3 */
</span><span class='line'>    //判断how的合法性。
</span><span class='line'>    if ((how &amp; ~SHUTDOWN_MASK) || !how) /* MAXINT-&gt;0 */
</span><span class='line'>        return -EINVAL;
</span><span class='line'>    //锁住sock
</span><span class='line'>    lock_sock(sk);
</span><span class='line'>
</span><span class='line'>    //SS_CONNECTING说明这个sock的连接正在处理中。state域表示socket当前的内部状态
</span><span class='line'>    if (sock-&gt;state == SS_CONNECTING) {
</span><span class='line'>        //如果状态为这几个状态，说明是处于半连接处理阶段，此时设置状态为SS_DISCONNECTING
</span><span class='line'>        if ((1 &lt;&lt; sk-&gt;sk_state) &amp;
</span><span class='line'>            (TCPF_SYN_SENT | TCPF_SYN_RECV | TCPF_CLOSE))
</span><span class='line'>            sock-&gt;state = SS_DISCONNECTING;
</span><span class='line'>        else
</span><span class='line'>            //否则设置为连接完毕
</span><span class='line'>            sock-&gt;state = SS_CONNECTED;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //除过TCP_LISTEN以及TCP_SYN_SENT状态外的其他状态最终都会进入sk-&gt;sk_prot-&gt;shutdown也就是tcp_shutdown函数。
</span><span class='line'>
</span><span class='line'>    switch (sk-&gt;sk_state) {
</span><span class='line'>    //如果状态为tco_close则设置错误号，然后进入default处理
</span><span class='line'>    case TCP_CLOSE:
</span><span class='line'>        err = -ENOTCONN;
</span><span class='line'>        /* Hack to wake up other listeners, who can poll for
</span><span class='line'>           POLLHUP, even on eg. unconnected UDP sockets -- RR */
</span><span class='line'>    default:
</span><span class='line'>        sk-&gt;sk_shutdown |= how;
</span><span class='line'>        if (sk-&gt;sk_prot-&gt;shutdown)
</span><span class='line'>            sk-&gt;sk_prot-&gt;shutdown(sk, how);
</span><span class='line'>        break;
</span><span class='line'>
</span><span class='line'>    /* Remaining two branches are temporary solution for missing
</span><span class='line'>     * close() in multithreaded environment. It is _not_ a good idea,
</span><span class='line'>     * but we have no choice until close() is repaired at VFS level.
</span><span class='line'>     */
</span><span class='line'>    case TCP_LISTEN:
</span><span class='line'>        //如果不为SHUT_RD则跳出switch，否则进入tcp_syn_sent的处理。
</span><span class='line'>        if (!(how &amp; RCV_SHUTDOWN))
</span><span class='line'>            break;
</span><span class='line'>        /* Fall through */
</span><span class='line'>    case TCP_SYN_SENT:
</span><span class='line'>        //断开连接，然后设置state
</span><span class='line'>        err = sk-&gt;sk_prot-&gt;disconnect(sk, O_NONBLOCK);
</span><span class='line'>        sock-&gt;state = err ? SS_DISCONNECTING : SS_UNCONNECTED;
</span><span class='line'>        break;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Wake up anyone sleeping in poll. */
</span><span class='line'>    //唤醒阻塞在这个socket上的进程，这里是为了将读缓冲区的数据尽量读完。
</span><span class='line'>    sk-&gt;sk_state_change(sk);
</span><span class='line'>    release_sock(sk);
</span><span class='line'>    return err;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;来看tcp_shutdown函数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这里要注意，当只关闭读的话，并不会引起发送fin，也就是只会设置个标记，然后在读取数据的时候返回错误。而关闭写端，则就会引起发送fin。</span></code></pre></td></tr></table></div></figure>
    void tcp_shutdown(struct sock <em>sk, int how)
    {
        /</em>  We need to grab some memory, and put together a FIN,
         *  and then put it into the queue to be sent.
         *      Tim MacKenzie(<a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x74;&#x79;&#x6d;&#x40;&#100;&#x69;&#98;&#98;&#108;&#101;&#x72;&#x2e;&#x63;&#115;&#46;&#x6d;&#x6f;&#x6e;&#97;&#115;&#104;&#x2e;&#x65;&#x64;&#x75;&#46;&#97;&#x75;">&#116;&#x79;&#x6d;&#x40;&#100;&#105;&#98;&#98;&#x6c;&#101;&#x72;&#x2e;&#99;&#115;&#46;&#x6d;&#111;&#110;&#97;&#x73;&#104;&#46;&#x65;&#100;&#x75;&#46;&#x61;&#117;</a>) 4 Dec &lsquo;92.
         */
        //如果为SHUT_RD则直接返回。
        if (!(how &amp; SEND_SHUTDOWN))
            return;</p>

<pre><code>    /* If we've already sent a FIN, or it's a closed state, skip this. */
    //这里英文注释很详细我就不多解释了。
    if ((1 &lt;&lt; sk-&gt;sk_state) &amp;
        (TCPF_ESTABLISHED | TCPF_SYN_SENT |
         TCPF_SYN_RECV | TCPF_CLOSE_WAIT)) {
        /* Clear out any half completed packets.  FIN if needed. */
        //和tcp_close那边处理一样
        if (tcp_close_state(sk))
            tcp_send_fin(sk);
    }
}
</code></pre>

<pre><code>
最后来看sock_def_readable它就是sk-&gt;sk_state_change。也就是用来唤醒阻塞的进程。
</code></pre>

<pre><code>static void sock_def_readable(struct sock *sk, int len)
{
    read_lock(&amp;sk-&gt;sk_callback_lock);
    //判断是否有进程在等待这个sk
    if (sk_has_sleeper(sk))
    //有的话，唤醒进程，这里可以看到递交给上层的是POLLIN,也就是读事件。
    wake_up_interruptible_sync_poll(sk-&gt;sk_sleep, POLLIN |
                        POLLRDNORM | POLLRDBAND);

    //这里异步唤醒，可以看到这里也是POLL_IN.
    sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
    read_unlock(&amp;sk-&gt;sk_callback_lock);
}
</code></pre>

<p>```</p>

<p>可以看到shutdown函数只会处理SEND_SHUTDOWN。并且当调用shutdown之后，读缓冲区，还可以继续读取。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Socket层实现系列 — I/O事件及其处理函数]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/06/12/kernel-net-socket-io/"/>
    <updated>2015-06-12T17:18:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/06/12/kernel-net-socket-io</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/45787989">http://blog.csdn.net/zhangskd/article/details/45787989</a></p>

<p>主要内容：Socket I/O事件的定义、I/O处理函数的实现。</p>

<p>内核版本：3.15.2</p>

<h4>I/O事件定义</h4>

<p>sock中定义了几个I/O事件，当协议栈遇到这些事件时，会调用它们的处理函数。</p>

<pre><code>    struct sock {
        ...
        struct socket_wq __rcu *sk_wq; /* socket的等待队列和异步通知队列 */
        ...
        /* callback to indicate change in the state of the sock.
         * sock状态改变时调用，比如从TCP_SYN_SENT或TCP_SYN_RECV变为TCP_ESTABLISHED，
         * 导致connect()的唤醒。比如从TCP_ESTABLISHED变为TCP_CLOSE_WAIT。
         */
        void (*sk_state_change) (struct sock *sk);

        /* callback to indicate there is data to be processed.
         * sock上有数据可读时调用，比如服务器端收到第三次握手的ACK时会调用，导致accept()的唤醒。
         */
        void (*sk_data_ready) (struct sock *sk);

        /* callback to indicate there is buffer sending space available.
         * sock上有发送空间可写时调用，比如发送缓存变得足够大了。
         */
        void (*sk_write_space) (struct sock *sk);

        /* callback to indicate errors (e.g. %MSG_ERRQUEUE)
         * sock上有错误发生时调用，比如收到RST包。
         */
        void (*sk_error_report) (struct sock *sk);
        ...
    };
</code></pre>

<p>Socket I/O事件的默认处理函数在sock初始化时赋值。</p>

<p>对于SOCK_STREAM类型的Socket，sock有发送缓存可写事件会被更新为sk_stream_write_space。</p>

<pre><code>    void sock_init_data(struct socket *sock, struct sock *sk)
    {
        ...
        sk-&gt;sk_state_change = sock_def_wakeup; /* sock状态改变事件 */
        sk-&gt;sk_data_ready = sock_def_readable; /* sock有数据可读事件 */
        sk-&gt;sk_write_space = sock_def_write_space; /* sock有发送缓存可写事件 */
        sk-&gt;sk_error_report = sock_def_error_report; /* sock有IO错误事件 */
        ...
    }
</code></pre>

<p>判断socket的等待队列上是否有进程。</p>

<pre><code>    static inline bool wq_has_sleeper(struct socket_wq *wq)
    {
        smp_mb();
        return wq &amp;&amp; waitqueue_active(&amp;wq-&gt;wait);
    }
</code></pre>

<h4>状态改变事件</h4>

<p>sk->sk_state_change的实例为sock_def_wakeup()，当sock的状态发生改变时，会调用此函数来进行处理。
```
    static void sock_def_wakeup(struct sock <em>sk)
    {
        struct socket_wq </em>wq; /<em> socket的等待队列和异步通知队列 </em>/</p>

<pre><code>    rcu_read_lock();
    wq = rcu_dereference(sk-&gt;sk_wq);
    if (wq_has_sleeper(wq)) /* 有进程阻塞在此socket上 */
        wake_up_interruptible_all(&amp;wq-&gt;wait); /* 唤醒此socket上的所有睡眠进程 */
    rcu_read_unlock();
}
</code></pre>

<p><code>
</code>
    #define wake_up_interruptible_all(x) __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)</p>

<pre><code>void __wake_up(wait_queue_head_t *q, unsigned int mode, int nr_exclusive, void *key)
{
    unsigned long flags;
    spin_lock_irqsave(&amp;q-&gt;lock, flags);
    __wake_up_common(q, mode, nr_exclusive, 0, key);
    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);
}
</code></pre>

<pre><code>初始化等待任务时，如果flags设置了WQ_FLAG_EXCLUSIVE，那么传入的nr_exclusive为1，

表示只允许唤醒一个等待任务，这是为了避免惊群现象。否则会把t等待队列上的所有睡眠进程都唤醒。
</code></pre>

<pre><code>static void __wake_up_common(wait_queue_head_t *q, unsigned int mode, int nr_exclusive,
                             int wake_flags, void *key)
{
    wait_queue_t *curr, *next;

    list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) {
        unsigned flags = curr-&gt;flags;

        if (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE)
            !--nr_exclusive)
            break;
    }
}
</code></pre>

<pre><code>
最终调用的是等待任务中的处理函数，默认为autoremove_wake_function()。
</code></pre>

<pre><code>#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)

#define DEFINE_WAIT_FUNC(name, function)    \
    wait_queue_t name = {    \
        .private = current,    \
        .func = function,    \
        .task_list = LIST_HEAD_INIT((name).task_list),    \
    }

int autoremove_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key)
{
    int ret = default_wake_function(wait, mode, sync, key); /* 默认的唤醒函数 */

    if (ret)
        list_del_init(&amp;wait-&gt;task_list); /* 从等待队列中删除 */

    return ret;
}

int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, void *key)
{
    return try_to_wake_up(curr-&gt;private, mode, wake_flags);
}
</code></pre>

<pre><code>try_to_wake_up()通过把进程的状态设置为TASK_RUNNING，并把进程插入CPU运行队列，来唤醒睡眠的进程。


#### 有数据可读事件

sk-&gt;sk_data_ready的实例为sock_def_readable()，当sock有输入数据可读时，会调用此函数来处理。
</code></pre>

<pre><code>static void sock_def_readable(struct sock *sk)
{
    struct socket_wq *wq; /* socket的等待队列和异步通知队列 */

    rcu_read_lock();
    wq = rcu_dereference(sk-&gt;sk_wq);

    if (wq_has_sleeper(wq)) /* 有进程在此socket的等待队列 */
        wake_up_interruptible_sync_poll(&amp;wq-&gt;wait, POLLIN | POLLPRI |
            POLLRDNORM | POLLRDBAND); /* 唤醒等待进程 */

    /* 异步通知队列的处理。
     * 检查应用程序是否通过recv()类调用来等待接收数据，如果没有就发送SIGIO信号，
     * 告知它有数据可读。
     * how为函数的处理方式，band为用来告知的IO类型。
     */
    sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
}
</code></pre>

<pre><code></code></pre>

<pre><code>#define wake_up_interruptible_sync_poll(x, m) \
    __wake_up_sync_key((x), TASK_INTERRUPTIBLE, 1, (void *) (m))

void __wake_up_sync_key(wait_queue_head_t *q, unsigned int mode, int nr_exclusive, void *key)
{
    unsigned long flags;
    int wake_flags = 1; /* XXX WF_SYNC */

    if (unlikely(!q))
        return;
    if (unlikely(nr_exclusive != 1))
        wake_flags = 0;

    spin_lock_irqsave(&amp;q-&gt;lock, flags);
    __wake_up_common(q, mode, nr_exclusive, wake_flags, key);
    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);
}
</code></pre>

<pre><code>
最终也是调用`__wake_up_common()`。初始化等待任务时，flags |= WQ_FLAG_EXCLUSIVE。

传入的nr_exclusive为1，表示只允许唤醒一个等待任务。所以这里只会唤醒一个等待的进程。


#### 有缓存可写事件

sk-&gt;sk_write_space的实例为sock_def_write_space()。

如果socket是SOCK_STREAM类型的，那么函数指针的值会更新为sk_stream_write_space()。

sk_stream_write_space()在TCP中的调用路径为：
</code></pre>

<pre><code>tcp_rcv_established / tcp_rcv_state_process
    tcp_data_snd_check
        tcp_check_space
            tcp_new_space
</code></pre>

<pre><code></code></pre>

<pre><code>/* When incoming ACK allowed to free some skb from write_queue,
 * we remember this event in flag SOCK_QUEUE_SHRUNK and wake up socket
 * on the exit from tcp input handler.
 */
static void tcp_new_space(struct sock *sk)
{
    struct tcp_sock *tp = tcp_sk(sk);

    if (tcp_should_expand_sndbuf(sk)) {
        tcp_sndbuf_expand(sk);
        tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
    }

    /* 检查是否需要触发有缓存可写事件 */
    sk-&gt;sk_write_space(sk);
}
</code></pre>

<pre><code></code></pre>

<pre><code>void sk_stream_write_space(struct sock *sk)
{
    struct socket *sock = sk-&gt;sk_socket;
    struct socket_wq *wq; /* 等待队列和异步通知队列 */

    /* 如果剩余的发送缓存不低于发送缓存上限的1/3，且尚未发送的数据不高于一定值时 */
    if (sk_stream_is_writeable(sk) &amp;&amp; sock) {
        clear_bit(SOCK_NOSPACE, &amp;sock-&gt;flags); /* 清除发送缓存不够的标志 */

        rcu_read_lock();
        wq = rcu_dereference(sk-&gt;sk_wq); /* socket的等待队列和异步通知队列 */
        if (wq_has_sleeper(wq)) /* 如果等待队列不为空，则唤醒一个睡眠进程 */
            wake_up_interruptible_poll(&amp;wq-&gt;wait, POLLOUT | POLLWRNORM | POLLWRBAND);

        /* 异步通知队列不为空，且允许发送数据时。
         * 检测sock的发送队列是否曾经到达上限，如果有的话发送SIGIO信号，告知异步通知队列上
         * 的进程有发送缓存可写。
         */
        if (wq &amp;&amp; wq-&gt;fasync_list &amp;&amp; !(sk-&gt;sk_shutdown &amp; SEND_SHUTDOWN))
            sock_wake_async(sock, SOCK_WAKE_SPACE, POLL_OUT);

        rcu_read_unlock();
    }
}

#define wake_up_interruptible_poll(x, m) \
    __wake_up(x, TASK_INTERRUPTIBLE, 1, (void *) (m))
</code></pre>

<pre><code>
最终也是调用`__wake_up_common()`。初始化等待任务时，flags |= WQ_FLAG_EXCLUSIVE。

传入的nr_exclusive为1，表示只允许唤醒一个等待进程。
</code></pre>

<pre><code>struct sock {
    ...
    /* 发送队列中，skb数据区的总大小 */
    atomic_t sk_wmem_alloc;
    ...
    int sk_sndbuf; /* 发送缓冲区大小的上限 */
    struct sk_buff_head sk_write_queue; /* 发送队列 */
    ...
    /* 发送队列的总大小，包含发送队列中skb数据区的总大小，
     * 以及sk_buff、sk_shared_info结构体、协议头的额外开销。
     */
    int sk_wmem_queued;
    ...
};
</code></pre>

<pre><code>如果剩余的发送缓存大于发送缓存上限的1/3，且尚未发送的数据少于一定值时，才会触发有发送

缓存可写的事件。
</code></pre>

<pre><code>static inline bool sk_stream_is_writeable(const struct sock *sk)
{
    return sk_stream_wspace(sk) &gt;= sk_stream_min_wspace(sk) &amp;&amp;
}

static inline int sk_stream_wspace(const struct sock *sk)
{
    return sk-&gt;sk_sndbuf - sk-&gt;sk_wmem_queued;
}

static inline int sk_stream_min_wspace(const struct sock *sk)
{
    return sk-&gt;sk_wmem_queued &gt;&gt; 1;
}
</code></pre>

<pre><code>
检查尚未发送的数据是否已经够多了，如果超过了用户设置的值，就不用触发有发送缓存可写事件，

以免使用过多的内存。
</code></pre>

<pre><code>static inline bool sk_stream_memory_free(const struct sock *sk)
{
    if (sk-&gt;sk_wmem_queued &gt;= sk-&gt;sk_sndbuf)
        return false;

    return sk-&gt;sk_prot-&gt;stream_memory_free ? sk-&gt;sk_prot-&gt;stream_memory_free(sk) : true;
}

struct proto tcp_prot = {
    ...
    .stream_memory_free = tcp_stream_memory_free,
    ...
};

static inline bool tcp_stream_memory_free(const struct sock *sk)
{
    const struct tcp_sock *tp = tcp_sk(sk);
    u32 notsent_bytes = tp-&gt;write_seq - tp-&gt;snd_nxt; /* 尚未发送的数据大小 */

    /* 当尚未发送的数据，少于配置的值时，才触发有发送缓存可写的事件。
     * 这是为了避免发送缓存占用过多的内存。
     */
    return notsent_bytes &lt; tcp_notsent_lowat(tp);
}
</code></pre>

<pre><code>如果有使用TCP_NOTSENT_LOWAT选项，则使用用户设置的值。

否则使用sysctl_tcp_notsent_lowat，默认为无穷大。
</code></pre>

<pre><code>static inline u32 tcp_notsent_lowat(const struct tcp_sock *tp)
{
    return tp-&gt;notsent_lowat ?: sysctl_tcp_notsent_lowat;
}
</code></pre>

<pre><code>
#### 有I/O错误事件

sk-&gt;sk_error_report的实例为sock_def_error_report()。

在以下函数中会调用I/O错误事件处理函数：
</code></pre>

<pre><code>tcp_disconnect
tcp_reset
tcp_v4_err
tcp_write_err
</code></pre>

<pre><code></code></pre>

<pre><code>static void sock_def_error_report(struct sock *sk)
{
    struct socket_wq *wq; /* 等待队列和异步通知队列 */

    rcu_read_lock();
    wq = rcu_dereference(sk-&gt;sk_wq);
    if (wq_has_sleeper(wq)) /* 有进程阻塞在此socket上 */
        wake_up_interruptible_poll(&amp;wq-&gt;wait, POLLERR);

    /* 如果使用了异步通知，则发送SIGIO信号通知进程有错误 */
    sk_wake_async(sk, SOCK_WAKE_IO, POLL_ERR);
}

#define wake_up_interruptible_poll(x, m) \
    __wake_up(x, TASK_INTERRUPTIBLE, 1, (void *) (m))
</code></pre>

<p><code>``
最终也是调用</code>__wake_up_common()`，由于nr_exclusive为1，只会唤醒socket上的一个等待进程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Socket层实现系列 — 睡眠驱动的同步等待]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/06/12/kernel-net-socket-wakeup/"/>
    <updated>2015-06-12T17:16:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/06/12/kernel-net-socket-wakeup</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/45770323">http://blog.csdn.net/zhangskd/article/details/45770323</a></p>

<p>主要内容：Socket的同步等待机制，connect和accept等待的实现。</p>

<p>内核版本：3.15.2</p>

<h4>概述</h4>

<p>socket上定义了几个IO事件：状态改变事件、有数据可读事件、有发送缓存可写事件、有IO错误事件。对于这些事件，socket中分别定义了相应的事件处理函数，也称回调函数。</p>

<p>Socket I/O事件的处理过程中，要使用到sock上的两个队列：等待队列和异步通知队列，这两个队列中都保存着等待该Socket I/O事件的进程。</p>

<p>Q：为什么要使用两个队列，等待队列和异步通知队列有什么区别呢？<br/>
A：等待队列上的进程会睡眠，直到Socket I/O事件的发生，然后在事件处理函数中被唤醒。异步通知队列上的进程则不需要睡眠，Socket I/O事件发时，事件处理函数会给它们发送到信号，这些进程事先注册的信号处理函数就能够被执行。</p>

<h4>等待队列</h4>

<p>Socket层使用等待队列来进行阻塞等待，在等待期间，阻塞在此socket上的进程会睡眠。</p>

<pre><code>    struct sock {
        ...
        struct socket_wq __rcu *sk_wq; /* socket的等待队列和异步通知队列 */
        ...
    }

    struct socket_wq {
        /* Note: wait MUST be first field of socket_wq */
        wait_queue_head_t wait; /* 等待队列头 */
        struct fasync_struct *fasync_list; /* 异步通知队列 */
        struct rcu_head *rcu;
    };
</code></pre>

<h6>(1)  socket的等待队列头</h6>

<pre><code>    struct __wait_queue_head {
        spinlock_t lock;
        struct list_head task_list;
    };
    typedef struct __wait_queue_head wait_queue_head_t;
</code></pre>

<h5>(2) 进程的等待任务</h5>

<pre><code>    struct __wait_queue {
        unsigned int flags;
    #define WQ_FLAG_EXCLUSIVE 0x01
        void *private; /* 指向当前的进程控制块 */
        wait_queue_func_t func; /* 唤醒函数 */
        struct list_head task_list; /* 用于链接入等待队列 */
    };
    typedef struct __wait_queue wait_queue_t;
    typedef int (*wait_queue_func_t) (wait_queue_t *wait, unsigned mode, int flags, void *key);
    int default_wake_function(wait_queue_t *wait, unsigned mode, int flags, void *key);
</code></pre>

<h5>(3) 初始化等待任务</h5>

<pre><code>    #define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)

    #define DEFINE_WAIT_FUNC(name, function)    \
        wait_queue_t name = {    \
            .private = current,    \
            .func = function,    \
            .task_list = LIST_HEAD_INIT((name).task_list),    \
        }

    int autoremove_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key)
    {
        int ret = default_wake_function(wait, mode, sync, key); /* 默认的唤醒函数 */

        if (ret)
            list_del_init(&amp;wait-&gt;task_list); /* 从等待队列中删除 */

        return ret;
    }

    int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, void *key)
    {
        return try_to_wake_up(curr-&gt;private, mode, wake_flags);
    }
</code></pre>

<p>try_to_wake_up()通过把进程的状态设置为TASK_RUNNING，并把进程插入CPU运行队列，来唤醒睡眠的进程。</p>

<h5>(4) 把等待任务插入到等待队列中</h5>

<p>获取sock的等待队列。</p>

<pre><code>    static inline wait_queue_head_t *sk_sleep(struct sock *sk)
    {
        BUILD_BUG_ON(offsetof(struct socket_wq, wait) != 0);
        return &amp;rcu_dereference_raw(sk-&gt;sk_wq)-&gt;wait;
    }
</code></pre>

<p>把等待任务加入到等待队列中，同时设置当前进程的状态，TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE。</p>

<pre><code>    void prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state)
    {
        unsigned long flags;
        wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE; /* 可以同时唤醒多个等待进程 */

        spin_lock_irqsave(&amp;q-&gt;lock, flags);

        if (list_empty(&amp;wait-&gt;task_list))
            __add_wait_queue(q, wait); /* 把等待任务加入到等待队列的头部，会最先被唤醒 */

        set_current_state(state); /* 设置进程的状态 */

        spin_unlock_irqrestore(&amp;q-&gt;lock, flags);
    }
</code></pre>

<p>prepare_to_wait()和prepare_to_wait_exclusive()都是用来把等待任务加入到等待队列中，不同之处在于使用prepare_to_wait_exclusive()时，会在等待任务中添加WQ_FLAG_EXCLUSIVE标志，表示一次只能唤醒一个等待任务，目的是为了避免惊群现象。</p>

<pre><code>    void prepare_to_wait_exclusive(wait_queue_head_t *q, wait_queue_t *wait, int state)
    {
        unsigned long flags;

        /* 这个标志表示一次只唤醒一个等待任务，避免惊群现象 */
        wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;

        spin_lock_irqsave(&amp;q-&gt;lock, flags);

        if (list_empty(&amp;wait-&gt;task_list))
            __add_wait_queue_tail(q, wait); /* 把此等待任务加入到等待队列尾部 */

        set_current_state(state); /* 设置当前进程的状态 */

        spin_unlock_irqrestore(&amp;q-&gt;lock, flags);
    }

    static inline void __add_wait_queue_tail(wait_queue_head_t *head, wait_queue_t *new)
    {
        list_add_tail(&amp;new-&gt;task_list, &amp;head-&gt;task_list);
    }

    #define set_current_state(state_value)    \
        set_mb(current-&gt;state, (state_value))
</code></pre>

<h5>(5) 删除等待任务</h5>

<p>从等待队列中删除等待任务，同时把等待进程的状态置为可运行状态，即TASK_RUNNING。</p>

<pre><code>    /**
     * finish_wait - clean up after waiting in a queue
     * @q: waitqueue waited on，等待队列头
     * @wait: wait descriptor，等待任务
     *
     * Sets current thread back to running state and removes the wait
     * descriptor from the given waitqueue if still queued.
     */
    void finish_wait(wait_queue_head_t *q, wait_queue_t *wait)
    {
        unsigned long flags;
        __set_current_state(TASK_RUNNING);

        if (! list_empty_careful(&amp;wait-&gt;task_list)) {
            spin_lock_irqsave(&amp;q-&gt;lock, flags);

            list_del_init(&amp;wait-&gt;task_list); /* 从等待队列中删除 */

            spin_unlock_irqrestore(&amp;q-&gt;lock, flags);
        }
    }
</code></pre>

<h4>connect等待</h4>

<h5>(1) 睡眠</h5>

<p>connect()的超时时间为sk->sk_sndtimeo，在sock_init_data()中初始化为MAX_SCHEDULE_TIMEOUT，表示无限等待，可以通过SO_SNDTIMEO选项来修改。</p>

<pre><code>    static long inet_wait_for_connect(struct sock *sk, long timeo, int writebias)
    {
        DEFINE_WAIT(wait);  /* 初始化等待任务 */

        /* 把等待任务加入到socket的等待队列头部，把进程的状态设为TASK_INTERRUPTIBLE */
        prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);
        sk-&gt;sk_write_pending += writebias;

        /* Basic assumption: if someone sets sk-&gt;sk_err, he _must_ change state of the socket
         * from TCP_SYN_*. Connect() does not allow to get error notifications without closing
         * the socket.
         */

        /* 完成三次握手后，状态就会变为TCP_ESTABLISHED，从而退出循环 */
        while ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
            release_sock(sk); /* 等下要睡觉了，先释放锁 */

            /* 进入睡眠，直到超时或收到信号，或者被I/O事件处理函数唤醒。
             * 1. 如果是收到信号退出的，timeo为剩余的jiffies。
             * 2. 如果使用了SO_SNDTIMEO选项，超时退出后，timeo为0。
             * 3. 如果没有使用SO_SNDTIMEO选项，timeo为无穷大，即MAX_SCHEDULE_TIMEOUT，
             *      那么返回值也是这个，而超时时间不定。为了无限阻塞，需要上面的while循环。
             */
            timeo = schedule_timeout(timeo);

            lock_sock(sk); /* 被唤醒后重新上锁 */

            /* 如果进程有待处理的信号，或者睡眠超时了，退出循环，之后会返回错误码 */
            if (signal_pending(current) || !timeo)
                break;

            /* 继续睡眠吧 */
            prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);
        }

        /* 等待结束时，把等待进程从等待队列中删除，把当前进程的状态设为TASK_RUNNING */
        finish_wait(sk_sleep(sk), &amp;wait);
        sk-&gt;sk_write_pending -= writebias;
        return timeo;
    }
</code></pre>

<h5>(2) 唤醒</h5>

<p>三次握手中，当客户端收到SYNACK、发出ACK后，连接就成功建立了。此时连接的状态从TCP_SYN_SENT或TCP_SYN_RECV变为TCP_ESTABLISHED，sock的状态发生变化，会调用sock_def_wakeup()来处理连接状态变化事件，唤醒进程，connect()就能成功返回了。</p>

<p>sock_def_wakeup()的函数调用路径如下：
<code>
    tcp_v4_rcv
        tcp_v4_do_rcv
            tcp_rcv_state_process
                tcp_rcv_synsent_state_process
                    tcp_finish_connect
                        sock_def_wakeup
                            wake_up_interruptible_all
                                __wake_up
                                    __wake_up_common
</code></p>

<pre><code>    void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)
    {
        ...
        tcp_set_state(sk, TCP_ESTABLISHED); /* 在这里设置为连接已建立的状态 */
        ...
        if (! sock_flag(sk, SOCK_DEAD)) {
            sk-&gt;sk_state_change(sk); /* 指向sock_def_wakeup，会唤醒调用connect()的进程，完成连接的建立 */
            sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT); /* 如果使用了异步通知，则发送SIGIO通知进程可写 */
        }
    }
</code></pre>

<h4>accept等待</h4>

<p>(1) 睡眠</p>

<p>accept()超时时间为sk->sk_rcvtimeo，在sock_init_data()中初始化为MAX_SCHEDULE_TIMEOUT，表示无限等待。</p>

<pre><code>    /* Wait for an incoming connection, avoid race conditions.
     * This must be called with the socket locked.
     */
    static int inet_csk_wait_for_connect(struct sock *sk, long timeo)
    {
        struct inet_connection_sock *icsk = inet_csk(sk);
        DEFINE_WAIT(wait); /* 初始化等待任务 */
        int err;

        for (; ;) {
            /* 把等待任务加入到socket的等待队列中，把进程状态设置为TASK_INTERRUPTIBLE */
            prepare_to_wait_exclusive(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);

            release_sock(sk); /* 等下可能要睡觉了，先释放 */

            if (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue)) /* 如果全连接队列为空 */
                timeo = schedule_timeout(timeo); /* 进入睡眠直到超时或收到信号，或被IO事件处理函数唤醒 */

            lock_sock(sk); /* 醒来后重新上锁 */
            err = 0;
            /* 全连接队列不为空时，说明有新的连接建立了，成功返回 */
            if (! reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))
                break;

            err = -EINVAL;
            if (sk-&gt;sk_state != TCP_LISTEN) /* 如果sock不处于监听状态了，退出，返回错误码 */
                break;

            err = sock_intr_errno(timeo);

            /* 如果进程有待处理的信号，退出，返回错误码。
             * 因为timeo默认为MAX_SCHEDULE_TIMEOUT，所以err默认为-ERESTARTSYS。
             * 接下来会重新调用此函数，所以accept()依然阻塞。
             */
            if (signal_pending(current))
                break;

            err = -EAGAIN;
            if (! timeo) /* 如果等待超时，即超过用户设置的sk-&gt;sk_rcvtimeo，退出 */
                break;
        }

        /* 从等待队列中删除等待任务，把等待进程的状态设为TASK_RUNNING */
        finish_wait(sk_sleep(sk), &amp;wait);
        return err;
    }
</code></pre>

<h5>(2) 唤醒</h5>

<p>三次握手中，当服务器端接收到ACK完成连接建立的时候，会把新的连接链入全连接队列中，然后唤醒监听socket上的等待进程，accept()就能成功返回了。</p>

<p>三次握手时，当收到客户端的ACK后，经过如下调用：</p>

<pre><code>    tcp_v4_rcv
        tcp_v4_do_rcv
            tcp_child_process
                sock_def_readable
                    wake_up_interruptible_sync_poll
                        __wake_up_sync_key
                            __wake_up_common
</code></pre>

<p>最终调用我们给等待任务注册的唤醒函数。</p>

<p>我们来看下accept()是如何避免惊群现象的。</p>

<pre><code>    static void __wake_up_common(wait_queue_head_t *q, unsigned int mode, int nr_exclusive,
                                 int wake_flags, void *key)
    {
        wait_queue_t *curr, *next;

        list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) {
            unsigned flags = curr-&gt;flags;

            if (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE)
                !--nr_exclusive)
                break;
        }
    }
</code></pre>

<p>初始化等待任务时，flags |= WQ_FLAG_EXCLUSIVE。传入的nr_exclusive为1，表示只允许唤醒一个等待任务。</p>

<p>所以这里只会唤醒一个等待的进程，不会导致惊群现象。</p>
]]></content>
  </entry>
  
</feed>
