<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013~08 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013~08/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2016-05-11T20:15:01+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[git-svn]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/08/29/tools-git-svn-base/"/>
    <updated>2013-08-29T14:37:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/08/29/tools-git-svn-base</id>
    <content type="html"><![CDATA[<h4>常用</h4>

<pre><code>1、git-svn clone your_svn_repository
2、git add/commit
3、git-svn rebase  获取中心svn repository的更新；
4、git-svn dcommit 将本地git库的修改同步到中心svn库。
</code></pre>

<hr />

<p>git-svn默认包含在Git的安装包中，不过在Ubuntu中，git-svn是作为一个独立的Package需要额外安装的(sudo apt-get install git-svn)。安装后你就可以使用git svn xxx命令来操作中心SVN代码库了。当然如果你要使用与git svn等价的git-svn命令的话，你还需要将/usr/lib/git-core配置到你的PATH环境变量中，否则Shell会提示你无法找到 git-svn这个命令。</p>

<ul>
<li><p>检出一个已存在svn repository(类似于svn checkout)<br/>
我们可以通过git-svn clone命令完成这个操作： git-svn clone your_svn_repository_url</p></li>
<li><p>从中心服务器的svn repository获取最新更新<br/>
这个操作可以通过"git-svn rebase"完成。注意这里用的是rebase，而不是update。update命令对于通过git-svn检出的svn repostory的git版本库是不可用的。</p></li>
<li><p>查看提交历史日志<br/>
这个简单，使用"git-svn log"，加上-v选项，还可以提供每次commit操作涉及的相关文件的详细信息。</p></li>
<li><p>将本地代码同步到Svn服务器<br/>
完成这一操作需要通过"git-svn dcommit"命令。这个命令会将你在本地使用git commit提交到本地代码库的所有更改逐一提交到svn库中。加上-n选项，则该命令不会真正执行commit到svn的操作，而是会显示会有哪些本地 变动将被commit到svn服务器。git-svn dcommit似乎不能单独提交某个本地版本的修改，而是一次批量提交所有与svn中心版本库的差异。</p></li>
</ul>


<h5>下面是一个git-svn的一般使用流程：</h5>

<p>1、git-svn clone your_svn_repository；<br/>
2、修改本地代码，使用git add/commit将修改提交到本地git库；<br/>
3、定期使用git-svn rebase获取中心svn repository的更新；<br/>
4、使用git-svn dcommit命令将本地git库的修改同步到中心svn库。</p>

<h5>冲突</h5>

<p>使用git-svn处理代码冲突的步骤有些繁琐，不过瑕不掩瑜吧。这里用一个小例子来说明一下。</p>

<p>假设某svn中心库上的某个项目foo中只有一个源码文件foo.c：<br/>
* 我在使用git-svn clone检出版本时，foo.c当时只有一个commit版本信息："svn v1"；<br/>
* clone出来后，我在本地git库中修改foo.c，并通过git commit提交到本地git库中，版本为"git v1"；<br/>
* 不过与此同时另外一个同事也在修改foo.c这个文件，并已经将他的修改提交到了svn库中，版本为"svn v2"；<br/>
* 此时我使用git-svn dcommit尝试提交我的改动，git-svn提示我：<br/>
  Committing to svn://10.10.1.1:80/foo &hellip;<br/>
  M foo.c<br/>
  事务过时: 过期: ”foo/foo.c“在事务“260-1” at /usr/lib/git-core/git-svn line 570<br/>
* 使用git-svn rebase获取svn服务器上的最新foo.c，导致与foo.c冲突，不过此时svn版本信息已经添加到本地git库中(通过git log可以查看)，git-svn rebase提示你在解决foo.c的冲突后，运行git rebase &ndash;continue完成rebase操作；<br/>
* 打开foo.c，修改代码，解决冲突；<br/>
* 执行git rebase &ndash;continue，git提示我：<br/>
You must edit all merge conflicts and then<br/>
mark them as resolved using git add<br/>
* 执行git add foo.c，告知git已完成冲突解决；<br/>
* 再次执行git rebase &ndash;continue，提示"Applying: git v1"，此时"git v1"版本又一次成功加入本地版本库，你可通过git log查看；<br/>
* 执行git-svn dcommit将foo.c的改动同步到svn中心库，到此算是完成一次冲突解决。</p>

<ul>
<li>设置忽略文件<br/>
要忽略某些文件, 需要首先执行如下命令:<br/>
git config &ndash;global core.excludesfile ~/.gitignore<br/>
然后编辑 vi ~/.gitignore.<br/>
例如: 需要忽略vim的临时文件，就写:<br/>
.*.swp</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析pcap数据包格式(code)]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/08/26/kernel-pcap-decode-code/"/>
    <updated>2013-08-26T11:17:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/08/26/kernel-pcap-decode-code</id>
    <content type="html"><![CDATA[<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;arpa/inet.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;string.h&gt;
    #include &lt;linux/types.h&gt;

    typedef unsigned int  bpf_u_int32;
    typedef unsigned short  u_short;
    typedef int bpf_int32;
    typedef struct pcap_file_header {
        bpf_u_int32 magic;
        u_short version_major;
        u_short version_minor;
        bpf_int32 thiszone;
        bpf_u_int32 sigfigs;   
        bpf_u_int32 snaplen;   
        bpf_u_int32 linktype;  
    }pcap_file_header;

    typedef struct  timestamp{
        bpf_u_int32 timestamp_s;
        bpf_u_int32 timestamp_ms;
    }timestamp;

    typedef struct pcap_header{
        timestamp ts;
        bpf_u_int32 capture_len;
        bpf_u_int32 len;

    }pcap_header;


    #define ETH_ALEN 6
    #define __LITTLE_ENDIAN_BITFIELD 1
    #define NIPQUAD(addr) \
            ((unsigned char *)&amp;addr)[0], \
            ((unsigned char *)&amp;addr)[1], \
            ((unsigned char *)&amp;addr)[2], \
            ((unsigned char *)&amp;addr)[3]


    struct ethhdr {
        unsigned char   h_dest[ETH_ALEN];       /* destination eth addr */
        unsigned char   h_source[ETH_ALEN];     /* source ether addr    */
        unsigned short  h_proto;                /* packet type ID field */
    };

    struct iphdr {
    #if defined(__LITTLE_ENDIAN_BITFIELD)
        __u8    ihl:4,
                version:4;
    #elif defined (__BIG_ENDIAN_BITFIELD)
        __u8    version:4,
                ihl:4;
    #endif
        __u8    tos;
        __be16  tot_len;
        __be16  id;
        __be16  frag_off;
        __u8    ttl;
        __u8    protocol;
        __u16   check;
        __be32  saddr;
        __be32  daddr;
        /*The options start here. */
    };

    struct tcphdr {
        __u16   source;
        __u16   dest;
        __u32   seq;
        __u32   ack_seq;
    #if defined(__LITTLE_ENDIAN_BITFIELD)
        __u16   res1:4,
                doff:4,
                fin:1,
                syn:1,
                rst:1,
                psh:1,
                ack:1,
                urg:1,
                ece:1,
                cwr:1;
    #elif defined(__BIG_ENDIAN_BITFIELD)
        __u16   doff:4,
                res1:4,
                cwr:1,
                ece:1,
                urg:1,
                ack:1,
                psh:1,
                rst:1,
                syn:1,
                fin:1;
    #endif  
        __u16   window;
        __u16   check;
        __u16   urg_ptr;
    };

    struct udphdr {
        __u16   source;
        __u16   dest;
        __u16   len;
        __u16   check;
    };

    struct icmphdr {
        __u8    type;
        __u8    code;
        __u16   checksum;
        union {
            struct {
                __u16   id;
                __u16   sequence;
            } echo;
            __u32   gateway;
            struct {
                __u16   __unused;
                __u16   mtu;
            } frag;
        } un;
    };

    FILE *fp1, *fp2;
    __u32 flag1, flag2, seq1, seq2, ip1, ip2;
    long long stime;

    void printPcap(int count, void * data, struct pcap_header *ph)
    {
        size_t size = ph-&gt;capture_len;
        unsigned  short iPos = 0;
        struct ethhdr *eth;
        struct iphdr *iph;
        struct tcphdr *tcph;
        struct udphdr *udph;
        struct icmphdr *icmph;
        __u8 op1, op2, type, len;
        void * data1;
        int i;
        long long dt;

        if (data==NULL) {
            return;
        }
        eth = (struct ethhdr*)(data);
        eth-&gt;h_proto = ntohs(eth-&gt;h_proto);
        //printf("Ether:\tproto = 0x%x\n", eth-&gt;h_proto);
        if (eth-&gt;h_proto == 0x0800) { // IP
            iph = (struct iphdr*)(data+sizeof(struct ethhdr));
            if (iph-&gt;protocol == IPPROTO_TCP) { // tcp
                tcph = (struct tcphdr*)(data+sizeof(struct ethhdr)+sizeof(struct iphdr));
                if (tcph-&gt;ack == 0 &amp;&amp; tcph-&gt;syn == 1) {
                    seq1 = ntohl(tcph-&gt;seq);
                    ip1 = iph-&gt;saddr;
                    flag1 = 1;
                    stime = 1000000LL*ph-&gt;ts.timestamp_s + ph-&gt;ts.timestamp_ms;
                } else if (tcph-&gt;ack == 1 &amp;&amp; tcph-&gt;syn == 1) {
                    seq2 = ntohl(tcph-&gt;seq);
                    ip2 = iph-&gt;saddr;
                    flag2 = 1;
                }

                if (flag1 == 0) {
                    flag1 = 1;
                    seq1 = ntohl(tcph-&gt;seq)-1;
                    ip1 = iph-&gt;saddr;
                    stime = 1000000LL*ph-&gt;ts.timestamp_s + ph-&gt;ts.timestamp_ms;
                }
                if (flag2 == 0 &amp;&amp; iph-&gt;saddr != ip1) {
                    flag2 = 1;
                    seq2 = ntohl(tcph-&gt;seq)-1;
                    ip2 = iph-&gt;saddr;
                }

                dt = (1000000LL*ph-&gt;ts.timestamp_s+ph-&gt;ts.timestamp_ms) - stime;
                fprintf(fp1, "%d\t%llu\t", count, dt/1000);
                fprintf(fp1, "%d.%d.%d.%d\t%d.%d.%d.%d\t%u\t%u\t%d\t",
                            NIPQUAD(iph-&gt;saddr), NIPQUAD(iph-&gt;daddr),
                            (iph-&gt;saddr==ip1?ntohl(tcph-&gt;seq)-seq1:ntohl(tcph-&gt;seq)-seq2),
                            (iph-&gt;saddr==ip1?ntohl(tcph-&gt;ack_seq)-seq2:ntohl(tcph-&gt;ack_seq)-seq1),
                            ntohs(iph-&gt;tot_len)-iph-&gt;ihl*4-tcph-&gt;doff*4 + tcph-&gt;syn + tcph-&gt;fin);
                fprintf(fp1, "%d\t%d\t%d\t%d\t", ntohs(iph-&gt;tot_len), iph-&gt;ihl*4, tcph-&gt;doff*4, iph-&gt;ttl);
                fprintf(fp1, "%u\t%u\t%d\t%d\t%d\t",
                            ntohl(tcph-&gt;seq), ntohl(tcph-&gt;ack_seq),
                            tcph-&gt;ack, tcph-&gt;syn, ntohs(tcph-&gt;window));

                if (tcph-&gt;doff &gt; 5) {
                    data1 = data + sizeof(struct ethhdr)+sizeof(struct iphdr)+sizeof(struct tcphdr);
                    op1 = *(__u8*)(data1);
                    op2 = *(__u8*)(data1+1);
                    type = *(__u8*)(data1+2);
                    len = *(__u8*)(data1+3);
                    //fprintf(fp1, "%u\t%u\t%u\t%u\n", op1, op2, type, len);
                    if (op1 == 1 &amp;&amp; op2 == 1 &amp;&amp; type == 5) { // sack
                        i = 4;
                        while (i &lt; len+2) {
                            if (i &gt; 4) fprintf(fp1, " ");
                            fprintf(fp1, "%u-%u", ntohl(*(__u32*)(data1+i))-seq2, ntohl(*(__u32*)(data1+i+4))-seq2);
                            i += 8;
                        }
                    }
                }
                fprintf(fp1, "\n");

            } else if (iph-&gt;protocol == IPPROTO_UDP) { // udp
                udph = (struct udphdr*)(data+sizeof(struct ethhdr)+sizeof(struct iphdr));
                //printf("UDP:\tsource=%u\tdest=%u\tlen=%d\n", ntohs(udph-&gt;source), ntohs(udph-&gt;dest), ntohs(udph-&gt;len));
            } else if (iph-&gt;protocol == IPPROTO_ICMP) { // ICMP
                icmph = (struct icmphdr*)(data+sizeof(struct ethhdr)+sizeof(struct iphdr));
                //printf("ICMP:\ttype=%u\tcode=%u\n", icmph-&gt;type, icmph-&gt;code);
            }
        }
    }

    #define MAX_ETH_FRAME 1514000
    int main (int argc, const char * argv[])
    {
        pcap_file_header  pfh;
        pcap_header  ph;
        int count=0;
        void * buff = NULL;
        int readSize=0;
        int ret = 0;

         if (argc != 2) {
             printf("uage: ./a.out pcap_filename\n");
             return -1;
         }
        FILE *fp = fopen(argv[1], "r");
        if (fp==NULL) {
            fprintf(stderr, "Open file %s error.", argv[1]);
            return -1;
        }
        fread(&amp;pfh, sizeof(pcap_file_header), 1, fp);

        fp1 = fopen("out", "w");
        fprintf(fp1, "#ID\tTIME\tsaddr\tdaddr\tseq\tack_seq\tpayload\ttot_len\tihl\tdoff\tttl\tseq\tack_seq\tack\tsyn\twin\tSACK\n");
        buff = (void *)malloc(MAX_ETH_FRAME);
        flag1 = flag2 = 0;

        for (count=1; ; count++) {
            memset(buff,0,MAX_ETH_FRAME);
            readSize=fread(&amp;ph, sizeof(pcap_header), 1, fp);
            if (readSize&lt;=0) {
                break;
            }
            if (buff==NULL) {
                fprintf(stderr, "malloc memory failed.\n");
                return -1;
            }

            readSize=fread(buff,1,ph.capture_len, fp);
            if (readSize != ph.capture_len) {
                free(buff);
                fprintf(stderr, "pcap file parse error.\n");
                return -1;
            }
            printPcap(count, buff, &amp;ph);

            if (feof(fp) || readSize &lt;=0 ) {
                break;
            }
        }
        fclose(fp);
        fclose(fp1);
        return ret;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析pcap数据包格式]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/08/26/kernel-pcap-decode/"/>
    <updated>2013-08-26T11:17:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/08/26/kernel-pcap-decode</id>
    <content type="html"><![CDATA[<p>  协议是一个比较复杂的协议集，有很多专业书籍介绍。在此，我仅介绍其与编程密切相关的部分：以太网上TCP/IP协议的分层结构及其报文格式。<br/>
我们知道TCP/IP协议采用分层结构，其分层模型及协议如下表：<br/>
应　用　层 (Application) HTTP、Telnet、FTP、SMTP、SNMP<br/>
传　输　层 (Transport) TCP、UDP<br/>
网 间 网层  (Internet) IP【ARP、RARP、ICMP】<br/>
网络接口层 (Network) Ethernet、X.25、SLIP、PPP</p>

<p>  协议采用分层结构，因此，数据报文也采用分层封装的方法。下面以应用最广泛的以太网为例说明其数据报文分层封装，如下图所示：</p>

<p><img src="/images/kernel/2013-08-26-1.png" alt="" /></p>

<p>  任何通讯协议都有独特的报文格式，TCP/IP协议也不例外。对于通讯协议编程，我们首先要清楚其报文格式。由于TCP/IP协议采用分层模型，各层都有专用的报头，以下就简单介绍以太网下TCP/IP各层报文格式。</p>

<p><img src="/images/kernel/2013-08-26-2.png" alt="" /></p>

<p>  8字节的前导用于帧同步，CRC域用于帧校验。这些用户不必关心其由网卡芯片自动添加。目的地址和源地址是指网卡的物理地址，即MAC地址，具有唯一性。帧类型或协议类型是指数据包的高级协议，如 0x0806表示ARP协议，0x0800表示IP协议等。</p>

<p>　　ARP/RARP（地址解析/反向地址解析）报文格式如下图：</p>

<p><img src="/images/kernel/2013-08-26-3.png" alt="" /></p>

<p> “硬件类型”域指发送者本机网络接口类型（值“1”代表以太网）。“协议类型”域指发送者所提供/请求的高级协议地址类型（“0x0800”代表 IP协议）。“操作”域指出本报文的类型（“1”为ARP请求，“2”为ARP响应，“3”为RARP请求，“4”为RARP响应）。</p>

<p>　　IP数据报头格式如下图：</p>

<p><img src="/images/kernel/2013-08-26-4.png" alt="" /></p>

<p>　　我们用单片机实现TCP/IP协议要作一些简化，不考虑数据分片和优先权。因此，在此我们不讨论服务类型和标志偏移域，只需填“0” 即可。协议“版本”为4，“头长度”单位为32Bit，“总长度”以字节为单位，表示整个IP数据报长度。“标识”是数据包的ID号，用于识别不同的IP 数据包。“生存时间” TTL是个数量及的概念，防止无用数据包一直存在网络中。一般每经过路由器时减一，因此通过TTL 可以算出数据包到达目的地所经过的路由器个数。“协议”域表示创建该数据包的高级协议类型。如 1表示ICMP协议，6表示TCP协议，17表示 UDP协议等。IP数据包为简化数据转发时间，仅采用头校验的方法，数据正确性由高层协议保证。</p>

<p>　　ICMP（网间网控制报文协议）协议 应用广泛。在此仅给出最常见的回应请求与应答报文格式，用户命令ping便是利用此报文来测试信宿机的可到达性。报文格式如下图所示：</p>

<p><img src="/images/kernel/2013-08-26-5.png" alt="" /></p>

<p>　　类型0 为回应应答报文，8 为回应请求报文。整个数据包均参与检验。注意ICMP封装在IP数据包里传送。</p>

<p>　　UDP报文格式如下图：</p>

<p><img src="/images/kernel/2013-08-26-6.png" alt="" /></p>

<p>　　TCP报文格式如下图：</p>

<p><img src="/images/kernel/2013-08-26-7.png" alt="" /></p>

<hr />

<p>WireShark捕获的数据</p>

<p><img src="/images/kernel/2013-08-26-8.jpg" alt="" /></p>

<pre><code>            以下为物理层的数据帧概况

Frame 1 (62 bytes on wire, 62 bytes captured)           1号帧，线路62字节，实际捕获62字节
Arrival Time: Jan 21, 2008 15:17:33.910261000           捕获日期和时间
[Time delta from previous packet:0.00000 seconds]       此包与前一包的时间间隔
[Time since reference or first frame: 0.00 seconds]     此包与第1帧的间隔时间
Frame Number: 1                                         帧序号
Packet Length: 62 bytes                                 帧长度
Capture Length: 62 bytes                                捕获长度
[Frame is marked: False]                                此帧是否做了标记：否
[Protocols in frame: eth:ip:tcp]                        帧内封装的协议层次结构
[Coloring Rule Name: HTTP]                              用不同颜色染色标记的协议名称：HTTP
[Coloring Rule String: http || tcp.port == 80]          染色显示规则的字符串：


            以下为数据链路层以太网帧头部信息
Ethernet II, Src: AcerTech_5b:d4:61 (00:00:e2:5b:d4:61), Dst: Jetcell_e5:1d:0a (00:d0:2b:e5:1d:0a)
以太网协议版本II，源地址：厂名_序号（网卡地址），目的：厂名_序号（网卡地址）
 Destination: Jetcell_e5:1d:0a (00:d0:2b:e5:1d:0a)       目的：厂名_序号（网卡地址）
 Source: AcerTech_5b:d4:61 (00:00:e2:5b:d4:61)           源：厂名_序号（网卡地址）
 Type: IP (0x0800)                                       帧内封装的上层协议类型为IP（十六进制码0800）看教材70页图3.2

            以下为互联网层IP包头部信息
Internet Protocol, Src: 202.203.44.225 (202.203.44.225), Dst: 202.203.208.32 (202.203.208.32)
互联网协议，源IP地址，目的IP地址
Version: 4                                                       互联网协议IPv4
Header length: 20 bytes                                          IP包头部长度
Differentiated Services Field:0x00(DSCP 0x00:Default;ECN:0x00)   差分服务字段
Total Length: 48                                                 IP包的总长度
Identification:0x8360 (33632)                                    标志字段
Flags:                                                           标记字段（在路由传输时，是否允许将此IP包分段）
Fragment offset: 0                                               分段偏移量（将一个IP包分段后传输时，本段的标识）
Time to live: 128                                                生存期TTL
Protocol: TCP (0x06)                                             此包内封装的上层协议为TCP
Header checksum: 0xe4ce [correct]                                头部数据的校验和
Source: 202.203.44.225 (202.203.44.225)                          源IP地址
Destination: 202.203.208.32 (202.203.208.32)                     目的IP地址

            以下为传输层TCP数据段头部信息
Transmission Control Protocol, Src Port: 2764 (2764), Dst Port: http (80), Seq: 0, Len: 0   传输控制协议TCP的内容
Source port: 2764 (2764）                              源端口名称（端口号）
Destination port: http (80)                            目的端口名http（端口号80）
Sequence number: 0    (relative sequence number)       序列号（相对序列号）
Header length: 28 bytes                                头部长度
Flags: 0x02 (SYN)                                      TCP标记字段（本字段是SYN，是请求建立TCP连接）
Window size: 65535                                     流量控制的窗口大小
Checksum: 0xf73b [correct]                             TCP数据段的校验和
Options: (8 bytes)                                     可选项
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核调试转储工具kdump crash]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/08/21/debug-kdump-base/"/>
    <updated>2013-08-21T17:21:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/08/21/debug-kdump-base</id>
    <content type="html"><![CDATA[<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-kdump4/index.html">http://www.ibm.com/developerworks/cn/linux/l-cn-kdump4/index.html</a></p>

<pre><code>$ crash vmlinux vmcore 
crash&gt; bt
crash&gt; dis -l ffffffff80081000
crash&gt; gdb x/8ub ffffffff90091000
......
</code></pre>

<p>如果是未完成文件可以尝试以最小方式调试
<code>
$ crash --minimal vmlinux vmcore
crash&gt; log
</code>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>crash_H_args_xbt&gt; mod -S
</span><span class='line'> MODULE   NAME       SIZE  OBJECT FILE
</span><span class='line'>c8019000  soundcore 2788  /lib/modules/2.2.5-15/misc/soundcore.o
</span><span class='line'>。。。
</span><span class='line'>crash_H_args_xbt&gt; mod -s soundcore
</span><span class='line'> MODULE   NAME       SIZE  OBJECT FILE
</span><span class='line'>c8019000  soundcore 2788  /lib/modules/2.2.5-15/misc/soundcore.o
</span><span class='line'>crash_H_args_xbt&gt; mod -d soundcore
</span><span class='line'>crash_H_args_xbt&gt; mod -s soundcore /tmp/soundcore.o
</span><span class='line'> MODULE   NAME       SIZE  OBJECT FILE
</span><span class='line'>c8019000  soundcore 2788  /tmp/soundcore.o&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;-------------------
</span><span class='line'>
</span><span class='line'>#### 1、kdump介绍与设置
</span><span class='line'>##### 1）介绍：
</span><span class='line'>Kdump 是一种基于 kexec 的内存转储工具，目前它已经被内核主线接收，成为了内核的一部分，它也由此获得了绝大多数 Linux 发行版的支持。与传统的内存转储机制不同不同，基于 Kdump 的系统工作的时候需要两个内核，一个称为系统内核，即系统正常工作时运行的内核；另外一个称为捕获内核，即正常内核崩溃时，用来进行内存转储的内核。
</span><span class='line'>
</span><span class='line'>安装crash，kexec-tools
</span><span class='line'>
</span><span class='line'>##### 2）设置
</span><span class='line'>查看/boot/grub/grub.conf文件中kernel一行最后是否有crashkernel=128M@64M，如果没有，添加上去，重启  
</span><span class='line'>如何设定 crashkernel 参数  
</span><span class='line'>在 kdump 的配置中，往往困惑于 crashkernel 的设置。“crashkernel=X@Y”，X 应该多大？ Y 又应该设在哪里呢？实际我们 可以完全省略“@Y”这一部分，这样，kernel 会为我们自动选择一个起始地址。而对于 X 的大小，般对 i386/x86_64 的系统， 设为 128M 即可；对于 powerpc 的系统，则要设为 256M。rhel6 引入的“auto”已经要被放弃了，代之以原来就有的如下语法：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;crashkernel=&lt;range1&gt;:&lt;size1&gt;[,&lt;range2&gt;:&lt;size2&gt;,...][@offset] 
</span><span class='line'>      range=start-[end] 
</span><span class='line'>      'start' is inclusive and 'end' is exclusive. 
</span><span class='line'>
</span><span class='line'>      For example: 
</span><span class='line'>      crashkernel=512M-2G:64M,2G-:128M
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;如何判断捕获内核是否加载  
</span><span class='line'>可通过查看 /sys/kernel/kexec_crash_loaded 的值。“1”为已经加载，“0”为还未加载。  
</span><span class='line'>缩小 crashkernel  
</span><span class='line'>可以通过向 /sys/kernel/kexec_crash_size 中输入一个比其原值小的数来缩小甚至完全释放 crashkernel。  
</span><span class='line'>
</span><span class='line'>##### 3）测试kdump是否可用
</span><span class='line'>执行
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;echo 1 &gt; /proc/sys/kernel/sysrq
</span><span class='line'>echo c &gt; /proc/sysrq-trigger</span></code></pre></td></tr></table></div></figure>
经过两次自动重启后，查看/var/crash/目录下是否有vmcore文件生成,如果有表示kdump可用</p>

<h4>2、生成带调试信息的vmlinux文件</h4>

<h5>1）</h5>

<p>centos: debuginfo.centos.org</p>

<h5>2）按顺序安装</h5>

<p>kernel-debuginfo-common-2.6.18-194.3.1.el5.i686.rpm和kernel-debuginfo-2.6.18-194.3.1.el5.i686.rpm，
之后会在/usr/lib/debug/lib/modules/2.6.18-194.3.1.el5/下生产vmlinux文件<br/>
或在源码里make binrpm-pkg -j8，然后该目录下会生成一个vmlinux<br/>
在编译内核之前，需要确认.config中，以下编译选项是否打开：</p>

<blockquote><p>（1）CONFIG_DEBUG_INFO ，必须打开该选项，否则crash会出现以下错误：<br/>
  crash no debugging data available<br/>
（2）CONFIG_STRICT_DEVMEM,必须打开该选项，否则crash会出现以下错误：<br/>
  crash: read error: kernel virtual address: c0670680  type: &ldquo;kernel_config_data&rdquo;<br/>
  WARNING: cannot read kernel_config_data<br/>
  crash: read error: kernel virtual address: c066bb68  type: &ldquo;cpu_possible_mask&rdquo;</p></blockquote>

<h4>3、进入vmlinux所在目录，</h4>

<p>执行crash /var/crash/2012-03-13-21:05/vmcore vmlinux <br/>
mod -S XXX  &ndash;导入XXX目录下所有符号<br/>
log &ndash;查看日志文件，找到最后一条，如EIP: [<f8ee53f5>] bshtej_interrupt+0x103f/0x11cb [tej21] SS:ESP 0068:c0768f38<br/>
l* bshtej_interrupt+0x103f 出现如下内容<br/>
<code>
0xf8ee53f5 is in bshtej_interrupt (/opt/dahdi-linux-complete-2.2.1+2.2.1/linux/drivers/dahdi/tej21/tej21.c:2910).
2904            int c, x;
2905
2906
2907            for(c = 0; c &lt; MAX_CARDS; c++)
2908            {
2909                if (!cards[c]) break;
2910                for (x=0;x&lt;cards[c]-&gt;numspans;x++) {
2911                    if (cards[c]-&gt;tspans[x]-&gt;sync)
2912                    {
2913
</code>
到此可确定死机问题出现在2910行。</p>

<h4>4、设置过滤等级：</h4>

<p>vmcore文件一般会收集内核崩溃时的各种信息，所以生成时间会较长，文件比较大，如果不需要某些信息的话，可对kdump.conf文件进行配置
<code>
vim  /etc/kdump.conf
</code>
将core_collector makedumpfile -c 这行打开，并加上-d 31，参数说明如下：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-c: Compress dump data by each page.
</span><span class='line'>-d: Specify the type of unnecessary page for analysis.
</span><span class='line'>    Dump  | zero    cache   cache   user    free
</span><span class='line'>    Level | page    page    private data    page
</span><span class='line'>  &mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
</span><span class='line'>    0  |
</span><span class='line'>    1  |    X
</span><span class='line'>    2  |        X
</span><span class='line'>    4  |        X   X
</span><span class='line'>    8  |                X
</span><span class='line'>    16  |                   X
</span><span class='line'>    31  |   X   X   X   X   X&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;5、根据Oops值大致判断错误：&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Oops的错误代码根据错误的原因会有不同的定义如果发现自己遇到的Oops和下面无法对应的话，最好去内核代码里查找：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>* error_code:
</span><span class='line'> *    bit 0 == 0 means no page found, 1 means protection fault
</span><span class='line'> *    bit 1 == 0 means read, 1 means write
</span><span class='line'> *    bit 2 == 0 means kernel, 1 means user-mode
</span><span class='line'> *    bit 3 == 0 means data, 1 means instruction
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>    &lt;title type="html"&gt;&lt;![CDATA[GCC内嵌汇编]]&gt;&lt;/title&gt;
</span><span class='line'>    &lt;link href="http://abcdxyzk.github.io/blog/2013/08/15/assembly-base-4/"/&gt;
</span><span class='line'>    &lt;updated&gt;2013-08-15T14:12:00+08:00&lt;/updated&gt;
</span><span class='line'>    &lt;id&gt;http://abcdxyzk.github.io/blog/2013/08/15/assembly-base-4&lt;/id&gt;
</span><span class='line'>    &lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;  内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;一、基本内嵌汇编&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  GCC提供了很好的内嵌汇编支持，最基本的格式是：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__ __volatile__&lt;/code&gt;(汇编语句模板);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;1、&lt;strong&gt;asm&lt;/strong&gt;&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  &lt;code&gt;__asm__&lt;/code&gt;是GCC关键字asm的宏定义：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;#define __asm__ asm&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>  &lt;code&gt;__asm__&lt;/code&gt;或asm用来声明一个内嵌汇编表达式，所以任何一个内嵌汇编表达式都是以它开头的，是必不可少的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;2、汇编语句模板&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt; “汇编语句模板”是一组插入到C程序中的汇编指令(可以是单个指令，也可以是一组指令)。每条指令都应该由双引号括起，或者整组指令应该由双引号括起。每条指令还应该用一个定界符结尾。有效的定界符为换行符(\n)和分号(;)。\n后可以跟一个制表符(\t)作为格式化符号，增加GCC在汇编文件中生成的指令的可读性。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  上述原则可以归结为：&lt;br/&gt;
</span><span class='line'>①任意两个指令间要么被分号(;)分开，要么被放在两行；&lt;br/&gt;
</span><span class='line'>②放在两行的方法既可以通过\n的方法来实现，也可以真正的放在两行；&lt;br/&gt;
</span><span class='line'>③可以使用一对或多对双引号，每对双引号里可以放任意多条指令，所有的指令都必须放到双引号中。&lt;br/&gt;
</span><span class='line'>  在基本内嵌汇编中，“汇编语句模板”的书写的格式和你直接在汇编文件中使用汇编语言编程没有什么不同，你可以在其中定义标号(Label)，定义对齐(.align n)，定义段(.section name)。例如：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>    __asm__(".align 2\n\t"
</span><span class='line'>    "movl %eax, %ebx\n\t"
</span><span class='line'>    "test %ebx, %ecx\n\t"
</span><span class='line'>    "jne error\n\t"
</span><span class='line'>    "sti\n\t"
</span><span class='line'>    "error: popl %edi\n\t"
</span><span class='line'>    "subl %ecx, %ebx");
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>建议大家都使用这种格式来写内嵌汇编代码。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;3、&lt;strong&gt;volatile&lt;/strong&gt;&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  &lt;code&gt;__volatile__&lt;/code&gt;是GCC关键字volatile的宏定义：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;#define __volatile__ volatile&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>  &lt;code&gt;__volatile__&lt;/code&gt;或&lt;code&gt;volatile&lt;/code&gt;是可选的。如果不想让GCC的优化改动你的内嵌汇编代码，你最好在前面都加上&lt;code&gt;__volatile__&lt;/code&gt;。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;二、带C语言表达式的内嵌汇编&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  在内嵌汇编中，可以将C语言表达式指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入哪个寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可，GCC会自动插入代码完成必要的操作。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  通常嵌入到C代码中的汇编语句很难做到与其它部分没有任何关系，因此更多时候需要用到扩展的内嵌汇编格式：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__ __volatile__&lt;/code&gt;(汇编语句模板 : 输出部分 : 输入部分 : 破坏描述部分);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  内嵌汇编表达式包含4个部分，各部分由“:”分隔。这4个部分都不是必须的，任何一个部分都可以为空，其规则为：&lt;br/&gt;
</span><span class='line'>①如果“破坏描述部分”为空，则其前面的“:”必须省略。比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("mov %%eax, %%ebx" : :);&lt;/code&gt;。
</span><span class='line'>②如果“汇编语句模板”为空，则“输出部分”，“输入部分”以及“破坏描述部分”可以不为空，也可以为空。比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("" : : : "memory");&lt;/code&gt;。
</span><span class='line'>③如果“输出部分”，“输入部分”以及“破坏描述部分”都为空，“输出部分”和“输入部分”之前的“:”既可以省略，也可以不省略。如果都省略，则此汇编退化为一个基本内嵌汇编，否则，仍然是一个带有C语言表达式的内嵌汇编。&lt;br/&gt;
</span><span class='line'>④如果“输入部分”和“破坏描述部分”为空，但“输出部分”不为空，“输入部分”前的“:”既可以省略，也可以不省略。&lt;br/&gt;
</span><span class='line'>⑤如果后面的部分不为空，而前面的部分为空，则前面的“:”都必须保留，否则无法说明不为空的部分究竟是第几部分。&lt;br/&gt;
</span><span class='line'>⑥如果“破坏描述部分”不为空，而“输出部分”和“输入部分”都为空，则“输出部分”和“输入部分”前的“:”都必须保留。&lt;br/&gt;
</span><span class='line'>  从上面的规则可以看到另外一个事实，区分一个内嵌汇编是基本格式的还是扩展格式的，其规则在于在“汇编语句模板”后面是否有“:”的存在，如果没有则是基本格式的，否则，就是扩展格式的。&lt;br/&gt;
</span><span class='line'>  这两种格式对寄存器语法的要求不同：基本格式要求寄存器前只能使用一个%，这一点和原生汇编相同；而扩展格式则要求寄存器前必须使用两个%%。比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("mov %%eax, %%ebx" :)&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>和&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("mov %eax, %ebx")&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>都是正确的写法，而&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("mov %eax, %ebx" :)&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>和&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("mov %%eax, %%ebx")&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>都是错误的写法。任何只带一个“%”的标识符都看成是操作数，而不是寄存器。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;1、内嵌汇编举例&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  使用内嵌汇编，要先编写汇编语句模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些约束条件。例如在下面的汇编语句：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("movl %1, %0" : "=r"(result) : "m"(input));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>“movl %1,%0”是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，内嵌汇编靠它们将C语言表达式与指令操作数相对应。指令模板后面用圆括号括起来的是C语言表达式，本例中只有两个：“result”和“input”，他们按照在输出部分和输入部分出现的顺序分别与指令操作数“%0”，“%1”对应；注意对应顺序：第一个C语言表达式对应“%0”；第二个表达式对应“%1”，依次类推。在每个操作数前面有一个用双引号括起来的字符串，字符串的内容是对该操作数的约束或者说要求。“result”前面的约束字符串是“=r”，其中“=”表示“result”在指令中是只写的(输出操作数)，“r”表示需要将“result”与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而不是“result”本身，当然指令执行完后需要将寄存器中的值存入变量“result”，从表面上看好像是指令直接对“result”进行操作，实际上GCC做了隐式处理，这样我们可以少写一些指令。“input”前面的“r”表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。&lt;br/&gt;
</span><span class='line'>  由此可见，C语言表达式或者变量与寄存器的关系由GCC自动处理，我们只需使用约束字符串指导GCC如何处理即可。&lt;br/&gt;
</span><span class='line'>  内联汇编的重要性体现在它能够灵活操作，而且可以使其输出通过C变量显示出来。因为它具有这种能力，所以&lt;code&gt;__asm__&lt;/code&gt;可以用作汇编指令和包含它的C程序之间的接口。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;2、汇编语句模板&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;◆操作数&lt;br/&gt;
</span><span class='line'>  C语言表达式可用作内嵌汇编中的汇编指令的操作数。在汇编指令通过对C语言表达式进行操作来执行有意义的作业的情况下，操作数是扩展格式的内嵌汇编的主要特性。&lt;br/&gt;
</span><span class='line'>  每个操作数都由操作数约束字符串指定，后面跟着用圆括号括起来的C语言表达式，例如：&lt;br/&gt;
</span><span class='line'>&ldquo;constraint&rdquo;(C expression)&lt;br/&gt;
</span><span class='line'>操作数约束的主要功能是确定操作数的寻址方式。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;◆占位符&lt;br/&gt;
</span><span class='line'>  在扩展格式的内嵌汇编的“汇编语句模板”中，操作数由占位符引用。如果总共有n个操作数(包括输入和输出)，那么第一个输出操作数的编号为0，逐项递增，总操作数的数目限制在10个(%0、%1、…、%9)。&lt;br/&gt;
</span><span class='line'>  如果要处理很多输入和输出操作，数字型的占位符很快就会变得混乱。为了使条理清晰，GNU编译器(从版本3.1开始)允许声明替换的名称作为占位符。&lt;br/&gt;
</span><span class='line'>  替换的名称在“输入部分”和“输出部分”中声明。格式如下：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;[name] "constraint"(C expression)&lt;/code&gt;
</span><span class='line'>  声明name后，使用%[name]的形式替换内嵌汇编代码中相应的数字型占位符。如下面所示：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>    __asm__("cmoveq %1, %2, %[result]"
</span><span class='line'>    : [result] "=r"(result)
</span><span class='line'>    : "r"(test), "r"(new), "[result]"(old));
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>  在内嵌汇编中使用占位符表示的操作数，总被视为long型(4个字节) ，但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是高字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;必须使用占位符的情况：
</span><span class='line'>我们看一看下面这个例子：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>    __asm__("addl %1, %0"
</span><span class='line'>    : "=a"(out)
</span><span class='line'>    : "m"(in1), "a"(in2));
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>①首先，我们看一看上例中的第1个输入操作表达式"m"(in1)，它被GCC替换之后，表现为addl address_of_in1, %%eax，in1的地址是什么？编译时才知道。所以我们完全无法直接在指令中去写出in1的地址，这时使用占位符，交给GCC在编译时进行替代，就可以解决这个问题。所以这种情况下，我们必须使用占位符。&lt;br/&gt;
</span><span class='line'>②其次，如果上例中的输出操作表达式"=a"(out)改为"=r"(out)，那么out究竟会使用哪个寄存器只有到编译时才能通过GCC来决定，既然在我们写代码的时候，我们不知道究竟哪个寄存器被选择，我们也就不能直接在指令中写出寄存器的名称，而只能通过占位符替代来解决。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;3、输出部分&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  “输出部分”用来指定当前内嵌汇编语句的输出。我们看一看这个例子：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("movl %%cr0, %0" : "=a"(cr0));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>这个内嵌汇编语句的输出部分为"=r"(cr0)，它是一个“操作表达式”，更具体地在这里叫作“输出操作表达式”，指定了一个输出操作。“输出操作表达式”由两部分组成，这两部分都是必不可少的：&lt;br/&gt;
</span><span class='line'>①圆括号括起来的部分是一个C语言表达式，用来保存内嵌汇编的一个输出值，其操作就等于C的赋值表达式cr0 = output_value，因此，圆括号中的输出表达式只能是C的左值表达式。那么右值output_value从何而来呢？&lt;br/&gt;
</span><span class='line'>②答案是双引号中的内容，被称作“操作约束”(Operation Constraint)，在这个例子中操作约束为"=a"，它包含两个约束：等号(=)和字母a，其中等号(=)说明圆括号中左值表达式cr0是Write-Only的，只能够被作为当前内嵌汇编的输出，而不能作为输入。而字母a是寄存器EAX/AX/AL的简写，说明cr0的值要从EAX寄存器中获取，也就是说cr0 = %eax，最终这一点被转化成汇编语句就是movl %eax, address_of_cr0。&lt;br/&gt;
</span><span class='line'>  另外，需要特别说明的是，很多文档都声明，所有输出操作的操作约束必须包含一个等号(=)，但GCC的文档中却很清楚的声明，并非如此。因为等号(=)约束说明当前的表达式是Write-Only的，但另外还有一个符号——加号(+)用来说明当前表达式是Read-Write的，如果一个操作约束中没有给出这两个符号中的任何一个，则说明当前表达式是Read-Only的。因为对于输出操作来说，肯定是必须是可写的，而等号(=)和加号(+)都表示可写，只不过加号(+) 同时也表示是可读的。所以对于一个输出操作来说，其操作约束只需要有等号(=)或加号(+)中的任意一个就可以了。二者的区别是：等号(=)表示当前操作表达式指定了一个纯粹的输出操作，而加号(+)则表示当前操作表达式不仅仅只是一个输出操作还是一个输入操作。但无论是等号(=)约束还是加号(+)约束所约束的操作表达式都只能放在“输出部分”中，而不能被用在“输入部分”中。&lt;br/&gt;
</span><span class='line'>  在“输出部分”中可以有多个输出操作表达式，多个操作表达式中间必须用逗号(,)分开。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;4、输入部分&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  “输入部分”的内容用来指定当前内嵌汇编语句的输入。我们看一看这个例子：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("movl %0, %%db7" : : "a"(cpu-&gt;db7));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>例中“输入部分”的内容为一个表达式"a"(cpu-&gt;db7)，被称作“输入操作表达式”，用来表示一个对当前内嵌汇编的输入。&lt;br/&gt;
</span><span class='line'>  像输出操作表达式一样，一个输入操作表达式也分为两部分：带圆括号的部分(cpu-&gt;db7)和带双引号的部分"a"。这两部分对于一个内嵌汇编输入操作表达式来说也是必不可少的。&lt;br/&gt;
</span><span class='line'>  圆括号中的表达式cpu-&gt;db7是一个C语言的表达式，它不必是一个左值表达式，也就是说它不仅可以是放在C赋值操作左边的表达式，还可以是放在C赋值操作右边的表达式。所以它可以是一个变量，一个数字，还可以是一个复杂的表达式。比如上例可以改为：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>    __asm__("movl %0, %%db7" : : "a"(foo));
</span><span class='line'>    __asm__("movl %0, %%db7" : : "a"(0x1000));
</span><span class='line'>    __asm__("movl %0, %%db7" : : "a"(x*y/z));
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>  双引号中的部分是约束部分，和输出操作表达式约束不同的是，它不允许指定加号(+)约束和等号(=)约束，也就是说它只能是默认的Read-Only的。约束中必须指定一个寄存器约束，例中的"a"表示当前输入变量cpu-&gt;db7要通过寄存器%eax输入到当前内嵌汇编中。&lt;br/&gt;
</span><span class='line'>  在“输入部分”中可以有多个输入操作表达式，多个操作表达式中间必须用逗号(,)分开。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;5、操作约束&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  前面提到过，在内嵌汇编中的每个操作数都应该由操作数约束字符串描述，后面跟着用圆括号括起来的C语言表达式。操作数约束主要是确定指令中操作数的寻址方式。约束也可以指定：&lt;br/&gt;
</span><span class='line'>①是否允许操作数位于寄存器中，以及它可以包括在哪些类型的寄存器中&lt;br/&gt;
</span><span class='line'>②操作数是否可以是内存引用，以及在这种情况下使用哪些类型的寻址方式&lt;br/&gt;
</span><span class='line'>③操作数是否可以是立即数&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  约束字符必须与指令对操作数的要求相匹配，否则产生的汇编代码将会有错，在这个例子中：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("movl %1,%0" : "=r"(result) : "r"(input));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>如果将那两个"r"，都改为"m"(“m”表示操作数是内存引用)编译后得到的结果是：&lt;br/&gt;
</span><span class='line'>movl input, result&lt;br/&gt;
</span><span class='line'>很明显这是一条非法指令(mov不允许内存到内存的操作)。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  每一个输入和输出操作表达式都必须指定自己的操作约束，下面是在80x86平台上可能使用的操作约束：&lt;br/&gt;
</span><span class='line'>◆寄存器约束&lt;br/&gt;
</span><span class='line'>  当你当前的输入或输出需要借助一个寄存器时，你需要为其指定一个寄存器约束。你可以直接指定一个寄存器的名字，比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("movl %0, %%cr0" : : "eax"(cr0));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>也可以指定一个缩写，比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("movl %0, %%cr0" : : "a"(cr0));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>如果你指定一个缩写，比如“a”，则GCC将会根据当前操作表达式中C语言表达式的类型决定使用%eax，还是%ax或%al。比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>    unsigned short shrt;
</span><span class='line'>    __asm__("mov %0，%%bx" : : "a"(shrt));
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>由于变量shrt是16-bit short类型，则编译出来的汇编代码中，会让此变量使用%ax寄存器。&lt;br/&gt;
</span><span class='line'>  无论是输入还是输出的操作表达式，都可以使用寄存器约束。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;◆内存约束&lt;br/&gt;
</span><span class='line'>  如果一个输入或输出操作表达式的C语言表达式表现为一个内存地址，并且不想借助于任何寄存器，则可以使用内存约束。比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("lidt %0" : "=m"(idt_addr));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>  使用内存方式进行输入输出时，由于不借助寄存器，所以GCC不会按照你的声明对其作任何的输入输出处理。GCC只会直接拿来用，究竟对这个C语言表达式而言是输入还是输出，完全依赖与你写在“汇编语句模板”中的指令对其操作的指令。&lt;br/&gt;
</span><span class='line'>  当操作数位于内存中时，任何对它们执行的操作都将在内存位置中直接发生，所以，对于内存约束类型的操作表达式而言，放在“输入部分”还是放在“输出部分”，对编译结果是没有任何影响的，既然对于内存约束类型的操作表达式来说，GCC不会自动为它做任何事情，那么放在哪儿也就无所谓了。但从程序员的角度而言，为了增强代码的可读性，最好能够把它放在符合实际情况的地方。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;◆立即数约束&lt;br/&gt;
</span><span class='line'>  如果一个输入或输出操作表达式的C语言表达式是一个数字常数，并且不想借助于任何寄存器，则可以使用立即数约束。&lt;br/&gt;
</span><span class='line'>  由于立即数在C中只能作为右值，所以对于使用立即数约束的操作表达式而言，只能放在“输入部分”。比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("movl %0, %%eax" : : "i"(100));&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;◆匹配约束&lt;br/&gt;
</span><span class='line'>  匹配约束符是一位数字：“0”，“1”，…，“9”，表示它约束的C表达式分别与占位符%0，%1，…，%9相对应的C变量匹配。例如使用“0”作为%1的约束字符，那么%0和%1表示同一个C变量。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  在某些情况下，一个变量既要充当输入操作数，也要充当输出操作数。可以通过使用匹配约束在内嵌汇编中的“输入部分”指定这种情况。&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("incl %0" : "=a"(var) : "0"(var));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>  在上面的示例中，寄存器%eax既用作输入变量，也用作输出变量。将输入变量var读取到%eax，执行inc指令后将更新了值的%eax再次存储在var中。这里的"0"指定与第0个输出变量相同的约束。即，它指定var的输出实例只应该存储在%eax中。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;该约束可以用于以下情况：&lt;br/&gt;
</span><span class='line'>①输入从变量中读取，或者变量被修改后，修改写回到同一变量中&lt;br/&gt;
</span><span class='line'>②不需要将输入操作数和输出操作数的实例分开&lt;br/&gt;
</span><span class='line'>使用匹配约束最重要的意义在于它们可以导致有效地使用可用寄存器。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  i386指令集中许多指令的操作数是读写型的，例如：&lt;br/&gt;
</span><span class='line'>addl %1, %0&lt;br/&gt;
</span><span class='line'>它先读取%0与%1原来的值然后将两者的值相加，并把结果存回%0，因此操作数%0是读写型操作数。老版本的GCC对这种类型操作数的支持不是很好，它将操作数严格分为输入和输出两种，分别放在输入部分和输出部分，而没有一个单独部分描述读写型操作数。&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("addl %1, %0" : "=r"(result) : "r"(input));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>上例使用“r”约束的输出变量，GCC会分配一个寄存器，然后用该寄存器替换占位符，但是在使用该寄存器之前并不将result变量的值先读入寄存器，GCC认为所有输出变量以前的值都没有用处，也就没有必要将其读入寄存器(这可能是因为AT&amp;T汇编源于RISC架构处理器的原故，在RISC处理器中大部分指令的输入输出明显分开，而不像CISC那样一个操作数既做输入又做输出，例如：&lt;br/&gt;
</span><span class='line'>add r0, r1, r2&lt;br/&gt;
</span><span class='line'>r0和r1是输入，r2是输出，输入和输出分开，不使用输入输出型操作数。这种情况下GCC理所当然认为所有输出变量以前的值都没有用处，也就没有必要先将输出操作数的值读入寄存器r2了)。&lt;br/&gt;
</span><span class='line'>  上面的内嵌汇编指令不能奏效，因为需要在执行addl之前把result的值入寄存器。因此在GCC中读写型的操作数需要在输入和输出部分分别描述，靠匹配约束符将两者关联到一起。注意仅在输入和输出部分使用相同的C变量，但是不用匹配约束符，例如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("addl %2, %0" : "=r"(result) : "r"(result), "m"(input));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>产生的代码很可能不对。&lt;br/&gt;
</span><span class='line'>  看上去上面的代码可以正常工作，因为我们知道%0和%1都和result相关，应该使用同一个寄存器，但是GCC并不去判断%0和%1是否和同一个C语言表达式或变量相关联(这样易于产生与内嵌汇编相应的汇编代码)，因此%0和%1使用的寄存器可能不同。&lt;br/&gt;
</span><span class='line'>  使用匹配约束符后，GCC知道应将对应的操作数放在同一个位置(同一个寄存器或者同一个内存变量)。使用匹配约束字符的代码如下：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("addl %2,%0" : "=r"(result) : "0"(result), "m"(input));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>相应的汇编代码为：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>      movl $0, _result
</span><span class='line'>      movl $1, _input
</span><span class='line'>      movl _result, %edx
</span><span class='line'>      movl %edx, %eax
</span><span class='line'>    #APP
</span><span class='line'>      addl _input, %eax
</span><span class='line'>    #NO_APP
</span><span class='line'>      movl %eax, %edx
</span><span class='line'>      movl %edx, _result
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>可以看到与result相关的寄存器是%edx，在执行指令addl之前先从%edx将result读入%eax，执行之后需要将结果从%eax读入%edx，最后存入result中。这里我们可以看出GCC处理内嵌汇编中输出操作数的一点点信息：addl并没有使用%edx，可见它不是简单的用result对应的寄存器%edx去替换%0，而是先分配一个寄存器，执行运算，最后才将运算结果存入对应的变量，因此GCC是先看该占位符对应的变量的约束符，发现是一个输出型寄存器变量，就为它分配一个寄存器，此时没有去管对应的C变量，最后GCC知道还要将寄存器的值写回变量，与此同时，它发现该变量与%edx关联，因此先存入%edx，再存入变量。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  在新版本的GCC中增加了一个约束字符“+”，它表示操作数是读写型的，GCC知道应将变量值先读入寄存器，然后计算，最后写回变量，而无需在输入部分再去描述该变量。&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("addl %1, %0" : "+r"(result) : "m"(input));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>产生的汇编代码如下：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>      movl $0,_result
</span><span class='line'>      movl $1,_input
</span><span class='line'>      movl _result,%eax
</span><span class='line'>    #APP
</span><span class='line'>      addl _input,%eax
</span><span class='line'>    #NO_APP
</span><span class='line'>      movl %eax,_result
</span><span class='line'>    L2:
</span><span class='line'>      movl %ebp,%esp
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>处理的比使用匹配约束符的情况还要好，省去了好几条汇编代码。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;◆修饰符
</span><span class='line'>  等号(=)和加号(+)用于对输出操作表达式的修饰，一个输出操作表达式要么被等号(=)修饰，要么被加号(+)修饰，二者必居其一。使用等号(=)说明此输出操作表达式是Write-Only的，使用加号(+)说明此输出操作表达式是Read-Write的。它们必须是输出操作表达式约束字符串中的第一个字符。比如："a=&ldquo;(var)是非法的，而&rdquo;+g"(var)则是合法的。&lt;br/&gt;
</span><span class='line'>  当使用加号(+)的时候，此输出操作表达式等价于使用等号(=)约束再加上一个输入操作表达式。比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("incl %0" : "+a"(var));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>等价于&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("incl %0" : "=a"(var) : "0"(var));&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  像等号(=)和加号(+)修饰符一样，符号(&amp;)也只能用于对输出操作表达式的修饰。&lt;br/&gt;
</span><span class='line'>  约束符“&amp;”表示输入和输出操作数不能使用相同的寄存器，这样可以避免很多错误。举一个例子，下面代码的作用是将函数foo的返回值存入变量ret中：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("call foo; movl %%edx, %1" : "=a"(ret) : "r"(bar));&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>我们知道函数的int型返回值存放在%eax中，但是GCC编译的结果是输入和输出同时使用了寄存器%eax，如下：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>      movl bar, %eax
</span><span class='line'>    #APP
</span><span class='line'>      call foo
</span><span class='line'>      movl %ebx, %eax
</span><span class='line'>    #NO_APP
</span><span class='line'>      movl %eax, ret
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>结果显然不对，原因是GCC并不知道%eax中的值是我们所要的。避免这种情况的方法是使用“&amp;”修饰符，这样bar就不会再使用%eax寄存器，因为已被ret指定使用。&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("call foo; movl %%edx, %1" : "=&amp;a"(ret) : "r"(bar));&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;6、破坏描述部分&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  有时在进行某些操作时，除了要用到进行数据输入和输出的寄存器外，还要使用多个寄存器来保存中间计算结果，这样就难免会破坏原有寄存器的内容。如果希望GCC在编译时能够将这一点考虑进去。那么你就可以在“破坏描述部分”声明这些寄存器或内存。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  这种情况一般发生在一个寄存器出现在“汇编语句模板”，但却不是由输入或输出操作表达式所指定的，也不是在一些输入或输出操作表达式使用"r"、"g"约束时由GCC为其选择的，同时此寄存器被“汇编语句模板”中的指令修改，而这个寄存器只是供当前内嵌汇编临时使用的情况。比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("movl %0, %%ebx" : : "a"(foo) : "%ebx");&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>寄存器%ebx出现在“汇编语句模板”中，并且被movl指令修改，但却未被任何输入或输出操作表达式指定，所以你需要在“破坏描述部分”指定"%ebx"，以让GCC知道这一点。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  因为你在输入或输出操作表达式所指定的寄存器，或当你为一些输入或输出操作表达式使用"r"、"g"约束，让GCC为你选择一个寄存器时，GCC对这些寄存器是非常清楚的——它知道这些寄存器是被修改的，你根本不需要在“破坏描述部分”再声明它们。但除此之外，GCC对剩下的寄存器中哪些会被当前的内嵌汇编修改一无所知。所以如果你真的在当前内嵌汇编语句中修改了它们，那么就最好“破坏描述部分”中声明它们，让GCC针对这些寄存器做相应的处理。否则有可能会造成寄存器的不一致，从而造成程序执行错误。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  在“破坏描述部分”中指定这些寄存器的方法很简单，你只需要将寄存器的名字使用双引号引起来。如果有多个寄存器需要声明，你需要在任意两个声明之间用逗号隔开。比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("movl %0, %%ebx; popl %%ecx" : : "a"(foo) : "%ebx", "%ecx" );&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>  注意准备在“破坏描述部分”声明的寄存器必须使用完整的寄存器名称，在寄存器名称前面使用的“%”是可选的。&lt;br/&gt;
</span><span class='line'>  另外需要注意的是，如果你在“破坏描述部分”声明了一个寄存器，那么这个寄存器将不能再被用做当前内嵌汇编语句的输入或输出操作表达式的寄存器约束，如果输入或输出操作表达式的寄存器约束被指定为"r"或"g"，GCC也不会选择已经被声明在“破坏描述部分”中的寄存器。比如：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__asm__("movl %0, %%ebx" : : "a"(foo) : "%eax", "%ebx");&lt;/code&gt;&lt;br/&gt;
</span><span class='line'>此例中，由于输出操作表达式"a"(foo)的寄存器约束已经指定了%eax寄存器，那么再在“破坏描述部分”中指定"%eax"就是非法的。编译时，GCC会给出编译错误。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  除了寄存器的内容会被改变，内存的内容也可以被修改。如果一个“汇编语句模板”中的指令对内存进行了修改，或者在此内嵌汇编出现的地方内存内容可能发生改变，而被改变的内存地址你没有在其输出操作表达式使用"m"约束，这种情况下你需要在“破坏描述部分”使用字符串"memory"向GCC声明：“在这里，内存发生了或可能发生了改变”。例如：&lt;br/&gt;</span></code></pre></td></tr></table></div></figure>
    void * memset(void * s, char c, size_t count)
    {
        <strong>asm</strong>(&ldquo;cld\n\t&rdquo;
        &ldquo;rep\n\t&rdquo;
        &ldquo;stosb&rdquo;
        : /<em> no output </em>/
        : &ldquo;a&rdquo;&copy;, &ldquo;D&rdquo;(s), &ldquo;c&rdquo;(count)
        : &ldquo;%ecx&rdquo;, &ldquo;%edi&rdquo;, &ldquo;memory&rdquo;);</p>

<pre><code>    return s;
}
</code></pre>

<p>```
  此例实现了标准函数库memset，其内嵌汇编中的stosb对内存进行了改动，而其被修改的内存地址s被指定装入%edi，没有任何输出操作表达式使用了"m"约束，以指定内存地址s处的内容发生了改变。所以在其“破坏描述部分”使用"memory"向GCC声明：内存内容发生了变动。</p>

<p>  如果一个内嵌汇编语句的“破坏描述部分”存在"memory"，那么GCC会保证在此内嵌汇编之前，如果某个内存的内容被装入了寄存器，那么在这个内嵌汇编之后，如果需要使用这个内存处的内容，就会直接到这个内存处重新读取，而不是使用被存放在寄存器中的拷贝。因为这个时候寄存器中的拷贝已经很可能和内存处的内容不一致了。</p>

<p>  当一个“汇编语句模板”中包含影响eflags寄存器中的条件标志，那么需要在“破坏描述部分”中使用"cc"来声明这一点。这些指令包括adc，div，popfl，btr，bts等等，另外，当包含call指令时，由于你不知道你所call的函数是否会修改条件标志，为了稳妥起见，最好也使用"cc"。</p>
]]></content>
  </entry>
  
</feed>
