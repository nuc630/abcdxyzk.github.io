<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tools~command | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/tools~command/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-09-22T11:40:38+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iostat 命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/08/21/tools-command-iostat/"/>
    <updated>2015-08-21T15:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/08/21/tools-command-iostat</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangjay/article/details/6656771">http://blog.csdn.net/zhangjay/article/details/6656771</a></p>

<p><a href="http://www.cnblogs.com/mfryf/archive/2012/03/12/2392000.html">http://www.cnblogs.com/mfryf/archive/2012/03/12/2392000.html</a></p>

<p>iostat用于输出CPU和磁盘I/O相关的统计信息.</p>

<p>命令格式:
<code>
    iostat [ -c | -d ] [ -k | -m ] [ -t ] [ -V ] [ -x ] [ device [ ... ] | ALL ] [ -p [ device | ALL ]  ]
           [ interval [ count ] ]
</code></p>

<h4>1)iostat的 简单使用</h4>

<p>iostat可以显示CPU和I/O系统的负载情况及分区状态信息. 直接执行iostat可以显示下面内容:
```
    # iostat
    Linux 2.6.9-8.11.EVAL (ts3-150.ts.cn.tlan)      08/08/2007</p>

<pre><code>avg-cpu:  %user   %nice    %sys %iowait   %idle
          12.01    0.00        2.15    2.30       83.54

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
hda               7.13       200.12        34.73     640119     111076
</code></pre>

<pre><code>
各个输出项目的含义如下:

avg-cpu段:
</code></pre>

<pre><code>%user: 在用户级别运行所使用的CPU的百分比.
%nice: nice操作所使用的CPU的百分比.
%sys: 在系统级别(kernel)运行所使用CPU的百分比.
%iowait: CPU等待硬件I/O时,所占用CPU百分比.
%idle: CPU空闲时间的百分比.
</code></pre>

<pre><code>
Device段:
</code></pre>

<pre><code>tps: 每秒钟发送到的I/O请求数.
Blk_read /s: 每秒读取的block数.
Blk_wrtn/s: 每秒写入的block数.
Blk_read:   读入的block总数.
Blk_wrtn:  写入的block总数.
</code></pre>

<pre><code>
#### 2)iostat参 数说明

iostat各个参数说明:
</code></pre>

<pre><code>-c 仅显示CPU统计信息.与-d选项互斥.
-d 仅显示磁盘统计信息.与-c选项互斥.
-k 以K为单位显示每秒的磁盘请求数,默认单位块.
-p device | ALL
 与-x选项互斥,用于显示块设备及系统分区的统计信息.也可以在-p后指定一个设备名,如:
 # iostat -p hda
 或显示所有设备
 # iostat -p ALL
-t    在输出数据时,打印搜集数据的时间.
-V    打印版本号和帮助信息.
-x    输出扩展信息.
</code></pre>

<pre><code>
#### 3)iostat输 出项目说明
</code></pre>

<pre><code>rrqm/s: 每秒进行 merge 的读操作数目。即 delta(rmerge)/s
wrqm/s: 每秒进行 merge 的写操作数目。即 delta(wmerge)/s
r/s: 每秒完成的读 I/O 设备次数。即 delta(rio)/s
w/s: 每秒完成的写 I/O 设备次数。即 delta(wio)/s
rsec/s: 每秒读扇区数。即 delta(rsect)/s
wsec/s: 每秒写扇区数。即 delta(wsect)/s
rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算)
wkB/s: 每秒写K字节数。是 wsect/s 的一半。(需要计算)
avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。delta(rsect+wsect)/delta(rio+wio)
avgqu-sz: 平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。
await: 平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)
svctm: 平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)
%util: 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为use的单位为毫秒)
如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。

Blk_read 读入块的当总数.
Blk_wrtn 写入块的总数.
kB_read/s 每秒从驱动器读入的数据量,单位为K.
kB_wrtn/s 每秒向驱动器写入的数据量,单位为K.
kB_read 读入的数据总量,单位为K.
kB_wrtn 写入的数据总量,单位为K.
rrqm/s 将读入请求合并后,每秒发送到设备的读入请求数.
wrqm/s 将写入请求合并后,每秒发送到设备的写入请求数.
r/s 每秒发送到设备的读入请求数.
w/s 每秒发送到设备的写入请求数.
rsec/s 每秒从设备读入的扇区数.
wsec/s 每秒向设备写入的扇区数.
rkB/s 每秒从设备读入的数据量,单位为K.
wkB/s 每秒向设备写入的数据量,单位为K.
avgrq-sz 发送到设备的请求的平均大小,单位是扇区.
avgqu-sz 发送到设备的请求的平均队列长度.
await I/O请求平均执行时间.包括发送请求和执行的时间.单位是毫秒.
svctm 发送到设备的I/O请求的平均执行时间.单位是毫秒.
%util 在I/O请求发送到设备期间,占用CPU时间的百分比.用于显示设备的带宽利用率.当这个值接近100%时,表示设备带宽已经占满.
</code></pre>

<pre><code>
#### 4)iostat示 例
</code></pre>

<pre><code># iostat
显示一条统计记录,包括所有的CPU和设备.

# iostat -d 2
每隔2秒,显示一次设备统计信息.

# iostat -d 2 6
每隔2秒,显示一次设备统计信息.总共输出6次.

# iostat -x hda hdb 2 6
每隔2秒显示一次hda,hdb两个设备的扩展统计信息,共输出6次.

# iostat -p sda 2 6
每隔2秒显示一次sda及上面所有分区的统计信息,共输出6次.
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[taskset 命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/08/21/tools-command-taskset/"/>
    <updated>2015-08-21T15:52:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/08/21/tools-command-taskset</id>
    <content type="html"><![CDATA[<pre><code>    #taskset --help
    taskset (util-linux 2.13-pre7)
    usage: taskset [options] [mask | cpu-list] [pid | cmd [args...]]
    set or get the affinity of a process

    -p, --pid operate on existing given pid
    -c, --cpu-list display and specify cpus in list format
    -h, --help display this help
    -v, --version output version information
</code></pre>

<ul>
<li>加-c用的是cpu-id，不加-c用的mask</li>
</ul>


<p>举例：</p>

<p>1、开启一个只用0标记的cpu核心的新进程(job.sh是你的工作脚本)
<code>
    #taskset -c 0 sh job.sh
</code></p>

<p>2、查找现有的进程号，调整该进程cpu核心使用情况（23328举例用的进程号）
<code>
    #taskset -pc 0 23328
    pid 23328's current affinity list: 0-3  #0-3表示使用所有4核进行处理
    pid 23328's new affinity list: 0 #调整后改为仅适用0标记单核处理
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[grep 命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/10/17/command-grep/"/>
    <updated>2014-10-17T18:18:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/10/17/command-grep</id>
    <content type="html"><![CDATA[<ul>
<li>^：匹配正则表达式的开始行。</li>
<li>$: 匹配正则表达式的结束行。</li>
</ul>


<h4>1.作用</h4>

<p>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p>

<h4>2.格式</h4>

<p>grep [options]</p>

<h4>3.主要参数</h4>

<p>[options]主要参数：
<code>
－c：只输出匹配行的计数。
－I：不区分大 小写(只适用于单字符)。
－h：查询多文件时不显示文件名。
－l：查询多文件时只输出包含匹配字符的文件名。
－n：显示匹配行及 行号。
－s：不显示不存在或无匹配文本的错误信息。
－v：显示不包含匹配文本的所有行。
</code>
pattern正则表达式主要参数：
<code>
\： 忽略正则表达式中特殊字符的原有含义。
^：匹配正则表达式的开始行。
$: 匹配正则表达式的结束行。
\&lt;：从匹配正则表达 式的行开始。
\&gt;：到匹配正则表达式的行结束。
[ ]：单个字符，如[A]即A符合要求 。
[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。
。：所有的单个字符。
* ：有字符，长度可以为0。
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dd 命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/09/19/command-dd/"/>
    <updated>2014-09-19T15:13:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/09/19/command-dd</id>
    <content type="html"><![CDATA[<p>贴自<a href="http://www.chinaunix.net/old_jh/4/1025448.html">http://www.chinaunix.net/old_jh/4/1025448.html</a>
dd 是 Linux/UNIX 下的一个非常有用的命令，作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p>

<h4>1. 命令简介</h4>

<p>dd 的主要选项：
<code>
指定数字的地方若以下列字符结尾乘以相应的数字:
b=512, c=1, k=1024, w=2, xm=number m
if=file
输入文件名，缺省为标准输入。
of=file
输出文件名，缺省为标准输出。
ibs=bytes
一次读入 bytes 个字节(即一个块大小为 bytes 个字节)。
obs=bytes
一次写 bytes 个字节(即一个块大小为 bytes 个字节)。
bs=bytes
同时设置读写块的大小为 bytes ，可代替 ibs 和 obs 。
cbs=bytes
一次转换 bytes 个字节，即转换缓冲区大小。
skip=blocks
从输入文件开头跳过 blocks 个块后再开始复制。
seek=blocks
从输出文件开头跳过 blocks 个块后再开始复制。(通常只有当输出文件是磁盘或磁带时才有效)。
count=blocks
仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数。
conv=conversion[,conversion...]
用指定的参数转换文件。
转换参数:
ascii 转换 EBCDIC 为 ASCII。
ebcdic 转换 ASCII 为 EBCDIC。
ibm 转换 ASCII 为 alternate EBCDIC.
block 把每一行转换为长度为 cbs 的记录，不足部分用空格填充。
unblock 使每一行的长度都为 cbs ，不足部分用空格填充。
lcase 把大写字符转换为小写字符。
ucase 把小写字符转换为大写字符。
swab 交换输入的每对字节。
noerror 出错时不停止。
notrunc 不截短输出文件。
sync 把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐。
</code></p>

<h4>2.实例分析</h4>

<h5>2.1.数据备份与恢复</h5>

<h6>2.1.1整盘数据备份与恢复</h6>

<p>备份：<br/>
dd if=/dev/hdx of=/dev/hdy<br/>
将本地的/dev/hdx整盘备份到/dev/hdy <br/>
dd if=/dev/hdx of=/path/to/image<br/>
将/dev/hdx全盘数据备份到指定路径的image文件<br/>
dd if=/dev/hdx | gzip >/path/to/image.gz<br/>
备份/dev/hdx全盘数据，并利用gzip工具进行压缩，保存到指定路径<br/>
恢复：<br/>
dd if=/path/to/image of=/dev/hdx<br/>
将备份文件恢复到指定盘<br/>
gzip -dc /path/to/image.gz | dd of=/dev/hdx<br/>
将压缩的备份文件恢复到指定盘</p>

<h6>2.1.2.利用netcat远程备份</h6>

<p>dd if=/dev/hda bs=16065b | netcat &lt; targethost-IP > 1234<br/>
在源主机上执行此命令备份/dev/hda<br/>
netcat -l -p 1234 | dd of=/dev/hdc bs=16065b<br/>
在目的主机上执行此命令来接收数据并写入/dev/hdc<br/>
netcat -l -p 1234 | bzip2 > partition.img<br/>
netcat -l -p 1234 | gzip > partition.img<br/>
以上两条指令是目的主机指令的变化分别采用bzip2  gzip对数据进行压缩，并将备份文件保存在当前目录。</p>

<h6>2.1.3.备份MBR</h6>

<p>备份：<br/>
dd if=/dev/hdx of=/path/to/image count=1 bs=512<br/>
备份磁盘开始的512Byte大小的MBR信息到指定文件<br/>
恢复：<br/>
dd if=/path/to/image of=/dev/hdx<br/>
将备份的MBR信息写到磁盘开始部分</p>

<h6>2.1.4.备份软盘</h6>

<p>dd if=/dev/fd0 of=disk.img count=1 bs=1440k<br/>
将软驱数据备份到当前目录的disk.img文件</p>

<h6>2.1.5.拷贝内存资料到硬盘</h6>

<p>dd if=/dev/mem of=/root/mem.bin bs=1024<br/>
将内存里的数据拷贝到root目录下的mem.bin文件</p>

<h6>2.1.6.从光盘拷贝iso镜像</h6>

<p>dd if=/dev/cdrom of=/root/cd.iso<br/>
拷贝光盘数据到root文件夹下，并保存为cd.iso文件</p>

<h5>2.2.增加Swap分区文件大小</h5>

<p>dd if=/dev/zero of=/swapfile bs=1024 count=262144<br/>
创建一个足够大的文件（此处为256M）<br/>
mkswap /swapfile<br/>
把这个文件变成swap文件<br/>
swapon /swapfile<br/>
启用这个swap文件<br/>
/swapfile swap swap defaults 0 0<br/>
在每次开机的时候自动加载swap文件, 需要在 /etc/fstab 文件中增加一行</p>

<h5>2.3销毁磁盘数据</h5>

<p>dd if=/dev/urandom of=/dev/hda1<br/>
利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据。执行此操作以后，/dev/hda1将无法挂载，创建和拷贝操作无法执行。</p>

<h5>2.4磁盘管理</h5>

<h6>2.4.1.得到最恰当的block size</h6>

<pre><code>dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file
dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file
dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file  
dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file
</code></pre>

<p>通过比较dd指令输出中所显示的命令执行时间，即可确定系统最佳的block size大小</p>

<h6>2.4.2测试硬盘读写速度</h6>

<pre><code>dd if=/root/1Gb.file bs=64k | dd of=/dev/null
dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000
</code></pre>

<p>通过上两个命令输出的执行时间，可以计算出测试硬盘的读／写速度</p>

<h6>2.4.3.修复硬盘</h6>

<p>dd if=/dev/sda of=/dev/sda<br/>
当硬盘较长时间（比如1，2年）放置不使用后，磁盘上会产生magnetic flux point。当磁头读到这些区域时会遇到困难，并可能导致I/O 错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数据起死回生。且这个过程是安全，高效的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[find命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/02/19/command-find/"/>
    <updated>2014-02-19T14:27:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/02/19/command-find</id>
    <content type="html"><![CDATA[<h5>find和其他命令共用</h5>

<pre><code>    find ... | while read line; do
      echo "$line"
       ....
    done

    find . -name *.dem | while read line; do ll -h "$line"; done

    统计目录并按行数排序（按行大小排序）：
    find . -name *.java | xargs wc -l | sort -n

    统计目录并按文件名排序：
    find . -name *.java | xargs wc -l | sort -k2
</code></pre>

<p> 由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍 历一个大的文件系统可能会花费很长的时间。</p>

<h4>一、find 命令格式</h4>

<h5>1、find命令的一般形式为：</h5>

<pre><code>find pathname -options [-print -exec -ok ...]
</code></pre>

<h5>2、find命令的参数；</h5>

<p>pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。<br/>
-print： find命令将匹配的文件输出到标准输出。<br/>
-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {} \;，注意{}和\；之间的空格。<br/>
-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</p>

<h5>3、find命令选项</h5>

<pre><code>-name           按照文件名查找文件。
-perm           按照文件权限来查找文件。
-prune          使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。
-user           按照文件属主来查找文件。
-group          按照文件所属的组来查找文件。
-mtime -n +n    按照文件的更改时间来查找文件， – n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。
-nogroup        查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。
-nouser         查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。
-newer file1 ! file2    查找更改时间比文件file1新但比文件file2旧的文件。
-type           查找某一类型的文件，诸如：
    b – 块设备文件。
    d – 目录。
    c – 字符设备文件。
    p – 管道文件。
    l – 符号链接文件。
    f – 普通文件。
-size n：[c]       查找文件长度为n块的文件，带有c时表示文件长度以字节计。
-depth：           在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。
-fstype：      查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。
-mount：           在查找文件时不跨越文件系统mount点。
-follow：      如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。
-cpio：            对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。
另外,下面三个的区别:
-amin n         查找系统中最后N分钟访问的文件
-atime n        查找系统中最后n*24小时访问的文件
-cmin n         查找系统中最后N分钟被改变文件状态的文件
-ctime n        查找系统中最后n*24小时被改变文件状态的文件
-mmin n         查找系统中最后N分钟被改变文件数据的文件
-mtime n        查找系统中最后n*24小时被改变文件数据的文件
</code></pre>

<h5>4、使用exec或ok来执行shell命令</h5>

<p> 使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便的<br/>
在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。<br/>
exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个\，最后是一个分号。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。<br/>
例如：为了用ls -l命令列出所匹配到的文件，可以把ls -l命令放在find命令的-exec选项中<br/>
find . -type f -exec ls -l {} \;
-rw-r–r– 1 root root 34928 2003-02-25 ./conf/httpd.conf
-rw-r–r– 1 root root 12959 2003-02-25 ./conf/magic
-rw-r–r– 1 root root 180 2003-02-25 ./conf.d/README
上面的例子中，find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。<br/>
在/logs目录中查找更改时间在5日以前的文件并删除它们：<br/>
$ find logs -type f -mtime +5 -exec rm {} \;<br/>
记住：在shell中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如mv或rm命令时，可以使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。<br/>
在下面的例子中， find命令在当前目录中查找所有文件名以.LOG结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。<br/>
$ find . -name “<em>.conf” -mtime +5 -ok rm {} \;<br/>
&lt; rm … ./conf/httpd.conf > ? n<br/>
按y键删除文件，按n键不删除。<br/>
任何形式的命令都可以在-exec选项中使用。<br/>
在下面的例子中我们使用grep命令。find命令首先匹配所有文件名为“ passwd</em>”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个sam用户。<br/>
find /etc -name “passwd*” -exec grep “sam” {} \;<br/>
sam:x:501:501::/usr/sam:/bin/bash</p>

<h4>二、xargs</h4>

<p>xargs – build and execute command lines from standard input<br/>
  在使用find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现 溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。</p>

<p>  find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</p>

<p>  在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高；而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。</p>

<p>来看看xargs命令是如何同find命令一起使用的，并给出一些例子。<br/>
下面的例子查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件<br/>
$ find . -type f -print | xargs file<br/>
./.kde/Autostart/Autorun.desktop: UTF-8 Unicode English text<br/>
./.kde/Autostart/.directory: ISO-8859 text\<br/>
……<br/>
在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中：<br/>
$ find / -name “core” -print | xargs echo “” >/tmp/core.log<br/>
上面这个执行太慢，我改成在当前目录下查找<br/>
$ find . -name “file<em>” -print | xargs echo “” > /temp/core.log<br/>
$ cat /temp/core.log<br/>
./file6<br/>
在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限：<br/>
$ ls -l<br/>
drwxrwxrwx 2 sam adm 4096 10月 30 20:14 file6<br/>
-rwxrwxrwx 2 sam adm 0 10月 31 01:01 http3.conf
-rwxrwxrwx 2 sam adm 0 10月 31 01:01 httpd.conf<br/>
$ find . -perm -7 -print | xargs chmod o-w<br/>
$ ls -l<br/>
drwxrwxr-x 2 sam adm 4096 10月 30 20:14 file6<br/>
-rwxrwxr-x 2 sam adm 0 10月 31 01:01 http3.conf<br/>
-rwxrwxr-x 2 sam adm 0 10月 31 01:01 httpd.conf<br/>
用grep命令在所有的普通文件中搜索hostname这个词：<br/>
$ find . -type f -print | xargs grep “hostname”<br/>
./httpd1.conf:# different IP addresses or hostnames and have them handled by the<br/>
./httpd1.conf:# VirtualHost: If you want to maintain multiple domains/hostnames<br/>
on your<br/>
用grep命令在当前目录下的所有普通文件中搜索hostnames这个词：<br/>
$ find . -name * -type f -print | xargs grep “hostnames”<br/>
./httpd1.conf:# different IP addresses or hostnames and have them handled by the<br/>
./httpd1.conf:# VirtualHost: If you want to maintain multiple domains/hostnames<br/>
on your<br/>
注意，在上面的例子中， \用来取消find命令中的</em>在shell中的特殊含义。<br/>
find命令配合使用exec和xargs可以使用户对所匹配到的文件执行几乎所有的命令。</p>
]]></content>
  </entry>
  
</feed>
