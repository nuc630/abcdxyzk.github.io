<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tools~command | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/tools~command/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2016-05-21T10:54:19+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[sed命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2016/03/21/command-sed/"/>
    <updated>2016-03-21T10:36:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2016/03/21/command-sed</id>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html">http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html</a></p>

<p>sed是一个很好的文件处理工具，本身是一个管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作，下面先了解一下sed的用法</p>

<p>sed命令行格式为：
<code>
    sed [-nefri] 'command' 输入文本        
</code></p>

<h4>常用选项：</h4>

<pre><code>    -n ∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
    -e ∶直接在指令列模式上进行 sed 的动作编辑；
    -f ∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作；
    -r ∶sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法)
    -i ∶直接修改读取的档案内容，而不是由萤幕输出。       
</code></pre>

<h4>常用命令：</h4>

<pre><code>    a  ∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
    c  ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
    d  ∶删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
    i  ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
    p  ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～
    s  ∶取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！
</code></pre>

<h4>举例：（假设我们有一文件名为ab）</h4>

<pre><code>    删除某行
    sed '1d' ab             #删除第一行 
    sed '$d' ab             #删除最后一行
    sed '1,2d' ab           #删除第一行到第二行
    sed '2,$d' ab           #删除第二行到最后一行

    显示某行
    sed -n '1p' ab          #显示第一行 
    sed -n '$p' ab          #显示最后一行
    sed -n '1,2p' ab        #显示第一行到第二行
    sed -n '2,$p' ab        #显示第二行到最后一行

    使用模式进行查询
    sed -n '/ruby/p' ab     #查询包括关键字ruby所在所有行
    sed -n '/\$/p' ab       #查询包括关键字$所在所有行，使用反斜线\屏蔽特殊含义

    增加一行或多行字符串
    sed '1a drink tea' ab   #第一行后增加字符串"drink tea"
    sed '1,3a drink tea' ab #第一行到第三行后增加字符串"drink tea"
    sed '1a drink tea\nor coffee' ab   #第一行后增加多行，使用换行符\n

    代替一行或多行
    sed '1c Hi' ab          #第一行代替为Hi
    sed '1,2c Hi' ab        #第一行到第二行代替为Hi

    替换一行中的某部分
    格式：sed 's/要替换的字符串/新的字符串/g'   （要替换的字符串可以用正则表达式）
    sed -n '/ruby/p' ab | sed 's/ruby/bird/g'    #替换ruby为bird
    sed -n '/ruby/p' ab | sed 's/ruby//g'        #删除ruby

    插入
    sed -i '$a bye' ab         #在文件ab中最后一行直接输入"bye"
    cat ab

    删除匹配行
    sed -i '/匹配字符串/d'  filename  （注：若匹配字符串是变量，则需要“”，而不是‘’。记得好像是）

    替换匹配行中的某个字符串
    sed -i '/匹配字符串/s/替换源字符串/替换目标字符串/g' filename
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[awk命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2016/03/21/command-awk/"/>
    <updated>2016-03-21T10:19:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2016/03/21/command-awk</id>
    <content type="html"><![CDATA[<h5>统计列和</h5>

<pre><code>    awk 'BEGIN { sum+=$1; } END { print sum }'
</code></pre>

<h4>-F 参数自定义分隔符可以用正则表达式</h4>

<pre><code>    awk -F '[ ;]+' '{print $2}'
</code></pre>

<hr />

<p><a href="http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html">http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html</a></p>

<h4>实例</h4>

<pre><code>    last -n 5 | awk  '{print $1}'
    cat /etc/passwd |awk  -F ':'  '{print $1"\t"$7}'
    cat /etc/passwd |awk  -F ':'  'BEGIN {print "name,shell"}  {print $1","$7} END {print "blue,/bin/nosh"}'
</code></pre>

<h4>awk内置变量</h4>

<pre><code>    ARGC            命令行参数个数
    ARGV            命令行参数排列
    ENVIRON         支持队列中系统环境变量的使用
    FILENAME        awk浏览的文件名
    FNR             浏览文件的记录数
    FS              设置输入域分隔符，等价于命令行 -F选项
    NF              浏览记录的域的个数
    NR              已读的记录数
    OFS             输出域分隔符
    ORS             输出记录分隔符
    RS              控制记录分隔符
</code></pre>

<p> 此外,$0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,&hellip;&hellip;以此类推。</p>

<h4>print和printf</h4>

<p>awk中同时提供了print和printf两种打印输出的函数。</p>

<p>其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。</p>

<p>printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。</p>

<h4>awk编程</h4>

<h5>变量和赋值</h5>

<pre><code>    # 统计/etc/passwd的账户人数
    awk '{count++;print $0;} END{print "user count is ", count}' /etc/passwd
</code></pre>

<h5>条件语句</h5>

<pre><code>    if (expression) {
        statement;
        statement;
        ... ...
    }

    if (expression) {
        statement;
    } else {
        statement2;
    }

    if (expression) {
        statement1;
    } else if (expression1) {
        statement2;
    } else {
        statement3;
    }
</code></pre>

<h5>循环语句</h5>

<p>awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。</p>

<h5>数组</h5>

<p> 因为awk中数组的下标可以是数字和字母，数组的下标通常被称为关键字(key)。值和关键字都存储在内部的一张针对key/value应用hash的表格里。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。</p>

<p>显示/etc/passwd的账户
<code>
    awk -F ':' 'BEGIN {count=0;} {name[count] = $1;count++;}; END{for (i = 0; i &lt; NR; i++) print i, name[i]}' /etc/passwd
    0 root
    1 daemon
    2 bin
    3 sys
    4 sync
    5 games
    ......
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[curl命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/11/17/command-curl/"/>
    <updated>2015-11-17T10:04:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/11/17/command-curl</id>
    <content type="html"><![CDATA[<p>-s 静默输出；没有-s的话就是下面的情况，这是在脚本等情况下不需要的信息。</p>

<h4>监控首页各项时间指标：</h4>

<pre><code>    curl -o /dev/null -s -w '%{time_connect} %{time_starttransfer} %{time_total}' http://www.miotour.com
    0.244 1.044 2.672

    时间指标解释 ：
    time_connect        建立到服务器的 TCP 连接所用的时间
    time_starttransfer  在发出请求之后，Web 服务器返回数据的第一个字节所用的时间
    time_total          完成请求所用的时间
</code></pre>

<p>在发出请求之后，Web 服务器处理请求并开始发回数据所用的时间是 （time_starttransfer）1.044 - （time_connect）0.244 = 0.8 秒</p>

<p>客户机从服务器下载数据所用的时间是 （time_total）2.672 - （time_starttransfer）1.044 = 1.682 秒</p>

<h4>-x 指定访问IP与端口号</h4>

<pre><code>    curl -x 61.135.169.105:80 http://www.baidu.com
</code></pre>

<h4>-I 仅仅取文件的http头部</h4>

<pre><code>    curl   -I  -x 192.168.1.1:80  http://www.miotour.com
</code></pre>

<h4>用referer做的防盗链，就可以使用-e来设置</h4>

<pre><code>    curl -e "http://www.qiecuo.org"    http:// www.miotour.com -v  -I
</code></pre>

<h4>-H去构造你想要的http头部</h4>

<pre><code>    curl -H "X-Forward-For:8.8.8.8" http://www.miotour.com  -v  -I
</code></pre>

<h4>curl提交用户名和密码</h4>

<pre><code>    curl http://name:passwd@www.miotour.com
    curl -u name:passwd http://www.miotour.com
</code></pre>

<h4>-b “cookie” 此参数用来构造一个携带cookie的请求</h4>

<h4>USER AGENT   关于浏览器发送的http请求信息. Curl允许用命令制定. 发送一些用于欺骗服务器或cgi的信息.</h4>

<pre><code>    curl -A 'Mozilla/3.0 (Win95; I)' http://www.nationsbank.com/
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[alias命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/11/17/command-alias/"/>
    <updated>2015-11-17T09:48:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/11/17/command-alias</id>
    <content type="html"><![CDATA[<p>功能说明: 设置指令的别名。</p>

<p>语   法: alias[别名]=[指令名称]</p>

<p>参   数: 若不加任何参数，则列出目前所有的别名设置。</p>

<p>举   例:
<code>
    alias
    alias egrep='egrep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias grep='grep --color=auto'
    alias l='ls -CF'
    alias la='ls -A'
    alias ll='ls -alF'
    alias ls='ls --color=auto'
</code></p>

<p>说   明：用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。　alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在/etc/profile或自己的~/.bashrc中设定指令的别名。</p>

<p>  如果你想给每一位用户都生效的别名，请把alias la=&lsquo;ls -al&rsquo; 一行加在/etc/bashrc最后面，bashrc是环境变量的配置文件 /etc/bashrc和~/.bashrc 区别就在于一个是设置给全系统一个是设置给单用户使用.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iostat 命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/08/21/tools-command-iostat/"/>
    <updated>2015-08-21T15:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/08/21/tools-command-iostat</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangjay/article/details/6656771">http://blog.csdn.net/zhangjay/article/details/6656771</a></p>

<p><a href="http://www.cnblogs.com/mfryf/archive/2012/03/12/2392000.html">http://www.cnblogs.com/mfryf/archive/2012/03/12/2392000.html</a></p>

<p>iostat用于输出CPU和磁盘I/O相关的统计信息.</p>

<p>命令格式:
<code>
    iostat [ -c | -d ] [ -k | -m ] [ -t ] [ -V ] [ -x ] [ device [ ... ] | ALL ] [ -p [ device | ALL ]  ]
           [ interval [ count ] ]
</code></p>

<h4>1)iostat的 简单使用</h4>

<p>iostat可以显示CPU和I/O系统的负载情况及分区状态信息. 直接执行iostat可以显示下面内容:
```
    # iostat
    Linux 2.6.9-8.11.EVAL (ts3-150.ts.cn.tlan)      08/08/2007</p>

<pre><code>avg-cpu:  %user   %nice    %sys %iowait   %idle
          12.01    0.00        2.15    2.30       83.54

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
hda               7.13       200.12        34.73     640119     111076
</code></pre>

<pre><code>
各个输出项目的含义如下:

avg-cpu段:
</code></pre>

<pre><code>%user: 在用户级别运行所使用的CPU的百分比.
%nice: nice操作所使用的CPU的百分比.
%sys: 在系统级别(kernel)运行所使用CPU的百分比.
%iowait: CPU等待硬件I/O时,所占用CPU百分比.
%idle: CPU空闲时间的百分比.
</code></pre>

<pre><code>
Device段:
</code></pre>

<pre><code>tps: 每秒钟发送到的I/O请求数.
Blk_read /s: 每秒读取的block数.
Blk_wrtn/s: 每秒写入的block数.
Blk_read:   读入的block总数.
Blk_wrtn:  写入的block总数.
</code></pre>

<pre><code>
#### 2)iostat参 数说明

iostat各个参数说明:
</code></pre>

<pre><code>-c 仅显示CPU统计信息.与-d选项互斥.
-d 仅显示磁盘统计信息.与-c选项互斥.
-k 以K为单位显示每秒的磁盘请求数,默认单位块.
-p device | ALL
 与-x选项互斥,用于显示块设备及系统分区的统计信息.也可以在-p后指定一个设备名,如:
 # iostat -p hda
 或显示所有设备
 # iostat -p ALL
-t    在输出数据时,打印搜集数据的时间.
-V    打印版本号和帮助信息.
-x    输出扩展信息.
</code></pre>

<pre><code>
#### 3)iostat输 出项目说明
</code></pre>

<pre><code>rrqm/s: 每秒进行 merge 的读操作数目。即 delta(rmerge)/s
wrqm/s: 每秒进行 merge 的写操作数目。即 delta(wmerge)/s
r/s: 每秒完成的读 I/O 设备次数。即 delta(rio)/s
w/s: 每秒完成的写 I/O 设备次数。即 delta(wio)/s
rsec/s: 每秒读扇区数。即 delta(rsect)/s
wsec/s: 每秒写扇区数。即 delta(wsect)/s
rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算)
wkB/s: 每秒写K字节数。是 wsect/s 的一半。(需要计算)
avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。delta(rsect+wsect)/delta(rio+wio)
avgqu-sz: 平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。
await: 平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)
svctm: 平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)
%util: 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为use的单位为毫秒)
如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。

Blk_read 读入块的当总数.
Blk_wrtn 写入块的总数.
kB_read/s 每秒从驱动器读入的数据量,单位为K.
kB_wrtn/s 每秒向驱动器写入的数据量,单位为K.
kB_read 读入的数据总量,单位为K.
kB_wrtn 写入的数据总量,单位为K.
rrqm/s 将读入请求合并后,每秒发送到设备的读入请求数.
wrqm/s 将写入请求合并后,每秒发送到设备的写入请求数.
r/s 每秒发送到设备的读入请求数.
w/s 每秒发送到设备的写入请求数.
rsec/s 每秒从设备读入的扇区数.
wsec/s 每秒向设备写入的扇区数.
rkB/s 每秒从设备读入的数据量,单位为K.
wkB/s 每秒向设备写入的数据量,单位为K.
avgrq-sz 发送到设备的请求的平均大小,单位是扇区.
avgqu-sz 发送到设备的请求的平均队列长度.
await I/O请求平均执行时间.包括发送请求和执行的时间.单位是毫秒.
svctm 发送到设备的I/O请求的平均执行时间.单位是毫秒.
%util 在I/O请求发送到设备期间,占用CPU时间的百分比.用于显示设备的带宽利用率.当这个值接近100%时,表示设备带宽已经占满.
</code></pre>

<pre><code>
#### 4)iostat示 例
</code></pre>

<pre><code># iostat
显示一条统计记录,包括所有的CPU和设备.

# iostat -d 2
每隔2秒,显示一次设备统计信息.

# iostat -d 2 6
每隔2秒,显示一次设备统计信息.总共输出6次.

# iostat -x hda hdb 2 6
每隔2秒显示一次hda,hdb两个设备的扩展统计信息,共输出6次.

# iostat -p sda 2 6
每隔2秒显示一次sda及上面所有分区的统计信息,共输出6次.
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
