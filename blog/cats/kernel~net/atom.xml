<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel~net | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel~net/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2016-02-29T23:44:14+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[socket建立连接 sys_connect]]></title>
    <link href="http://abcdxyzk.github.io/blog/2016/02/29/kernel-net-connect/"/>
    <updated>2016-02-29T22:52:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2016/02/29/kernel-net-connect</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/chensichensi/article/details/5272346">http://blog.csdn.net/chensichensi/article/details/5272346</a></p>

<p><a href="http://blog.csdn.net/qy532846454/article/details/7882819">http://blog.csdn.net/qy532846454/article/details/7882819</a></p>

<p><a href="http://www.2cto.com/kf/201303/198459.html">http://www.2cto.com/kf/201303/198459.html</a></p>

<pre><code>    connect(fd, servaddr, addrlen);
    -&gt; SYSCALL_DEFINE3()
    -&gt; sock-&gt;ops-&gt;connect() == inet_stream_connect (sock-&gt;ops即inet_stream_ops)
    -&gt; tcp_v4_connect()
        -&gt; inet_hash_connect()
            -&gt; __inet_hash_connect()
                -&gt; check_established()
                    -&gt; __inet_check_established()
</code></pre>

<pre><code>    SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
            int, addrlen)
    {
        struct socket *sock;
        struct sockaddr_storage address;
        int err, fput_needed;
        /* 找到文件描述符对应的BSD socket结构，在前面的socket调用中建立*/
        sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);
        if (!sock)
            goto out;
        /* copy对端的地址到内核空间 */
        err = move_addr_to_kernel(uservaddr, addrlen, (struct sockaddr *)&amp;address);
        if (err &lt; 0)
            goto out_put;

        err =
            security_socket_connect(sock, (struct sockaddr *)&amp;address, addrlen);
        if (err)
            goto out_put;
        /* 调用该BSD socket对应的connect调用 */
        err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)&amp;address, addrlen,
                     sock-&gt;file-&gt;f_flags);
    out_put:
        /* 释放文件的引用 */
        fput_light(sock-&gt;file, fput_needed);
    out:
        return err;
    }
</code></pre>

<pre><code>    /*
     *  Connect to a remote host. There is regrettably still a little
     *  TCP 'magic' in here.
     */
    int inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,
                int addr_len, int flags)
    {
        struct sock *sk = sock-&gt;sk;
        int err;
        long timeo;

        lock_sock(sk);

        if (uaddr-&gt;sa_family == AF_UNSPEC) {
            err = sk-&gt;sk_prot-&gt;disconnect(sk, flags);
            sock-&gt;state = err ? SS_DISCONNECTING : SS_UNCONNECTED;
            goto out;
        }

        switch (sock-&gt;state) {
        default:
            err = -EINVAL;
            goto out;
        case SS_CONNECTED:     /* 该BSD socket已连接*/
            err = -EISCONN;
            goto out;
        case SS_CONNECTING:   /* 该BSD socket正在连接*/
            err = -EALREADY;
            /* Fall out of switch with err, set for this state */
            break;
        case SS_UNCONNECTED:
            err = -EISCONN;
            if (sk-&gt;sk_state != TCP_CLOSE)
                goto out;
                /* INET SOCKET 调用协议特有connect操作符 */
            err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);
            if (err &lt; 0)
                goto out;
                /* 上面的调用完成后，连接并没有完成，*/
            sock-&gt;state = SS_CONNECTING;

            /* Just entered SS_CONNECTING state; the only
             * difference is that return value in non-blocking
             * case is EINPROGRESS, rather than EALREADY.
             */
            err = -EINPROGRESS;
            break;
        }
        /* 获取连接超时时间*/
        timeo = sock_sndtimeo(sk, flags &amp; O_NONBLOCK);

        if ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
            /* Error code is set above 进入定时等待 */
            if (!timeo || !inet_wait_for_connect(sk, timeo))
                goto out;

            err = sock_intr_errno(timeo);
            if (signal_pending(current))
                goto out;
        }

        /* Connection was closed by RST, timeout, ICMP error
         * or another process disconnected us.
         */
        if (sk-&gt;sk_state == TCP_CLOSE)
            goto sock_error;

        /* sk-&gt;sk_err may be not zero now, if RECVERR was ordered by user
         * and error was received after socket entered established state.
         * Hence, it is handled normally after connect() return successfully.
         */

        sock-&gt;state = SS_CONNECTED;
        err = 0;
    out:
        release_sock(sk);
        return err;

    sock_error:
        err = sock_error(sk) ? : -ECONNABORTED;
        sock-&gt;state = SS_UNCONNECTED;
        if (sk-&gt;sk_prot-&gt;disconnect(sk, flags))
            sock-&gt;state = SS_DISCONNECTING;
        goto out;
    }
</code></pre>

<pre><code>    /* This will initiate an outgoing connection. */
    int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
    {
        struct inet_sock *inet = inet_sk(sk);
        struct tcp_sock *tp = tcp_sk(sk);
        struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;
        struct rtable *rt;
        __be32 daddr, nexthop;
        int tmp;
        int err;

        if (addr_len &lt; sizeof(struct sockaddr_in))
            return -EINVAL;

        if (usin-&gt;sin_family != AF_INET)
            return -EAFNOSUPPORT;
        /* 开始准备路由 */
        nexthop = daddr = usin-&gt;sin_addr.s_addr;
        if (inet-&gt;opt &amp;&amp; inet-&gt;opt-&gt;srr) {
            if (!daddr)
                return -EINVAL;
            nexthop = inet-&gt;opt-&gt;faddr;
        }
        /* 调用路由模块获取出口信息，这里不深入 */
        tmp = ip_route_connect(&amp;rt, nexthop, inet-&gt;saddr,
                       RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,
                       IPPROTO_TCP,
                       inet-&gt;sport, usin-&gt;sin_port, sk, 1);
        if (tmp &lt; 0) {
            if (tmp == -ENETUNREACH)
                IP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);
            return tmp;
        }
        /* 如果获取的路由是广播或多播域， 返回网络不可达，tcp不支持多播与广播 */
        if (rt-&gt;rt_flags &amp; (RTCF_MULTICAST | RTCF_BROADCAST)) {
            ip_rt_put(rt);
            return -ENETUNREACH;
        }

        if (!inet-&gt;opt || !inet-&gt;opt-&gt;srr)
            daddr = rt-&gt;rt_dst;

        if (!inet-&gt;saddr)
            inet-&gt;saddr = rt-&gt;rt_src;
        inet-&gt;rcv_saddr = inet-&gt;saddr;

        if (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; inet-&gt;daddr != daddr) {
            /* Reset inherited state */
            tp-&gt;rx_opt.ts_recent       = 0;
            tp-&gt;rx_opt.ts_recent_stamp = 0;
            tp-&gt;write_seq          = 0;
        }

        if (tcp_death_row.sysctl_tw_recycle &amp;&amp;
            !tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; rt-&gt;rt_dst == daddr) {
            struct inet_peer *peer = rt_get_peer(rt);
            /*
             * VJ's idea. We save last timestamp seen from
             * the destination in peer table, when entering state
             * TIME-WAIT * and initialize rx_opt.ts_recent from it,
             * when trying new connection.
             */
            if (peer != NULL &amp;&amp;
                peer-&gt;tcp_ts_stamp + TCP_PAWS_MSL &gt;= get_seconds()) {
                tp-&gt;rx_opt.ts_recent_stamp = peer-&gt;tcp_ts_stamp;
                tp-&gt;rx_opt.ts_recent = peer-&gt;tcp_ts;
            }
        }

        inet-&gt;dport = usin-&gt;sin_port;
        inet-&gt;daddr = daddr;

        inet_csk(sk)-&gt;icsk_ext_hdr_len = 0;
        if (inet-&gt;opt)
            inet_csk(sk)-&gt;icsk_ext_hdr_len = inet-&gt;opt-&gt;optlen;
        /* mss_clamp */
        tp-&gt;rx_opt.mss_clamp = 536;

        /* Socket identity is still unknown (sport may be zero).
         * However we set state to SYN-SENT and not releasing socket
         * lock select source port, enter ourselves into the hash tables and
         * complete initialization after this.
         */
        tcp_set_state(sk, TCP_SYN_SENT);
        err = inet_hash_connect(&amp;tcp_death_row, sk);
        if (err)
            goto failure;

        err = ip_route_newports(&amp;rt, IPPROTO_TCP,
                    inet-&gt;sport, inet-&gt;dport, sk);
        if (err)
            goto failure;

        /* OK, now commit destination to socket.  */
        sk-&gt;sk_gso_type = SKB_GSO_TCPV4;
        sk_setup_caps(sk, &amp;rt-&gt;u.dst);

        if (!tp-&gt;write_seq)
            tp-&gt;write_seq = secure_tcp_sequence_number(inet-&gt;saddr,
                                   inet-&gt;daddr,
                                   inet-&gt;sport,
                                   usin-&gt;sin_port);
        /* id是IP包头的id域 */
        inet-&gt;id = tp-&gt;write_seq ^ jiffies;

        err = tcp_connect(sk);
        rt = NULL;
        if (err)
            goto failure;

        return 0;

    failure:
        /*
         * This unhashes the socket and releases the local port,
         * if necessary.
         */
        tcp_set_state(sk, TCP_CLOSE);
        ip_rt_put(rt);
        sk-&gt;sk_route_caps = 0;
        inet-&gt;dport = 0;
        return err;
    }
</code></pre>

<p>当snum==0时，表明此时源端口没有指定，此时会随机选择一个空闲端口作为此次连接的源端口。low和high分别表示可用端口的下限和上限，remaining表示可用端口的数，注意这里的可用只是指端口可以用作源端口，其中部分端口可能已经作为其它socket的端口号在使用了，所以要循环1~remaining，直到查找到空闲的源端口。</p>

<p>下面来看下对每个端口的检查，即//choose a valid port部分的代码。这里要先了解下tcp的内核表组成，udp的表内核表udptable只是一张hash表，tcp的表则稍复杂，它的名字是tcp_hashinfo，在tcp_init()中被初始化，这个数据结构定义如下(省略了不相关的数据)：</p>

<pre><code>    struct inet_hashinfo {
        struct inet_ehash_bucket *ehash;
        ……
        struct inet_bind_hashbucket *bhash;
        ……
        struct inet_listen_hashbucket  listening_hash[INET_LHTABLE_SIZE]
                        ____cacheline_aligned_in_smp;
    };
</code></pre>

<p>从定义可以看出，tcp表又分成了三张表ehash, bhash, listening_hash，其中ehash, listening_hash对应于socket处在TCP的ESTABLISHED, LISTEN状态，bhash对应于socket已绑定了本地地址。三者间并不互斥，如一个socket可同时在bhash和ehash中，由于TIME_WAIT是一个比较特殊的状态，所以ehash又分成了chain和twchain，为TIME_WAIT的socket单独形成一张表。</p>

<p>回到刚才的代码，现在还只是建立socket连接，使用的就应该是tcp表中的bhash。首先取得内核tcp表的bind表 – bhash，查看是否已有socket占用：</p>

<p>如果没有，则调用inet_bind_bucket_create()创建一个bind表项tb，并插入到bind表中，跳转至goto ok代码段；
如果有，则跳转至goto ok代码段。</p>

<p>进入ok代码段表明已找到合适的bind表项(无论是创建的还是查找到的)，调用inet_bind_hash()赋值源端口inet_num。</p>

<p>inet_hash_connect()函数只是对<code>__inet_hash_connect()</code>函数进行了简单的封装。在<code>__inet_hash_connect()</code>中如果已绑定了端口号，并且是和其他传输控制块共享绑定的端口号，则会调用check_established参数指向的函数来检查这个绑定的端口号是否可用，代码如下所示：</p>

<pre><code>    int __inet_hash_connect(struct inet_timewait_death_row *death_row,
            struct sock *sk, u32 port_offset,
            int (*check_established)(struct inet_timewait_death_row *,
            struct sock *, __u16, struct inet_timewait_sock **),
            void (*hash)(struct sock *sk))
    {
        struct inet_hashinfo *hinfo = death_row-&gt;hashinfo;
        const unsigned short snum = inet_sk(sk)-&gt;num;
        struct inet_bind_hashbucket *head;
        struct inet_bind_bucket *tb;
        int ret;
        struct net *net = sock_net(sk);

        if (!snum) {
            int i, remaining, low, high, port;
            static u32 hint;
            u32 offset = hint + port_offset;
            struct hlist_node *node;
            struct inet_timewait_sock *tw = NULL;

            inet_get_local_port_range(&amp;low, &amp;high);
            remaining = (high - low) + 1;

            local_bh_enable();
            for (i = 1; i &lt;= remaining; i++) {
                port = low + (i + offset) % remaining;
                if (inet_is_reserved_local_port(port)
                    continue;
                head = &amp;hinfo-&gt;bhash[inet_bhashfn(net, port, hinfo-&gt;bhash_size)];
                spin_lock(&amp;head-&gt;lock);
                inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain) {
                    if (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == port) {
                        if (tb-&gt;fastreuse &gt;= 0)
                            goto next_port;
                        WARN_ON(hlist_empty(&amp;tb-&gt;owners));
                        if (!check_established(death_row, sk, port, &amp;tw))
                            goto ok;
                        goto next_port;
                    }
                }

                tb = inet_bind_bucket_create(hinfo-&gt;bind_bucket_cachep, net, head, port);
                if (!tb) {
                    spin_unlock(&amp;head-&gt;lock);
                    break;
                }
                tb-&gt;fastreuse = -1;
                tb-&gt;fastreuseport = -1;
                goto ok;
            next_port:
                spin_unlock(&amp;head-&gt;lock);
            }
            local_bh_enable();

            return -EADDRNOTAVAIL;

    ok:
            hint += i;

            inet_bind_hash(sk, tb, port);
            if (sk_unhashed(sk)) {
                inet_sk(sk)-&gt;sport = htons(port);
                hash(sk);
            }
            spin_unlock(&amp;head-&gt;lock);
            if (tw) {
                inet_twsk_deschedule(tw, death_row);
                inet_twsk_put(tw);
            }

            ret = 0;
            goto out;
        }

        head = &amp;hinfo-&gt;bhash[inet_bhashfn(net, snum, hinfo-&gt;bhash_size)];
        tb  = inet_csk(sk)-&gt;icsk_bind_hash;
        spin_lock_bh(&amp;head-&gt;lock);
        if (sk_head(&amp;tb-&gt;owners) == sk &amp;&amp; !sk-&gt;sk_bind_node.next) {
            hash(sk);
            spin_unlock_bh(&amp;head-&gt;lock);
            return 0;
        } else {
            spin_unlock(&amp;head-&gt;lock);
            /* No definite answer... Walk to established hash table */
            ret = check_established(death_row, sk, snum, NULL);
    out:
            local_bh_enable();
            return ret;
        }
    }
</code></pre>

<p>(sk_head(&amp;tb->owners) == sk &amp;&amp; !sk->sk_bind_node.next)这个判断条件就是用来判断是不是只有当前传输控制块在使用已绑定的端口，条件为false时，会执行else分支，检查是否可用。这么看来，调用bind()成功并不意味着这个端口就真的可以用。</p>

<p>check_established参数对应的函数是<code>__inet_check_established()</code>，在inet_hash_connect()中可以看到。在上面的代码中我们还注意到调用check_established()时第三个参数为NULL，这在后面的分析中会用到。</p>

<p><code>__inet_check_established()</code>函数中，会分别在TIME_WAIT传输控制块和除TIME_WIAT、LISTEN状态外的传输控制块中查找是已绑定的端口是否已经使用，代码片段如下所示：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt; called with local bh disabled &lt;/em&gt;/
</span><span class='line'>static int &lt;strong&gt;inet_check_established(struct inet_timewait_death_row &lt;em&gt;death_row,
</span><span class='line'>            struct sock &lt;/em&gt;sk, &lt;/strong&gt;u16 lport,
</span><span class='line'>            struct inet_timewait_sock &lt;em&gt;&lt;em&gt;twp)
</span><span class='line'>{
</span><span class='line'>    struct inet_hashinfo &lt;/em&gt;hinfo = death_row-&gt;hashinfo;
</span><span class='line'>    struct inet_sock &lt;/em&gt;inet = inet_sk(sk);
</span><span class='line'>    &lt;strong&gt;be32 daddr = inet-&gt;rcv_saddr;
</span><span class='line'>    &lt;/strong&gt;be32 saddr = inet-&gt;daddr;
</span><span class='line'>    int dif = sk-&gt;sk_bound_dev_if;
</span><span class='line'>    INET_ADDR_COOKIE(acookie, saddr, daddr)
</span><span class='line'>    const __portpair ports = INET_COMBINED_PORTS(inet-&gt;dport, lport);
</span><span class='line'>    struct net &lt;em&gt;net = sock_net(sk);
</span><span class='line'>    unsigned int hash = inet_ehashfn(net, daddr, lport, saddr, inet-&gt;dport);
</span><span class='line'>    struct inet_ehash_bucket &lt;/em&gt;head = inet_ehash_bucket(hinfo, hash);
</span><span class='line'>    spinlock_t &lt;em&gt;lock = inet_ehash_lockp(hinfo, hash);
</span><span class='line'>    struct sock &lt;/em&gt;sk2;
</span><span class='line'>    const struct hlist_nulls_node &lt;em&gt;node;
</span><span class='line'>    struct inet_timewait_sock &lt;/em&gt;tw;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    spin_lock(lock);
</span><span class='line'>
</span><span class='line'>/* Check TIME-WAIT sockets first. */
</span><span class='line'>sk_nulls_for_each(sk2, node, &amp;head-&gt;twchain) {
</span><span class='line'>    tw = inet_twsk(sk2);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    if (INET_TW_MATCH(sk2, net, hash, acookie,
</span><span class='line'>            saddr, daddr, ports, dif)) {
</span><span class='line'>        if (twsk_unique(sk, sk2, twp))
</span><span class='line'>            goto unique;
</span><span class='line'>        else
</span><span class='line'>            goto not_unique;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>tw = NULL;
</span><span class='line'>
</span><span class='line'>/* And established part... */
</span><span class='line'>sk_nulls_for_each(sk2, node, &amp;head-&gt;chain) {
</span><span class='line'>    if (INET_MATCH(sk2, net, hash, acookie,
</span><span class='line'>            saddr, daddr, ports, dif))
</span><span class='line'>        goto not_unique;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>unique:
</span><span class='line'>......
</span><span class='line'>return 0;
</span><span class='line'>
</span><span class='line'>not_unique:
</span><span class='line'>spin_unlock(lock);
</span><span class='line'>return -EADDRNOTAVAIL;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>如果是TCP套接字，twsk_uniqueue()中会调用tcp_twsk_uniqueue()来判断，返回true的条件如下所示：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp)
</span><span class='line'>{
</span><span class='line'>const struct tcp_timewait_sock *tcptw = tcp_twsk(sktw);
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>if (tcptw-&gt;tw_ts_recent_stamp &amp;&amp;
</span><span class='line'>        (twp == NULL || (sysctl_tcp_tw_reuse &amp;&amp;
</span><span class='line'>        get_seconds() - tcptw-&gt;tw_ts_recent_stamp &gt; 1))) {
</span><span class='line'>    ......
</span><span class='line'>    return 1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/*
</span><span class='line'> * Build a SYN and send it off.
</span><span class='line'> */
</span><span class='line'>int tcp_connect(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>struct sk_buff *buff;
</span><span class='line'>/* 初始化连接对应的INET socket结构的参数，为连接做准备 */
</span><span class='line'>tcp_connect_init(sk);
</span><span class='line'>/* 获取一个skb，由于是syn包，没有数据，所以大小是MAX_TCP_HEADER的16位对齐 */
</span><span class='line'>buff = alloc_skb_fclone(MAX_TCP_HEADER + 15, sk-&gt;sk_allocation);
</span><span class='line'>if (unlikely(buff == NULL))
</span><span class='line'>    return -ENOBUFS;
</span><span class='line'>
</span><span class='line'>/* Reserve space for headers. */
</span><span class='line'>skb_reserve(buff, MAX_TCP_HEADER);
</span><span class='line'>
</span><span class='line'>tp-&gt;snd_nxt = tp-&gt;write_seq;
</span><span class='line'>/* 设置skb相关参数 */
</span><span class='line'>tcp_init_nondata_skb(buff, tp-&gt;write_seq++, TCPCB_FLAG_SYN);
</span><span class='line'>/* 设置ECN */
</span><span class='line'>TCP_ECN_send_syn(sk, buff);
</span><span class='line'>
</span><span class='line'>/* Send it off. */
</span><span class='line'>/* 保存该数据包的发送时间*/
</span><span class='line'>TCP_SKB_CB(buff)-&gt;when = tcp_time_stamp;
</span><span class='line'>tp-&gt;retrans_stamp = TCP_SKB_CB(buff)-&gt;when;
</span><span class='line'>skb_header_release(buff);
</span><span class='line'>/* 加入发送队列，待确认后在丢弃*/
</span><span class='line'>__tcp_add_write_queue_tail(sk, buff);
</span><span class='line'>sk-&gt;sk_wmem_queued += buff-&gt;truesize;
</span><span class='line'>sk_mem_charge(sk, buff-&gt;truesize);
</span><span class='line'>tp-&gt;packets_out += tcp_skb_pcount(buff);
</span><span class='line'>tcp_transmit_skb(sk, buff, 1, GFP_KERNEL);
</span><span class='line'>
</span><span class='line'>/* We change tp-&gt;snd_nxt after the tcp_transmit_skb() call
</span><span class='line'> * in order to make this packet get counted in tcpOutSegs.
</span><span class='line'> */
</span><span class='line'>tp-&gt;snd_nxt = tp-&gt;write_seq;
</span><span class='line'>tp-&gt;pushed_seq = tp-&gt;write_seq;
</span><span class='line'>TCP_INC_STATS(sock_net(sk), TCP_MIB_ACTIVEOPENS);
</span><span class='line'>
</span><span class='line'>/* Timer for repeating the SYN until an answer. */
</span><span class='line'>inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
</span><span class='line'>              inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/*
</span><span class='line'> * Do all connect socket setups that can be done AF independent.
</span><span class='line'> */
</span><span class='line'>static void tcp_connect_init(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>struct dst_entry *dst = __sk_dst_get(sk);
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>__u8 rcv_wscale;
</span><span class='line'>
</span><span class='line'>/* We'll fix this up when we get a response from the other end.
</span><span class='line'> * See tcp_input.c:tcp_rcv_state_process case TCP_SYN_SENT.
</span><span class='line'> */
</span><span class='line'>tp-&gt;tcp_header_len = sizeof(struct tcphdr) +
</span><span class='line'>    (sysctl_tcp_timestamps ? TCPOLEN_TSTAMP_ALIGNED : 0);
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_TCP_MD5SIG
</span><span class='line'>if (tp-&gt;af_specific-&gt;md5_lookup(sk, sk) != NULL)
</span><span class='line'>    tp-&gt;tcp_header_len += TCPOLEN_MD5SIG_ALIGNED;
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>/* If user gave his TCP_MAXSEG, record it to clamp */
</span><span class='line'>if (tp-&gt;rx_opt.user_mss)
</span><span class='line'>    tp-&gt;rx_opt.mss_clamp = tp-&gt;rx_opt.user_mss;
</span><span class='line'>tp-&gt;max_window = 0;
</span><span class='line'>/* 初始化MTU probe*/
</span><span class='line'>tcp_mtup_init(sk);
</span><span class='line'>/* 设置mss */
</span><span class='line'>tcp_sync_mss(sk, dst_mtu(dst));
</span><span class='line'>
</span><span class='line'>if (!tp-&gt;window_clamp)
</span><span class='line'>    tp-&gt;window_clamp = dst_metric(dst, RTAX_WINDOW);
</span><span class='line'>tp-&gt;advmss = dst_metric(dst, RTAX_ADVMSS);
</span><span class='line'>if (tp-&gt;rx_opt.user_mss &amp;&amp; tp-&gt;rx_opt.user_mss &lt; tp-&gt;advmss)
</span><span class='line'>    tp-&gt;advmss = tp-&gt;rx_opt.user_mss;
</span><span class='line'>
</span><span class='line'>tcp_initialize_rcv_mss(sk);
</span><span class='line'>/* 根据接收空间大小初始化一个通告窗口 */
</span><span class='line'>tcp_select_initial_window(tcp_full_space(sk),
</span><span class='line'>              tp-&gt;advmss - (tp-&gt;rx_opt.ts_recent_stamp ? tp-&gt;tcp_header_len - sizeof(struct tcphdr) : 0),
</span><span class='line'>              &amp;tp-&gt;rcv_wnd,
</span><span class='line'>              &amp;tp-&gt;window_clamp,
</span><span class='line'>              sysctl_tcp_window_scaling,
</span><span class='line'>              &amp;rcv_wscale);
</span><span class='line'>
</span><span class='line'>tp-&gt;rx_opt.rcv_wscale = rcv_wscale;
</span><span class='line'>tp-&gt;rcv_ssthresh = tp-&gt;rcv_wnd;
</span><span class='line'>
</span><span class='line'>sk-&gt;sk_err = 0;
</span><span class='line'>sock_reset_flag(sk, SOCK_DONE);
</span><span class='line'>tp-&gt;snd_wnd = 0;
</span><span class='line'>/* 更新一些滑动窗口的成员*/
</span><span class='line'>tcp_init_wl(tp, tp-&gt;write_seq, 0);
</span><span class='line'>tp-&gt;snd_una = tp-&gt;write_seq;
</span><span class='line'>tp-&gt;snd_sml = tp-&gt;write_seq;
</span><span class='line'>tp-&gt;snd_up = tp-&gt;write_seq;
</span><span class='line'>tp-&gt;rcv_nxt = 0;
</span><span class='line'>tp-&gt;rcv_wup = 0;
</span><span class='line'>tp-&gt;copied_seq = 0;
</span><span class='line'>
</span><span class='line'>inet_csk(sk)-&gt;icsk_rto = TCP_TIMEOUT_INIT;
</span><span class='line'>inet_csk(sk)-&gt;icsk_retransmits = 0;
</span><span class='line'>tcp_clear_retrans(tp);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>skb发送后，connect并没有返回，因为此时连接还没有建立，tcp进入等待状态，此时回到前面的inet_stream_connect函数
</span><span class='line'>
</span><span class='line'>在发送syn后进入等待状态
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static long inet_wait_for_connect(struct sock *sk, long timeo)
</span><span class='line'>{
</span><span class='line'>DEFINE_WAIT(wait);
</span><span class='line'>/* sk_sleep 保存此INET SOCKET的等待队列 */
</span><span class='line'>prepare_to_wait(sk-&gt;sk_sleep, &amp;wait, TASK_INTERRUPTIBLE);
</span><span class='line'>
</span><span class='line'>/* Basic assumption: if someone sets sk-&gt;sk_err, he _must_
</span><span class='line'> * change state of the socket from TCP_SYN_*.
</span><span class='line'> * Connect() does not allow to get error notifications
</span><span class='line'> * without closing the socket.
</span><span class='line'> */
</span><span class='line'>/* 定时等待知道状态变化 */
</span><span class='line'>while ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
</span><span class='line'>    release_sock(sk);
</span><span class='line'>    timeo = schedule_timeout(timeo);
</span><span class='line'>    lock_sock(sk);
</span><span class='line'>    if (signal_pending(current) || !timeo)
</span><span class='line'>        break;
</span><span class='line'>    prepare_to_wait(sk-&gt;sk_sleep, &amp;wait, TASK_INTERRUPTIBLE);
</span><span class='line'>}
</span><span class='line'>finish_wait(sk-&gt;sk_sleep, &amp;wait);
</span><span class='line'>return timeo;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[udp checksum]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2016/01/21/kernel-net-udp-sum/"/&gt;
</span><span class='line'>&lt;updated&gt;2016-01-21T16:43:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2016/01/21/kernel-net-udp-sum&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://wenx05124561.blog.163.com/blog/static/124000805201242032041268/"&gt;http://wenx05124561.blog.163.com/blog/static/124000805201242032041268/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;a. 网卡设备属性&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    #define NETIF_F_IP_CSUM     2   /* 基于IPv4的L4层checksum. */  
</span><span class='line'>#define NETIF_F_NO_CSUM     4   /* 设备可靠不需要L4层checksum. loopack. */  
</span><span class='line'>#define NETIF_F_HW_CSUM     8   /* 基于所有协议的L4层checksum*/  
</span><span class='line'>#define NETIF_F_IPV6_CSUM   16  /* 基于IPv6的L4层checksum*/  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;通过ethtool -k eth0可以查看网卡是否支持硬件checksum，tx-checksumming: on  表明支持发送hardware checksum。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;b. linux UDP checksum数据结构&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    union {
</span><span class='line'>    __wsum  csum;
</span><span class='line'>    struct {
</span><span class='line'>        __u16   csum_start;
</span><span class='line'>        __u16   csum_offset;
</span><span class='line'>    };
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1） skb-&gt;csum和skb-&gt;ip_summed这两个域也是与4层校验相关的，这两个域的含义依赖于skb表示的是一个输入包还是一个输出包。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2） 当网卡设备能提供硬件checksum并且作为输出包的时候，表示为skb-&gt;csum_start和skb-&gt;csum_offset&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;csum_start: Offset from skb-&gt;head where checksumming should start&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;csum_offset: Offset from csum_start where checksum should be stored&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;当数据包是一个输入包时&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;skb-&gt;ip_summed表示的是四层校验的状态，下面的几个宏定义表示了设备驱动传递给4层的一些信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    #define CHECKSUM_NONE 0
</span><span class='line'>#define CHECKSUM_UNNECESSARY 1
</span><span class='line'>#define CHECKSUM_COMPLETE 2
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;skb-&gt;csum:存放硬件或者软件计算的payload的checksum不包括伪头，但是是否有意义由skb-&gt;ip_summed的值决定。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CHECKSUM_NONE表示csum域中的校验值是无意义的，需要L4层自己校验payload和伪头。有可能是硬件检验出错或者硬件没有校验功能，协议栈软件更改如pskb_trim_rcsum函数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CHECKSUM_UNNECESSARY表示网卡或者协议栈已经计算和验证了L4层的头和校验值。也就是计算了tcp udp的伪头。还有一种情况就是回环，因为在回环中错误发生的概率太低了，因此就不需要计算校验来节省cpu事件。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CHECKSUM_COMPLETE表示网卡已经计算了L4层payload的校验，并且csum已经被赋值，此时L4层的接收者只需要加伪头并验证校验结果。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1) 在L4层发现如果udp-&gt;check位段被设为0，那么skb-&gt;ip_summed直接设为CHECKSUM_UNNECESSARY，放行该报文。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2) 如果skb-&gt;ip_summed为CHECKSUM_COMPLETE，则把skb-&gt;csum加上伪头进行校验，成功则将skb-&gt;ip_summed设为CHECKSUM_UNNECESSARY， 放行该数据包。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;3) 通过上述后skb-&gt;ip_summed还不是CHECKSUM_UNNECESSARY，那么重新计算伪头赋给skb-&gt;csum。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;4) 将还不是CHECKSUM_UNNECESSARY的数据报文的payload加上skb-&gt;csum进行checksum计算，成功将设为CHECKSUM_UNNECESSARY并放行，失败则丢弃。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline int udp4_csum_init(struct sk_buff *skb, struct udphdr *uh, 
</span><span class='line'>                int proto)
</span><span class='line'>{
</span><span class='line'>    const struct iphdr *iph;
</span><span class='line'>    int err; 
</span><span class='line'>
</span><span class='line'>    UDP_SKB_CB(skb)-&gt;partial_cov = 0; 
</span><span class='line'>    UDP_SKB_CB(skb)-&gt;cscov = skb-&gt;len;
</span><span class='line'>
</span><span class='line'>    if (proto == IPPROTO_UDPLITE) {
</span><span class='line'>        err = udplite_checksum_init(skb, uh); 
</span><span class='line'>        if (err)
</span><span class='line'>            return err; 
</span><span class='line'>    }    
</span><span class='line'>
</span><span class='line'>    iph = ip_hdr(skb);
</span><span class='line'>    if (uh-&gt;check == 0) { 
</span><span class='line'>        skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</span><span class='line'>    } else if (skb-&gt;ip_summed == CHECKSUM_COMPLETE) {
</span><span class='line'>        if (!csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr, skb-&gt;len,
</span><span class='line'>                proto, skb-&gt;csum))
</span><span class='line'>            skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</span><span class='line'>    }    
</span><span class='line'>    if (!skb_csum_unnecessary(skb))
</span><span class='line'>        skb-&gt;csum = csum_tcpudp_nofold(iph-&gt;saddr, iph-&gt;daddr,
</span><span class='line'>                            skb-&gt;len, proto, 0);
</span><span class='line'>    /* Probably, we should checksum udp header (it should be in cache
</span><span class='line'>     * in any case) and data in tiny packets (&lt; rx copybreak).
</span><span class='line'>     */
</span><span class='line'>
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    if (udp_lib_checksum_complete(skb))
</span><span class='line'>    goto csum_error;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline int udp_lib_checksum_complete(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    return !skb_csum_unnecessary(skb) &amp;&amp;
</span><span class='line'>        __udp_lib_checksum_complete(skb);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static inline __sum16 __udp_lib_checksum_complete(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    return __skb_checksum_complete_head(skb, UDP_SKB_CB(skb)-&gt;cscov);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>__sum16 __skb_checksum_complete_head(struct sk_buff *skb, int len)
</span><span class='line'>{
</span><span class='line'>    __sum16 sum;
</span><span class='line'>
</span><span class='line'>    sum = csum_fold(skb_checksum(skb, 0, len, skb-&gt;csum));
</span><span class='line'>    if (likely(!sum)) {
</span><span class='line'>        if (unlikely(skb-&gt;ip_summed == CHECKSUM_COMPLETE))
</span><span class='line'>            netdev_rx_csum_fault(skb-&gt;dev);
</span><span class='line'>        skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</span><span class='line'>    }
</span><span class='line'>    return sum;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;当数据包是输出包时&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;skb-&gt;csum表示为csum_start和csum_offset，它表示硬件网卡存放将要计算的校验值的地址，和最后填充的便宜。这个域在输出包时使用，只在校验值在硬件计算的情况下才对于网卡真正有意义。硬件checksum功能只能用于非分片报文。
</span><span class='line'>而此时ip_summed可以被设置的值有下面两种：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    #define CHECKSUM_NONE       0
</span><span class='line'>#define CHECKSUM_PARTIAL    3
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CHECKSUM_NONE 表示协议栈计算好了校验值，设备不需要做任何事。CHECKSUM_PARTIAL表示协议栈算好了伪头需要硬件计算payload checksum。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1）对于UDP socket开启了UDP_CSUM_NOXMIT /&lt;em&gt; UDP csum disabled &lt;/em&gt;/&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    uh-&gt;check = 0；
</span><span class='line'>skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2）软件udp checksum
</span><span class='line'>&lt;code&gt;
</span><span class='line'>struct iphdr *iph = ip_hdr(skb);
</span><span class='line'>struct udphdr *uh = udp_hdr(skb);
</span><span class='line'>uh-&gt;check = 0;
</span><span class='line'>skb-&gt;csum = csum_partial(skb_transport_header (skb), skb-&gt;len, 0);//skb-&gt;data指向传输层头
</span><span class='line'>uh-&gt;check = csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr, skb-&gt;len, iph-&gt;protocol, skb-&gt;csum);
</span><span class='line'>skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>//Todo: scatter and gather
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;3)  硬件checksum: 只能是ip报文长度小于mtu的数据报(没有分片的报文)。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CHECKSUM_PARTIAL表示使用硬件checksum ，L4层的伪头的校验已经完毕，并且已经加入uh-&gt;check字段中，此时只需要设备计算整个头4层头的校验值。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（对于支持scatter and gather的报文必须要传输层头在线性空间才能使用硬件checksum功能）&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    uh-&gt;check = ~csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr, skb-&gt;len, IPPROTO_UDP, 0);
</span><span class='line'>skb-&gt;csum_start = skb_transport_header (skb) - skb-&gt;head;
</span><span class='line'>skb-&gt;csum_offset = offsetof(struct udphdr, check);
</span><span class='line'>skb-&gt;ip_summed = CHECKSUM_PARTIAL;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最后在dev_queue_xmit发送的时候发现设备不支持硬件checksum就会进行软件计算&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,
</span><span class='line'>                struct netdev_queue *txq)
</span><span class='line'>
</span><span class='line'>{
</span><span class='line'>    .......
</span><span class='line'>
</span><span class='line'>            /* If packet is not checksummed and device does not
</span><span class='line'>             * support checksumming for this protocol, complete
</span><span class='line'>             * checksumming here.
</span><span class='line'>             */
</span><span class='line'>            if (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {
</span><span class='line'>                skb_set_transport_header(skb, skb-&gt;csum_start -
</span><span class='line'>                        skb_headroom(skb));
</span><span class='line'>                if (!dev_can_checksum(dev, skb) &amp;&amp;
</span><span class='line'>                        skb_checksum_help(skb))
</span><span class='line'>                    goto out_kfree_skb;
</span><span class='line'>            }
</span><span class='line'>    ........
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[Web压力测试工具]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/12/27/kernel-net-test-tool/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-12-27T02:51:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/12/27/kernel-net-test-tool&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://297020555.blog.51cto.com/1396304/592386"&gt;http://297020555.blog.51cto.com/1396304/592386&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;一、http_load&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;http_load以并行复用的方式运行，用以测试web服务器的吞吐量与负载。但是它不同于大多数压力测试工具，它可以以一个单一的进程运行，一般不会把客户机搞死。还可以测试HTTPS类的网站请求。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;下载地址：&lt;a href="http://www.acme.com/software/http_load/"&gt;http://www.acme.com/software/http_load/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    ./http_load -verbose -proxy 192.168.99.6:80 -parallel 24 -seconds 1000 url.txt
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;二、webbench&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;webbench是Linux下的一个网站压力测试工具，最多可以模拟3万个并发连接去测试网站的负载能力。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>用法：webbench -c 并发数 -t 运行测试时间 URL
</span><span class='line'>如：webbench -c 5000 -t 120 http://www.163.com
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;三、ab&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ab是apache自带的一款功能强大的测试工具。安装了apache一般就自带了，用法可以查看它的说明&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;参数众多，一般我们用到的是-n 和-c&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;例如：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>./ab -c 1000 -n 100 http://www.vpser.net/index.php
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>这个表示同时处理1000个请求并运行100次index.php文件.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;四、Siege&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;一款开源的压力测试工具，可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。
</span><span class='line'>官方：&lt;a href="http://www.joedog.org/"&gt;http://www.joedog.org/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;使用
</span><span class='line'>&lt;code&gt;
</span><span class='line'>siege -c 200 -r 10 -f example.url
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;-c是并发量，-r是重复次数。 url文件就是一个文本，每行都是一个url，它会从里面随机访问的。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[TCP拥塞控制窗口有效性验证机制]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/12/08/kernel-net-cwnd-test/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-12-08T15:49:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/12/08/kernel-net-cwnd-test&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;blog.csdn.net/zhangskd/article/details/7609465&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;概述&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;问题1：当发送方长时间受到应用程序的限制，不能发送数据时，会使拥塞窗口无效。TCP是根据拥塞窗口来动态地估计网络带宽的。发送方受到应用程序的限制后，没有数据可以发送。那么此时的拥塞窗口就不能准确的反应网络状况，因为这个拥塞窗口是很早之前的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;问题2：当发送方受到应用程序限制，不能利用完拥塞窗口，会使拥塞窗口的增长无效。TCP不断调整cwnd来测试网络带宽。如果不能完全使用掉cwnd，就不知道网络能否承受得了cwnd的数据量，这种情况下的cwnd增长是无效的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;原理&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;TCP sender受到的两种限制&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;(1) application-limited ：when the sender sends less than is allowed by the congestion or receiver window.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;(2) network-limited：when the sender is limited by the TCP window. More precisely, we define a network-limited period as any period when the sender is sending a full window of data.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;问题1描述&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;TCP&rsquo;s congestion window controls the number of packets a TCP flow may have in the
</span><span class='line'>network at any time. However, long periods when the sender is idle or application-limited
</span><span class='line'>can lead to the invalidation of the congestion window, in that the congestion window no longer
</span><span class='line'>reflects current information about the state of the network.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;The congestion window is set using an Additive-Increase, Multiplicative-Decrease(AIMD) mechanism
</span><span class='line'>that probes for available bandwidth, dynamically adapting to changing network conditions. This AIMD
</span><span class='line'>works well when the sender continually has data to send, as is typically the case for TCP used for
</span><span class='line'>bulk-data transfer. In contrast, for TCP used with telnet applications, the data sender often has little
</span><span class='line'>or no data to send, and the sending rate is often determined by the rate at which data is generated
</span><span class='line'>by the user.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;问题2描述&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;An invalid congestion window also results when the congestion window is increased (i.e.,
</span><span class='line'>in TCP&rsquo;s slow-start or congestion avoidance phases) during application-limited periods, when the
</span><span class='line'>previous value of the congestion window might never have been fully utilized. As far as we know, all
</span><span class='line'>current TCP implementations increase the congestion window when an acknowledgement arrives,
</span><span class='line'>if allowed by the receiver&rsquo;s advertised window and the slow-start or congestion avoidance window
</span><span class='line'>increase algorithm, without checking to see if the previous value of the congestion window has in
</span><span class='line'>fact been used.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;This document proposes that the window increase algorithm not be invoked during application-
</span><span class='line'>limited periods. This restriction prevents the congestion window from growing arbitrarily large,
</span><span class='line'>in the absence of evidence that the congestion window can be supported by the network.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;实现(1)&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;发送方在发送数据包时，如果发送的数据包有负载，则会检测拥塞窗口是否超时。如果超时，则会使拥塞窗口失效并重新计算拥塞窗口。然后根据最近接收段的时间，确定是否进入pingpong模式。</span></code></pre></td></tr></table></div></figure>
    /<em> Congestion state accounting after a packet has been sent. </em>/<br/>
    static void tcp_event_data_sent (struct tcp_sock <em>tp, struct sock </em>sk)<br/>
    {<br/>
        struct inet_connection_sock *icsk = inet_csk(sk);<br/>
        const u32 now = tcp_time_stamp;</p>

<pre><code>    if (sysctl_tcp_slow_start_after_idle &amp;&amp;   
        (!tp-&gt;packets_out &amp;&amp; (s32) (now - tp-&gt;lsndtime) &gt; icsk-&gt;icsk_rto))  
        tcp_cwnd_restart(sk, __sk_dst_get(sk)); /* 重置cnwd */  

    tp-&gt;lsndtime = now; /* 更新最近发包的时间*/  

    /* If it is a reply for ato after last received packets,  
     * enter pingpong mode. */  
    if ((u32)(now - icsk-&gt;icsk_ack.lrcvtime) &lt; icsk.icsk_ack.ato)  
        icsk-&gt;icsk_ack.pingpong = 1;  
}  
</code></pre>

<pre><code>
tcp_event_data_sent()中，符合三个条件才重置cwnd：

（1）tcp_slow_start_after_idle选项设置，这个内核默认置为1
（2）tp-&gt;packets_out == 0，表示网络中没有未确认数据包
（3）now - tp-&gt;lsndtime &gt; icsk-&gt;icsk_rto，距离上次发送数据包的时间超过了RTO
</code></pre>

<pre><code>/* RFC2861. Reset CWND after idle period longer RTO to "restart window". 
 * This is the first part of cnwd validation mechanism. 
 */  
static void tcp_cwnd_restart (struct sock *sk, const struct dst_entry *dst)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    s32 delta = tcp_time_stamp - tp-&gt;lsndtime;  

    /* 关于tcp_init_cwnd()可见上一篇blog.*/  
    u32 restart_cwnd = tcp_init_cwnd(tp, dst);  
    u32 cwnd = tp-&gt;snd_cwnd;  

    /* 触发拥塞窗口重置事件*/  
    tcp_ca_event(sk, CA_EVENT_CWND_RESTART);  

    /* 阈值保存下来，并没有重置。*/  
    tp-&gt;snd_ssthresh = tcp_current_ssthresh(sk);  
    restart_cwnd = min(restart_cwnd, cwnd);  

    /* 闲置时间每超过一个RTO且cwnd比重置后的大时，cwnd减半。*/  
    while((delta -= inet_csk(sk)-&gt;icsk_rto) &gt; 0 &amp;&amp; cwnd &gt; restart_cwnd)  
        cwnd &gt;&gt; 1;  

    tp-&gt;snd_cwnd = max(cwnd, restart_cwnd); /* 取其大者！*/  
    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;  
    tp-&gt;snd_cwnd_used = 0;  
}  
</code></pre>

<pre><code>
那么调用tcp_cwnd_restart()后，tp-&gt;snd_cwnd是多少呢？这个是不确定的，要看闲置时间delta、闲置前的cwnd、路由器中设置的initcwnd。当然，最大概率的是：拥塞窗口降为闲置前cwnd的一半。

#### 实现(2)

在发送方成功发送一个数据包后，会检查从发送队列发出而未确认的数据包是否用完拥塞窗口。
如果拥塞窗口被用完了，说明发送方收到网络限制；
如果拥塞窗口没被用完，且距离上次检查时间超过了RTO，说明发送方收到应用程序限制。
</code></pre>

<pre><code>/* Congestion window validation.(RFC2861) */  
static void tcp_cwnd_validate(struct sock *sk) {  
    struct tcp_sock *tp = tcp_sk(sk);  

    if (tp-&gt;packets_out &gt;= tp-&gt;snd_cwnd) {  
        /* Network is feed fully. */  
        tp-&gt;snd_cwnd_used = 0; /*不用这个变量*/  
        tp-&gt;snd_cwnd_stamp = tcp_time_stamp; /* 更新检测时间*/  

    } else {  
        /* Network starves. */  
        if (tp-&gt;packets_out &gt; tp-&gt;snd_cwnd_used)  
            tp-&gt;snd_cwnd_used = tp-&gt;packets_out; /* 更新已使用窗口*/  

            /* 如果距离上次检测的时间，即距离上次发包时间已经超过RTO*/  
            if (sysctl_tcp_slow_start_after_idle &amp;&amp;  
                (s32) (tcp_time_stamp - tp-&gt;snd_cwnd_stamp) &gt;= inet_csk(sk)-&gt;icsk_rto)  
                tcp_cwnd_application_limited(sk);  
    }  
}  
</code></pre>

<pre><code>
在发送方收到应用程序的限制期间，每隔RTO时间，都会调用tcp_cwnd_application_limited()来重新设置sshresh和cwnd，具体如下：
</code></pre>

<pre><code>/* RFC2861, slow part. Adjust cwnd, after it was not full during one rto. 
 * As additional protections, we do not touch cwnd in retransmission phases, 
 * and if application hit its sndbuf limit recently. 
 */  
void tcp_cwnd_application_limited(struct sock *sk)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  

    /* 只有处于Open态，应用程序没受到sndbuf限制时，才进行 
     * ssthresh和cwnd的重置。 
     */  
    if (inet_csk(sk)-&gt;icsk_ca_state == TCP_CA_Open &amp;&amp;   
        sk-&gt;sk_socket &amp;&amp; !test_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags)) {  

        /* Limited by application or receiver window. */  
        u32 init_win = tcp_init_cwnd(tp, __sk_dst_get(sk));  
        u32 win_used = max(tp-&gt;snd_cwnd_used, init_win);  

        /* 没用完拥塞窗口*/  
        if (win_used &lt; tp-&gt;snd_cwnd) {  
            /* 并没有减小ssthresh，反而增大，保留了过去的信息，以便之后有数据发送 
              * 时能快速增大到接近此时的窗口。 
              */  
            tp-&gt;snd_ssthresh = tcp_current_ssthresh(sk);   
            /* 减小了snd_cwnd */  
            tp-&gt;snd_cwnd = (tp-&gt;snd_cwnd + win_used) &gt;&gt; 1;  
        }  
        tp-&gt;snd_cwnd_used = 0;  
    }  
    tp-&gt;snd_cwnd_stamp = tcp_time_stamp; /* 更新最近的数据包发送时间*/  
}  
</code></pre>

<p>```</p>

<p>发送方受到应用程序限制，且限制的时间每经过RTO后，就会调用以上函数来处理snd_ssthresh和snd_cwnd：</p>

<p>（1）snd_ssthresh = max(snd_ssthresh, &frac34; cwnd)</p>

<p>慢启动阈值并没有减小，相反，如果此时cwnd较大，ssthresh会相应的增大。ssthresh是一个很重要的参数，它保留了旧的信息。这样一来，如果应用程序产生了大量的数据，发送方不再受到限制后，经过慢启动阶段，拥塞窗口就能快速恢复到接近以前的值了。</p>

<p>（2）snd_cwnd = (snd_cwnd + snd_cwnd_used) / 2</p>

<p>因为snd_cwnd_used &lt; snd_cwnd，所以snd_cwnd是减小了的。减小snd_cwnd是为了不让它盲目的增长。因为发送方没有利用完拥塞窗口，并不能检测到网络是否能承受该拥塞窗口，这时的增长是无根据的。</p>

<h4>结论</h4>

<p>在发送完数据包后，通过对拥塞窗口有效性的检验，能够避免使用不合理的拥塞窗口。</p>

<p>拥塞窗口代表着网络的状况，通过避免使用不合理的拥塞窗口，就能得到正确的网络状况，而不会采取一些不恰当的措施。</p>

<p>在上文的两种情况下，通过TCP的拥塞窗口有效性验证机制（TCP congestion window validationmechanism），能够更合理的利用网络、避免丢包，从而提高传输效率。</p>

<h4>Reference</h4>

<p>RFC2861</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ixgbe]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/11/17/kernel-net-ixgbe/"/>
    <updated>2015-11-17T15:16:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/11/17/kernel-net-ixgbe</id>
    <content type="html"><![CDATA[<p><a href="http://www.pagefault.info/?p=403">http://www.pagefault.info/?p=403</a></p>

<p>这里分析的驱动代码是给予linux kernel 3.4.4</p>

<p>对应的文件在drivers/net/ethernet/intel 目录下，这个分析不涉及到很细节的地方，主要目的是理解下数据在协议栈和驱动之间是如何交互的。</p>

<p>首先我们知道网卡都是pci设备，因此这里每个网卡驱动其实就是一个pci驱动。并且intel这里是把好几个万兆网卡(82599/82598/x540)的驱动做在一起的。</p>

<p>首先我们来看对应的pci_driver的结构体，这里每个pci驱动都是一个pci_driver的结构体，而这里是多个万兆网卡共用这个结构体ixgbe_driver.</p>

<pre><code>    static struct pci_driver ixgbe_driver = {
        .name     = ixgbe_driver_name,
        .id_table = ixgbe_pci_tbl,
        .probe    = ixgbe_probe,
        .remove   = __devexit_p(ixgbe_remove),
    #ifdef CONFIG_PM
        .suspend  = ixgbe_suspend,
        .resume   = ixgbe_resume,
    #endif
        .shutdown = ixgbe_shutdown,
        .err_handler = &amp;ixgbe_err_handler
    };
</code></pre>

<p>然后是模块初始化方法,这里其实很简单，就是调用pci的驱动注册方法，把ixgbe挂载到pci设备链中。 这里不对pci设备的初始化做太多介绍，我以前的blog有这方面的介绍，想了解的可以去看看。这里我们只需要知道最终内核会调用probe回调来初始化ixgbe。</p>

<pre><code>    char ixgbe_driver_name[] = "ixgbe";
    static const char ixgbe_driver_string[] =
                    "Intel(R) 10 Gigabit PCI Express Network Driver";

    static int __init ixgbe_init_module(void)
    {
        int ret;
        pr_info("%s - version %s\n", ixgbe_driver_string, ixgbe_driver_version);
        pr_info("%s\n", ixgbe_copyright);

    #ifdef CONFIG_IXGBE_DCA
        dca_register_notify(&amp;dca_notifier);
    #endif

        ret = pci_register_driver(&amp;ixgbe_driver);
        return ret;
    }
</code></pre>

<p>这里不去追究具体如何调用probe的细节，我们直接来看probe函数，这个函数中通过硬件的信息来确定需要初始化那个驱动(82598/82599/x540),然后核心的驱动结构就放在下面的这个数组中。</p>

<pre><code>    static const struct ixgbe_info *ixgbe_info_tbl[] = {
        [board_82598] = &amp;ixgbe_82598_info,
        [board_82599] = &amp;ixgbe_82599_info,
        [board_X540] = &amp;ixgbe_X540_info,
    };
</code></pre>

<p>ixgbe_probe函数很长，我们这里就不详细分析了，因为这部分就是对网卡进行初始化。不过我们关注下面几个代码片段。</p>

<p>首先是根据硬件的参数来取得对应的驱动值:</p>

<pre><code>    const struct ixgbe_info *ii = ixgbe_info_tbl[ent-&gt;driver_data];
</code></pre>

<p>然后就是如何将不同的网卡驱动挂载到对应的回调中，这里做的很简单，就是通过对应的netdev的结构取得adapter，然后所有的核心操作都是保存在adapter中的，最后将ii的所有回调拷贝给adapter就可以了。我们来看代码：</p>

<pre><code>        struct net_device *netdev;
        struct ixgbe_adapter *adapter = NULL;
        struct ixgbe_hw *hw;
        .....................................

        adapter = netdev_priv(netdev);
        pci_set_drvdata(pdev, adapter);

        adapter-&gt;netdev = netdev;
        adapter-&gt;pdev = pdev;
        hw = &amp;adapter-&gt;hw;
        hw-&gt;back = adapter;
        .......................................
        memcpy(&amp;hw-&gt;mac.ops, ii-&gt;mac_ops, sizeof(hw-&gt;mac.ops));
        hw-&gt;mac.type  = ii-&gt;mac;

        /* EEPROM */
        memcpy(&amp;hw-&gt;eeprom.ops, ii-&gt;eeprom_ops, sizeof(hw-&gt;eeprom.ops));
        .....................................
</code></pre>

<p>最后需要关注的就是设置网卡属性，这些属性一般来说都是通过ethtool 可以设置的属性(比如tso/checksum等),这里我们就截取一部分:</p>

<pre><code>        netdev-&gt;features = NETIF_F_SG |
                   NETIF_F_IP_CSUM |
                   NETIF_F_IPV6_CSUM |
                   NETIF_F_HW_VLAN_TX |
                   NETIF_F_HW_VLAN_RX |
                   NETIF_F_HW_VLAN_FILTER |
                   NETIF_F_TSO |
                   NETIF_F_TSO6 |
                   NETIF_F_RXHASH |
                   NETIF_F_RXCSUM;

        netdev-&gt;hw_features = netdev-&gt;features;

        switch (adapter-&gt;hw.mac.type) {
        case ixgbe_mac_82599EB:
        case ixgbe_mac_X540:
            netdev-&gt;features |= NETIF_F_SCTP_CSUM;
            netdev-&gt;hw_features |= NETIF_F_SCTP_CSUM |
                           NETIF_F_NTUPLE;
            break;
        default:
            break;
        }

        netdev-&gt;hw_features |= NETIF_F_RXALL;
        ..................................................

        netdev-&gt;priv_flags |= IFF_UNICAST_FLT;
        netdev-&gt;priv_flags |= IFF_SUPP_NOFCS;

        if (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED)
            adapter-&gt;flags &amp;= ~(IXGBE_FLAG_RSS_ENABLED |
                        IXGBE_FLAG_DCB_ENABLED);
        ...................................................................
        if (pci_using_dac) {
            netdev-&gt;features |= NETIF_F_HIGHDMA;
            netdev-&gt;vlan_features |= NETIF_F_HIGHDMA;
        }

        if (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_CAPABLE)
            netdev-&gt;hw_features |= NETIF_F_LRO;
        if (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED)
            netdev-&gt;features |= NETIF_F_LRO;
</code></pre>

<p>然后我们来看下中断的注册，因为万兆网卡大部分都是多对列网卡(配合msix)，因此对于上层软件来说，就好像有多个网卡一样，它们之间的数据是相互独立的，这里读的话主要是napi驱动的poll方法，后面我们会分析这个.</p>

<p>到了这里或许要问那么网卡是如何挂载回调给上层，从而上层来发送数据呢，这里是这样子的，每个网络设备都有一个回调函数表(比如ndo_start_xmit)来供上层调用，而在ixgbe中的话，就是ixgbe_netdev_ops，下面就是这个结构，不过只是截取了我们很感兴趣的几个地方.</p>

<p>不过这里注意，读回调并不在里面，这是因为写是软件主动的，而读则是硬件主动的。现在ixgbe是NAPI的，因此它的poll回调是ixgbe_poll，是中断注册时候通过netif_napi_add添加进去的。</p>

<pre><code>    static const struct net_device_ops ixgbe_netdev_ops = {
        .ndo_open       = ixgbe_open,
        .ndo_stop       = ixgbe_close,
        .ndo_start_xmit     = ixgbe_xmit_frame,
        .ndo_select_queue   = ixgbe_select_queue,
        .ndo_set_rx_mode    = ixgbe_set_rx_mode,
        .ndo_validate_addr  = eth_validate_addr,
        .ndo_set_mac_address    = ixgbe_set_mac,
        .ndo_change_mtu     = ixgbe_change_mtu,
        .ndo_tx_timeout     = ixgbe_tx_timeout,
        .................................................
        .ndo_set_features = ixgbe_set_features,
        .ndo_fix_features = ixgbe_fix_features,
    };
</code></pre>

<p>这里我们最关注的其实就是ndo_start_xmit回调，这个回调就是驱动提供给协议栈的发送回调接口。我们来看这个函数.</p>

<p>它的实现很简单，就是选取对应的队列，然后调用ixgbe_xmit_frame_ring来发送数据。</p>

<pre><code>    static netdev_tx_t ixgbe_xmit_frame(struct sk_buff *skb,
                        struct net_device *netdev)
    {
        struct ixgbe_adapter *adapter = netdev_priv(netdev);
        struct ixgbe_ring *tx_ring;

        if (skb-&gt;len &lt;= 0) {
            dev_kfree_skb_any(skb);
            return NETDEV_TX_OK;
        }

        /*
         * The minimum packet size for olinfo paylen is 17 so pad the skb
         * in order to meet this minimum size requirement.
         */
        if (skb-&gt;len &lt; 17) {
            if (skb_padto(skb, 17))
                return NETDEV_TX_OK;
            skb-&gt;len = 17;
        }
        //取得对应的队列
        tx_ring = adapter-&gt;tx_ring[skb-&gt;queue_mapping];
        //发送数据
        return ixgbe_xmit_frame_ring(skb, adapter, tx_ring);
    }
</code></pre>

<p>而在ixgbe_xmit_frame_ring中，我们就关注两个地方，一个是tso(什么是TSO，请自行google)，一个是如何发送.</p>

<pre><code>        tso = ixgbe_tso(tx_ring, first, &amp;hdr_len);
        if (tso &lt; 0)
            goto out_drop;
        else if (!tso)
            ixgbe_tx_csum(tx_ring, first);

        /* add the ATR filter if ATR is on */
        if (test_bit(__IXGBE_TX_FDIR_INIT_DONE, &amp;tx_ring-&gt;state))
            ixgbe_atr(tx_ring, first);

    #ifdef IXGBE_FCOE
    xmit_fcoe:
    #endif /* IXGBE_FCOE */
        ixgbe_tx_map(tx_ring, first, hdr_len);
</code></pre>

<p>调用ixgbe_tso处理完tso之后，就会调用ixgbe_tx_map来发送数据。而ixgbe_tx_map所做的最主要是两步，第一步请求DMA，第二步写寄存器，通知网卡发送数据.</p>

<pre><code>        dma = dma_map_single(tx_ring-&gt;dev, skb-&gt;data, size, DMA_TO_DEVICE);
        if (dma_mapping_error(tx_ring-&gt;dev, dma))
            goto dma_error;

        /* record length, and DMA address */
        dma_unmap_len_set(first, len, size);
        dma_unmap_addr_set(first, dma, dma);

        tx_desc-&gt;read.buffer_addr = cpu_to_le64(dma);

        for (;;) {
            while (unlikely(size &gt; IXGBE_MAX_DATA_PER_TXD)) {
                tx_desc-&gt;read.cmd_type_len =
                    cmd_type | cpu_to_le32(IXGBE_MAX_DATA_PER_TXD);

                i++;
                tx_desc++;
                if (i == tx_ring-&gt;count) {
                    tx_desc = IXGBE_TX_DESC(tx_ring, 0);
                    i = 0;
                }

                dma += IXGBE_MAX_DATA_PER_TXD;
                size -= IXGBE_MAX_DATA_PER_TXD;

                tx_desc-&gt;read.buffer_addr = cpu_to_le64(dma);
                tx_desc-&gt;read.olinfo_status = 0;
            }

            ...................................................
            data_len -= size;

            dma = skb_frag_dma_map(tx_ring-&gt;dev, frag, 0, size,
                           DMA_TO_DEVICE);
            ..........................................................

            frag++;
        }
        .................................
        tx_ring-&gt;next_to_use = i;

        /* notify HW of packet */
        writel(i, tx_ring-&gt;tail);
        .................
</code></pre>

<p>上面的操作是异步的，也就是说此时内核还不能释放SKB，而是网卡硬件发送完数据之后，会再次产生中断通知内核，然后内核才能释放内存.接下来我们来看这部分代码。</p>

<p>首先来看的是中断注册的代码，这里我们假设启用了MSIX,那么网卡的中断注册回调就是ixgbe_request_msix_irqs函数，这里我们可以看到调用request_irq函数来注册回调，并且每个队列都有自己的中断号。</p>

<pre><code>    static int ixgbe_request_msix_irqs(struct ixgbe_adapter *adapter)
    {
        struct net_device *netdev = adapter-&gt;netdev;
        int q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
        int vector, err;
        int ri = 0, ti = 0;

        for (vector = 0; vector &lt; q_vectors; vector++) {
            struct ixgbe_q_vector *q_vector = adapter-&gt;q_vector[vector];
            struct msix_entry *entry = &amp;adapter-&gt;msix_entries[vector];
            .......................................................................
            err = request_irq(entry-&gt;vector, &amp;ixgbe_msix_clean_rings, 0,
                      q_vector-&gt;name, q_vector);
            if (err) {
                e_err(probe, "request_irq failed for MSIX interrupt "
                      "Error: %d\n", err);
                goto free_queue_irqs;
            }
            /* If Flow Director is enabled, set interrupt affinity */
            if (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) {
                /* assign the mask for this irq */
                irq_set_affinity_hint(entry-&gt;vector,
                              &amp;q_vector-&gt;affinity_mask);
            }
        }

        ..............................................

        return 0;

    free_queue_irqs:
        ...............................
        return err;
    }
</code></pre>

<p>而对应的中断回调是ixgbe_msix_clean_rings,而这个函数呢，做的事情很简单(需要熟悉NAPI的原理，我以前的blog有介绍),就是调用napi_schedule来重新加入软中断处理.</p>

<pre><code>    static irqreturn_t ixgbe_msix_clean_rings(int irq, void *data)
    {
        struct ixgbe_q_vector *q_vector = data;

        /* EIAM disabled interrupts (on this vector) for us */

        if (q_vector-&gt;rx.ring || q_vector-&gt;tx.ring)
            napi_schedule(&amp;q_vector-&gt;napi);

        return IRQ_HANDLED;
    }
</code></pre>

<p>而NAPI驱动我们知道，最终是会调用网卡驱动挂载的poll回调，在ixgbe中，对应的回调就是ixgbe_poll，那么也就是说这个函数要做两个工作，一个是处理读，一个是处理写完之后的清理.</p>

<pre><code>    int ixgbe_poll(struct napi_struct *napi, int budget)
    {
        struct ixgbe_q_vector *q_vector =
                    container_of(napi, struct ixgbe_q_vector, napi);
        struct ixgbe_adapter *adapter = q_vector-&gt;adapter;
        struct ixgbe_ring *ring;
        int per_ring_budget;
        bool clean_complete = true;

    #ifdef CONFIG_IXGBE_DCA
        if (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED)
            ixgbe_update_dca(q_vector);
    #endif
        //清理写
        ixgbe_for_each_ring(ring, q_vector-&gt;tx)
            clean_complete &amp;= !!ixgbe_clean_tx_irq(q_vector, ring);

        /* attempt to distribute budget to each queue fairly, but don't allow
         * the budget to go below 1 because we'll exit polling */
        if (q_vector-&gt;rx.count &gt; 1)
            per_ring_budget = max(budget/q_vector-&gt;rx.count, 1);
        else
            per_ring_budget = budget;
        //读数据，并清理已完成的
        ixgbe_for_each_ring(ring, q_vector-&gt;rx)
            clean_complete &amp;= ixgbe_clean_rx_irq(q_vector, ring,
                                 per_ring_budget);

        /* If all work not completed, return budget and keep polling */
        if (!clean_complete)
            return budget;

        /* all work done, exit the polling mode */
        napi_complete(napi);
        if (adapter-&gt;rx_itr_setting &amp; 1)
            ixgbe_set_itr(q_vector);
        if (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
            ixgbe_irq_enable_queues(adapter, ((u64)1 &lt;&lt; q_vector-&gt;v_idx));

        return 0;
    }
</code></pre>
]]></content>
  </entry>
  
</feed>
