<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013~11 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013~11/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-07-23T17:56:52+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[BFD or dwarf? article]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/11/29/debug-dwarf-article/"/>
    <updated>2013-11-29T17:54:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/11/29/debug-dwarf-article</id>
    <content type="html"><![CDATA[<p><a href="http://blog.techveda.org/howsourcedebuggerswork/">http://blog.techveda.org/howsourcedebuggerswork/</a></p>

<p><a href="http://bbs.sjtu.edu.cn/bbscon,board,Security,file,M.1134227822.A.html">http://bbs.sjtu.edu.cn/bbscon,board,Security,file,M.1134227822.A.html</a></p>

<p><a href="http://blog.csdn.net/warriorpaw/article/details/8660704">http://blog.csdn.net/warriorpaw/article/details/8660704</a></p>

<p><a href="http://blog.csdn.net/rrerre/article/details/6843539">http://blog.csdn.net/rrerre/article/details/6843539</a></p>

<p><a href="http://blog.csdn.net/rrerre/article/details/6639484">http://blog.csdn.net/rrerre/article/details/6639484</a></p>

<p><a href="http://dwarfstd.org/doc/Dwarf3.pdf">http://dwarfstd.org/doc/Dwarf3.pdf</a></p>

<p>dwarf2解析 <a href="http://hi.baidu.com/tag/dwarf2%E8%A7%A3%E6%9E%90/feeds">http://hi.baidu.com/tag/dwarf2%E8%A7%A3%E6%9E%90/feeds</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GDB MI接口相关]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/11/29/debug-gdb-mi/"/>
    <updated>2013-11-29T14:04:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/11/29/debug-gdb-mi</id>
    <content type="html"><![CDATA[<p><span style="color:red">所谓GDB MI就是GNU Debugger Machine-Interface,是GNU设计来给其它前端使用的交互协议.</span></p>

<p>  说实在的,这个接口设计得并不是很好,仅仅是能用而已.它的指令和GDB/CLI即GDB Command Line Interface基本是对应的.<br/>
为 了方便机器交互,它把允许所有的指令有一个前缀,比如901-stack-list-frames 0 99.这样,在GDB返回的结果前,也会有同样的前缀901,我们可以根据这个前缀进行命令/结果匹配. 同时它还保证结果格式的统一性.不会出现CLI那种百花齐放的结果.当然,如果你安了GDB的python插件来做变量格式化,就可能出现例外的情况.</p>

<p>  它的命令有同步的,也有异步的.这对于前端的设计是个很大的障碍,而且除了命令结果以外,它还会有很多异步的消息,事件&hellip;这些东西混在一起,处理起来会相当麻烦.</p>

<p>  这是 <a href="http://ftp.gnu.org/old-gnu/Manuals/gdb-5.1.1/html_node/gdb_211.html#SEC216">GDB/MI的官方文档</a> 有兴趣的话可以仔细研究一下.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调试器工作原理之三——调试信息]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/11/29/debug-debuger-3/"/>
    <updated>2013-11-29T09:36:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/11/29/debug-debuger-3</id>
    <content type="html"><![CDATA[<p><a href="/blog/2013/11/29/debug-debuger-1/">调试器工作原理之一——基础篇</a><br/>
<a href="/blog/2013/11/29/debug-debuger-2/">调试器工作原理之二——实现断点</a><br/>
调试器工作原理之三——调试信息</p>

<h4>本篇主要内容</h4>

<p>在本文中我将向大家解释关于调试器是如何在机器码中寻找C函数以及变量的，以及调试器使用了何种数据能够在C源代码的行号和机器码中来回映射。</p>

<h4>调试信息</h4>

<p>  现代的编译器在转换高级语言程序代码上做得十分出色，能够将源代码中漂亮的缩进、嵌套的控制结构以及任意类型的 变量全都转化为一长串的比特流——这就是机器码。这么做的唯一目的就是希望程序能在目标CPU上尽可能快的运行。大多数的C代码都被转化为一些机器码指 令。变量散落在各处——在栈空间里、在寄存器里，甚至完全被编译器优化掉。结构体和对象甚至在生成的目标代码中根本不存在——它们只不过是对内存缓冲区中 偏移量的抽象化表示。</p>

<p>  那么当你在某些函数的入口处设置断点时，调试器如何知道该在哪里停止目标进程的运行呢？当你希望查看一个变量的值时，调试器又是如何找到它并展示给你呢？答案就是——调试信息。</p>

<p>  调试信息是在编译器生成机器码的时候一起产生的。它代表着可执行程序和源代码之间的关系。这个信息以预定义的格式进行编码，并同机器码一起存储。许 多年以来，针对不同的平台和可执行文件，人们发明了许多这样的编码格式。由于本文的主要目的不是介绍这些格式的历史渊源，而是为您展示它们的工作原理，所 以我们只介绍一种最重要的格式，这就是DWARF。作为Linux以及其他类Unix平台上的ELF可执行文件的调试信息格式，如今的DWARF可以说是 无处不在。</p>

<h4>ELF文件中的DWARF格式</h4>

<p>  根据维基百科上的词条解释，DWARF是同ELF可执行文件格式一同设计出来的，尽管在理论上DWARF也能够嵌入到其它的对象文件格式中。</p>

<p>  DWARF是一种复杂的格式，在多种体系结构和操作系统上经过多年的探索之后，人们才在之前的格式基础上创建了DWARF。它肯定是很复杂的，因为 它解决了一个非常棘手的问题——为任意类型的高级语言和调试器之间提供调试信息，支持任意一种平台和应用程序二进制接口（ABI）。要完全解释清楚这个主 题，本文就显得太微不足道了。说实话，我也不理解其中的所有角落。本文我将采取更加实践的方法，只介绍足量的DWARF相关知识，能够阐明实际工作中调试 信息是如何发挥其作用的就可以了。</p>

<h4>ELF文件中的调试段</h4>

<p>  首先，让我们看看DWARF格式信息处在ELF文件中的什么位置上。ELF可以为每个目标文件定义任意多个段（section）。而Section header表中则定义了实际存在有哪些段，以及它们的名称。不同的工具以各自特殊的方式来处理这些不同的段，比如链接器只寻找它关注的段信息，而调试器 则只关注其他的段。
我们通过下面的C代码构建一个名为traceprog2的可执行文件来做下实验。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void do_stuff(int my_arg)
</span><span class='line'>{
</span><span class='line'>int my_local = my_arg + 2;
</span><span class='line'>int i;
</span><span class='line'>
</span><span class='line'>for (i = 0; i &lt; my_local; ++i)
</span><span class='line'>    printf("i = %d\n", i);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>do_stuff(2);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;通过objdump –h导出ELF可执行文件中的段头信息，我们注意到其中有几个段的名字是以.debug_打头的，这些就是DWARF格式的调试段：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;26 .debug_aranges 00000020  00000000  00000000  00001037
</span><span class='line'>                CONTENTS, READONLY, DEBUGGING
</span><span class='line'>27 .debug_pubnames  00000028  00000000  00000000  00001057
</span><span class='line'>                CONTENTS, READONLY, DEBUGGING
</span><span class='line'>28 .debug_info      000000cc  00000000  00000000  0000107f
</span><span class='line'>                CONTENTS, READONLY, DEBUGGING
</span><span class='line'>29 .debug_abbrev    0000008a  00000000  00000000  0000114b
</span><span class='line'>                CONTENTS, READONLY, DEBUGGING
</span><span class='line'>30 .debug_line      0000006b  00000000  00000000  000011d5
</span><span class='line'>                CONTENTS, READONLY, DEBUGGING
</span><span class='line'>31 .debug_frame     00000044  00000000  00000000  00001240
</span><span class='line'>                CONTENTS, READONLY, DEBUGGING
</span><span class='line'>32 .debug_str       000000ae  00000000  00000000  00001284
</span><span class='line'>                CONTENTS, READONLY, DEBUGGING
</span><span class='line'>33 .debug_loc       00000058  00000000  00000000  00001332
</span><span class='line'>                CONTENTS, READONLY, DEBUGGING</span></code></pre></td></tr></table></div></figure>
  每行的第一个数字表示每个段的大小，而最后一个数字表示距离ELF文件开始处的偏移量。调试器就是利用这个信息来从可执行文件中读取相关的段信息。现在，让我们通过一些实际的例子来看看如何在DWARF中找寻有用的调试信息。</p>

<h4>定位函数</h4>

<p>  当我们在调试程序时，一个最为基本的操作就是在某些函数中设置断点，期望调试器能在函数入口处将程序断下。要完成这个功能，调试器必须具有某种能够从源代码中的函数名称到机器码中该函数的起始指令间相映射的能力。</p>

<p>  这个信息可以通过从DWARF中的.debug_info段获取到。在我们继续之前，先说点背景知识。DWARF的基本描述实体被称为调试信息表项 （Debugging Information Entry —— DIE），每个DIE有一个标签——包含它的类型，以及一组属性。各个DIE之间通过兄弟和孩子结点互相链接，属性值可以指向其他的DIE。<br/>
我们运行
<code>
objdump –dwarf=info traceprog2
</code>
得到的输出非常长，对于这个例子，我们只用关注这几行就可以了：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;1&gt;&lt;71&gt;: Abbrev Number: 5 (DW_TAG_subprogram)
</span><span class='line'>    &lt;72&gt;   DW_AT_external   : 1
</span><span class='line'>    &lt;73&gt;   DW_AT_name       : (&hellip;): do_stuff
</span><span class='line'>    &lt;77&gt;   DW_AT_decl_file  : 1
</span><span class='line'>    &lt;78&gt;   DW_AT_decl_line  : 4
</span><span class='line'>    &lt;79&gt;   DW_AT_prototyped : 1
</span><span class='line'>    &lt;7a&gt;   DW_AT_low_pc     : 0x8048604
</span><span class='line'>    &lt;7e&gt;   DW_AT_high_pc    : 0x804863e
</span><span class='line'>    &lt;82&gt;   DW_AT_frame_base : 0x0     (location list)
</span><span class='line'>    &lt;86&gt;   DW_AT_sibling    : &lt;0xb3&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;1&gt;&lt;b3&gt;: Abbrev Number: 9 (DW_TAG_subprogram)
</span><span class='line'>    &lt;b4&gt;   DW_AT_external   : 1
</span><span class='line'>    &lt;b5&gt;   DW_AT_name       : (&hellip;): main
</span><span class='line'>    &lt;b9&gt;   DW_AT_decl_file  : 1
</span><span class='line'>    &lt;ba&gt;   DW_AT_decl_line  : 14
</span><span class='line'>    &lt;bb&gt;   DW_AT_type       : &lt;0x4b&gt;
</span><span class='line'>    &lt;bf&gt;   DW_AT_low_pc     : 0x804863e
</span><span class='line'>    &lt;c3&gt;   DW_AT_high_pc    : 0x804865a
</span><span class='line'>&lt;c7&gt;   DW_AT_frame_base     : 0x2c   (location list)
</span><span class='line'>&lt;code&gt;
</span><span class='line'>  这里有两个被标记为DW_TAG_subprogram的DIE，从DWARF的角度看这就是函数。注意，这里do_stuff和main都各有一 个表项。这里有许多有趣的属性，但我们感兴趣的是DW_AT_low_pc。这就是函数起始处的程序计数器的值（x86下的EIP）。注意，对于 do_stuff来说，这个值是0×8048604。现在让我们看看，通过objdump –d做反汇编后这个地址是什么：
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>08048604 &lt;do_stuff&gt;:
</span><span class='line'> 8048604:       55           push   ebp
</span><span class='line'> 8048605:       89 e5        mov    ebp,esp
</span><span class='line'> 8048607:       83 ec 28     sub    esp,0x28
</span><span class='line'> 804860a:       8b 45 08     mov    eax,DWORD PTR [ebp+0x8]
</span><span class='line'> 804860d:       83 c0 02     add    eax,0x2
</span><span class='line'> 8048610:       89 45 f4     mov    DWORD PTR [ebp-0xc],eax
</span><span class='line'> 8048613:       c7 45 (&hellip;)  mov    DWORD PTR [ebp-0x10],0x0
</span><span class='line'> 804861a:       eb 18        jmp    8048634 &lt;do_stuff+0x30&gt;
</span><span class='line'> 804861c:       b8 20 (&hellip;)  mov    eax,0x8048720
</span><span class='line'> 8048621:       8b 55 f0     mov    edx,DWORD PTR [ebp-0x10]
</span><span class='line'> 8048624:       89 54 24 04  mov    DWORD PTR [esp+0x4],edx
</span><span class='line'> 8048628:       89 04 24     mov    DWORD PTR [esp],eax
</span><span class='line'> 804862b:       e8 04 (&hellip;)  call   8048534 &lt;printf@plt&gt;
</span><span class='line'> 8048630:       83 45 f0 01  add    DWORD PTR [ebp-0x10],0x1
</span><span class='line'> 8048634:       8b 45 f0     mov    eax,DWORD PTR [ebp-0x10]
</span><span class='line'> 8048637:       3b 45 f4     cmp    eax,DWORD PTR [ebp-0xc]
</span><span class='line'> 804863a:       7c e0        jl     804861c &lt;do_stuff+0x18&gt;
</span><span class='line'> 804863c:       c9           leave
</span><span class='line'> 804863d:       c3           ret</span></code></pre></td></tr></table></div></figure>
  没错，从反汇编结果来看0×8048604确实就是函数do_stuff的起始地址。因此，这里调试器就同函数和它们在可执行文件中的位置确立了映射关系。</p>

<h4>定位变量</h4>

<p>  假设我们确实在do_stuff中的断点处停了下来。我们希望调试器能够告诉我们my_local变量的值，调试器怎么知道去哪里找到相关的信息 呢？这可比定位函数要难多了，因为变量可以在全局数据区，可以在栈上，甚至是在寄存器中。另外，具有相同名称的变量在不同的词法作用域中可能有不同的值。 调试信息必须能够反映出所有这些变化，而DWARF确实能做到这些。</p>

<p>  我不会涵盖所有的可能情况，作为例子，我将只展示调试器如何在do_stuff函数中定位到变量my_local。我们从.debug_info段开始，再次看看do_stuff这一项，这一次我们也看看其他的子项：
<code>
&lt;1&gt;&lt;71&gt;: Abbrev Number: 5 (DW_TAG_subprogram)
    &lt;72&gt;   DW_AT_external    : 1
    &lt;73&gt;   DW_AT_name        : (...): do_stuff
    &lt;77&gt;   DW_AT_decl_file   : 1
    &lt;78&gt;   DW_AT_decl_line   : 4
    &lt;79&gt;   DW_AT_prototyped  : 1
    &lt;7a&gt;   DW_AT_low_pc      : 0x8048604
    &lt;7e&gt;   DW_AT_high_pc     : 0x804863e
    &lt;82&gt;   DW_AT_frame_base  : 0x0      (location list)
    &lt;86&gt;   DW_AT_sibling     : &lt;0xb3&gt;
 &lt;2&gt;&lt;8a&gt;: Abbrev Number: 6 (DW_TAG_formal_parameter)
    &lt;8b&gt;   DW_AT_name        : (...): my_arg
    &lt;8f&gt;   DW_AT_decl_file   : 1
    &lt;90&gt;   DW_AT_decl_line   : 4
    &lt;91&gt;   DW_AT_type        : &lt;0x4b&gt;
    &lt;95&gt;   DW_AT_location    : (...)       (DW_OP_fbreg: 0)
 &lt;2&gt;&lt;98&gt;: Abbrev Number: 7 (DW_TAG_variable)
    &lt;99&gt;   DW_AT_name        : (...): my_local
    &lt;9d&gt;   DW_AT_decl_file   : 1
    &lt;9e&gt;   DW_AT_decl_line   : 6
    &lt;9f&gt;   DW_AT_type        : &lt;0x4b&gt;
    &lt;a3&gt;   DW_AT_location    : (...)      (DW_OP_fbreg: -20)
&lt;2&gt;&lt;a6&gt;: Abbrev Number: 8 (DW_TAG_variable)
    &lt;a7&gt;   DW_AT_name        : i
    &lt;a9&gt;   DW_AT_decl_file   : 1
    &lt;aa&gt;   DW_AT_decl_line   : 7
    &lt;ab&gt;   DW_AT_type        : &lt;0x4b&gt;
&lt;af&gt;   DW_AT_location    : (...)      (DW_OP_fbreg: -24)
</code>
  注意每一个表项中第一个尖括号里的数字，这表示嵌套层次——在这个例子中带有<2>的表项都是表项<1>的子项。因此我们 知道变量my_local（以DW_TAG_variable作为标签）是函数do_stuff的一个子项。调试器同样还对变量的类型感兴趣，这样才能正 确的显示变量的值。这里my_local的类型根据DW_AT_type标签可知为<0x4b>。如果查看objdump的输出，我们会发现 这是一个有符号4字节整数。</p>

<p>  要在执行进程的内存映像中实际定位到变量，调试器需要检查DW_AT_location属性。对于my_local来说，这个属性为 DW_OP_fberg: -20。这表示变量存储在从所包含它的函数的DW_AT_frame_base属性开始偏移-20处，而DW_AT_frame_base正代表了该函数 的栈帧起始点。</p>

<p>  函数do_stuff的DW_AT_frame_base属性的值是0×0（location list），这表示该值必须要在location list段去查询。我们看看objdump的输出：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ objdump &ndash;dwarf=loc tracedprog2&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;tracedprog2:     file format elf32-i386&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Contents of the .debug_loc section:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;Offset   Begin    End      Expression
</span><span class='line'>00000000 08048604 08048605 (DW_OP_breg4: 4 )
</span><span class='line'>00000000 08048605 08048607 (DW_OP_breg4: 8 )
</span><span class='line'>00000000 08048607 0804863e (DW_OP_breg5: 8 )
</span><span class='line'>00000000 &lt;End of list&gt;
</span><span class='line'>0000002c 0804863e 0804863f (DW_OP_breg4: 4 )
</span><span class='line'>0000002c 0804863f 08048641 (DW_OP_breg4: 8 )
</span><span class='line'>0000002c 08048641 0804865a (DW_OP_breg5: 8 )
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;0000002c &lt;End of list&gt;</span></code></pre></td></tr></table></div></figure>
  关于位置信息，我们这里感兴趣的就是第一个。对于调试器可能定位到的每一个地址，它都会指定当前栈帧到变量间的偏移量，而这个偏移就是通过寄存器来计算的。对于x86体系结构，bpreg4代表esp寄存器，而bpreg5代表ebp寄存器。</p>

<p>让我们再看看do_stuff的开头几条指令：
<code>
08048604 &lt;do_stuff&gt;:
 8048604:       55          push   ebp
 8048605:       89 e5       mov    ebp,esp
 8048607:       83 ec 28    sub    esp,0x28
 804860a:       8b 45 08    mov    eax,DWORD PTR [ebp+0x8]
 804860d:       83 c0 02    add    eax,0x2
 8048610:       89 45 f4    mov    DWORD PTR [ebp-0xc],eax
</code>
  注意，ebp只有在第二条指令执行后才与我们建立起关联，对于前两个地址，基地址由前面列出的位置信息中的esp计算得出。一旦得到了ebp的有效值，就可以很方便的计算出与它之间的偏移量。因为之后ebp保持不变，而esp会随着数据压栈和出栈不断移动。</p>

<p>  那么这到底为我们定位变量my_local留下了什么线索？我们感兴趣的只是在地址0×8048610上的指令执行过后my_local的值（这里 my_local的值会通过eax寄存器计算，而后放入内存）。因此调试器需要用到DW_OP_breg5: 8 基址来定位。现在回顾一下my_local的DW_AT_location属性：DW_OP_fbreg: -20。做下算数：从基址开始偏移-20，那就是ebp – 20，再偏移+8，我们得到ebp – 12。现在再看看反汇编输出，注意到数据确实是从eax寄存器中得到的，而ebp – 12就是my_local存储的位置。</p>

<h4>定位到行号</h4>

<p>  当我说到在调试信息中寻找函数时，我撒了个小小的谎。当我们调试C源代码并在函数中放置了一个断点时，我们通常并不会对第一条机器码指令感兴趣。我们真正感兴趣的是函数中的第一行C代码。</p>

<p>这就是为什么DWARF在可执行文件中对C源码到机器码地址做了全部映射。这部分信息包含在.debug_line段中，可以按照可读的形式进行解读：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ objdump &ndash;dwarf=decodedline tracedprog2&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;tracedprog2:     file format elf32-i386&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Decoded dump of debug contents of section .debug_line:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CU: /home/eliben/eli/eliben-code/debugger/tracedprog2.c:
</span><span class='line'>File name           Line number    Starting address
</span><span class='line'>tracedprog2.c                5           0x8048604
</span><span class='line'>tracedprog2.c                6           0x804860a
</span><span class='line'>tracedprog2.c                9           0x8048613
</span><span class='line'>tracedprog2.c               10           0x804861c
</span><span class='line'>tracedprog2.c                9           0x8048630
</span><span class='line'>tracedprog2.c               11           0x804863c
</span><span class='line'>tracedprog2.c               15           0x804863e
</span><span class='line'>tracedprog2.c               16           0x8048647
</span><span class='line'>tracedprog2.c               17           0x8048653
</span><span class='line'>tracedprog2.c               18           0x8048658</span></code></pre></td></tr></table></div></figure>
  不难看出C源码同反汇编输出之间的关系。第5行源码指向函数do_stuff的入口点——地址0×8040604。接下第6行源码，当在 do_stuff上设置断点时，这里就是调试器实际应该停下的地方，它指向地址0x804860a——刚过do_stuff的开场白。这个行信息能够方便 的在C源码的行号同指令地址间建立双向的映射关系。<br/>
1. 当在某一行上设定断点时，调试器将利用行信息找到实际应该陷入的地址（还记得前一篇中的int 3指令吗？）<br/>
2. 当某个指令引起段错误时，调试器会利用行信息反过来找出源代码中的行号，并告诉用户。</p>

<h4>libdwarf —— 在程序中访问DWARF</h4>

<p>  通过命令行工具来访问DWARF信息这虽然有用但还不能完全令我们满意。作为程序员，我们希望知道应该如何写出实际的代码来解析DWARF格式并从中读取我们需要的信息。</p>

<p>  自然的，一种方法就是拿起DWARF规范开始钻研。还记得每个人都告诉你永远不要自己手动解析HTML，而应该使用函数库来做吗？没错，如果你要手 动解析DWARF的话情况会更糟糕，DWARF比HTML要复杂的多。本文展示的只是冰山一角而已。更困难的是，在实际的目标文件中，这些信息大部分都以 非常紧凑和压缩的方式进行编码处理。</p>

<p>因此我们要走另一条路，使用一个函数库来同DWARF打交道。我知道的这类函数库主要有两个：<br/>
1. BFD（libbfd），GNU binutils就是使用的它，包括本文中多次使用到的工具objdump，ld（GNU链接器），以及as（GNU汇编器）。<br/>
2. libdwarf —— 同它的老大哥libelf一样，为Solaris以及FreeBSD系统上的工具服务。<br/>
我这里选择了libdwarf，因为对我来说它看起来没那么神秘，而且license更加自由（LGPL，BFD是GPL）。<br/>
  由于libdwarf自身非常复杂，需要很多代码来操作。我这里不打算把所有代码贴出来，但你可以下载，然后自己编译运行。要编译这个文件，你需要安装libelf以及libdwarf，并在编译时为链接器提供-lelf以及-ldwarf标志。</p>

<p>这个演示程序接收一个可执行文件，并打印出程序中的函数名称同函数入口点地址。下面是本文用以演示的C程序产生的输出：
<code>
$ dwarf_get_func_addr tracedprog2
DW_TAG_subprogram: 'do_stuff'
low pc  : 0x08048604
high pc : 0x0804863e
DW_TAG_subprogram: 'main'
low pc  : 0x0804863e
high pc : 0x0804865a
</code>
libdwarf的文档非常好（见本文的参考文献部分），花点时间看看，对于本文中提到的DWARF段信息你处理起来就应该没什么问题了。</p>

<h4>结论及下一步</h4>

<p>  调试信息只是一个简单的概念，具体实现细节可能相当复杂。但最终我们知道了调试器是如何从可执行文件中找出同源代码之间的关系。有了调试信息在手，调试器为用户所能识别的源代码和数据结构同可执行文件之间架起了一座桥。</p>

<p>  本文加上之前的两篇文章总结了调试器内部的工作原理。通过这一系列文章，再加上一点编程工作就应该可以在Linux下创建一个具有基本功能的调试器。</p>

<p>  至于下一步，我还不确定。也许我会就此终结这一系列文章，也许我会再写一些高级主题比如backtrace，甚至Windows系统上的调试。读者们也可以为今后这一系列文章提供意见和想法。不要客气，请随意在评论栏或通过Email给我提些建议吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调试器工作原理之二——实现断点]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/11/29/debug-debuger-2/"/>
    <updated>2013-11-29T09:34:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/11/29/debug-debuger-2</id>
    <content type="html"><![CDATA[<p><a href="/blog/2013/11/29/debug-debuger-1/">调试器工作原理之一——基础篇</a><br/>
调试器工作原理之二——实现断点<br/>
<a href="/blog/2013/11/29/debug-debuger-3/">调试器工作原理之三——调试信息</a></p>

<h4>本文的主要内容</h4>

<p>  这里我将说明调试器中的断点机制是如何实现的。断点机制是调试器的两大主要支柱之一 ——另一个是在被调试进程的内存空间中查看变量的值。我们已经在第一篇文章中稍微涉及到了一些监视被调试进程的知识，但断点机制仍然还是个迷。阅读完本文之后，这将不再是什么秘密了。</p>

<h4>软中断</h4>

<p>  要在x86体系结构上实现断点我们要用到软中断（也称为“陷阱”trap）。在我们深入细节之前，我想先大致解释一下中断和陷阱的概念。</p>

<p>  CPU有一个单独的执行序列，会一条指令一条指令的顺序执行。要处理类似IO或者硬件时钟这样的异步事件时CPU就要用到中断。硬件中断通常是一个 专门的电信号，连接到一个特殊的“响应电路”上。这个电路会感知中断的到来，然后会使CPU停止当前的执行流，保存当前的状态，然后跳转到一个预定义的地 址处去执行，这个地址上会有一个中断处理例程。当中断处理例程完成它的工作后，CPU就从之前停止的地方恢复执行。</p>

<p>  软中断的原理类似，但实际上有一点不同。CPU支持特殊的指令允许通过软件来模拟一个中断。当执行到这个指令时，CPU将其当做一个中断——停止当 前正常的执行流，保存状态然后跳转到一个处理例程中执行。这种“陷阱”让许多现代的操作系统得以有效完成很多复杂任务（任务调度、虚拟内存、内存保护、调 试等）。
一些编程错误（比如除0操作）也被CPU当做一个“陷阱”，通常被认为是“异常”。这里软中断同硬件中断之间的界限就变得模糊了，因为这里很难说这种异常到底是硬件中断还是软中断引起的。我有些偏离主题了，让我们回到关于断点的讨论上来。</p>

<h4>关于int 3指令</h4>

<p>  看过前一节后，现在我可以简单地说断点就是通过CPU的特殊指令——int 3来实现的。int就是x86体系结构中的“陷阱指令”——对预定义的中断处理例程的调用。x86支持int指令带有一个8位的操作数，用来指定所发生的 中断号。因此，理论上可以支持256种“陷阱”。前32个由CPU自己保留，这里第3号就是我们感兴趣的——称为“trap to debugger”。</p>

<p>  不多说了，我这里就引用“圣经”中的原话吧（这里的圣经就是Intel’s Architecture software developer’s manual, volume2A）：<br/>
  “INT 3指令产生一个特殊的单字节操作码（CC），这是用来调用调试异常处理例程的。（这个单字节形式非常有价值，因为这样可以通过一个断点来替换掉任何指令的第一个字节，包括其它的单字节指令也是一样，而不会覆盖到其它的操作码）。”</p>

<p>上面这段话非常重要，但现在解释它还是太早，我们稍后再来看。</p>

<h4>使用int 3指令</h4>

<p>  是的，懂得事物背后的原理是很棒的，但是这到底意味着什么？我们该如何使用int 3来实现断点机制？套用常见的编程问答中出现的对话——请用代码说话！
实际上这真的非常简单。一旦你的进程执行到int 3指令时，操作系统就将它暂停。在Linux上（本文关注的是Linux平台），这会给该进程发送一个SIGTRAP信号。</p>

<p>  这就是全部——真的！现在回顾一下本系列文章的第一篇，跟踪（调试器）进程可以获得所有其子进程（或者被关联到的进程）所得到信号的通知，现在你知道我们该做什么了吧？
  就是这样，再没有什么计算机体系结构方面的东东了，该写代码了。</p>

<h4>手动设定断点</h4>

<p>现在我要展示如何在程序中设定断点。用于这个示例的目标程序如下：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>section .text
</span><span class='line'>    ; The &lt;em&gt;start symbol must be declared for the linker (ld)
</span><span class='line'>    global &lt;/em&gt;start&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;_start:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;; Prepare arguments for the sys_write system call:
</span><span class='line'>;   - eax: system call number (sys_write)
</span><span class='line'>;   - ebx: file descriptor (stdout)
</span><span class='line'>;   - ecx: pointer to string
</span><span class='line'>;   - edx: string length
</span><span class='line'>mov edx, len1
</span><span class='line'>mov ecx, msg1
</span><span class='line'>mov ebx, 1
</span><span class='line'>mov eax, 4
</span><span class='line'>
</span><span class='line'>; Execute the sys_write system call
</span><span class='line'>int 0x80
</span><span class='line'>
</span><span class='line'>; Now print the other message
</span><span class='line'>mov edx, len2
</span><span class='line'>mov ecx, msg2
</span><span class='line'>mov ebx, 1
</span><span class='line'>mov eax, 4
</span><span class='line'>int 0x80
</span><span class='line'>
</span><span class='line'>; Execute sys_exit
</span><span class='line'>mov eax, 1
</span><span class='line'>int 0x80
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;section .data&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;msg1    db  &lsquo;Hello,&rsquo;, 0xa
</span><span class='line'>len1    equ $ - msg1
</span><span class='line'>msg2    db  &lsquo;world!&rsquo;, 0xa
</span><span class='line'>len2    equ $ - msg2</span></code></pre></td></tr></table></div></figure>
  我现在使用的是汇编语言，这是为了避免当使用C语言时涉及到的编译和符号的问题。上面列出的程序功能就是在一行中打印“Hello，”，然后在下一行中打印“world！”。这个例子与上一篇文章中用到的例子很相似。</p>

<p>  我希望设定的断点位置应该在第一条打印之后，但恰好在第二条打印之前。我们就让断点打在第一个int 0×80指令之后吧，也就是mov edx, len2。首先，我需要知道这条指令对应的地址是什么。运行objdump –d：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>traced_printer2:    file format elf32-i386&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Sections:
</span><span class='line'>Idx Name    Size        VMA         LMA         File off    Algn
</span><span class='line'>  0 .text   00000033    08048080    08048080    00000080    2&lt;strong&gt;4
</span><span class='line'>            CONTENTS,ALLOC,LOAD,READONLY,CODE
</span><span class='line'>  1 .data   0000000e    080490b4    080490b4    000000b4    2&lt;/strong&gt;2
</span><span class='line'>            CONTENTS,ALLOC,LOAD,DATA&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Disassembly of section .text:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;08048080 &lt;.text&gt;:
</span><span class='line'> 8048080:   ba 07 00 00 00      mov     $0x7,%edx
</span><span class='line'> 8048085:   b9 b4 90 04 08      mov     $0x80490b4,%ecx
</span><span class='line'> 804808a:   bb 01 00 00 00      mov     $0x1,%ebx
</span><span class='line'> 804808f:   b8 04 00 00 00      mov     $0x4,%eax
</span><span class='line'> 8048094:   cd 80               int     $0x80
</span><span class='line'> 8048096:   ba 07 00 00 00      mov     $0x7,%edx
</span><span class='line'> 804809b:   b9 bb 90 04 08      mov     $0x80490bb,%ecx
</span><span class='line'> 80480a0:   bb 01 00 00 00      mov     $0x1,%ebx
</span><span class='line'> 80480a5:   b8 04 00 00 00      mov     $0x4,%eax
</span><span class='line'> 80480aa:   cd 80               int     $0x80
</span><span class='line'> 80480ac:   b8 01 00 00 00      mov     $0x1,%eax
</span><span class='line'> 80480b1:   cd 80               int     $0x80</span></code></pre></td></tr></table></div></figure>
  通过上面的输出，我们知道要设定的断点地址是0×8048096。等等，真正的调试器不是像这样工作的，对吧？真正的调试器可以根据代码行数或者函 数名称来设定断点，而不是基于什么内存地址吧？非常正确。但是我们离那个标准还差的远——如果要像真正的调试器那样设定断点，我们还需要涵盖符号表以及调 试信息方面的知识，这需要用另一篇文章来说明。至于现在，我们还必须得通过内存地址来设定断点。</p>

<p>看到这里我真的很想再扯一点题外话，所以你有两个选择。如果你真的对于为什么地址是0×8048096，以及这代表什么意思非常感兴趣的话，接着看下一节。如果你对此毫无兴趣，只是想看看怎么设定断点，可以略过这一部分。</p>

<h4>题外话——进程地址空间以及入口点</h4>

<p>  坦白的说，0×8048096本身并没有太大意义，这只不过是相对可执行镜像的代码段（text section）开始处的一个偏移量。如果你仔细看看前面objdump出来的结果，你会发现代码段的起始位置是0×08048080。这告诉了操作系统 要将代码段映射到进程虚拟地址空间的这个位置上。在Linux上，这些地址可以是绝对地址（比如，有的可执行镜像加载到内存中时是不可重定位的），因为在 虚拟内存系统中，每个进程都有自己独立的内存空间，并把整个32位的地址空间都看做是属于自己的（称为线性地址）。</p>

<p>如果我们通过readelf工具来检查可执行文件的ELF头，我们将得到如下输出：
<code>
$ readelf -h traced_printer2
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                                ELF32
  Data:                                 2's complement, little endian
  Version:                              1 (current)
  OS/ABI:                               UNIX - System V
  ABI Version:                          0
  Type:                                 EXEC (Executable file)
  Machine:                              Intel 80386
  Version:                              0x1
  Entry point address:                  0x8048080
  Start of program headers:             52 (bytes into file)
  Start of section headers:             220 (bytes into file)
  Flags:                                0x0
  Size of this header:                  52 (bytes)
  Size of program headers:              32 (bytes)
  Number of program headers:            2
  Size of section headers:              40 (bytes)
  Number of section headers:            4
  Section header string table index:    3
</code>
  注意，ELF头的“entry point address”同样指向的是0×8048080。因此，如果我们把ELF文件中的这个部分解释给操作系统的话，就表示：<br/>
1. 将代码段映射到地址0×8048080处<br/>
2. 从入口点处开始执行——地址0×8048080<br/>
  但是，为什么是0×8048080呢？它的出现是由于历史原因引起的。每个进程的地址空间的前128MB被保留给栈空间了（注：这一部分原因可参考 Linkers and Loaders）。128MB刚好是0×80000000，可执行镜像中的其他段可以从这里开始。0×8048080是Linux下的链接器ld所使用的 默认入口点。这个入口点可以通过传递参数-Ttext给ld来进行修改。</p>

<p>  因此，得到的结论是这个地址并没有什么特别的，我们可以自由地修改它。只要ELF可执行文件的结构正确且在ELF头中的入口点地址同程序代码段（text section）的实际起始地址相吻合就OK了。</p>

<h4>通过int 3指令在调试器中设定断点</h4>

<p>  要在被调试进程中的某个目标地址上设定一个断点，调试器需要做下面两件事情：<br/>
1. 保存目标地址上的数据<br/>
2. 将目标地址上的第一个字节替换为int 3指令<br/>
  然后，当调试器向操作系统请求开始运行进程时（通过前一篇文章中提到的PTRACE_CONT），进程最终一定会碰到int 3指令。此时进程停止，操作系统将发送一个信号。这时就是调试器再次出马的时候了，接收到一个其子进程（或被跟踪进程）停止的信号，然后调试器要做下面几 件事：<br/>
1. 在目标地址上用原来的指令替换掉int 3<br/>
2. 将被跟踪进程中的指令指针向后递减1。这么做是必须的，因为现在指令指针指向的是已经执行过的int 3之后的下一条指令。<br/>
3. 由于进程此时仍然是停止的，用户可以同被调试进程进行某种形式的交互。这里调试器可以让你查看变量的值，检查调用栈等等。<br/>
4. 当用户希望进程继续运行时，调试器负责将断点再次加到目标地址上（由于在第一步中断点已经被移除了），除非用户希望取消断点。<br/>
  让我们看看这些步骤如何转化为实际的代码。我们将沿用第一篇文章中展示过的调试器“模版”（fork一个子进程，然后对其跟踪）。无论如何，本文结尾处会给出完整源码的链接。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt; Obtain and show child&rsquo;s instruction pointer &lt;/em&gt;/
</span><span class='line'>ptrace(PTRACE_GETREGS, child_pid, 0, ®s);
</span><span class='line'>procmsg(&ldquo;Child started. EIP = 0x%08x\n&rdquo;, regs.eip);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;/&lt;em&gt; Look at the word at the address we&rsquo;re interested in &lt;/em&gt;/
</span><span class='line'>unsigned addr = 0x8048096;
</span><span class='line'>unsigned data = ptrace(PTRACE_PEEKTEXT, child_pid, (void&lt;em&gt;)addr, 0);
</span><span class='line'>procmsg(&ldquo;Original data at 0x%08x: 0x%08x\n&rdquo;, addr, data);
</span><span class='line'>&lt;code&gt;
</span><span class='line'>这里调试器从被跟踪进程中获取到指令指针，然后检查当前位于地址0×8048096处的字长内容。运行本文前面列出的汇编码程序，将打印出：
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>[13028] Child started. EIP = 0x08048080
</span><span class='line'>[13028] Original data at 0x08048096: 0x000007ba
</span><span class='line'>&lt;code&gt;
</span><span class='line'>目前为止一切顺利，下一步：
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>/&lt;/em&gt; Write the trap instruction &lsquo;int 3&rsquo; into the address &lt;em&gt;/
</span><span class='line'>unsigned data_with_trap = (data &amp; 0xFFFFFF00) | 0xCC;
</span><span class='line'>ptrace(PTRACE_POKETEXT, child_pid, (void&lt;/em&gt;)addr, (void*)data_with_trap);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;/&lt;em&gt; See what&rsquo;s there again&hellip; &lt;/em&gt;/
</span><span class='line'>unsigned readback_data = ptrace(PTRACE_PEEKTEXT, child_pid, (void&lt;em&gt;)addr, 0);
</span><span class='line'>procmsg(&ldquo;After trap, data at 0x%08x: 0x%08x\n&rdquo;, addr, readback_data);
</span><span class='line'>&lt;code&gt;
</span><span class='line'>注意看我们是如何将int 3指令插入到目标地址上的。这部分代码将打印出：
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>[13028] After trap, data at 0x08048096: 0x000007cc
</span><span class='line'>&lt;code&gt;
</span><span class='line'>再一次如同预计的那样——0xba被0xcc取代了。调试器现在运行子进程然后等待子进程在断点处停止住。
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>    /&lt;/em&gt; Let the child run to the breakpoint and wait for it to
</span><span class='line'>    &lt;em&gt;* reach it
</span><span class='line'>    &lt;/em&gt;/
</span><span class='line'>    ptrace(PTRACE_CONT, child_pid, 0, 0);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;wait(&amp;wait_status);
</span><span class='line'>if (WIFSTOPPED(wait_status)) {
</span><span class='line'>    procmsg("Child got a signal: %s\n", strsignal(WSTOPSIG(wait_status)));
</span><span class='line'>}
</span><span class='line'>else {
</span><span class='line'>    perror("wait");
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* See where the child is now */
</span><span class='line'>ptrace(PTRACE_GETREGS, child_pid, 0, ®s);
</span><span class='line'>procmsg("Child stopped at EIP = 0x%08x\n", regs.eip);
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;这段代码打印出：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Hello,
</span><span class='line'>[13028] Child got a signal: Trace/breakpoint trap
</span><span class='line'>[13028] Child stopped at EIP = 0x08048097
</span><span class='line'>&lt;code&gt;
</span><span class='line'>注意，“Hello,”在断点之前打印出来了——同我们计划的一样。同时我们发现子进程已经停止运行了——就在这个单字节的陷阱指令执行之后。
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>/&lt;em&gt; Remove the breakpoint by restoring the previous data
</span><span class='line'>&lt;strong&gt; at the target address, and unwind the EIP back by 1 to
</span><span class='line'>&lt;/strong&gt; let the CPU execute the original instruction that was
</span><span class='line'>** there.
</span><span class='line'>&lt;/em&gt;/
</span><span class='line'>ptrace(PTRACE_POKETEXT, child_pid, (void&lt;em&gt;)addr, (void&lt;/em&gt;)data);
</span><span class='line'>regs.eip -= 1;
</span><span class='line'>ptrace(PTRACE_SETREGS, child_pid, 0, ®s);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;/&lt;em&gt; The child can continue running now &lt;/em&gt;/
</span><span class='line'>ptrace(PTRACE_CONT, child_pid, 0, 0);</span></code></pre></td></tr></table></div></figure>
这会使子进程打印出“world！”然后退出，同之前计划的一样。<br/>
注意，我们这里并没有重新加载断点。这可以在单步模式下执行，然后将陷阱指令加回去，再做PTRACE_CONT就可以了。本文稍后介绍的debug库实现了这个功能。</p>

<h4>更多关于int 3指令</h4>

<p>  现在是回过头来说说int 3指令的好机会，以及解释一下Intel手册中对这条指令的奇怪说明。</p>

<p>“这个单字节形式非常有价值，因为这样可以通过一个断点来替换掉任何指令的第一个字节，包括其它的单字节指令也是一样，而不会覆盖到其它的操作码。”</p>

<p>  x86架构上的int指令占用2个字节——0xcd加上中断号。int 3的二进制形式可以被编码为cd 03，但这里有一个特殊的单字节指令0xcc以同样的作用而被保留。为什么要这样做呢？因为这允许我们在插入一个断点时覆盖到的指令不会多于一条。这很重 要，考虑下面的示例代码：
<code>
.. some code ..
    jz  foo
    dec eax
foo:
    call    bar
    .. some code ..
</code>
  假设我们要在dec eax上设定断点。这恰好是条单字节指令（操作码是0×48）。如果替换为断点的指令长度超过1字节，我们就被迫改写了接下来的下一条指令（call）， 这可能会产生一些完全非法的行为。考虑一下条件分支jz foo，这时进程可能不会在dec eax处停止下来（我们在此设定的断点，改写了原来的指令），而是直接执行了后面的非法指令。</p>

<p>  通过对int 3指令采用一个特殊的单字节编码就能解决这个问题。因为x86架构上指令最短的长度就是1字节，这样我们可以保证只有我们希望停止的那条指令被修改。</p>

<h4>封装细节</h4>

<p>  前面几节中的示例代码展示了许多底层的细节，这些可以很容易地通过API进行封装。我已经做了一些封装，使其成为一个小型的调试库——debuglib。代码在本文末尾处可以下载。这里我只想介绍下它的用法，我们要开始调试C程序了。</p>

<h4>跟踪C程序</h4>

<p>目前为止为了简单起见我把重点放在对汇编程序的跟踪上了。现在升一级来看看我们该如何跟踪一个C程序。<br/>
其实事情并没有很大的不同——只是现在有点难以找到放置断点的位置。考虑如下这个简单的C程序:<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void do_stuff()
</span><span class='line'>{
</span><span class='line'>printf("Hello, ");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>for (int i = 0; i &lt; 4; ++i)
</span><span class='line'>    do_stuff();
</span><span class='line'>printf("world!\n");
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;假设我想在do_stuff的入口处设置一个断点。我将请出我们的老朋友objdump来反汇编可执行文件，但得到的输出太多。其实，查看text 段不太管用，因为这里面包含了大量的初始化C运行时库的代码，我目前对此并不感兴趣。所以，我们只需要在dump出来的结果里看do_stuff部分就好 了。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;080483e4 &lt;do_stuff&gt;:
</span><span class='line'> 80483e4:   55                      push    %ebp
</span><span class='line'> 80483e5:   89 e5                   mov     %esp,%ebp
</span><span class='line'> 80483e7:   83 ec 18                sub     $0x18,%esp
</span><span class='line'> 80483ea:   c7 04 24 f0 84 04 08    movl    $0x80484f0,(%esp)
</span><span class='line'> 80483f1:   e8 22 ff ff ff          call    8048318 &lt;puts@plt&gt;
</span><span class='line'> 80483f6:   c9                      leave
</span><span class='line'> 80483f7:   c3                      ret
</span><span class='line'>&lt;code&gt;
</span><span class='line'>好的，所以我们应该把断点设定在0x080483e4上，这是do_stuff的第一条指令。另外，由于这个函数是在循环体中调用的，我们希望在循 环全部结束前保留断点，让程序可以在每一轮循环中都在断点处停下。我将使用debuglib来简化代码编写。这里是完整的调试器函数：
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>void run_debugger(pid_t child_pid)
</span><span class='line'>{
</span><span class='line'>    procmsg(&ldquo;debugger started\n&rdquo;);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    /* Wait for child to stop on its first instruction */
</span><span class='line'>wait(0);
</span><span class='line'>procmsg("child now at EIP = 0x%08x\n", get_child_eip(child_pid));
</span><span class='line'>
</span><span class='line'>/* Create breakpoint and run to it*/
</span><span class='line'>debug_breakpoint* bp = create_breakpoint(child_pid, (void*)0x080483e4);
</span><span class='line'>procmsg("breakpoint created\n");
</span><span class='line'>ptrace(PTRACE_CONT, child_pid, 0, 0);
</span><span class='line'>wait(0);
</span><span class='line'>
</span><span class='line'>/* Loop as long as the child didn't exit */
</span><span class='line'>while (1) {
</span><span class='line'>    /* The child is stopped at a breakpoint here. Resume its
</span><span class='line'>    ** execution until it either exits or hits the
</span><span class='line'>    ** breakpoint again.
</span><span class='line'>    */
</span><span class='line'>    procmsg("child stopped at breakpoint. EIP = 0x%08X\n", get_child_eip(child_pid));
</span><span class='line'>    procmsg("resuming\n");
</span><span class='line'>    int rc = resume_from_breakpoint(child_pid, bp);
</span><span class='line'>
</span><span class='line'>    if (rc == 0) {
</span><span class='line'>        procmsg("child exited\n");
</span><span class='line'>        break;
</span><span class='line'>    }
</span><span class='line'>    else if (rc == 1) {
</span><span class='line'>        continue;
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        procmsg("unexpected: %d\n", rc);
</span><span class='line'>        break;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>cleanup_breakpoint(bp);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;我们不用手动修改EIP指针以及目标进程的内存空间，我们只需要通过create_breakpoint, resume_from_breakpoint以及cleanup_breakpoint来操作就可以了。我们来看看当跟踪这个简单的C程序后的打印输出：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ bp_use_lib traced_c_loop
</span><span class='line'>[13363] debugger started
</span><span class='line'>[13364] target started. will run &lsquo;traced_c_loop&rsquo;
</span><span class='line'>[13363] child now at EIP = 0x00a37850
</span><span class='line'>[13363] breakpoint created
</span><span class='line'>[13363] child stopped at breakpoint. EIP = 0x080483E5
</span><span class='line'>[13363] resuming
</span><span class='line'>Hello,
</span><span class='line'>[13363] child stopped at breakpoint. EIP = 0x080483E5
</span><span class='line'>[13363] resuming
</span><span class='line'>Hello,
</span><span class='line'>[13363] child stopped at breakpoint. EIP = 0x080483E5
</span><span class='line'>[13363] resuming
</span><span class='line'>Hello,
</span><span class='line'>[13363] child stopped at breakpoint. EIP = 0x080483E5
</span><span class='line'>[13363] resuming
</span><span class='line'>Hello,
</span><span class='line'>world!
</span><span class='line'>[13363] child exited</span></code></pre></td></tr></table></div></figure>
跟预计的情况一模一样！</p>

<h4>代码</h4>

<p>这里是完整的源码。在文件夹中你会发现：<br/>
debuglib.h以及debuglib.c——封装了调试器的一些内部工作。<br/>
bp_manual.c —— 本文一开始介绍的“手动”式设定断点。用到了debuglib库中的一些样板代码。<br/>
bp_use_lib.c—— 大部分代码用到了debuglib，这就是本文中用于说明跟踪一个C程序中的循环的示例代码。</p>

<h4>结论及下一步要做的</h4>

<p>我们已经涵盖了如何在调试器中实现断点机制。尽管实现细节根据操作系统的不同而有所区别，但只要你使用的是x86架构的处理器，那么一切变化都基于相同的主题——在我们希望停止的指令上将其替换为int 3。<br/>
我敢肯定，有些读者就像我一样，对于通过指定原始地址来设定断点的做法不会感到很激动。我们更希望说“在do_stuff上停住”，甚至是“在do_stuff的这一行上停住”，然后调试器就能照办。在下一篇文章中，我将向您展示这是如何做到的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调试器工作原理之一——基础篇]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/11/29/debug-debuger-1/"/>
    <updated>2013-11-29T09:33:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/11/29/debug-debuger-1</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/">Eli Bendersky</a>  编译：<a href="http://blog.jobbole.com/23463/">陈舸</a><br/>
调试器工作原理之一——基础篇<br/>
<a href="/blog/2013/11/29/debug-debuger-2/">调试器工作原理之二——实现断点</a><br/>
<a href="/blog/2013/11/29/debug-debuger-3/">调试器工作原理之三——调试信息</a></p>

<p>  本文是一系列探究调试器工作原理的文章的第一篇。我还不确定这个系列需要包括多少篇文章以及它们所涵盖的主题，但我打算从基础知识开始说起。</p>

<h4>关于本文</h4>

<p>  我打算在这篇文章中介绍关于Linux下的调试器实现的主要组成部分——ptrace系统调用。本文中出现的代码都在32位的Ubuntu系统上开发。请注意，这里出现的代码是同平台紧密相关的，但移植到别的平台上应该不会太难。</p>

<h4>动机</h4>

<p> 要想理解我们究竟要做什么，试着想象一下调试器是如何工作的。调试器可以启动某些进程，然后对其进行调试，或者 将自己本身关联到一个已存在的进程之上。它可以单步运行代码，设置断点然后运行程序，检查变量的值以及跟踪调用栈。许多调试器已经拥有了一些高级特性，比 如执行表达式并在被调试进程的地址空间中调用函数，甚至可以直接修改进程的代码并观察修改后的程序行为。</p>

<p>  尽管现代的调试器都是复杂的大型程序，但令人惊讶的是构建调试器的基础确是如此的简单。调试器只用到了几个由操作系统以及编译器/链接器提供的基础服务，剩下的仅仅就是简单的编程问题了。（可查阅维基百科中关于这个词条的解释，作者是在反讽）</p>

<h4>Linux下的调试——ptrace</h4>

<p>  Linux下调试器拥有一个瑞士军刀般的工具，这就是ptrace系统调用。这是一个功能众多且相当复杂的工 具，能允许一个进程控制另一个进程的运行，而且可以监视和渗入到进程内部。ptrace本身需要一本中等篇幅的书才能对其进行完整的解释，这就是为什么我 只打算通过例子把重点放在它的实际用途上。让我们继续深入探寻。</p>

<h4>遍历进程的代码</h4>

<p>  我现在要写一个在“跟踪”模式下运行的进程的例子，这里我们要单步遍历这个进程的代码——由CPU所执行的机器 码（汇编指令）。我会在这里给出例子代码，解释每个部分，本文结尾处你可以通过链接下载一份完整的C程序文件，可以自行编译执行并研究。从高层设计来说， 我们要写一个程序，它产生一个子进程用来执行一个用户指定的命令，而父进程跟踪这个子进程。首先，main函数是这样的：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main(int argc, char** argv)
</span><span class='line'>{
</span><span class='line'>    pid_t child_pid;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    if (argc &lt; 2) {
</span><span class='line'>    fprintf(stderr, "Expected a program name as argument\n");
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>child_pid = fork();
</span><span class='line'>if (child_pid == 0)
</span><span class='line'>    run_target(argv[1]);
</span><span class='line'>else if (child_pid &gt; 0)
</span><span class='line'>    run_debugger(child_pid);
</span><span class='line'>else {
</span><span class='line'>    perror("fork");
</span><span class='line'>    return -1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  代码相当简单，我们通过fork产生一个新的子进程。随后的if语句块处理子进程（这里称为“目标进程”），而else if语句块处理父进程（这里称为“调试器”）。下面是目标进程：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void run_target(const char* programname)
</span><span class='line'>{
</span><span class='line'>procmsg("target started. will run '%s'\n", programname);
</span><span class='line'>
</span><span class='line'>/* Allow tracing of this process */
</span><span class='line'>if (ptrace(PTRACE_TRACEME, 0, 0, 0) &lt; 0) {
</span><span class='line'>    perror("ptrace");
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Replace this process's image with the given program */
</span><span class='line'>execl(programname, programname, 0);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;这部分最有意思的地方在ptrace调用。ptrace的原型是（在sys/ptrace.h）：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;long ptrace(enum __ptrace_request request,  pid_t pid, void *addr,  void *data);
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  第一个参数是request，可以是预定义的以PTRACE_打头的常量值。第二个参数指定了进程id，第三以及第四个参数是地址和指向数据的指 针，用来对内存做操作。上面代码段中的ptrace调用使用了PTRACE_TRACEME请求，这表示这个子进程要求操作系统内核允许它的父进程对其跟 踪。这个请求在man手册中解释的非常清楚：  
</span><span class='line'>  “表明这个进程由它的父进程来跟踪。任何发给这个进程的信号（除了SIGKILL）将导致该进程停止运行，而它的父进程会通过wait()获得通知。另外，该进程之后所有对exec()的调用都将使操作系统产生一个SIGTRAP信号发送给它，这让父进程有机会在新程序开始执行之前获得对子进程的控制权。如果不希望由父进程来跟踪的话，那就不应该使用这个请求。（pid、addr、data被忽略）”
</span><span class='line'>
</span><span class='line'>  我已经把这个例子中我们感兴趣的地方高亮显示了。注意，run_target在ptrace调用之后紧接着做的是通过execl来调用我们指定的程 序。这里就会像我们高亮显示的部分所解释的那样，操作系统内核会在子进程开始执行execl中指定的程序之前停止该进程，并发送一个信号给父进程。
</span><span class='line'>因此，是时候看看父进程需要做些什么了：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void run_debugger(pid_t child_pid)
</span><span class='line'>{
</span><span class='line'>int wait_status;
</span><span class='line'>unsigned icounter = 0;
</span><span class='line'>procmsg("debugger started\n");
</span><span class='line'>
</span><span class='line'>/* Wait for child to stop on its first instruction */
</span><span class='line'>wait(&amp;wait_status);
</span><span class='line'>
</span><span class='line'>while (WIFSTOPPED(wait_status)) {
</span><span class='line'>    icounter++;
</span><span class='line'>    /* Make the child execute another instruction */
</span><span class='line'>    if (ptrace(PTRACE_SINGLESTEP, child_pid, 0, 0) &lt; 0) {
</span><span class='line'>        perror("ptrace");
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Wait for child to stop on its next instruction */
</span><span class='line'>    wait(&amp;wait_status);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>procmsg("the child executed %u instructions\n", icounter);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  通过上面的代码我们可以回顾一下，一旦子进程开始执行exec调用，它就会停止然后接收到一个SIGTRAP信号。父进程通过第一个wait调用正 在等待这个事件发生。一旦子进程停止（如果子进程由于发送的信号而停止运行，WIFSTOPPED就返回true），父进程就去检查这个事件。
</span><span class='line'>
</span><span class='line'>  父进程接下来要做的是本文中最有意思的地方。父进程通过PTRACE_SINGLESTEP以及子进程的id号来调用ptrace。这么做是告诉操 作系统——请重新启动子进程，但当子进程执行了下一条指令后再将其停止。然后父进程再次等待子进程的停止，整个循环继续得以执行。当从wait中得到的不 是关于子进程停止的信号时，循环结束。在正常运行这个跟踪程序时，会得到子进程正常退出（WIFEXITED会返回true）的信号。
</span><span class='line'>
</span><span class='line'>  icounter会统计子进程执行的指令数量。因此我们这个简单的例子实际上还是做了点有用的事情——通过在命令行上指定一个程序名，我们的例子会执行这个指定的程序，然后统计出从开始到结束该程序执行过的CPU指令总数。让我们看看实际运行的情况。
</span><span class='line'>
</span><span class='line'>#### 实际测试
</span><span class='line'>我编译了下面这个简单的程序，然后在我们的跟踪程序下执行：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#include &lt;stdio.h&gt;
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>printf(“Hello, world!\n”);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  令我惊讶的是，我们的跟踪程序运行了很长的时间然后报告显示一共有超过100000条指令得到了执行。仅仅只是一个简单的printf调用，为什么 会这样？答案非常有意思。默认情况下，Linux中的gcc编译器会动态链接到C运行时库。这意味着任何程序在运行时首先要做的事情是加载动态库。这需要 很多代码实现——记住，我们这个简单的跟踪程序会针对每一条被执行的指令计数，不仅仅是main函数，而是整个进程。
</span><span class='line'>
</span><span class='line'>  因此，当我采用-static标志静态链接这个测试程序时（注意到可执行文件因此增加了500KB的大小，因为它静态链接了C运行时库），我们的跟 踪程序报告显示只有7000条左右的指令被执行了。这还是非常多，但如果你了解到libc的初始化工作仍然先于main的执行，而清理工作会在main之 后执行，那么这就完全说得通了。而且，printf也是一个复杂的函数。
</span><span class='line'>
</span><span class='line'>  我们还是不满足于此，我希望能看到一些可检测的东西，例如我可以从整体上看到每一条需要被执行的指令是什么。这一点我们可以通过汇编代码来得到。因此我把这个“Hello，world”程序汇编（gcc -S）为如下的汇编码：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;section .text
</span><span class='line'>; The _start symbol must be declared for the linker (ld)
</span><span class='line'>global _start
</span><span class='line'>
</span><span class='line'>_start:
</span><span class='line'>
</span><span class='line'>; Prepare arguments for the sys_write system call:
</span><span class='line'>;   - eax: system call number (sys_write)
</span><span class='line'>;   - ebx: file descriptor (stdout)
</span><span class='line'>;   - ecx: pointer to string
</span><span class='line'>;   - edx: string length
</span><span class='line'>mov edx, len
</span><span class='line'>mov ecx, msg
</span><span class='line'>mov ebx, 1
</span><span class='line'>mov eax, 4
</span><span class='line'>
</span><span class='line'>; Execute the sys_write system call
</span><span class='line'>int 0x80
</span><span class='line'>
</span><span class='line'>; Execute sys_exit
</span><span class='line'>mov eax, 1
</span><span class='line'>int 0x80
</span><span class='line'>
</span><span class='line'>section   .data
</span><span class='line'>msg db  'Hello, world!', 0xa
</span><span class='line'>len equ $ - msg
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;这就足够了。现在跟踪程序会报告有7条指令得到了执行，我可以很容易地从汇编代码来验证这一点。
</span><span class='line'>
</span><span class='line'>#### 深入指令流
</span><span class='line'>汇编码程序得以让我为大家介绍ptrace的另一个强大的功能——详细检查被跟踪进程的状态。下面是run_debugger函数的另一个版本：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void run_debugger(pid_t child_pid)
</span><span class='line'>{
</span><span class='line'>int wait_status;
</span><span class='line'>unsigned icounter = 0;
</span><span class='line'>procmsg("debugger started\n");
</span><span class='line'>
</span><span class='line'>/* Wait for child to stop on its first instruction */
</span><span class='line'>wait(&amp;wait_status);
</span><span class='line'>
</span><span class='line'>while (WIFSTOPPED(wait_status)) {
</span><span class='line'>    icounter++;
</span><span class='line'>    struct user_regs_struct regs;
</span><span class='line'>    ptrace(PTRACE_GETREGS, child_pid, 0, ®s);
</span><span class='line'>    unsigned instr = ptrace(PTRACE_PEEKTEXT, child_pid, regs.eip, 0);
</span><span class='line'>
</span><span class='line'>    procmsg("icounter = %u.  EIP = 0x%08x.  instr = 0x%08x\n",
</span><span class='line'>                icounter, regs.eip, instr);
</span><span class='line'>
</span><span class='line'>    /* Make the child execute another instruction */
</span><span class='line'>    if (ptrace(PTRACE_SINGLESTEP, child_pid, 0, 0) &lt; 0) {
</span><span class='line'>        perror("ptrace");
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Wait for child to stop on its next instruction */
</span><span class='line'>    wait(&amp;wait_status);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>procmsg("the child executed %u instructions\n", icounter);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  同前个版本相比，唯一的不同之处在于while循环的开始几行。这里有两个新的ptrace调用。第一个读取进程的寄存器值到一个结构体中。结构体 user_regs_struct定义在sys/user.h中。这儿有个有趣的地方——如果你打开这个头文件看看，靠近文件顶端的地方有一条这样的注 释：  
</span><span class='line'>1  
</span><span class='line'>/* 本文件的唯一目的是为GDB，且只为GDB所用。对于这个文件，不要看的太多。除了GDB以外不要用于任何其他目的，除非你知道你正在做什么。*/  
</span><span class='line'>现在，我不知道你是怎么想的，但我感觉我们正处于正确的跑道上。无论如何，回到我们的例子上来。一旦我们将所有的寄存器值获取到regs中，我们就 可以通过PTRACE_PEEKTEXT标志以及将regs.eip（x86架构上的扩展指令指针）做参数传入ptrace来调用。我们所得到的就是指 令。让我们在汇编代码上运行这个新版的跟踪程序。  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ simple_tracer traced_helloworld
</span><span class='line'>[5700] debugger started
</span><span class='line'>[5701] target started. will run &lsquo;traced_helloworld&rsquo;
</span><span class='line'>[5700] icounter = 1.  EIP = 0x08048080.  instr = 0x00000eba
</span><span class='line'>[5700] icounter = 2.  EIP = 0x08048085.  instr = 0x0490a0b9
</span><span class='line'>[5700] icounter = 3.  EIP = 0x0804808a.  instr = 0x000001bb
</span><span class='line'>[5700] icounter = 4.  EIP = 0x0804808f.  instr = 0x000004b8
</span><span class='line'>[5700] icounter = 5.  EIP = 0x08048094.  instr = 0x01b880cd
</span><span class='line'>Hello, world!
</span><span class='line'>[5700] icounter = 6.  EIP = 0x08048096.  instr = 0x000001b8
</span><span class='line'>[5700] icounter = 7.  EIP = 0x0804809b.  instr = 0x000080cd
</span><span class='line'>[5700] the child executed 7 instructions
</span><span class='line'>&lt;code&gt;
</span><span class='line'>OK，所以现在除了icounter以外，我们还能看到指令指针以及每一步的指令。如何验证这是否正确呢？可以通过在可执行文件上执行objdump –d来实现：
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>$ objdump -d traced_helloworld&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;traced_helloworld:  file format elf32-i386&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Disassembly of section .text:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;08048080 &lt;.text&gt;:
</span><span class='line'> 8048080:   ba 0e 00 00 00      mov    $0xe,%edx
</span><span class='line'> 8048085:   b9 a0 90 04 08      mov    $0x80490a0,%ecx
</span><span class='line'> 804808a:   bb 01 00 00 00      mov    $0x1,%ebx
</span><span class='line'> 804808f:   b8 04 00 00 00      mov    $0x4,%eax
</span><span class='line'> 8048094:   cd 80               int    $0x80
</span><span class='line'> 8048096:   b8 01 00 00 00      mov    $0x1,%eax
</span><span class='line'> 804809b:   cd 80               int    $0x80</span></code></pre></td></tr></table></div></figure>
用这份输出对比我们的跟踪程序输出，应该很容易观察到相同的地方。</p>

<h4>关联到运行中的进程上</h4>

<p>你已经知道了调试器也可以关联到已经处于运行状态的进程上。看到这里，你应该不会感到惊讶，这也是通过ptrace来实现的。这需要通过 PTRACE_ATTACH请求。这里我不会给出一段样例代码，因为通过我们已经看到的代码，这应该很容易实现。基于教学的目的，这里采用的方法更为便捷 （因为我们可以在子进程刚启动时立刻将它停止）。</p>

<h4>代码</h4>

<p>本文给出的这个简单的跟踪程序的完整代码（更高级一点，可以将具体指令打印出来）可以在这里找到。程序通过-Wall –pedantic –std=c99编译选项在4.4版的gcc上编译。</p>

<h4>结论及下一步要做的</h4>

<p>诚然，本文并没有涵盖太多的内容——我们离一个真正可用的调试器还差的很远。但是，我希望这篇文章至少已经揭开了调试过程的神秘面纱。ptrace是一个拥有许多功能的系统调用，目前我们只展示了其中少数几种功能。
能够单步执行代码是很有用处的，但作用有限。以“Hello， world”为例，要到达main函数，需要先遍历好几千条初始化C运行时库的指令。这就不太方便了。我们所希望的理想方案是可以在main函数入口处设 置一个断点，从断点处开始单步执行。下一篇文章中我将向您展示该如何实现断点机制。</p>

<h4>参考文献</h4>

<p>写作本文时我发现下面这些文章很有帮助：<br/>
<a href="http://www.linuxjournal.com/article/6100?page=0,1">Playing with ptrace, Part I</a><br/>
<a href="http://linuxgazette.net/81/sandeep.html">Process tracing using ptrace</a><br/>
<a href="http://www.alexonlinux.com/how-debugger-works">How debugger works</a></p>
]]></content>
  </entry>
  
</feed>
