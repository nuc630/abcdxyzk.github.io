<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2015 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2015/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-07-27T18:24:50+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[系统级性能分析工具 --- Perf]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/27/debug-perf/"/>
    <updated>2015-07-27T17:09:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/27/debug-perf</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/37902159">http://blog.csdn.net/zhangskd/article/details/37902159</a></p>

<p>从2.6.31内核开始，linux内核自带了一个性能分析工具perf，能够进行函数级与指令级的热点查找。</p>

<h4>perf</h4>

<p>Performance analysis tools for Linux.<br/>
Performance counters for Linux are a new kernel-based subsystem that provide a framework for all things performance analysis. It covers hardware level (CPU/PMU, Performance Monitoring Unit) features and software features (software counters, tracepoints) as well.</p>

<p>perf是内置于Linux内核源码树中的性能剖析(profiling)工具。</p>

<p>它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。</p>

<p>常用于性能瓶颈的查找与热点代码的定位。</p>

<p>CPU周期(cpu-cycles)是默认的性能事件，所谓的CPU周期是指CPU所能识别的最小时间单元，通常为亿分之几秒，是CPU执行最简单的指令时所需要的时间，例如读取寄存器中的内容，也叫做clock tick。</p>

<p>perf是一个包含22种子工具的工具集，以下是最常用的5种：
<code>
    perf list
    perf stat
    perf top
    perf record
    perf report
</code></p>

<hr />

<h4>perf list</h4>

<p>perf list用来查看perf所支持的性能事件，有软件的也有硬件的。</p>

<p>List all symbolic event types.
<code>
    perf list [hw | sw | cache | tracepoint | event_glob]
</code></p>

<h5>(1) 性能事件的分布</h5>

<p>hw：Hardware event，9个<br/>
sw：Software event，9个<br/>
cache：Hardware cache event，26个<br/>
tracepoint：Tracepoint event，775个</p>

<p>sw实际上是内核的计数器，与硬件无关。<br/>
hw和cache是CPU架构相关的，依赖于具体硬件。<br/>
tracepoint是基于内核的ftrace，主线2.6.3x以上的内核版本才支持。</p>

<h5>(2) 指定性能事件(以它的属性)</h5>

<pre><code>    -e &lt;event&gt; : u // userspace
    -e &lt;event&gt; : k // kernel
    -e &lt;event&gt; : h // hypervisor
    -e &lt;event&gt; : G // guest counting (in KVM guests)
    -e &lt;event&gt; : H // host counting (not in KVM guests)
</code></pre>

<h5>(3) 使用例子</h5>

<p>显示内核和模块中，消耗最多CPU周期的函数：
<code>
    # perf top -e cycles:k
</code>
显示分配高速缓存最多的函数：
<code>
    # perf top -e kmem:kmem_cache_alloc
</code></p>

<hr />

<h4>perf top</h4>

<p>对于一个指定的性能事件(默认是CPU周期)，显示消耗最多的函数或指令。</p>

<p>System profiling tool.<br/>
Generates and displays a performance counter profile in real time.<br/>
<code>
    perf top [-e &lt;EVENT&gt; | --event=EVENT] [&lt;options&gt;]
</code></p>

<p>perf top主要用于实时分析各个函数在某个性能事件上的热度，能够快速的定位热点函数，包括应用程序函数、模块函数与内核函数，甚至能够定位到热点指令。默认的性能事件为cpu cycles。</p>

<h5>(1) 输出格式</h5>

<pre><code>    # perf top

    Samples: 1M of event 'cycles', Event count (approx.): 73891391490
         5.44%  perf              [.] 0x0000000000023256
         4.86%  [kernel]          [k] _spin_lock
         2.43%  [kernel]          [k] _spin_lock_bh
         2.29%  [kernel]          [k] _spin_lock_irqsave
         1.77%  [kernel]          [k] __d_lookup
         1.55%  libc-2.12.so      [.] __strcmp_sse42
         1.43%  nginx             [.] ngx_vslprintf
         1.37%  [kernel]          [k] tcp_poll
</code></pre>

<p>第一列：符号引发的性能事件的比例，默认指占用的cpu周期比例。<br/>
第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。<br/>
第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库)。[k]表述此符号属于内核或模块。<br/>
第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p>

<h5>(2) 常用交互命令</h5>

<p>h：显示帮助<br/>
UP/DOWN/PGUP/PGDN/SPACE：上下和翻页。<br/>
a：annotate current symbol，注解当前符号。能够给出汇编语言的注解，给出各条指令的采样率。<br/>
d：过滤掉所有不属于此DSO的符号。非常方便查看同一类别的符号。<br/>
P：将当前信息保存到perf.hist.N中。<br/>
s：输入函数，查看函数内部热点。</p>

<h5>(3) 常用命令行参数</h5>

<pre><code>    -e &lt;event&gt;：指明要分析的性能事件。
    -p &lt;pid&gt;：Profile events on existing Process ID (comma sperated list). 仅分析目标进程及其创建的线程。
    -k &lt;path&gt;：Path to vmlinux. Required for annotation functionality. 带符号表的内核映像所在的路径。
    -K：不显示属于内核或模块的符号。
    -U：不显示属于用户态程序的符号。
    -d &lt;n&gt;：界面的刷新周期，默认为2s，因为perf top默认每2s从mmap的内存区域读取一次性能数据。
    -G：得到函数的调用关系图。
    perf top -G [fractal]，路径概率为相对值，加起来为100%，调用顺序为从下往上。
    perf top -G graph，路径概率为绝对值，加起来为该函数的热度。
</code></pre>

<h5>(4) 使用例子</h5>

<pre><code>    # perf top // 默认配置
    # perf top -G // 得到调用关系图
    # perf top -e cycles // 指定性能事件
    # perf top -p 23015,32476 // 查看这两个进程的cpu cycles使用情况
    # perf top -s comm,pid,symbol // 显示调用symbol的进程名和进程号
    # perf top --comms nginx,top // 仅显示属于指定进程的符号
    # perf top --symbols kfree // 仅显示指定的符号
</code></pre>

<hr />

<h4>perf stat</h4>

<p>用于分析指定程序的性能概况。</p>

<p>Run a command and gather performance counter statistics.
<code>
    perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] &lt;command&gt;
    perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] - &lt;command&gt; [&lt;options&gt;]
</code></p>

<h5>(1) 输出格式</h5>

<pre><code>    # perf stat ls

    Performance counter stats for 'ls':

             0.653782 task-clock                #    0.691 CPUs utilized
                    0 context-switches          #    0.000 K/sec
                    0 CPU-migrations            #    0.000 K/sec
                  247 page-faults               #    0.378 M/sec
            1,625,426 cycles                    #    2.486 GHz
            1,050,293 stalled-cycles-frontend   #   64.62% frontend cycles idle
              838,781 stalled-cycles-backend    #   51.60% backend  cycles idle
            1,055,735 instructions              #    0.65  insns per cycle
                                                #    0.99  stalled cycles per insn
              210,587 branches                  #  322.106 M/sec
               10,809 branch-misses             #    5.13% of all branches

          0.000945883 seconds time elapsed
</code></pre>

<p>输出包括ls的执行时间，以及10个性能事件的统计。</p>

<p>task-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized = task-clock / time elapsed，CPU的占用率。<br/>
context-switches：上下文的切换次数。<br/>
CPU-migrations：处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。<br/>
page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。<br/>
cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles / task-clock算出。<br/>
stalled-cycles-frontend：略过。<br/>
stalled-cycles-backend：略过。<br/>
instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。<br/>
branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p>

<h5>(2) 常用参数</h5>

<pre><code>    -p：stat events on existing process id (comma separated list). 仅分析目标进程及其创建的线程。
    -a：system-wide collection from all CPUs. 从所有CPU上收集性能数据。
    -r：repeat command and print average + stddev (max: 100). 重复执行命令求平均。
    -C：Count only on the list of CPUs provided (comma separated list), 从指定CPU上收集性能数据。
    -v：be more verbose (show counter open errors, etc), 显示更多性能数据。
    -n：null run - don't start any counters，只显示任务的执行时间 。
    -x SEP：指定输出列的分隔符。
    -o file：指定输出文件，--append指定追加模式。
    --pre &lt;cmd&gt;：执行目标程序前先执行的程序。
    --post &lt;cmd&gt;：执行目标程序后再执行的程序。
</code></pre>

<h5>(3) 使用例子</h5>

<p>执行10次程序，给出标准偏差与期望的比值：
<code>
    # perf stat -r 10 ls &gt; /dev/null
</code></p>

<p>显示更详细的信息：
<code>
    # perf stat -v ls &gt; /dev/null
</code></p>

<p>只显示任务执行时间，不显示性能计数器：
<code>
    # perf stat -n ls &gt; /dev/null
</code></p>

<p>单独给出每个CPU上的信息：
<code>
    # perf stat -a -A ls &gt; /dev/null
</code></p>

<p>ls命令执行了多少次系统调用：
<code>
    # perf stat -e syscalls:sys_enter ls
</code></p>

<hr />

<h4>perf record</h4>

<p>收集采样信息，并将其记录在数据文件中。随后可以通过其它工具(perf-report)对数据文件进行分析，结果类似于perf-top的。</p>

<p>Run a command and record its profile into perf.data.<br/>
This command runs a command and gathers a performance counter profile from it, into perf.data,without displaying anything. This file can then be inspected later on, using perf report.</p>

<h5>(1) 常用参数</h5>

<pre><code>    -e：Select the PMU event.
    -a：System-wide collection from all CPUs.
    -p：Record events on existing process ID (comma separated list).
    -A：Append to the output file to do incremental profiling.
    -f：Overwrite existing data file.
    -o：Output file name.
    -g：Do call-graph (stack chain/backtrace) recording.
    -C：Collect samples only on the list of CPUs provided.
</code></pre>

<h5>(2) 使用例子</h5>

<p>记录nginx进程的性能数据：
<code>
    # perf record -p `pgrep -d ',' nginx`
</code></p>

<p>记录执行ls时的性能数据：
<code>
    # perf record ls -g
</code></p>

<p>记录执行ls时的系统调用，可以知道哪些系统调用最频繁：
<code>
    # perf record -e syscalls:sys_enter ls
</code></p>

<hr />

<h4>perf report</h4>

<p>读取perf record创建的数据文件，并给出热点分析结果。</p>

<p>Read perf.data (created by perf record) and display the profile.<br/>
This command displays the performance counter profile information recorded via perf record.</p>

<h5>(1) 常用参数</h5>

<pre><code>    -i：Input file name. (default: perf.data)
</code></pre>

<h5>(2) 使用例子</h5>

<pre><code>    # perf report -i perf.data.2
</code></pre>

<hr />

<h3>More</h3>

<p>除了以上5个常用工具外，还有一些适用于较特殊场景的工具， 比如内核锁、slab分配器、调度器，也支持自定义探测点。</p>

<h4>perf lock</h4>

<p>内核锁的性能分析。</p>

<p>Analyze lock events.
<code>
    perf lock {record | report | script | info}
</code></p>

<ul>
<li>需要编译选项的支持：CONFIG_LOCKDEP、CONFIG_LOCK_STAT。</li>
</ul>


<p>CONFIG_LOCKDEP defines acquired and release events.<br/>
CONFIG_LOCK_STAT defines contended and acquired lock events.</p>

<h5>(1) 常用选项</h5>

<pre><code>    -i &lt;file&gt;：输入文件
    -k &lt;value&gt;：sorting key，默认为acquired，还可以按contended、wait_total、wait_max和wait_min来排序。
</code></pre>

<h5>(2) 使用例子</h5>

<pre><code>    # perf lock record ls // 记录
    # perf lock report // 报告
</code></pre>

<h5>(3) 输出格式</h5>

<pre><code>                   Name   acquired  contended total wait (ns)   max wait (ns)   min wait (ns)

    &amp;mm-&gt;page_table_...        382          0               0               0               0
    &amp;mm-&gt;page_table_...         72          0               0               0               0
              &amp;fs-&gt;lock         64          0               0               0               0
            dcache_lock         62          0               0               0               0
          vfsmount_lock         43          0               0               0               0
    &amp;newf-&gt;file_lock...         41          0               0               0               0
</code></pre>

<p>Name：内核锁的名字。<br/>
aquired：该锁被直接获得的次数，因为没有其它内核路径占用该锁，此时不用等待。<br/>
contended：该锁等待后获得的次数，此时被其它内核路径占用，需要等待。<br/>
total wait：为了获得该锁，总共的等待时间。<br/>
max wait：为了获得该锁，最大的等待时间。<br/>
min wait：为了获得该锁，最小的等待时间。</p>

<p>最后还有一个Summary：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>=== output for debug===&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;bad: 10, total: 246  
</span><span class='line'>bad rate: 4.065041 %  
</span><span class='line'>histogram of events caused bad sequence  
</span><span class='line'>acquire: 0  
</span><span class='line'>   acquired: 0  
</span><span class='line'>  contended: 0  
</span><span class='line'>release: 10  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>---------------
</span><span class='line'>
</span><span class='line'>##### perf kmem
</span><span class='line'>
</span><span class='line'>slab分配器的性能分析。
</span><span class='line'>
</span><span class='line'>Tool to trace/measure kernel memory(slab) properties.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;perf kmem {record | stat} [&lt;options&gt;]
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (1) 常用选项
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;--i &lt;file&gt;：输入文件
</span><span class='line'>--caller：show per-callsite statistics，显示内核中调用kmalloc和kfree的地方。
</span><span class='line'>--alloc：show per-allocation statistics，显示分配的内存地址。
</span><span class='line'>-l &lt;num&gt;：print n lines only，只显示num行。
</span><span class='line'>-s &lt;key[,key2...]&gt;：sort the output (default: frag,hit,bytes)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (2) 使用例子
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# perf kmem record ls // 记录
</span><span class='line'># perf kmem stat --caller --alloc -l 20 // 报告
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (3) 输出格式
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;------------------------------------------------------------------------------------------------------
</span><span class='line'> Callsite                           | Total_alloc/Per | Total_req/Per   | Hit      | Ping-pong | Frag
</span><span class='line'>------------------------------------------------------------------------------------------------------
</span><span class='line'> perf_event_mmap+ec                 |    311296/8192  |    155952/4104  |       38 |        0 | 49.902%
</span><span class='line'> proc_reg_open+41                   |        64/64    |        40/40    |        1 |        0 | 37.500%
</span><span class='line'> __kmalloc_node+4d                  |      1024/1024  |       664/664   |        1 |        0 | 35.156%
</span><span class='line'> ext3_readdir+5bd                   |        64/64    |        48/48    |        1 |        0 | 25.000%
</span><span class='line'> load_elf_binary+8ec                |       512/512   |       392/392   |        1 |        0 | 23.438%
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>Callsite：内核代码中调用kmalloc和kfree的地方。  
</span><span class='line'>Total_alloc/Per：总共分配的内存大小，平均每次分配的内存大小。  
</span><span class='line'>Total_req/Per：总共请求的内存大小，平均每次请求的内存大小。  
</span><span class='line'>Hit：调用的次数。  
</span><span class='line'>Ping-pong：kmalloc和kfree不被同一个CPU执行时的次数，这会导致cache效率降低。  
</span><span class='line'>Frag：碎片所占的百分比，碎片 = 分配的内存 - 请求的内存，这部分是浪费的。  
</span><span class='line'>有使用--alloc选项，还会看到Alloc Ptr，即所分配内存的地址。  
</span><span class='line'>
</span><span class='line'>最后还有一个Summary：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;SUMMARY
</span><span class='line'>=======
</span><span class='line'>Total bytes requested: 290544
</span><span class='line'>Total bytes allocated: 447016
</span><span class='line'>Total bytes wasted on internal fragmentation: 156472
</span><span class='line'>Internal fragmentation: 35.003669%
</span><span class='line'>Cross CPU allocations: 2/509
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>---------------
</span><span class='line'>
</span><span class='line'>#### probe sched
</span><span class='line'>
</span><span class='line'>调度模块分析。
</span><span class='line'>
</span><span class='line'>trace/measure scheduler properties (latencies)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;perf sched {record | latency | map | replay | script}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (1) 使用例子 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# perf sched record sleep 10 // perf sched record &lt;command&gt;
</span><span class='line'># perf report latency --sort max
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (2) 输出格式
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;---------------------------------------------------------------------------------------------------------------
</span><span class='line'> Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at     |
</span><span class='line'>---------------------------------------------------------------------------------------------------------------
</span><span class='line'> events/10:61          |      0.655 ms |       10 | avg:    0.045 ms | max:    0.161 ms | max at: 9804.958730 s
</span><span class='line'> sleep:11156           |      2.263 ms |        4 | avg:    0.052 ms | max:    0.118 ms | max at: 9804.865552 s
</span><span class='line'> edac-poller:1125      |      0.598 ms |       10 | avg:    0.042 ms | max:    0.113 ms | max at: 9804.958698 s
</span><span class='line'> events/2:53           |      0.676 ms |       10 | avg:    0.037 ms | max:    0.102 ms | max at: 9814.751605 s
</span><span class='line'> perf:11155            |      2.109 ms |        1 | avg:    0.068 ms | max:    0.068 ms | max at: 9814.867918 s
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;TASK：进程名和pid。  
</span><span class='line'>Runtime：实际的运行时间。  
</span><span class='line'>Switches：进程切换的次数。  
</span><span class='line'>Average delay：平均的调度延迟。  
</span><span class='line'>Maximum delay：最大的调度延迟。  
</span><span class='line'>Maximum delay at：最大调度延迟发生的时刻。  
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>---------------
</span><span class='line'>
</span><span class='line'>#### perf probe
</span><span class='line'>
</span><span class='line'>可以自定义探测点。
</span><span class='line'>
</span><span class='line'>Define new dynamic tracepoints.
</span><span class='line'>
</span><span class='line'>##### 使用例子
</span><span class='line'>
</span><span class='line'>(1) Display which lines in schedule() can be probed
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# perf probe --line schedule
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;前面有行号的可以探测，没有行号的就不行了。
</span><span class='line'>
</span><span class='line'>(2) Add a probe on schedule() function 12th line.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# perf probe -a schedule:12
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```
</span><span class='line'>在schedule函数的12处增加一个探测点。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Reference&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;[1]. Linux的系统级性能剖析工具系列，by 承刚&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;[2]. &lt;a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/"&gt;http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;[3]. &lt;a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/"&gt;http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;[4]. &lt;a href="https://perf.wiki.kernel.org/index.php/Tutorial"&gt;https://perf.wiki.kernel.org/index.php/Tutorial&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[haproxy splice]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/07/24/tools-haproxy-splice/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-07-24T16:45:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/07/24/tools-haproxy-splice&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;www.haproxy.org/download/1.5/doc/configuration.txt 或 &lt;a href="/download/tools/haproxy-1.5-configuration.txt"&gt;configuration.txt&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;旧版编译加
</span><span class='line'>&lt;code&gt;
</span><span class='line'>USE_TCPSPLICE=1
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;比较新的加
</span><span class='line'>&lt;code&gt;
</span><span class='line'>USE_LINUX_SPLICE=1
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>默认编译会加入&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;编译加入了也要在配置文件中开启才有效
</span><span class='line'>&lt;code&gt;
</span><span class='line'>option splice-auto
</span><span class='line'>option splice-request
</span><span class='line'>option splice-response
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在global中关闭splice功能
</span><span class='line'>&lt;code&gt;
</span><span class='line'>nosplice
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[haproxy log]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/07/24/tools-haproxy-log/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-07-24T16:39:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/07/24/tools-haproxy-log&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://sharadchhetri.com/2013/10/16/how-to-enable-logging-of-haproxy-in-rsyslog/"&gt;http://sharadchhetri.com/2013/10/16/how-to-enable-logging-of-haproxy-in-rsyslog/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  After installing the HAproxy 1.4 in CentOS 6.4 bydefault logging of haproxy was not enable.To enable the logging of HAProxy you have to enable it in rsyslog(In CentOS 6.4 minimal installation,rsyslog version 5.2 is shipped).
</span><span class='line'>To setup logging in HAproxy,follow the given below steps&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Step 1:&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;In Global Section of haproxy.cfg put the value log 127.0.0.1 local0 .Like given below
</span><span class='line'>&lt;code&gt;
</span><span class='line'>global
</span><span class='line'>    log 127.0.0.1   local0
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Step 2:&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Create new haproxy configuration file in /etc/rsyslog.d . Here we are keeping the log in localhost or in other words we should say HAproxy server&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Note:&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;local0.=info -/var/log/haproxy.log defines the http log will be saved in haproxy.log&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;local0.notice -/var/log/haproxy-status.log defines the Server status like start,stop,restart,down,up etc. will be saved in haproxy-status.log&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;UDPServerRun 514 means opening UDP port no. 514 to listen haproxy messages&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    vi /etc/rsyslog.d/haproxy.conf
</span><span class='line'>
</span><span class='line'>$ModLoad imudp
</span><span class='line'>$UDPServerRun 514 
</span><span class='line'>$template Haproxy,"%msg%\n"
</span><span class='line'>local0.=info -/var/log/haproxy.log;Haproxy
</span><span class='line'>local0.notice -/var/log/haproxy-status.log;Haproxy
</span><span class='line'>### keep logs in localhost ##
</span><span class='line'>local0.* ~ 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Step 3:&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Now restart the HAproxy service
</span><span class='line'>&lt;code&gt;
</span><span class='line'>/etc/init.d/haproxy restart
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>After restarting the haproxy service two logs will be created itself i.e haproxy.log and haproxy-status.log&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Step 4:&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Check your logrotae file for haproxy also so that logs keep on rotating and compress itself. If bydefault it is not present in /etc/logrotate.d directory then create a new file called haproxy and paste the given below code.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Here I am keeping the logs upto 120 days hence rotate 120 and daily is written in file.</span></code></pre></td></tr></table></div></figure>
    cat /etc/logrotate.d/haproxy</p>

<pre><code>/var/log/haproxy.log {
    missingok
    notifempty
    sharedscripts
    rotate 120
    daily
    compress
    postrotate
        reload rsyslog &gt;/dev/null 2&gt;&amp;1 || true
    endscript
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[haproxy安装配置]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/23/tools-haproxy/"/>
    <updated>2015-07-23T15:47:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/23/tools-haproxy</id>
    <content type="html"><![CDATA[<p>HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上.</p>

<p>haproxy 配置中分成五部分内容，分别如下：</p>

<p>1、global：参数是进程级的，通常是和操作系统相关。这些参数一般只设置一次，如果配置无误，就不需要再次进行修改</p>

<p>2、defaults：配置默认参数，这些参数可以被用到frontend，backend，Listen组件</p>

<p>3、frontend：接收请求的前端虚拟节点，Frontend可以更加规则直接指定具体使用后端的backend</p>

<p>4、backend：后端服务集群的配置，是真实服务器，一个Backend对应一个或者多个实体服务器</p>

<p>5、Listen Fronted和backend的组合体</p>

<h4>一、安装HAProxy</h4>

<h5>1.下载最新haproxy安装包</h5>

<p>官网：<a href="http://www.haproxy.org">http://www.haproxy.org</a> ,如果不能访问，可以使用在线代理访问下载。下载：<a href="http://fossies.org/linux/misc/haproxy-1.5.14.tar.gz">http://fossies.org/linux/misc/haproxy-1.5.14.tar.gz</a> 或 <a href="/download/tools/haproxy-1.5.14.tar.gz">haproxy-1.5.14.tar.gz</a></p>

<h5>2.上传到linux的haproxy用户根目录下，并解压：</h5>

<pre><code>    tar -zxvf haproxy-1.5.14.tar.gz 
</code></pre>

<p>创建目录/home/haproxy/haproxy</p>

<h5>3.安装</h5>

<p>CentOS5编译新的haproxy需要在Makefile中禁掉USE_ACCEPT4</p>

<pre><code>    cd haproxy-1.5.14
    make  TARGET=linux26 ARCH=x86_64 PREFIX=/home/haproxy/haproxy   #将haproxy安装到/home/haproxy/haproxy ,TARGET是指定内核版本
    make install PREFIX=/home/haproxy/haproxy  
</code></pre>

<p>进入/home/haproxy/haproxy  目录创建/home/haproxy/haproxy/conf目录，复制配置examples
<code>
    cp  /home/haproxy/haproxy-1.5.14/examples/haproxy.cfg  /home/haproxy/haproxy/conf/
</code></p>

<h5>4.修改配置</h5>

<p>配置说明如下：(参考:<a href="http://freehat.blog.51cto.com/1239536/1347882">http://freehat.blog.51cto.com/1239536/1347882</a>)</p>

<pre><code>    ###########全局配置#########
    global
        log 127.0.0.1   local0          #[日志输出配置，所有日志都记录在本机，通过local0输出]
        log 127.0.0.1   local1 notice   #定义haproxy 日志级别[error warringinfo debug]
        daemon                          #以后台形式运行harpoxy
        nbproc    1                     #设置进程数量
        maxconn   4096                  #默认最大连接数,需考虑ulimit-n限制
        #pidfile  /var/run/haproxy.pid  #haproxy 进程PID文件
        #ulimit-n 819200                #ulimit 的数量限制
        #chroot   /usr/share/haproxy    #chroot运行路径
        #debug                          #haproxy 调试级别，建议只在开启单进程的时候调试
        #quiet

    ########默认配置############
    defaults
        log      global
        mode     http                  #默认的模式mode { tcp|http|health }，tcp是4层，http是7层，health只会返回OK
        option   httplog               #日志类别,采用httplog
        option   dontlognull           #不记录健康检查日志信息
        retries  2                     #两次连接失败就认为是服务器不可用，也可以通过后面设置
        option   forwardfor            #如果后端服务器需要获得客户端真实ip需要配置的参数，可以从Http Header中获得客户端ip
        option   httpclose             #每次请求完毕后主动关闭http通道,haproxy不支持keep-alive,只能模拟这种模式的实现
        #option  redispatch            #当serverId对应的服务器挂掉后，强制定向到其他健康的服务器，以后将不支持
        option   abortonclose          #当服务器负载很高的时候，自动结束掉当前队列处理比较久的链接
        maxconn  4096                  #默认的最大连接数
        timeout  connect  5000ms       #连接超时
        timeout  client 30000ms        #客户端超时
        timeout  server 30000ms        #服务器超时
        #timeout check 2000            #心跳检测超时
        #timeout http-keep-alive10s    #默认持久连接超时时间
        #timeout http-request   10s    #默认http请求超时时间
        #timeout queue          1m     #默认队列超时时间
        balance  roundrobin            #设置默认负载均衡方式，轮询方式
        #balance source                #设置默认负载均衡方式，类似于nginx的ip_hash
        #balnace leastconn             #设置默认负载均衡方式，最小连接数

    ########统计页面配置########
    listen admin_stats
        bind 0.0.0.0:1080               #设置Frontend和Backend的组合体，监控组的名称，按需要自定义名称
        mode http                       #http的7层模式
        option httplog                  #采用http日志格式
        #log 127.0.0.1 local0 err       #错误日志记录
        maxconn 10                      #默认的最大连接数
        stats refresh 30s               #统计页面自动刷新时间
        stats uri /stats                #统计页面url
        stats realm XingCloud\ Haproxy  #统计页面密码框上提示文本
        stats auth admin:admin          #设置监控页面的用户和密码:admin,可以设置多个用户名
        stats auth  Frank:Frank         #设置监控页面的用户和密码：Frank
        stats hide-version              #隐藏统计页面上HAProxy的版本信息
        stats  admin if TRUE            #设置手工启动/禁用，后端服务器(haproxy-1.4.9以后版本)

    ########设置haproxy 错误页面#####
    errorfile 403 /home/haproxy/haproxy/errorfiles/403.http
    errorfile 500 /home/haproxy/haproxy/errorfiles/500.http
    errorfile 502 /home/haproxy/haproxy/errorfiles/502.http
    errorfile 503 /home/haproxy/haproxy/errorfiles/503.http
    errorfile 504 /home/haproxy/haproxy/errorfiles/504.http

    ########frontend前端配置##############
    bind *:80         #这里建议使用bind *:80的方式，要不然做集群高可用的时候有问题，vip切换到其他机器就不能访问了。
        acl web hdr(host) -i www.abc.com  #acl后面是规则名称，-i是要访问的域名，如果访问www.abc.com这个域名就分发到下面的webserver 的作用域。
        acl img hdr(host) -i img.abc.com  #如果访问img.abc.com.cn就分发到imgserver这个作用域。
        use_backend webserver if web
        use_backend imgserver if img

    ########backend后端配置##############
    backend webserver             #webserver作用域
        mode http
        balance   roundrobin                  #balance roundrobin 轮询，balance source 保存session值，支持static-rr，leastconn，first，uri等参数
        option  httpchk /index.html HTTP/1.0  #健康检查, 检测文件，如果分发到后台index.html访问不到就不再分发给它
        server  web1 10.16.0.9:8085  cookie 1 weight 5 check inter 2000 rise 2 fall 3
        server  web2 10.16.0.10:8085 cookie 2 weight 3 check inter 2000 rise 2 fall 3
        #cookie 1表示serverid为1，check inter 1500 是检测心跳频率  
        #rise 2是2次正确认为服务器可用，fall 3是3次失败认为服务器不可用，weight代表权重
    backend imgserver
        mode http
        option  httpchk /index.php
        balance     roundrobin                          
        server      img01 192.168.137.101:80  check inter 2000 fall 3
        server      img02 192.168.137.102:80  check inter 2000 fall 3
    listen tcptest  
        bind 0.0.0.0:5222  
        mode tcp  
        option tcplog                  #采用tcp日志格式  
        balance source  
        #log 127.0.0.1 local0 debug  
        server s1 192.168.100.204:7222    weight 1  
        server s2 192.168.100.208:7222    weight 1
</code></pre>

<h5>5.加上日志支持</h5>

<pre><code>    # vim /etc/syslog.conf
    在最下边增加
    local1.*        /home/haproxy/haproxy/logs/haproxy.log
    local0.*        /home/haproxy/haproxy/logs/haproxy.log
</code></pre>

<pre><code>    # vim /etc/sysconfig/syslog
    修改： SYSLOGD_OPTIONS="-r -m 0"
    重启日志服务 service syslog restart
</code></pre>

<h6>6.启动服务</h6>

<p>启动服务：
<code>
    # /home/haproxy/haproxy/sbin/haproxy -f /home/haproxy/haproxy/conf/haproxy.cfg
</code>
重启服务：
<code>
    # /home/haproxy/haproxy/sbin/haproxy -f /home/haproxy/haproxy/conf/haproxy.cfg -st `cat /home/haproxy/haproxy/conf/haproxy.pid`
</code>
停止服务：
<code>
    # killall haproxy
</code></p>

<h5>7.监控</h5>

<p>访问：<a href="http://192.168.101.125:1080/stats">http://192.168.101.125:1080/stats</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[同时运行多个squid]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/23/tools-squid-muti/"/>
    <updated>2015-07-23T15:32:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/23/tools-squid-muti</id>
    <content type="html"><![CDATA[<p><a href="http://wenku.baidu.com/link?url=UXFXZVxSsQMyXVzoTA5y3Oal6s5zknpozLhfodYZ7d43R_XpziB08h28ynXZy3Sq8r-XH1tdXGvxD_X2Pa_aI4f6pFTBgGXMm0QRaRbEYmq">http://wenku.baidu.com/link?url=UXFXZVxSsQMyXVzoTA5y3Oal6s5zknpozLhfodYZ7d43R_XpziB08h28ynXZy3Sq8r-XH1tdXGvxD_X2Pa_aI4f6pFTBgGXMm0QRaRbEYmq</a></p>

<h4>多代理（SQUID）同时运行的配置方法 </h4>

<p>作成日期：2012/8/24 </p>

<h5>多代理用途： </h5>

<p>1、HTTP反向加速； 
2、权限控制部分客户端，而权限控制选项是全局设置时； </p>

<p>总之，一般的代理服务器运行一个即可，当有特殊要求的时候，才有此需要，HTTP反向代理本文没有涉及，仅是为了权限控制，一台机器同一网卡运行了2个Squid，对于HTTP反向代理，有兴趣者可自行研究配置。  </p>

<h5>环境： </h5>

<p>1、 Cent OS 5 
2、 Squid （Version 2.6.STABLE21） <br/>
3、 DELL R710  </p>

<h5>配置： </h5>

<p>在配置多Squid同时运行时，我的服务器已经安装配置好的Squid，并正常运行，如果你的服务器还不具备此条件，请先配置好Squid，并确保可以正确运行。 </p>

<p>1、 复制一份Squid .conf配置文件 <br/>
2、 编辑新文件，配置如下的选项与第一个Squid区分开 </p>

<table>
    <tr>
        <th>项目</th>
        <th>参数</th>
        <th>备注</th>
    </tr>
    <tr>
        <td>端口</td>
        <td>8080</td>
        <td>端口可自定，但要注意两个问题，与原有的Squid 默认的3128区分开，并且与系统已经存在的服务占用端口区分开，避免冲突发生。</td>
    </tr>
    <tr>
        <td>缓存目录</td>
        <td>指定一个新目录与第一个Squid区分开</td>
        <td>TAG: cache_dir， 注意，新的目录必须将权限设定为777。</td>
    </tr>
    <tr>
        <td>系统日志</td>
        <td>指定一个新目录与第一个Squid区分开</td>
        <td>TAG: access_log TAG: cache_log TAG: cache_store_log 以上日志存放地点可自定与第一个Squid区分开即可，注意，新的目录必须将权限设定为777。</td>
    </tr>
    <tr>
        <td>PID文件</td>
        <td>指定一个新目录与第一个Squid区分开</td>
        <td>TAG: pid_filename 第1个Suqid的PID文件默认存放地点是/VAR/RUN 重新指定新的目录，避免与第1个Squid文件冲突。</td>
    </tr>
</table>


<p>3、初始化缓存目录 <br/>
命令如下：<code>squid -z -f 新的配置文件</code> 
注意，"-f"参数后面一定要写上新配置文件，一般设定2个Squid同时运行时，都是这一步没有处理或者处理错误，比如没有加"-f"参数的话，就会初始化原有的Squid缓存目录 而不是新squid缓存目录。 </p>

<p>4、运行第2个代理服务器 <br/>
命令如下：<code>squid -D -f 新的配置文件</code>  </p>

<p> var script = document.createElement(&lsquo;script&rsquo;); script.src = &lsquo;<a href="http://static.pay.baidu.com/resource/baichuan/ns.js">http://static.pay.baidu.com/resource/baichuan/ns.js</a>&rsquo;; document.body.appendChild(script);</p>

<h4> 维护： </h4>

<p>至此，服务器上已经运行两个代理服务器，使用不同的端口，就会通过不同代理服务器进行网络连接，设定配置文件，可为客户端设定不同的网络权限。   </p>

<p>1、关于配置文件的更新后Reload 
如更新第1个代理，使用默认系统命令：squid -k reconfigure      如更新第2个代理，squid -k reconfigure -f 新的配置文件   </p>

<p>2、第2个代理的自动启动 <br/>
当系统重新时，想第2个代理随机启动，请参照以下脚本（第1个代理启动，可以在系统中设定）： </p>

<pre><code>    #! /bin/sh 
    echo "Start special squid”             #输出一些提示信息 
    squid -D -f /etc/squid/squidnew.conf   #我的新配置文件在/etc/squid下面 
    echo "Please wait ...."                #输出一些提示信息 
    sleep 5                             #等待5秒，给Squid启动时间，实际可能不需要怎么久 
    cd /var/cache/squidnew/             #进入缓存目录，我的PID文件放在这里 
    if [ -s squid.pid ];                #判断PID文件是否存在，存在squid启动成功，否则失败      
    then                                              
        echo "Squid start success"      
    else 
        echo "Squid start failed" 
    fi
    exit 0 
</code></pre>

<p>将该脚本放置到启动目录，自行启动即可，另外我不是自行启动，因有时候不运行，如自行启动，可将判断的部分删除，因为系统启动，可能看不到脚本提示信息。 </p>

<p>关于关闭Squid，请使用多次的 squid -k shutdown 命令关闭服务， 同时使用ps -ef |grep squid 判断代理服务是否全部关闭完成。 </p>

<p>调试过程如有问题，使用tail -f /var/log/messages 排错也是个不错的办法。  </p>

<p>备注： </p>

<p>另外，系统究竟可以运行多少个Squid？没有测试，猜测如CPU足够快、内存足够大，应该可以运行很多副本。</p>
]]></content>
  </entry>
  
</feed>
