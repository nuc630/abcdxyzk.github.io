<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2011~08 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2011~08/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2016-03-09T11:22:18+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AT&T 汇编]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/08/31/assembly-base-3/"/>
    <updated>2011-08-31T13:06:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/08/31/assembly-base-3</id>
    <content type="html"><![CDATA[<p>AT&amp;T 汇编</p>

<h4>1.Register Reference</h4>

<p>引用寄存器要在寄存器号前加百分号%,如“movl %eax, %ebx”。<br/>
80386 有如下寄存器:
<code>
[1] 8 个 32-bit 寄存器 %eax,%ebx,%ecx,%edx,%edi,%esi,%ebp,%esp;
( 8 个 16-bit 寄存器,它们事实上是上面 8 个 32-bit 寄存器的低 16 位:%ax,%bx,
%cx,%dx,%di,%si,%bp,%sp;
8 个 8-bit 寄存器:%ah,%al,%bh,%bl,%ch,%cl,%dh,%dl。它们事实上
是寄存器%ax,%bx,%cx,%dx 的高 8 位和低 8 位;)
[2] 6 个段寄存器:%cs(code),%ds(data),%ss(stack), %es,%fs,%gs;
[3] 3 个控制寄存器:%cr0,%cr2,%cr3;
[4] 6 个 debug 寄存器:%db0,%db1,%db2,%db3,%db6,%db7;
[5] 2 个测试寄存器:%tr6,%tr7;
[6] 8 个浮点寄存器栈:%st(0),%st(1),%st(2),%st(3),%st(4),%st(5),%st(6),%st(7)。
</code></p>

<h4>2. Operator Sequence</h4>

<p>操作数排列是从源(左)到目的(右),如“movl %eax(源), %ebx(目的)”</p>

<h4>3. Immediately Operator</h4>

<p>使用立即数,要在数前面加符号$, 如“movl $0x04, %ebx”<br/>
或者:
<code>
para = 0x04
movl $para, %ebx
</code>
指令执行的结果是将立即数 0x04 装入寄存器 ebx。</p>

<h4>4. Symbol Constant</h4>

<p>符号常数直接引用 如
<code>
value: .long 0x12a3f2de
movl value , %ebx
</code>
指令执行的结果是将常数 0x12a3f2de 装入寄存器 ebx。<br/>
引用符号地址在符号前加符号$, 如“movl $value, % ebx”则是将符号 value 的地址装入寄存器 ebx。</p>

<h4>5. Length of Operator</h4>

<p>操作数的长度用加在指令后的符号表示 b(byte, 8-bit), w(word, 16-bits), l(long,32-bits) ,如“movb %al, %bl” ,“movw
%ax, %bx”,“movl %eax, %ebx ”。<br/>
如 果没有指定操作数长度的话,编译器将按照目标操作数的长度来设置。比如指令“mov %ax, %bx”,由于目标操作数 bx 的长度为
word , 那 么 编 译 器 将 把 此 指 令 等 同 于 “ movw %ax,%bx” 。 同 样 道 理 , 指 令 “ mov $4, %ebx” 等 同 于 指 令 “ movl $4,
%ebx”,“push %al”等同于“pushb %al”。对于没有指定操作数长度,但编译器又无法猜测的指令,编译器将会报错,比如指令
“push $4”。</p>

<h4>6. Sign and Zero Extension</h4>

<p>绝大多数面向 80386 的 AT&amp;T 汇编指令与 Intel 格式的汇编指令都是相同的,但符号扩展指令和零扩展指令有不同格式。符号扩展指令
和零扩展指令需要指定源操作数长度和目的操作数长度,即使在某些指令中这些操作数是隐含的。</p>

<p>在 AT&amp;T 语法中,符号扩展和零扩展指令的格式为,基本部分"movs"和"movz"(对应 Intel 语法的 movsx 和 movzx),后面跟
上源操作数长度和目的操作数长度。 movsbl 意味着 movs (from)byte (to)long;movbw 意味着 movs (from)byte
(to)word;movswl 意味着 movs (from)word (to)long。对于 movz 指令也一样。比如指令“movsbl %al,%edx”意味着将
al 寄存器的内容进行符号扩展后放置到 edx 寄存器中。</p>

<p>其它的 Intel 格式的符号扩展指令还有:
<code>
cbw -- sign-extend byte in %al to word in %ax;
cwde -- sign-extend word in %ax to long in %eax;
cwd -- sign-extend word in %ax to long in %dx:%ax;
cdq -- sign-extend dword in %eax to quad in %edx:%eax;
</code>
对应的 AT&amp;T 语法的指令为 cbtw,cwtl,cwtd,cltd。</p>

<h4>7. Call and Jump</h4>

<p>段内调用和跳转指令为 &ldquo;call&rdquo; , &ldquo;ret&rdquo; 和 &ldquo;jmp&rdquo;,段间调用和跳转指令为 &ldquo;lcall&rdquo; , &ldquo;lret&rdquo; 和 &ldquo;ljmp&rdquo; 。段间调用和跳转指令的格式为<br/>
“lcall/ljmp $SECTION, $OFFSET”,而段间返回指令则为“lret $STACK-ADJUST”。</p>

<h4>8. Prefix</h4>

<p>操作码前缀被用在下列的情况:
<code>
[1]字符串重复操作指令(rep,repne);
[2]指定被操作的段(cs,ds,ss,es,fs,gs);
[3]进行总线加锁(lock);
[4]指定地址和操作的大小(data16,addr16);
</code>
在 AT&amp;T 汇编语法中,操作码前缀通常被单独放在一行,后面不跟任何操作数。例如,对于重复 scas 指令,其写法为:
<code>
repne
scas
</code></p>

<p>上述操作码前缀的意义和用法如下:
<code>
[1]指定被操作的段前缀为 cs,ds,ss,es,fs,和 gs。在 AT&amp;T 语法中,只需要按照
section:memory-operand 的格式就指定了相应的段前缀。比如:
lcall %cs:realmode_swtch
[2]操作数/地址大小前缀是“data16”和"addr16",它们被用来在 32-bit 操作数/地址代码中指定 16-bit 的操作数/地址。
[3]总线加锁前缀“lock”,它是为了在多处理器环境中,保证在当前指令执行期间禁止一切中断。这个前缀仅仅对 ADD, ADC, AND,
BTC, BTR, BTS, CMPXCHG,DEC,
INC, NEG, NOT, OR, SBB, SUB, XOR, XADD,XCHG 指令有效,如果将 Lock 前
缀用在其它指令之前,将会引起异常。
[4]字符串重复操作前缀"rep","repe","repne"用来让字符串操作重复“%ecx”次。
</code></p>

<h4>9. Memory Reference</h4>

<p>Intel 语法的间接内存引用的格式为:<br/>
<code>
section:[base+index*scale+displacement]
</code>
而在 AT&amp;T 语法中对应的形式为:
<code>
section:displacement(base,index,scale)
</code>
其中,base 和 index 是任意的 32-bit base 和 index 寄存器。scale 可以取值 1,2,4,8。如果不指定 scale 值,则默认值为 1。
section 可以指定任意的段寄存器作为段前缀,默认的段寄存器在不同的情况下不一样。如果在指令中指定了默认的段前缀,则编译器在
目标代码中不会产生此段前缀代码。</p>

<p>下面是一些例子:<br/>
-4(%ebp):base=%ebp,displacement=-4,section 没有指定,由于 base=%ebp,所以默认的 section=%ss,index,scale
没有指定,则 index 为 0。<br/>
foo(,%eax,4):index=%eax,scale=4,displacement=foo。其它域没有指定。这里默认的 section=%ds。<br/>
foo(,1):这个表达式引用的是指针 foo 指向的地址所存放的值。注意这个表达式中没有 base 和 index,并且只有一个逗号,这是一种
异常语法,但却合法。<br/>
%gs:foo:这个表达式引用的是放置于%gs 段里变量 foo 的值。<br/>
如果 call 和 jump 操作在操作数前指定前缀“<em>”,则表示是一个绝对地址调用/跳转,也就是说 jmp/call 指令指定的是一个绝对地址。<br/>
如果没有指定"</em>&ldquo;,则操作数是一个相对地址。<br/>
任何指令如果其操作数是一个内存操作, 则指令必须指定它的操作尺寸<br/>
(byte,word,long),也就是说必须带有指令后缀(b,w,l)。<br/>
Linux 工作在保护模式下,用的是 32 位线性地址,所以在计算地址时不用考虑段基址和偏移量,而是采用如下的地<br/>
址计算方法:<br/>
disp + base + index * scale<br/>
下面是一些内存操作数的例子:<br/>
<code>
AT&amp;T 格式
movl -4(%ebp), %eax
movl array(, %eax, 4), %eax
movw array(%ebx, %eax, 4), %cx
movb $4, %fs:(%eax)
</code>
其中下面这些省略了浮点数及 IA-32 如 SSE FPU 等特殊的指令集部分, 我觉得重要的是学习
linux 汇编的语法及编译原理和程序控制流程, 具体的指令细节就不那么重要了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LINUX汇编]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/08/27/assembly-base-2/"/>
    <updated>2011-08-27T22:39:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/08/27/assembly-base-2</id>
    <content type="html"><![CDATA[<h3>一, IA-32 硬件特性</h3>

<h4>寄存器:</h4>

<h5>1, 通用寄存器, 用于存放正在处理的数据</h5>

<pre><code>EAX 用于操作数和结果数的累加器
EBX 指向数据内存断中的数据的指针
ECX 字符串和循环操作的计数器
EDX IO指针
EDI 用于字符串操作的目标的数据指针
ESI 用于字符串操作的源的数据指针
ESP 堆栈指针
EBP 堆栈数据指针
</code></pre>

<p>其中寄存器EAX, EBX, ECX, EDX又可以通过16位和8位寄存器名称引用
如EAX, AX 引用EAX低16位, AL 引用EAX低8位, AH 引用AL之后的高8位</p>

<h5>2, 段寄存器:</h5>

<p>IA-32平台允许使用3中内存模型: 平坦内存模式 分段内存模式 实地址模式</p>

<p>平坦内存: 把全部的系统内存表示为连续的地址空间， 通过线性地址的特定地址访问内存位置.</p>

<p>分段内存: 把系统内存划分为独立的段组, 通过位于寄存器中的指针进行引用. 每个段用于包含特定类型的数据。 一个段用于包含指令码, 另一个段包含数据元素, 第三个段包含数据堆栈。段中的内存位置是通过逻辑地址引用的, 逻辑地址是由段地址加上偏移量构成， 处理器把逻辑地址转换为相应的线性地址以便访问。
<code>
段寄存器：
CS 代码段
DS 数据段
SS 堆栈段
ES 附加段指针
FS 附加段指针
GS 附加段指针
</code>
每个段寄存器都是16位的， 包含指向内存特定段起始位置的指针，程序不能显示加载或改变CS寄存器, DS, ES, FS, GS都用于指向数据段, 通过4个独立的段, 程序可以分隔数据元素， 确保他们不会重叠， 程序必须加载带有段的正确指针值的数据段寄存器， 并且使用偏移值引用各个内存的位置。SS段寄存器用于指向堆栈段, 堆栈包含传递给函数和过程的数据值。</p>

<p>实地址: 如果实地址模式, 所有段寄存器都指向线性0地址， 并且都不会被程序改动，所有的指令码 数据元素 堆栈元素 都是通过他们的线性地址直接访问的。</p>

<h5>3， 指令指针寄存器</h5>

<p>是EIP寄存器, 它跟踪要执行程序的下一条指令代码, 应用程序不能修改指令指针本身，不能指定内存地址把它拖放EIP寄存器中，相反必须通过一般的跳转指令来改变预存取缓存的下一条指令。</p>

<p>在平坦内存模型中， 指令指针包含下一条指令码的线性地址, 在分段模型中指令指针包含逻辑地址指针， 通过CS寄存器的内存引用。</p>

<h5>4, 控制寄存器</h5>

<pre><code>CRO 控制操作模式 和 处理器当前状态的系统标志
CR1 当前没有使用
CR2 内存页面错误信息
CR3 内存页面目录信息
CR4 支持处理器特性和说明处理器特性能力的标志
</code></pre>

<p>不能直接访问控制寄存器, 但是能把控制寄存器中的值传递给通用寄存器，如果必须改动控制寄存器的标志， 可以改动通用寄存器的值， 然后把内容传递给控制寄存器。</p>

<h4>标志:</h4>

<p>IA-32使用单一的寄存器来包含一组状态控制和系统标志, EFLAGS寄存器包含32位标志信息</p>

<h5>1, 状态标志</h5>

<pre><code>标志 位 说明
CF 0 进位标志, 如果无符号数的数学操作产生最高有效位的进位或者借位, 此时值为1
PF 2 奇偶校验标志, 用于表明数学操作的结果寄存器中的是否包含错误数据
AF 4 辅助进位标志, 用于二进制编码的10进制(BCD)的数学操作中， 如果用于运算的
寄存器的第三位发生进位或借位， 该值为1
ZF 6 0标志, 如果操作为0， 则该值为1
SF 7 符号标志, 设置为结果的最高有效位, 这一位是符号位表明结果是正值还是负值
OF 11 溢出标志
</code></pre>

<h5>2, 控制标志</h5>

<p>当前只定义了一个控制标志DF即方向标志, 用于控制处理器处理字符串的方式
如果设置为1, 字符串指令自动递减内存地址以便到达字符串中的下一字节。
反之。</p>

<h5>3, 系统标志</h5>

<pre><code>标志 位 说明
TF 8 陷阱标志, 设置为1时启用单步模式, 在单步模式下处理器每次只执行一条命令。
IF 9 中断使能标志, 控制处理器如响应从外部源接收到的信号。
IOPL 12和13 IO特权级别标志, 表明当前正在运行任务的IO特权级别, 它定义IO地址空间的
特权访问级别, 该值必须小于或者等于访问I/O地址空间的级别; 否则任何访问
IO空间的请求都会被拒绝！
NT 14 嵌套任务标志控制当前运行的任务是否连接到前一个任务, 它用于连接被中断
和被调用的任务.
RF 16 恢复标志用于控制在调试模式中如何响应异常。
VM 17 虚拟8086模式, 表明处理器在虚拟8086模式中而不是保护模式或者实模式。
AC 18 对准检查标志, 用于启用内存引用的对准检查
VIF 19 虚拟中断标志, 当处理器在虚拟模式中操作时, 该标志起IF标志的作用.
VIP 20 虚拟中断挂起标志, 在虚拟模式操作时用于表示一个中断正在被挂起。
ID 21 表示CPU是否支持cpuid指令, 如果处理器能够设置或者清零这个标志, 表示
处理器支持该指令。
</code></pre>

<h3>二，GNU汇编工具系列</h3>

<h4>1, 二进制工具系列</h4>

<pre><code>addr2line 把地址转换成文件名或者行号
ar 创建 修改或者展开文件存档
as 把汇编语言代码汇编成目标代码
c++filt 还原c++符号的过滤器
gprof 显示程序简档信息的程序
ld 把目标代码文件转换成可执行文件的转换器
nm 列出目标文件中的符号
objcopy 复制或翻译目标文件
objdump 显示来自目标文件的信息
ranlib 生成存档文件内容的索引
readelf 按照elf格式显示目标文件信息
size 列出目标文件或者存档文件的段长度
strings 显示目标文件中可打印字符串
strip 丢弃符号
windres 编译Microsoft Windows资源文件
</code></pre>

<h4>2, GNU编译器</h4>

<p>gcc</p>

<h4>3, GNU调试程序</h4>

<p>gdb</p>

<h3>三, GNU汇编语言结构</h3>

<p>主要包括三个常用的段：
data 数据段 声明带有初始值的元素<br/>
bss 数据段 声明使用0或者null初始化的元素<br/>
text 正文段 包含的指令, 每个汇编程序都必须包含此段</p>

<p>使用.section 指令定义段, 如:
<code>
.section .data
.section .bss
.section .text
</code></p>

<h4>起始点:</h4>

<p>gnu汇编器使用<em>start标签表示默认的起始点, 此外如果想要汇编内部的标签能够被外部程序访问,
需要使用.globl 指令, 如:.globl </em>start</p>

<p>使用通用库函数时可以使用:<br/>
ld -dynamic-linker /lib/ld-linux.so.2</p>

<h3>四, 数据传递</h3>

<h4>1, 数据段</h4>

<p>使用.data声明数据段, 这个段中声明的任何数据元素都保留在内存中并可以被汇编程序的指令读取,
此外还可以使用.rodata声明只读的数据段, 在声明一个数据元素时, 需要使用标签和命令:</p>

<p>标签:用做引用数据元素所使用的标记， 它和c语言的变量很相似, 它对于处理器是没有意义的, 它
只是用做汇编器试图访问内存位置时用做引用指针的一个位置。</p>

<p>指令:这个名字指示汇编器为通过标签引用的数据元素保留特定数量的内存， 声明命令之后必须给出
一个或多个默认值。</p>

<p>声明指令:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.ascii 文本字符串
</span><span class='line'>.asciz 以空字符结尾的字符串
</span><span class='line'>.byte 字节值
</span><span class='line'>.double 双精度浮点值
</span><span class='line'>.float 单精度浮点值
</span><span class='line'>.int 32位整数
</span><span class='line'>.long 32位整数, 和int相同
</span><span class='line'>.octa 16字节整数
</span><span class='line'>.quad 8字节整数
</span><span class='line'>.short 16位整数
</span><span class='line'>.single 单精度浮点数(和float相同)&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;例子:
</span><span class='line'>output:
</span><span class='line'>.ascii &ldquo;hello world.&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;pi:
</span><span class='line'>.float 2.14&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;声明可以在一行中定义多个值, 如:
</span><span class='line'>ages:
</span><span class='line'>.int 20, 10, 30, 40</span></code></pre></td></tr></table></div></figure></p>

<p>定义静态符号:<br/>
使用.equ命令把常量值定义为可以在文本段中使用的符号，如:<br/>
<code>
.section .data
.equ LINUX_SYS_CALL, 0x80
.section .text
movl $LINUX_SYS_CALL, %eax
</code></p>

<h4>2, bss段</h4>

<p>和data段不同, 无需声明特定的数据类型, 只需声明为所需目的保留的原始内存部分即可。
GNU汇编器使用以下两个命令声明内存区域:
<code>
.comm 声明为未初始化的通用内存区域
.lcomm 声明为未初始化的本地内存区域
</code>
两种声明很相似， 但.lcomm是为不会从本地汇编代码之外进行访问的数据保留的， 格式为:
<code>
.comm/.lcomm symbol, length
</code>
例子:
<code>
.section .bss
.lcomm buffer, 1000
</code>
该语句把1000字节的内存地址赋予标签buffer, 在声明本地通用内存区域的程序之外的函数是
不能访问他们的.(不能在.globl命令中使用他们)</p>

<p>在bss段声明的好处是, 数据不包含在可执行文件中。在数据段中定义数据时, 它必须被包含在
可执行程序中, 因为必须使用特定值初始化它。 因为不使用数据初始化bss段中声明的数据区域,
所以内存区域被保留在运行时使用, 并且不必包含在最终的程序中</p>

<h4>3， 传送数据</h4>

<p>move 指令: 格式 movex 源操作数, 目的操作数。 其中x为要传送数据的长度, 取值有:
l 用于32位的长字节<br/>
w 用于16位的字<br/>
b 用于8位的字节值</p>

<p>立即数前面要加一个$符号, 寄存器前面要加%符号。<br/>
8个通用的寄存器是用于保存数据的最常用的寄存器, 这些寄存器的内容可以传递
给其他的任何可用的寄存器。 和通用寄存器不同, 专用寄存器(控制, 调试, 段)
的内容只能传送给通用寄存器, 或者接收从通用寄存器传过来的内容。</p>

<p>在对标签进行引用时:
例：
<code>
.section .data
value:
.int 100
_start:
movl value, %eax
movl $value, %eax
movl %ebx, (%edi)
movl %ebx, 4(%edi)
</code>
其中:<br/>
movl value, %eax 只是把标签value当前引用的内存值传递给eax<br/>
movl $value, %eax 把标签value当前引用的内存地址指针传递给eax<br/>
movl %ebx, (%edi) 如果edi外面没有括号那么这个指令只是把ebx中的<br/>
值加载到edi中, 如果有了括号就表示把ebx中的内容<br/>
传送给edi中包含的内存位置。<br/>
movl %ebx, 4（%edi) 表示把edi中的值放在edi指向的位置之后的4字节内存位置中<br/>
movl %ebx, -4(%edi) 表示把edi中的值放在edi指向的位置之前的4字节内存位置中</p>

<p>cmove 指令(条件转移): cmovex 源操作数, 目的操作数. x的取值为:<br/>
无符号数:<br/>
<code>
a/nbe 大于/不小于或者等于
ae/nb 大于或者等于/不小于
nc 无进位
b/nae 小于/不大于等于
c 进位
be/na 小于或等于/不大于
e/z 等于/零
ne/nz 不等于/不为零
p/pe 奇偶校验/偶校验
np/po 非奇偶校验/奇校验
</code>
有符号数:
<code>
ge/nl 大于或者等于/不小于
l/nge 小于/不大于或者等于
le/ng 小于或者等于/不大于
o 溢出
no 未溢出
s 带符号（负)
ns 无符号(非负)
</code>
交换数据: xchg 在两个寄存器之间或者寄存器和内存间交换值。如:<br/>
xchg 操作数, 操作数, 要求两个操作数必须长度相同且不能同时都是内存位置<br/>
其中寄存器可以是32，16，8位的</p>

<p>bswap 反转一个32位寄存器的字节顺序<br/>
如: bswap %ebx</p>

<p>xadd 交换两个值 并把两个值只和存储在目标操作数中<br/>
如: xadd 源操作数,目标操作数<br/>
其中源操作数必须是寄存器, 目标操作数可以是内存位置也可以是寄存器<br/>
其中寄存器可以是32，16，8位的</p>

<p>cmpxchg<br/>
cmpxchg source, destination<br/>
其中source必须是寄存器, destination可以是内存或者寄存器, 用来比较
两者的值, 如果相等，就把源操作数的值加载到目标操作数中, 如果不等就把
目标操作数加载到源操作数中，其中寄存器可以是32，16，8位的, 其中源操作
数是EAX,AX或者AL寄存器中的值</p>

<p>cmpxchg8b 同cmpxchg， 但是它处理8字节值， 同时它只有一个操作数<br/>
cmpxchg8b destination<br/>
其中destination引用一个内存位置, 其中的8字节值会与EDX和EAX寄存器中
包含的值(EDX高位寄存器, EAX低位寄存器)进行比较, 如果目标值和EDX:EAX
对中的值相等, 就把EDX:EAX对中的64位值传递给内存位置, 如果不匹配就把
内存地址中的值加载到EDX:EAX对中</p>

<h4>4, 堆栈</h4>

<p>ESP 寄存器保存了当前堆栈的起始位置, 当一个数据压入栈时， 它就会自动递减,反之其自动递增<br/>
压入堆栈操作:<br/>
<code>
pushx source, x取值为:
l 32位长字
w 16位字
</code>
*出堆栈操作:<br/>
<code>
popx source
</code>
其中source必须是16或32位寄存器或者内存位置, 当pop最后一个元素时ESP值应该和以前的相等</p>

<h4>5，压入和*出所有寄存器</h4>

<pre><code>pusha/popa 压入或者*出所有16位通用寄存器
pushad/popad 压入或者*出所有32位通用寄存器
pushf/popf 压入或者*出EFLAGS寄存器的低16位
pushfd/popfd 压入或者*出EFLAGS寄存器的全部32位
</code></pre>

<h4>6，数据地址对齐</h4>

<p>gas 汇编器支持.align 命令， 它用于在特定的内存边界对准定义的数据元素， 在数据段中.align命令紧贴在数据定义的前面</p>

<h3>五，控制流程</h3>

<h4>无条件跳转:</h4>

<h5>1, 跳转</h5>

<p>jmp location 其中location为要跳转到的内存地址, 在汇编中为定义的标签</p>

<h5>2，调用</h5>

<p>调用指令分为两个部分:<br/>
1, 调用call address 跳转到指定位置<br/>
2, 返回指令ret, 它没有参数紧跟在call指令后面的位置</p>

<p>执行call指令时，它把EIP的值放到堆栈中， 然后修改EIP以指向被调用的函数地址， 当被调用函数完成后， 它从堆栈获取过去的EIP的值， 并把控制权返还给原始程序。</p>

<h5>3，中断</h5>

<p>由硬件设备生成中断。 程序生成软件中断
当一个程序产生中断调用时, 发出调用的程序暂停, 被调用的程序接替它运行, 指令指针被转移到被调用的函数地址， 当调用完成时使用中断返回指令可以返回调原始程序。</p>

<h4>条件跳转：</h4>

<p>条件跳转按照EFLAGS中的值来判断是否该跳转, 格式为:
<code>
jxx address, 其中xx是1－3个字符的条件代码, 取值如下:
a 大于时跳转
ae 大于等于
b 小于
be 小于等于
c 进位
cxz 如果CX寄存器为0
ecxz 如果ECS寄存器为0
e 相等
na 不大于
nae 不大于或者等于
nb 不小于
nbe 不小于或等于
nc 无进位
ne 不等于
g 大于(有符号)
ge 大于等于(有符号)
l 小于(有符号)
le 小于等于(有符号)
ng 不大于(有符号)
nge 不大于等于(有符号)
nl 不小于
nle 不小于等于
no 不溢出
np 不奇偶校验
ns 无符号
nz 非零
o 溢出
p 奇偶校验
pe 如果偶校验
po 如果奇校验
s 如果带符号
z 如果为零
</code></p>

<p>条件跳转不支持分段内存模型下的远跳转， 如果在该模式下进行程序设计必须使用程序逻辑确定条件是否存在, 然后实现无条件跳转, 跳转前必须设置EFLAGS寄存器</p>

<p>比较:<br/>
cmp operend1, operend2</p>

<p>进位标志修改指令:<br/>
CLC 清空进位标志(设置为0)<br/>
CMC 对进位标志求反(把它改变为相反的值)<br/>
STC 设置进位标志(设置为1)</p>

<p>循环:<br/>
loop 循环直到ECX寄存器为0<br/>
loope/loopz 循环直到ecx寄存器为0 或者没有设置ZF标志<br/>
loopne/loopnz 循环直到ecx为0或者设置了ZF标志</p>

<p>指令格式为: loopxx address 注意循环指令只支持8位偏移地址</p>

<h3>六，数字</h3>

<p>IA-32平台中存储超过一字节的数都被存储为小尾数的形式但是把数字传递给寄存器时, 寄存器里面保存是按照大尾数的形式存储</p>

<p>把无符号数转换成位数更大的值时， 必须确保所有的高位部分都被设置为零</p>

<p>把有符号数转换成位数更大的数时:<br/>
intel 提供了movsx指令它允许扩展带符号数并保留符号, 它与movzx相似, 但是它假设要传送的字节是带符号数形式</p>

<h4>浮点数:</h4>

<p>fld 指令用于把浮点数字传送入和传送出FPU寄存器, 格式:<br/>
<code>
fld source
</code>
其中source可以为32 64或者80位整数值</p>

<p>IA-32使用FLD指令用于把存储在内存中的单精度和双精度浮点值FPU寄存器堆栈中， 为了区分这两种长度GNU汇编器使用FLDS加载单精度浮点数, FLDL加载双精度浮点数</p>

<p>类似FST用于获取FPU寄存器堆栈中顶部的值, 并且把这个值放到内存位置中, 对于单精度使用FSTS, 对于双精度使用FSTL</p>

<h3>七，基本数学运算</h3>

<h5>1, 加法</h5>

<p>ADD source, destination 把两个整数相加<br/>
其中source可以是立即数内存或者寄存器, destination可以是内存或者寄存器, 但是两者不能同时都是内存位置</p>

<p>ADC 和ADD相似进行加法运算, 但是它把前一个ADD指令的产生进位标志的值包含在其中, 在处理位数大于32(如64)位的整数时, 该指令非常有用</p>

<h5>2, 减法</h5>

<p>SUB source, destination 把两个整数相减
NEG 它生成值的补码<br/>
SBB 指令, 和加法操作一样, 可以使用进位情况帮助执行大的无符号数值的减法运算. SBB在多字节减法操作中利用<br/>
进位和溢出标志实现跨数据边界的的借位特性</p>

<h5>3，递增和递减</h5>

<p>dec destination 递减<br/>
inc destination 递增<br/>
其中dec和inc指令都不会影响进位标志, 所以递增或递减计数器的值都不会影响程序中涉及进位标志的其他任何运算</p>

<h5>4, 乘法</h5>

<p>mul source 进行无符号数相乘
它使用隐含的目标操作数, 目标位置总是使用eax的某种形式, 这取决与源操作数的长度， 因此根据源操作数的长度,
目标操作数必须放在AL, AX, EAX中。 此外由于乘法可能产生很大的值, 目标位置必须是源操作数的两倍位置, 源为
8时, 应该是16, 源为16时, 应该为32, 但是当源为16位时intel为了向下兼容, 目标操作数不是存放在eax中, 而
是分别存放在DX:AX中, 结果高位存储在DX中, 地位存储在AX中。对于32位的源, 目标操作数存储在EDX:EAX中, 其中
EDX存储的是高32位, EAX存储的是低32位</p>

<p>imul source 进行有符号数乘法运算, 其中的目标操作数和mul的一样</p>

<p>imul source, destination 也可以执行有符号乘法运算, 但是此时可以把目标放在指定的位置, 使用这种格式的缺陷
在与乘法的操作结果被限制为单一目标寄存器的长度.</p>

<p>imul multiplier, source, destination
其中multiplier是一个立即数, 这种方式允许一个值与给定的源操作数进行快速的乘法运算, 然后把结果存储在通用
寄存器中</p>

<h5>5, 除法</h5>

<p>div divisor 执行无符号数除法运算
除数的最大值取决与被除数的长度, 对于16位被除数 ,除数只能为8位, 32或64位同上
被除数 被除数长度 商 余数<br/>
AX 16位 AL AH<br/>
DX:AX 32位 AX DX<br/>
EDX:EAX 64位 EAX EDX</p>

<p>idiv divisor 执行有符号数的除法运算, 方式和div一样</p>

<h5>6, 移位</h5>

<p>左移位:<br/>
sal 向左移位<br/>
sal destination 把destination向左移动1位<br/>
sal %cl, destination 把destination的值向左移动CL寄存器中指定的位数<br/>
sal shifter, destination 把destination的值向左移动shifter值指定的位数<br/>
向左移位可以对带符号数和无符号数执行向左移位的操作, 移位造成的空位用零填充, 移位造成的超过数据长度的任何位
都被存放在进位标志中, 然后在下一次移位操作中被丢弃</p>

<p>右移位:<br/>
shr向右移位<br/>
sar向右移位<br/>
SHR指令清空移位造成的空位, 所以它只能对无符号数进行移位操作<br/>
SAR指令根据整数的符号位, 要么清空, 要么设置移位造成的空位, 对于负数, 空位被设置为1</p>

<p>循环移位:<br/>
和移位指令类似, 只不过溢出的位被存放回值的另一端, 而不是丢弃<br/>
ROL 向左循环移位<br/>
ROR 向右循环移位<br/>
RCL 向左循环移位, 并且包含进位标志<br/>
RCR 向右循环移位, 并且包含进位标志</p>

<h5>7, 逻辑运算</h5>

<p>AND OR XOR<br/>
这些指令使用相同的格式:<br/>
and source, destination<br/>
其中source可以是8位 16 位或者32位的立即值 寄存器或内存中的值, destination可以是8位 16 位或者
32位寄存器或内存中的值, 不能同时使用内存值作为源和目标。 布尔逻辑功能对源和目标执行按位操作。
也就是说使用指定的逻辑功能按照顺序对数据的元素的每个位进行单独比较。</p>

<p>NOT指令使用单一操作数, 它即是源值也是目标结果的位置
清空寄存器的最高效方式是使用OR指令对寄存器和它本身进行异或操作.当和本身进行XOR操作时, 每个设置为
1的位就变为0， 每个设置为0的位也变位0。</p>

<p>位测试可以使用以上的逻辑运算指令, 但这些指令会修改destination的值, 因此intel提供了test指令, 它不
会修改目标值而是设置相应的标志</p>

<h3>八，字符串处理</h3>

<h5>1, 传送字符串</h5>

<pre><code>movs 有三种格式
movsb 传送单一字节
movsw 传送一个字
movsl 传送双字
</code></pre>

<p>movs指令使用隐含的源和目的操作数， 隐含的源操作数是ESI， 隐含的目的操作数是EDI， 有两种方式加载内存地址到
ESI和EDI， 第一种是使用标签间接寻址 movl $output, %ESI, 第二种是使用lea指令, lea指令加载对象的地址到指定
的目的操作数如lea output, %esi, 每次执行movs指令后， 数据传送后ESI和EDI寄存器会自动改变，为另一次传送做
准备, ESI和EDI可能随着标志DF的不同自动递增或者自动递减， 如果DF标志为0则movs指令后ESI和EDI会递增, 反之会
递减， 为了设置DF标志, 可以使用一下指令:<br/>
CLD 将DF标志清零<br/>
STD 设置DF标志</p>

<h5>2，rep前缀</h5>

<p>REP 指令的特殊之处在与它不执行什么操作, 这条指令用于按照特定次数重复执行字符串指令, 有ECX寄存器控制,
但不需要额外的loop指令, 如rep movsl<br/>
rep的其他格式:<br/>
repe 等于时重复<br/>
repne 不等于时重复<br/>
repnz 不为零时重复<br/>
repz 为零时重复</p>

<h5>3, 存储和加载字符串</h5>

<p>LODS 加载字符串, ESI为源, 当一次执行完lods时会递增或递减ESI寄存器， 然后把字符串值存放到EAX中</p>

<p>STOS 使用lods把字符串值加载到EAX后， 可以使用它把EAX中的值存储到内存中去:
stos使用EDI作为目的操作数, 执行stos指令后, 会根据DF的值自动递增或者递减EDI中的值</p>

<h5>4, 比较字符串</h5>

<p>cmps 和其他的操作字符串的指令一样, 隐含的源和目标操作数都为ESI和EDI, 每次执行时都会根据DF的值把
ESI和EDI递增或者递减, cmps指令从目标字符串中减去源字符串, 执行后会设置EFLAGS寄存器的状态.</p>

<h5>5，扫描字符串</h5>

<p>scas 把EDI作为目标, 它把EDI中的字符串和EAX中的字符串进行比较 ,然后根据DF的值递增或者递减EDI</p>

<h3>九，使用函数</h3>

<p>GNU汇编语言定义函数的语法:<br/>
.type 标签(也就是函数名), @function<br/>
ret 返回到调用处</p>

<h3>十，linux系统调用</h3>

<p>linux系统调用的中断向量为0x80</p>

<p>1, 系统调用标识存放在%eax中<br/>
2, 系统调用输入值:
<code>
EBX 第一个参数
ECX 第二个参数
EDX 第三个参数
ESI 第四个参数
EDI 第五个参数
</code>
需要输入超过6个输入参数的系统调用, EBX指针用于保存指向输入参数内存位置的指针, 输入参数按照连续的的顺序
存储, 系统调用的返回值存放在EAX中</p>

<h3>十一，汇编语言的高级功能</h3>

<h4>1，gnu内联汇编的语法:</h4>

<p><code>asm</code>或<code>__asm__</code>(&ldquo;汇编代码&rdquo;);
指令必须包含在引号里
如果包含的指令超过一行 必须使用新行分隔符分隔</p>

<p>使用c全局变量, 不能在内联汇编中使用局部变量, 注意在汇编语言代码中值被用做内存位置, 而不是立即数值</p>

<p>如果不希望优化内联汇编, 则可以volatile修饰符如:<code>__asm__ volatile</code>（"code");</p>

<h4>2，GCC内联汇编的扩展语法</h4>

<p><code>__asm__("assembly code":output locations:input operands:changed registers);</code>
第一部分是汇编代码
第二部分是输出位置, 包含内联汇编代码的输出值的寄存器和内存位置列表
第三部分是输入操作数，包含内联汇编代码输入值的寄存器和内存位置的列表
第四部分是改动的寄存器， 内联汇编改变的任何其他寄存器的列表
这几个部分可以不全有, 但是没有的还必须使用:分隔</p>

<h5>1, 指定输入值和输出值， 输入值和输出值的列表格式为:</h5>

<p>&ldquo;constraint&rdquo;(variable), 其中variable是程序中声明的c变量, 在扩展asm格式中， 局部和全局变量都可以使用,
使用constrant（约束)定义把变量存放到哪(输入)或从哪里传送变量(输出)
约束使用单一的字符, 如下:
<code>
约束 描述
a 使用%eax, %ax, %al寄存器
b 使用%ebx, %bx, %bl寄存器
c 使用%ecx, %cx, %cl寄存器
d 使用%edx, %dx, %dl寄存器
S 使用%esi, %si寄存器
D 使用%edi, %di寄存器
r 使用任何可用的通用寄存器
q 使用%eax, %ebx, %ecx,%edx之一
A 对于64位值使用%eax, %edx寄存器
f 使用浮点寄存器
t 使用第一个(顶部)的浮点寄存器
u 使用第二个浮点寄存器
m 使用变量的内存位置
o 使用偏移内存位置
V 只使用直接内存位置
i 使用立即整数值
n 使用值已知的立即整数值
g 使用任何可用的寄存器和内存位置
</code></p>

<p>除了这些约束之外, 输出值还包含一个约束修饰符:
<code>
输出修饰符 描述
+ 可以读取和写入操作数
= 只能写入操作数
% 如果有必要操作数可以和下一个操作数切换
&amp; 在内联函数完成之前, 可以删除和重新使用操作数
</code>
如:<br/>
<code>__asm__("assembly code": "=a"(result):"d"(data1),"c"(data2));</code>
把c变量data1存放在edx寄存器中, 把c变量data2存放到ecx寄存器中, 内联汇编的结果
将存放在eax寄存器中, 然后传送给变量result</p>

<p>在扩展的asm语句块中如果要使用寄存器必须使用两个百分号符号</p>

<p>不一定总要在内联汇编代码中指定输出值, 一些汇编指令假定输入值包含输出值, 如movs指令</p>

<h5>其他扩展内联汇编知识:</h5>

<h6>1, 使用占位符</h6>

<p>输入值存放在内联汇编段中声明的特定寄存器中, 并且在汇编指令中专门使用这些寄存器.
虽然这种方式能够很好的处理只有几个输入值的情况, 但对于需要很多输入值的情况, 这
中方式显的有点繁琐. 为了帮助解决这个问题, 扩展asm格式提供了占位符, 可以在内联
汇编代码中使用它引用输入和输出值.</p>

<p>占位符是前面加上百分号的数字, 按照内联汇编中列出的每个输入和输出值在列表中的位置,
每个值被赋予从0开始的地方. 然后就可以在汇编代码中引用占位符来表示值。</p>

<p>如果内联汇编代码中的输入和输出值共享程序中相同的c变量, 则可以指定使用占位符作为
约束值, 如:
<code>
    __asm__("imull %1, %0"
    : "=r"(data2)
    : "r"(data1), "0"(data2));
</code>
如输入输出值**享相同的变量data2， 而在输入变量中则可以使用标记0作为输入参数的约束</p>

<h6>2, 替换占位符</h6>

<p>如果处理很多输入和输出值, 数字型的占位符很快就会变的很混乱, 为了使条理清晰 ,GNU汇编
器(从版本3.1开始)允许声明替换的名称作为占位符.替换的名称在声明输入值和输出值的段中
定义, 格式如下:
<code>
    %[name]"constraint"(variable)
    定义的值name成为内联汇编代码中变量的新的占位符号标识, 如下面的例子:
    __asm__("imull %[value1], %[value2]"
    : [value2] "=r"(data2)
    : [value1] "r"(data1), "0"(data2));
</code></p>

<h6>3, 改动寄存器列表</h6>

<p>编译器假设输入值和输出值使用的寄存器会被改动, 并且相应的作出处理。程序员不需要在改动的
寄存器列表中包含这些值, 如果这样做了, 就会产生错误消息. 注意改动的寄存器列表中的寄存器
使用完整的寄存器名称, 而不像输入和输出寄存器定义的那样仅仅是单一字母。 在寄存器名称前面
使用百分号符号是可选的。</p>

<p>改动寄存器列表的正确使用方法是, 如果内联汇编代码使用了没有被初始化地声明为输入或者输出
值的其他任何寄存器 , 则要通知编译器。编译器必须知道这些寄存器, 以避免使用他们。如:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main(void) {
</span><span class='line'>int data1 = 10;
</span><span class='line'>int result = 20;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;__asm__("movl %1, %%eax\n\t"
</span><span class='line'>"addl %%eax, %0"
</span><span class='line'>: "=r"(result)
</span><span class='line'>: "r"(data1), "0"(result)
</span><span class='line'>: "%eax");
</span><span class='line'>printf("The result is %d\n", result);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;###### 4, 使用内存位置
</span><span class='line'>虽然在内联汇编代码中使用寄存器比较快, 但是也可以直接使用c变量的内存位置。 约束m用于引用输入值
</span><span class='line'>和输出值中的内存位置。 记住, 对于要求使用寄存器的汇编指令, 仍然必须使用寄存器, 所以不得不定义
</span><span class='line'>保存数据的中间寄存器。如:
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int main(void) {
</span><span class='line'>int dividentd = 20;
</span><span class='line'>int divisor = 5;
</span><span class='line'>int result;
</span><span class='line'>
</span><span class='line'>__asm__("divb %2\n\t"
</span><span class='line'>"movl %%eax, %0"
</span><span class='line'>: "=m"(result)
</span><span class='line'>: "a"(dividend), "m"(divisor));
</span><span class='line'>printf("The result is %d\n", result);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;###### 5, 处理跳转
</span><span class='line'>内联汇编语言代码也可以包含定义其中位置的标签。 可以实现一般的汇编条件分支和无条件分支， 如：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int main(void) {
</span><span class='line'>int a = 10;
</span><span class='line'>int b = 20;
</span><span class='line'>int result;
</span><span class='line'>
</span><span class='line'>__asm__("cmp %1, %2\n\t"
</span><span class='line'>"jge greater\n\t"
</span><span class='line'>"movl %1, %0\n\t"
</span><span class='line'>"jmp end\n"
</span><span class='line'>"greater:\n\t"
</span><span class='line'>"movl %2, %0\n"
</span><span class='line'>"end:"
</span><span class='line'>:"=r"(result)
</span><span class='line'>:"r"(a), "r"(b));
</span><span class='line'>printf("The larger value is %d\n", result);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```
</span><span class='line'>在内联汇编代码中使用标签时有两个限制。 第一个限制是只能跳转到相同的asm段内的标签，
</span><span class='line'>不能从－个asm段跳转到另一个asm段中的标签。第二个限制更加复杂一点。 以上程序使用
</span><span class='line'>标签greater和end。 但是, 这样有个潜在的问题, 查看汇编后的代码清单， 可以发现内联
</span><span class='line'>汇编标签也被编码到了最终汇编后的代码中。 这意味着如果在c代码中还有另一个asm段, 就
</span><span class='line'>不能再次使用相同的标签, 否则会因为标签重复使用而导致错误消息。还有如果试图整合使用
</span><span class='line'>c关键字(比如函数名称或者全局变量)的标签也会导致错误。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[Linux 汇编基础]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2011/08/27/assembly-base/"/&gt;
</span><span class='line'>&lt;updated&gt;2011-08-27T16:07:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2011/08/27/assembly-base&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;绝顶好书&lt;a href="/download/assembly/Professional_Assembly_Language.pdf"&gt;Professional_Assembly_Language&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;一、简介&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;作为最基本的编程语言之一，汇编语言虽然应用的范围不算很广，但重要性却勿庸置疑，因为它能够完成许多其它语言所无法完成的功能。就拿 Linux 内核来讲，虽然绝大部分代码是用 C 语言编写的，但仍然不可避免地在某些关键地方使用了汇编代码，其中主要是在 Linux 的启动部分。由于这部分代码与硬件的关系非常密切，即使是 C 语言也会有些力不从心，而汇编语言则能够很好扬长避短，最大限度地发挥硬件的性能。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;大多数情况下 Linux 程序员不需要使用汇编语言，因为即便是硬件驱动这样的底层程序在 Linux 操作系统中也可以用完全用 C 语言来实现，再加上 GCC 这一优秀的编译器目前已经能够对最终生成的代码进行很好的优化，的确有足够的理由让我们可以暂时将汇编语言抛在一边了。但实现情况是 Linux 程序员有时还是需要使用汇编，或者不得不使用汇编，理由很简单：精简、高效和 libc 无关性。假设要移植 Linux 到某一特定的嵌入式硬件环境下，首先必然面临如何减少系统大小、提高执行效率等问题，此时或许只有汇编语言能帮上忙了。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;汇编语言直接同计算机的底层软件甚至硬件进行交互，它具有如下一些优点：
</span><span class='line'>能够直接访问与硬件相关的存储器或 I/O 端口； 能够不受编译器的限制，对生成的二进制代码进行完全的控制； 能够对关键代码进行更准确的控制，避免因线程共同访问或者硬件设备共享引起的死锁； 能够根据特定的应用对代码做最佳的优化，提高运行速度； 能够最大限度地发挥硬件的功能。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;同时还应该认识到，汇编语言是一种层次非常低的语言，它仅仅高于直接手工编写二进制的机器指令码，因此不可避免地存在一些缺点：
</span><span class='line'>编写的代码非常难懂，不好维护； 很容易产生 bug，难于调试； 只能针对特定的体系结构和处理器进行优化； 开发效率很低，时间长且单调。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Linux 下用汇编语言编写的代码具有两种不同的形式。第一种是完全的汇编代码，指的是整个程序全部用汇编语言编写。尽管是完全的汇编代码，Linux 平台下的汇编工具也吸收了 C 语言的长处，使得程序员可以使用 #include、#ifdef 等预处理指令，并能够通过宏定义来简化代码。第二种是内嵌的汇编代码，指的是可以嵌入到C语言程序中的汇编代码片段。虽然 ANSI 的 C 语言标准中没有关于内嵌汇编代码的相应规定，但各种实际使用的 C 编译器都做了这方面的扩充，这其中当然就包括 Linux 平台下的 GCC。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;!--more--&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;二、Linux 汇编语法格式&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;绝大多数 Linux 程序员以前只接触过DOS/Windows 下的汇编语言，这些汇编代码都是 Intel 风格的。但在 Unix 和 Linux 系统中，更多采用的还是 AT&amp;T 格式，两者在语法格式上有着很大的不同：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在 AT&amp;T 汇编格式中，寄存器名要加上 &lsquo;%&rsquo; 作为前缀；而在 Intel 汇编格式中，寄存器名不需要加前缀。例如：&lt;br/&gt;
</span><span class='line'>AT&amp;T 格式 Intel 格式&lt;br/&gt;
</span><span class='line'>pushl %eax push eax&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在 AT&amp;T 汇编格式中，用 &lsquo;$&rsquo; 前缀表示一个立即操作数；而在 Intel 汇编格式中，立即数的表示不用带任何前缀。例如：&lt;br/&gt;
</span><span class='line'>AT&amp;T 格式 Intel 格式&lt;br/&gt;
</span><span class='line'>pushl $1 push 1&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;AT&amp;T 和 Intel 格式中的源操作数和目标操作数的位置正好相反。在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&amp;T 汇编格式中，目标操作数在源操作数的右边。例如：&lt;br/&gt;
</span><span class='line'>AT&amp;T 格式 Intel 格式&lt;br/&gt;
</span><span class='line'>addl $1, %eax add eax, 1&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在 AT&amp;T 汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀'b'、'w'、'l'分别表示操作数为字节（byte，8 比特）、字（word，16 比特）和长字（long，32比特）；而在 Intel 汇编格式中，操作数的字长是用 &ldquo;byte ptr&rdquo; 和 &ldquo;word ptr&rdquo; 等前缀来表示的。例如：
</span><span class='line'>AT&amp;T 格式Intel 格式movb val, %almov al, byte ptr val在 AT&amp;T 汇编格式中，绝对转移和调用指令（jump/call）的操作数前要加上'*&lsquo;作为前缀，而在 Intel 格式中则不需要。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;远程转移指令和远程子调用指令的操作码，在 AT&amp;T 汇编格式中为 &ldquo;ljump&rdquo; 和 &ldquo;lcall"，而在 Intel 汇编格式中则为 "jmp far&rdquo; 和 &ldquo;call far"，即：
</span><span class='line'>AT&amp;T 格式Intel 格式ljump $section, $offsetjmp far section:offsetlcall $section, $offsetcall far section:offset&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;与之相应的远程返回指令则为：&lt;br/&gt;
</span><span class='line'>AT&amp;T 格式 Intel 格式&lt;br/&gt;
</span><span class='line'>lret $stack_adjust  ret far stack_adjust&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在 AT&amp;T 汇编格式中，内存操作数的寻址方式是&lt;br/&gt;
</span><span class='line'>section:disp(base, index, scale)&lt;br/&gt;
</span><span class='line'>而在 Intel 汇编格式中，内存操作数的寻址方式为：&lt;br/&gt;
</span><span class='line'>section:[base + index*scale + disp]&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;由于 Linux 工作在保护模式下，用的是 32 位线性地址，所以在计算地址时不用考虑段基址和偏移量，而是采用如下的地址计算方法：&lt;br/&gt;
</span><span class='line'>disp + base + index * scale&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;下面是一些内存操作数的例子：&lt;br/&gt;
</span><span class='line'>AT&amp;T 格式Intel 格式
</span><span class='line'>&lt;code&gt;
</span><span class='line'>movl -4(%ebp), %eax  mov eax, [ebp - 4]
</span><span class='line'>movl array(, %eax, 4), %eax  mov eax, [eax*4 + array]
</span><span class='line'>movw array(%ebx, %eax, 4), %cx  mov cx, [ebx + 4*eax + array]
</span><span class='line'>movb $4, %fs:(%eax)  mov fs:eax, 4
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;三、Hello World!&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;真不知道打破这个传统会带来什么样的后果，但既然所有程序设计语言的第一个例子都是在屏幕上打印一个字符串 &ldquo;Hello World!"，那我们也以这种方式来开始介绍 Linux 下的汇编语言程序设计。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在 Linux 操作系统中，你有很多办法可以实现在屏幕上显示一个字符串，但最简洁的方式是使用 Linux 内核提供的系统调用。使用这种方法最大的好处是可以直接和操作系统的内核进行通讯，不需要链接诸如 libc 这样的函数库，也不需要使用 ELF 解释器，因而代码尺寸小且执行速度快。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Linux 是一个运行在保护模式下的 32 位操作系统，采用 flat memory 模式，目前最常用到的是 ELF 格式的二进制代码。一个 ELF 格式的可执行程序通常划分为如下几个部分：.text、.data 和 .bss，其中 .text 是只读的代码区，.data 是可读可写的数据区，而 .bss 则是可读可写且没有初始化的数据区。代码区和数据区在 ELF 中统称为 section，根据实际需要你可以使用其它标准的 section，也可以添加自定义 section，但一个 ELF 可执行程序至少应该有一个 .text 部分。下面给出我们的第一个汇编程序，用的是 AT&amp;T 汇编语言格式：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;例1. AT&amp;T 格式&lt;br/&gt;</span></code></pre></td></tr></table></div></figure>
    hello.s
    .data # 数据段声明
    msg : .string &ldquo;Hello, world!\n&rdquo; # 要输出的字符串
    len = . - msg # 字串长度
    .text # 代码段声明
    .global _start # 指定入口函数</p>

<pre><code>_start: # 在屏幕上显示一个字符串
movl $len, %edx # 参数三：字符串长度
movl $msg, %ecx # 参数二：要显示的字符串
movl $1, %ebx # 参数一：文件描述符(stdout)
movl $4, %eax # 系统调用号(sys_write)
int $0x80 # 调用内核功能

# 退出程序
movl $0,%ebx # 参数一：退出代码
movl $1,%eax # 系统调用号(sys_exit)
int $0x80 # 调用内核功能
</code></pre>

<pre><code>初次接触到 AT&amp;T 格式的汇编代码时，很多程序员都认为太晦涩难懂了，没有关系，在 Linux 平台上你同样可以使用 Intel 格式来编写汇编程序：

例2. Intel 格式
; hello.asm
</code></pre>

<pre><code>section .data ; 数据段声明
msg db "Hello, world!", 0xA ; 要输出的字符串
len equ $ - msg ; 字串长度
section .text ; 代码段声明
global _start ; 指定入口函数
_start: ; 在屏幕上显示一个字符串
mov edx, len ; 参数三：字符串长度
mov ecx, msg ; 参数二：要显示的字符串
mov ebx, 1 ; 参数一：文件描述符(stdout)
mov eax, 4 ; 系统调用号(sys_write)
int 0x80 ; 调用内核功能
; 退出程序
mov ebx, 0 ; 参数一：退出代码
mov eax, 1 ; 系统调用号(sys_exit)
int 0x80 ; 调用内核功能
</code></pre>

<pre><code>上面两个汇编程序采用的语法虽然完全不同，但功能却都是调用 Linux 内核提供的 sys_write 来显示一个字符串，然后再调用 sys_exit 退出程序。在 Linux 内核源文件 include/asm-i386/unistd.h 中，可以找到所有系统调用的定义。

#### 四、Linux 汇编工具

Linux 平台下的汇编工具虽然种类很多，但同 DOS/Windows 一样，最基本的仍然是汇编器、连接器和调试器。

##### 1.汇编器

汇编器（assembler）的作用是将用汇编语言编写的源程序转换成二进制形式的目标代码。Linux 平台的标准汇编器是 GAS，它是 GCC 所依赖的后台汇编工具，通常包含在 binutils 软件包中。GAS 使用标准的 AT&amp;T 汇编语法，可以用来汇编用 AT&amp;T 格式编写的程序：

    $ as -o hello.o hello.s

Linux 平台上另一个经常用到的汇编器是 NASM，它提供了很好的宏指令功能，并能够支持相当多的目标代码格式，包括 bin、a.out、coff、elf、rdf 等。NASM 采用的是人工编写的语法分析器，因而执行速度要比 GAS 快很多，更重要的是它使用的是 Intel 汇编语法，可以用来编译用 Intel 语法格式编写的汇编程序：

    $ nasm -f elf hello.asm

##### 2.链接器

由汇编器产生的目标代码是不能直接在计算机上运行的，它必须经过链接器的处理才能生成可执行代码。链接器通常用来将多个目标代码连接成一个可执行代码，这样可以先将整个程序分成几个模块来单独开发，然后才将它们组合(链接)成一个应用程序。Linux 使用 ld 作为标准的链接程序，它同样也包含在 binutils 软件包中。汇编程序在成功通过 GAS 或 NASM 的编译并生成目标代码后，就可以使用 ld 将其链接成可执行程序了：

    $ ld -s -o hello hello.o

##### 3.调试器

有人说程序不是编出来而是调出来的，足见调试在软件开发中的重要作用，在用汇编语言编写程序时尤其如此。Linux 下调试汇编代码既可以用 GDB、DDD 这类通用的调试器，也可以使用专门用来调试汇编代码的 ALD(Assembly Language Debugger)。

从调试的角度来看，使用 GAS 的好处是可以在生成的目标代码中包含符号表(symbol table)，这样就可以使用 GDB 和 DDD 来进行源码级的调试了。要在生成的可执行程序中包含符号表，可以采用下面的方式进行编译和链接：

    $ as --gstabs -o hello.o hello.s
    $ ld -o hello hello.o

执行 as 命令时带上参数 --gstabs 可以告诉汇编器在生成的目标代码中加上符号表，同时需要注意的是，在用 ld 命令进行链接时不要加上 -s 参数，否则目标代码中的符号表在链接时将被删去。

在 GDB 和 DDD 中调试汇编代码和调试 C 语言代码是一样的，你可以通过设置断点来中断程序的运行，查看变量和寄存器的当前值，并可以对代码进行单步跟踪。

#### 五、系统调用

即便是最简单的汇编程序，也难免要用到诸如输入、输出以及退出等操作，而要进行这些操作则需要调用操作系统所提供的服务，也就是系统调用。除非你的程序只完成加减乘除等数学运算，否则将很难避免使用系统调用，事实上除了系统调用不同之外，各种操作系统的汇编编程往往都是很类似的。

在 Linux 平台下有两种方式来使用系统调用：利用封装后的 C 库（libc）或者通过汇编直接调用。其中通过汇编语言来直接调用系统调用，是最高效地使用 Linux 内核服务的方法，因为最终生成的程序不需要与任何库进行链接，而是直接和内核通信。

和 DOS 一样，Linux 下的系统调用也是通过中断（int 0x80）来实现的。在执行 int 80 指令时，寄存器 eax 中存放的是系统调用的功能号，而传给系统调用的参数则必须按顺序放到寄存器 ebx，ecx，edx，esi，edi 中，当系统调用完成之后，返回值可以在寄存器 eax 中获得。

所有的系统调用功能号都可以在文件 /usr/include/bits/syscall.h 中找到，为了便于使用，它们是用 SYS_&lt;name&gt; 这样的宏来定义的，如 SYS_write、SYS_exit 等。例如，经常用到的 write 函数是如下定义的：
ssize_t write(int fd, const void *buf, size_t count);

该函数的功能最终是通过 SYS_write 这一系统调用来实现的。根据上面的约定，参数 fb、buf 和 count 分别存在寄存器 ebx、ecx 和 edx 中，而系统调用号 SYS_write 则放在寄存器 eax 中，当 int 0x80 指令执行完毕后，返回值可以从寄存器 eax 中获得。

或许你已经发现，在进行系统调用时至多只有 5 个寄存器能够用来保存参数，难道所有系统调用的参数个数都不超过 5 吗？当然不是，例如 mmap 函数就有 6 个参数，这些参数最后都需要传递给系统调用 SYS_mmap：
void * mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset);

当一个系统调用所需的参数个数大于 5 时，执行int 0x80 指令时仍需将系统调用功能号保存在寄存器 eax 中，所不同的只是全部参数应该依次放在一块连续的内存区域里，同时在寄存器 ebx 中保存指向该内存区域的指针。系统调用完成之后，返回值仍将保存在寄存器 eax 中。

由于只是需要一块连续的内存区域来保存系统调用的参数，因此完全可以像普通的函数调用一样使用栈(stack)来传递系统调用所需的参数。但要注意一点，Linux 采用的是 C 语言的调用模式，这就意味着所有参数必须以相反的顺序进栈，即最后一个参数先入栈，而第一个参数则最后入栈。如果采用栈来传递系统调用所需的参数，在执行int 0x80 指令时还应该将栈指针的当前值复制到寄存器 ebx中。

##### 六、命令行参数

在 Linux 操作系统中，当一个可执行程序通过命令行启动时，其所需的参数将被保存到栈中：首先是 argc，然后是指向各个命令行参数的指针数组 argv，最后是指向环境变量的指针数据 envp。在编写汇编语言程序时，很多时候需要对这些参数进行处理，下面的代码示范了如何在汇编代码中进行命令行参数的处理：

例3. 处理命令行参数
</code></pre>

<pre><code># args.s
.text
.globl _start

_start:
popl %ecx # argc
vnext:
popl %ecx # argv
test %ecx, %ecx # 空指针表明结束
jz exit
movl %ecx, %ebx
xorl %edx, %edx
strlen:
movb (%ebx), %al
inc %edx
inc %ebx
test %al, %al
jnz strlen
movb $10, -1(%ebx)
movl $4, %eax # 系统调用号(sys_write)
movl $1, %ebx # 文件描述符(stdout)
int $0x80
jmp vnext
exit:
movl $1,%eax # 系统调用号(sys_exit)
xorl %ebx, %ebx # 退出代码
int $0x80

ret
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
