<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013~06 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013~06/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-07-14T22:08:34+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用户空间和内核空间数据交换方式-sysctl]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/06/27/kernel-sysctl/"/>
    <updated>2013-06-27T17:20:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/06/27/kernel-sysctl</id>
    <content type="html"><![CDATA[<p>  sysctl是一种用户应用来设置和获得运行时内核的配置参数的一种有效方式，通过这种 方式，用户应用可以在内核运行的任何时刻来改变内核的配置参数，也可以在任何时候获得内核的配置参数，通常，内核的这些配置参数也出现在proc文件系统 的/proc/sys目录下，用户应用可以直接通过这个目录下的文件来实现内核配置的读写操作，例如，用户可以通过
<code>
cat /proc/sys/net/ipv4/ip_forward
</code>
来得知内核IP层是否允许转发IP包，用户可以通过
<code>
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</code>
  把内核 IP 层设置为允许转发 IP 包，即把该机器配置成一个路由器或网关。 一般地，所有的 Linux 发布也提供了一个系统工具  sysctl，它可以设置和读取内核的配置参数，但是该工具依赖于 proc 文件系统，为了使用该工具，内核必须支持 proc 文件系统。下面是使用  sysctl 工具来获取和设置内核配置参数的例子：
<code>
    # sysctl net.ipv4.ip_forward
    net.ipv4.ip_forward = 0
    # sysctl -w net.ipv4.ip_forward=1
    net.ipv4.ip_forward = 1
    # sysctl net.ipv4.ip_forward
    net.ipv4.ip_forward = 1
</code>
  注意，参数 net.ipv4.ip_forward 实际被转换到对应的 proc  文件/proc/sys/net/ipv4/ip_forward，选项 -w 表示设置该内核配置参数，没有选项表示读内核配置参数，用户可以使用  sysctl -a 来读取所有的内核配置参数，对应更多的 sysctl 工具的信息，请参考手册页 sysctl(8)。</p>

<p>  但是 proc 文件系统对 sysctl 不是必须的，在没有 proc 文件系统的情况下，仍然可以，这时需要使用内核提供的系统调用 sysctl 来实现对内核配置参数的设置和读取。</p>

<p>  在源代码中给出了一个实际例子程序，它说明了如何在内核和用户态使用sysctl。头文件 sysctl-exam.h 定义了 sysctl  条目 ID，用户态应用和内核模块需要这些 ID 来操作和注册 sysctl 条目。内核模块在文件 sysctl-exam-kern.c  中实现，在该内核模块中，每一个 sysctl 条目对应一个 struct ctl_table 结构，该结构定义了要注册的 sysctl 条目的  ID(字段 ctl_name)，在 proc  下的名称（字段procname），对应的内核变量（字段data，注意该该字段的赋值必须是指针），条目允许的最大长度（字段maxlen，它主要用于 字符串内核变量，以便在对该条目设置时，对超过该最大长度的字符串截掉后面超长的部分），条目在proc文件系统下的访问权限（字段mode），在通过  proc设置时的处理函数（字段proc_handler，对于整型内核变量，应当设置为&amp;proc_dointvec，而对于字符串内核变量， 则设置为 &amp;proc_dostring），字符串处理策略（字段strategy，一般这是为&amp;sysctl_string）。</p>

<p>  sysctl 条目可以是目录，此时 mode 字段应当设置为 0555，否则通过 sysctl 系统调用将无法访问它下面的 sysctl  条目，child 则指向该目录条目下面的所有条目，对于在同一目录下的多个条目，不必一一注册，用户可以把它们组织成一个 struct  ctl_table 类型的数组，然后一次注册就可以，但此时必须把数组的最后一个结构设置为NULL，即
<code>
    {
        .ctl_name = 0
    }
</code>
  注册sysctl条目使用函数register_sysctl_table(struct ctl_table *,  int)，第一个参数为定义的struct  ctl_table结构的sysctl条目或条目数组指针，第二个参数为插入到sysctl条目表中的位置，如果插入到末尾，应当为0，如果插入到开头， 则为非0。内核把所有的sysctl条目都组织成sysctl表。</p>

<p>  当模块卸载时，需要使用函数unregister_sysctl_table(struct ctl_table_header  *)解注册通过函数register_sysctl_table注册的sysctl条目，函数register_sysctl_table在调用成功时返  回结构struct ctl_table_header，它就是sysctl表的表头，解注册函数使用它来卸载相应的sysctl条目。  用户态应用sysctl-exam-user.c通过sysctl系统调用来查看和设置前面内核模块注册的sysctl条目（当然如果用户的系统内核已经 支持proc文件系统，可以直接使用文件操作应用如cat, echo等直接查看和设置这些sysctl条目）。</p>

<h5>下面是运行该模块与应用的输出结果示例：</h5>

<pre><code>    # insmod ./sysctl-exam-kern.ko
    # cat /proc/sys/mysysctl/myint
    0
    # cat /proc/sys/mysysctl/mystring
    # ./sysctl-exam-user
    mysysctl.myint =0
    mysysctl.mystring =""
    # ./sysctl-exam-user 100"Hello, World"
    old value: mysysctl.myint =0
    newvalue: mysysctl.myint =100
    old vale: mysysctl.mystring =""
    newvalue: mysysctl.mystring ="Hello, World"
    # cat /proc/sys/mysysctl/myint
    100
    # cat /proc/sys/mysysctl/mystring
    Hello, World
    #
</code></pre>

<hr />

<p>struct ctl_table是相关的主要的数据结构。定义如下：
<code>
    struct ctl_table
    {
        int ctl_name;            /* Binary ID */
        const char *procname;        /* Text ID for /proc/sys, or zero */
        void *data;
        int maxlen;
        mode_t mode;
        struct ctl_table *child;
        struct ctl_table *parent;    /* Automatically set */
        proc_handler *proc_handler;    /* Callback for text formatting */
        ctl_handler *strategy;        /* Callback function for all r/w */
        void *extra1;
        void *extra2;
    };
</code>
每个这样的数据结构，都对应了/proc/sys目录下的一项内核参数。</p>

<p>其中各字段的意义如下：<br/>
  ctl_name: 唯一标识此表项的一个整数。<br/>
  proc_name: 相对于/proc/sys目录下对应的参数名称。<br/>
  data: 一个void *指针，指向与这个表项相关联的数据的指针。<br/>
  maxlen: 可以读取或者写入data的最大字节数。eg：data指向的是一个int型参数，则maxlen一般为sizeof(int)。<br/>
  mode: 文件的权限。<br/>
  child: 如果此数据结构对应的表项为一目录，则chind是指向其子表项的指针。<br/>
  parent: 同child，指向其所在目录对应的ctl_table。<br/>
  proc_handler: 如果是通过/proc/sys文件读写内核运行时的参数，则执行此操作。<br/>
  strategy: 如果是通过系统调用sysctl对内核参数进行读写，则调用此函数。<br/>
  extra1和extra2可以指向处理这个表项时的任何补充数据。</p>

<p>下面分别简单说下这两个函数大概的执行流程：<br/>
proc_handler:<br/>
一般情况下，proc_handler指向proc_dostring（操作数为string）或者proc_dointvec（操作数为int）。</p>

<p>strategy:<br/>
sysctl ==> sys_sysctl ==> do_sysctl ==> parse_table ==> do_sysctl_strategy ==> ctl_table中strategy对应的操作。</p>

<hr />

<h5>示例：</h5>

<p>头文件：sysctl-exam.h：
<code>
    //header: sysctl-exam.h
    #ifndef _SYSCTL_EXAM_H
    #define _SYSCTL_EXAM_H
    #include &lt;linux/sysctl.h&gt;
    #define MY_ROOT (CTL_CPU + 10)
    #define MY_MAX_SIZE 256
    enum {
        MY_INT_EXAM = 1,
        MY_STRING_EXAM = 2,
    };
    #endif
</code></p>

<p>内核模块代码  sysctl-exam-kern.c：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//kernel module: sysctl-exam-kern.c
</span><span class='line'>#include &lt;linux/kernel.h&gt;
</span><span class='line'>#include &lt;linux/module.h&gt;
</span><span class='line'>#include &lt;linux/sysctl.h&gt;
</span><span class='line'>#include &ldquo;sysctl-exam.h&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static char mystring[256];
</span><span class='line'>static int myint;
</span><span class='line'>
</span><span class='line'>static struct ctl_table my_sysctl_exam[] = {
</span><span class='line'>{
</span><span class='line'>    .ctl_name       = MY_INT_EXAM,
</span><span class='line'>    .procname       = "myint",
</span><span class='line'>    .data           = &amp;myint,
</span><span class='line'>    .maxlen         = sizeof(int),
</span><span class='line'>    .mode           = 0666,
</span><span class='line'>    .proc_handler   = &amp;proc_dointvec,
</span><span class='line'>},
</span><span class='line'>{
</span><span class='line'>    .ctl_name       = MY_STRING_EXAM,
</span><span class='line'>    .procname       = "mystring",
</span><span class='line'>    .data           = mystring,
</span><span class='line'>    .maxlen         = MY_MAX_SIZE,
</span><span class='line'>    .mode           = 0666,
</span><span class='line'>    .proc_handler   = &amp;proc_dostring,
</span><span class='line'>    .strategy       = &amp;sysctl_string,
</span><span class='line'>}，
</span><span class='line'>{
</span><span class='line'>    .ctl_name = 0
</span><span class='line'>}
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static struct ctl_table my_root = {
</span><span class='line'>.ctl_name       = MY_ROOT,
</span><span class='line'>.procname       = "mysysctl",
</span><span class='line'>.mode           = 0555,
</span><span class='line'>.child          = my_sysctl_exam,
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static struct ctl_table_header * my_ctl_header;
</span><span class='line'>
</span><span class='line'>static int __init sysctl_exam_init(void)
</span><span class='line'>{
</span><span class='line'>my_ctl_header = register_sysctl_table(&amp;my_root, 0);
</span><span class='line'>
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static void __exit sysctl_exam_exit(void)
</span><span class='line'>{
</span><span class='line'>unregister_sysctl_table(my_ctl_header);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>module_init(sysctl_exam_init);
</span><span class='line'>module_exit(sysctl_exam_exit);
</span><span class='line'>MODULE_LICENSE("GPL");
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>用户程序 sysctl-exam-user.c：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;//application: sysctl-exam-user.c
</span><span class='line'>#include &lt;linux/unistd.h&gt;
</span><span class='line'>#include &lt;linux/types.h&gt;
</span><span class='line'>#include &lt;linux/sysctl.h&gt;
</span><span class='line'>#include "sysctl-exam.h"
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;errno.h&gt;
</span><span class='line'>
</span><span class='line'>_syscall1(int, _sysctl, struct __sysctl_args *, args);
</span><span class='line'>
</span><span class='line'>int sysctl(int *name, int nlen, void *oldval, size_t *oldlenp, void *newval, size_t newlen)
</span><span class='line'>{
</span><span class='line'>struct __sysctl_args args={name,nlen,oldval,oldlenp,newval,newlen};
</span><span class='line'>return _sysctl(&amp;args);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>#define SIZE(x) sizeof(x)/sizeof(x[0])
</span><span class='line'>#define OSNAMESZ 100
</span><span class='line'>
</span><span class='line'>int oldmyint;
</span><span class='line'>int oldmyintlen;
</span><span class='line'>
</span><span class='line'>int newmyint;
</span><span class='line'>int newmyintlen;
</span><span class='line'>
</span><span class='line'>char oldmystring[MY_MAX_SIZE];
</span><span class='line'>int oldmystringlen;
</span><span class='line'>
</span><span class='line'>char newmystring[MY_MAX_SIZE];
</span><span class='line'>int newmystringlen;
</span><span class='line'>
</span><span class='line'>int myintctl[] = {MY_ROOT, MY_INT_EXAM};
</span><span class='line'>int mystringctl[] = {MY_ROOT, MY_STRING_EXAM};
</span><span class='line'>
</span><span class='line'>int main(int argc, char ** argv)
</span><span class='line'>{
</span><span class='line'>if (argc &lt; 2) 
</span><span class='line'>{
</span><span class='line'>    oldmyintlen = sizeof(int);
</span><span class='line'>    if (sysctl(myintctl, SIZE(myintctl), &amp;oldmyint, &amp;oldmyintlen, 0, 0)) {
</span><span class='line'>        perror("sysctl");
</span><span class='line'>        exit(-1);
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        printf("mysysctl.myint = %d\n", oldmyint);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    oldmystringlen = MY_MAX_SIZE;
</span><span class='line'>    if (sysctl(mystringctl, SIZE(mystringctl), oldmystring, &amp;oldmystringlen, 0, 0)) {
</span><span class='line'>        perror("sysctl");
</span><span class='line'>        exit(-1);
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        printf("mysysctl.mystring = \"%s\"\n", oldmystring);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>else if (argc != 3) 
</span><span class='line'>{
</span><span class='line'>    printf("Usage:\n");
</span><span class='line'>    printf("\tsysctl-exam-user\n");
</span><span class='line'>    printf("Or\n");
</span><span class='line'>    printf("\tsysctl-exam-user aint astring\n");
</span><span class='line'>}
</span><span class='line'>else 
</span><span class='line'>{
</span><span class='line'>    newmyint = atoi(argv[1]);
</span><span class='line'>    newmyintlen = sizeof(int);
</span><span class='line'>    oldmyintlen = sizeof(int);
</span><span class='line'>
</span><span class='line'>    strcpy(newmystring, argv[2]);
</span><span class='line'>    newmystringlen = strlen(newmystring);
</span><span class='line'>    oldmystringlen = MY_MAX_SIZE;
</span><span class='line'>
</span><span class='line'>    if (sysctl(myintctl, SIZE(myintctl), &amp;oldmyint, &amp;oldmyintlen, &amp;newmyint, newmyintlen)) {
</span><span class='line'>        perror("sysctl");
</span><span class='line'>        exit(-1);
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        printf("old value: mysysctl.myint = %d\n", oldmyint);
</span><span class='line'>        printf("new value: mysysctl.myint = %d\n", newmyint);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    if (sysctl(mystringctl, SIZE(mystringctl), oldmystring, &amp;oldmystringlen, newmystring, newmystringlen)) {
</span><span class='line'>        perror("sysctl");
</span><span class='line'>        exit(-1);
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        printf("old vale: mysysctl.mystring = \"%s\"\n", oldmystring);
</span><span class='line'>        printf("new value: mysysctl.mystring = \"%s\"\n", newmystring);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>exit(0);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[Makefile与Shell的问题]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2013/06/21/compiler-makefile-shell/"/&gt;
</span><span class='line'>&lt;updated&gt;2013-06-21T18:28:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2013/06/21/compiler-makefile-shell&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;  大概只要知 道Makefile的人，都知道Makefile可以调用Shell脚本。但是在实际使用时，并不那么简单，一些模棱两可的地方可能会让你抓狂。你若不信，可以先看几个例子，想象一下这些这些例子会打印什么内容，记下你想象的结果，然后在计算机上运行这些例子，对照看一下。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;示例一：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>if [ "$(BUILD)" = "debug" ]; then
</span><span class='line'>    echo "build debug";
</span><span class='line'>else
</span><span class='line'>    echo "build release";
</span><span class='line'>fi
</span><span class='line'>all:
</span><span class='line'>    echo "done"
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>示例二：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>all:
</span><span class='line'>    @CC=arm-linux-gcc
</span><span class='line'>    @echo $(CC)
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>示例三：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>CC=arm-linux-gcc
</span><span class='line'>all:
</span><span class='line'>    @echo $(CC)
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>示例四：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>SUBDIR=src example
</span><span class='line'>all:
</span><span class='line'>    @for subdir in $(SUBDIR);
</span><span class='line'>    do
</span><span class='line'>        echo "building " $(subdir);
</span><span class='line'>    done
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;说明：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1.Shell脚本在target里才有效，其它地方都被忽略掉了。所以示例一中，”build debug”之类的字符串根本打印不出来。示例一的正确写法是：
</span><span class='line'>示例一：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>all:
</span><span class='line'>    if [ "$(BUILD)" = "debug" ]; then
</span><span class='line'>        echo "build debug";
</span><span class='line'>    else
</span><span class='line'>        echo "build release";
</span><span class='line'>    fi
</span><span class='line'>    echo "done"
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>2.make把每一行Shell脚本当作一个独立的单元，它们在单独的进程中运行。示例二中，两行Shell脚本在两个莫不相干的进程里运行，第一个进程把 CC设置为arm-linux-gcc，第二个进程是不知道的，所以打印的结果自然不是arm-linux-gcc了。示例二的正确写法是：&lt;br/&gt;
</span><span class='line'>示例二：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>all:
</span><span class='line'>    @CC=arm-linux-gcc; echo $(CC)
</span><span class='line'>或者：
</span><span class='line'>all:
</span><span class='line'>    @CC=arm-linux-gcc;
</span><span class='line'>    echo $(CC)
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>3.make在调用Shell之前先进行预处理，即展开所有Makefile的变量和函数。这些变量和函数都以$开头。示例三中，Shell拿的脚本实际上是echo arm-linux-gcc，所以打印结果正确。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;4.make预处理时，所有以$开头的，它都不会放过。要想引用Shell自己的变量，应该以$$开头。另外要注意，Shell自己的变量是不需要括号的。示例四的正确写法是：&lt;br/&gt;
</span><span class='line'>示例四：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>SUBDIR=src example
</span><span class='line'>all:
</span><span class='line'>    @for subdir in $(SUBDIR);
</span><span class='line'>    do
</span><span class='line'>        echo "building " $$subdir;
</span><span class='line'>    done
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[字节序和比特序]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte/"/&gt;
</span><span class='line'>&lt;updated&gt;2013-06-20T18:23:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;字节序和比特序，因为比特序对所有代码（包括汇编）是透明的，所以对于小端系统，有说是用大端比特序，也有说是用小端比特序。&lt;br/&gt;
</span><span class='line'>下面是copy一部分觉得靠谱的内容：&lt;br/&gt;
</span><span class='line'>大小端
</span><span class='line'>我们对"endianness"这个名词估计都很熟悉了。它首先被Danny Cohen于1980引入，用来表述计算机系统表示多字节整数的方式。
</span><span class='line'>endianness分为两种：大端和小端。(从字节序的角度来看)大端方式是将整数中最高位byte存放在最低地址中。而小端方式则相反，将整数中的最高位byte存放在最高地址中。
</span><span class='line'>对于某个确定的计算机系统，比特序通常与字节序保持一致。换言之，在大端系统中，每个byte中最高位bit存放在内存最低位；在小端系统中，最低位bit存放在内存最低位。
</span><span class='line'>正如大部分人是按照从左至右的顺序书写数字，一个多字节整数的内存布局也应该遵循同样的方式，即从左至右为数值的最高位至最低位。正如我们在下面的例子中所看到的，这是书写整数最清晰的方式。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;根据上述规则，我们按以下方式分别在大端和小端系统中值为0x0a0b0c0d的整数。
</span><span class='line'>在大端系统中书写整数：
</span><span class='line'>byte  addr  0   1   2   3
</span><span class='line'>bit offset  01234567 01234567 01234567 01234567&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;binary  00001010 00001011 00001100 00001101
</span><span class='line'>  hex      0a       0b       0c       0d
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在小端系统中书写整数(认真看)
</span><span class='line'>byte  addr  0   1   2   3
</span><span class='line'>bit offset  01234567 01234567 01234567 01234567&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;binary  10110000 00110000 11010000 01010000
</span><span class='line'>  hex      d0       c0       b0       a0
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;说明字节序：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>#include &lt;stdio.h&gt;  
</span><span class='line'>int main (void)  
</span><span class='line'>{  
</span><span class='line'>    union b  
</span><span class='line'>    {  
</span><span class='line'>        short k;  //测试环境short占2字节  
</span><span class='line'>        char i[2];  //测试环境char占1字节  
</span><span class='line'>    }*s,a;  
</span><span class='line'>    s=&amp;a;  
</span><span class='line'>    s-&gt;i[0]=0x41;  
</span><span class='line'>    s-&gt;i[1]=0x52;  
</span><span class='line'>    printf("%x\n",s-&gt;k);  
</span><span class='line'>    return 0;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>输出：5241&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;self code:</span></code></pre></td></tr></table></div></figure>
    #include &lt;stdio.h>
    union W
    {
        struct Y
        {
            unsigned int s1:4;
            unsigned int s2:8;
            unsigned int s3:20;
        } y;
        unsigned int c;
    } w;</p>

<pre><code>union V 
{
    struct X
    {
        unsigned char s1:3;
        unsigned char s2:3;
        unsigned char s3:2;
    } x;
    unsigned char c;
} v;

int main()
{
    w.c = 0x12345678;
    printf("%x %x %x %x\n", w.c, w.y.s1, w.y.s2, w.y.s3); 

    v.c = 100;
    printf("%d %x %x %x\n", v.c, v.x.s1, v.x.s2, v.x.s3); 
    return 0;
}
</code></pre>

<p>```</p>

<p>输出：<br/>
12345678 8 67 12345<br/>
100 4 4 1</p>

<p>100 = （01100100）2<br/>
因为字节序是小端的所以第一行输出说明：位域变量从左到右分配位，所以第二行的输出的位域变量也应该从左到右分配位。所以<br/>
100 = 001 001 10  （小端比特序二进制）<br/>
对应:  s1  s2  s3  （位域变量从左到右分配位）</p>

<p>符合。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jmp指令对应的机器码]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/06/18/assembly-jmp-addr/"/>
    <updated>2013-06-18T15:53:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/06/18/assembly-jmp-addr</id>
    <content type="html"><![CDATA[<p>  短跳转和近跳转指令中包含的操作数都是相对于(E)IP的偏移，而远跳转指令中包含的是目标的绝对地址，所以短/近跳转会出现跳至同一目标的指令机器码不同，不仅会不同，而且应该不同。而远跳转中包含的是绝对地址，因此转移到同一地址的指令机器码相同</p>

<p>  绝对跳转/调用指令中的内存操作数必须以’*’为前缀，否则gas总是认为是相对跳转/调用指令,而且gas汇编程序自动对跳转指令进行优化，总是使用尽可能小的跳转偏移量。如果8比特的偏移量无法满足要求的话，as会使用一个32位的偏移量，as汇编程序暂时还不支持16位的跳转偏移量，所以对跳转指令使用’addr16’前缀是无效的。还有一些跳转指令只支持8位的跳转偏移量，这些指令是：’jcxz’,’jecxz’,’loop’,’loopz’,’loope’,’loopnz’’loopne’如果你在汇编中使用了这些指令，用gas的汇编可能会出错，因为gcc在编译过程中不产生这些指令，所以在c语言中不必担心这些问题。
<code>
ffffffff88873036      e8 ff ff 5f c6   =&gt;  call XX        // e8 = call
ffffffff8887303a      ......
</code>
相当于：目标地址 - ffffffff8887303a(RIP, 指向下一条指令) = ffffffffffff5fc6 (这个是负数，以补码形式展示）<br/>
所以：   目标地址 = ffffffff88869000</p>

<ul>
<li>即：  ffffffff88869000 - ffffffff8887303a + ffffffffffffffff + 1 = ffffffffffff5fc6</li>
<li>可以用 unsigned long 类型来计算，让它自然溢出就好了，(unsigned long)func1 - ((unsigned long)func2 + 0x偏移)</li>
</ul>


<p>先计算好偏移，再替换call地址，就偷偷的改了调用。</p>

<p>附：若为e8 00 00 00 00 则可以同过模块读取 00 00 00 00 的实际值</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux中X86的内联汇编]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/06/07/assembly-base-5/"/>
    <updated>2013-06-07T17:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/06/07/assembly-base-5</id>
    <content type="html"><![CDATA[<p>GCC支持在C/C++代码中嵌入汇编代码,这些代码被称作是"GCC Inline ASM"(GCC内联汇编);</p>

<h4>一、基本内联汇编</h4>

<p>GCC中基本的内联汇编非常易懂,格式如下:<br/>
<code>__asm__ [__volatile__] ("instruction list");</code></p>

<p>其中,<br/>
1.<code>__asm__</code>:<br/>
它是GCC定义的关键字asm的宏定义(<code>#define __asm__ asm</code>),它用来声明一个内联汇编表达式,所以,任何一个内联汇编表达式都以它开头,它是必不可少的;如果要编写符合ANSI C标准的代码(即:与ANSI C兼容),那就要使用<code>__asm__</code>;<br/>
2.<code>__volatile__</code>:<br/>
它 是GCC关键字volatile的宏定义;这个选项是可选的;它向GCC声明"不要动我所写的instruction  list,我需要原封不动地保留每一条指令";如果不使用<code>__volatile__</code>,则当你使用了优化选项-O进行优化编译时,GCC将会根据自己的判断 来决定是否将这个内联汇编表达式中的指令优化掉;如果要编写符合ANSI C标准的代码(即:与ANSI  C兼容),那就要使用<code>__volatile__</code>;
3.instruction list:<br/>
它是汇编指令列表;它可以是空列表,比 如:<code>__asm__  __volatile__("");</code>或<code>__asm__("");</code>都是合法的内联汇编表达式,只不过这两条语句什么都不做,没有什么意义;但并非所 有"instruction  list"为空的内联汇编表达式都是没意义的,比如:<code>__asm__("":::"memory");</code>就是非常有意义的,它向GCC声明:&ldquo;我对内存做了 改动&rdquo;,这样,GCC在编译的时候,就会将此因素考虑进去;<br/>
例如:<br/>
<code>__asm__("movl %esp,%eax");</code>
或者是
<code>
    __asm__("movl $1,%eax
             xor %ebx,%ebx
             int $0x80");
</code>
或者是
<code>
    __asm__("movl $1,%eax \t"\
            "xor %ebx,%ebx \t"\
            "int $0x80");
</code>
instruction   list的编写规则:当指令列表里面有多条指令时,可以在一对双引号中全部写出,也可将一条或多条指令放在一对双引号中,所有指令放在多对双引号中;如果 是将所有指令写在一对双引号中,那么,相邻两条指令之间（此时没有单独写在两行中）必须用分号";&ldquo;或换行符( )隔开,如果使用换行符(  ),通常后面还要跟一个\t（主要是为了代码对齐）;或者是相邻两条指令分别单独写在两行中;<br/>
规则1:任意两条指令之间要么被分号(;)或换行符( )或( \t)分隔开,要么单独放在两行(等效于）;<br/>
规则2:单独放在两行的方法既可以通过或 \t的方法来实现,也可以真正地放在两行;<br/>
规则3:可以使用1对或多对双引号,每1对双引号里面可以放1条或多条指令,所有的指令都要放在双引号中;<br/>
例如,下面的内联汇编语句都是合法的:（注意：下面例子并不等价，只是用来说明格式而已）<br/>
<code>
    __asm__("movl %eax,%ebx
            sti
            popl %edi
            subl %ecx,%ebx");
    __asm__("movl %eax,%ebx; sti
             popl %edi; subl %ecx,%ebx");
    __asm__("movl %eax,%ebx; sti \t popl %edi
             subl %ecx,%ebx");
</code>
如果将指令放在多对双引号中,则,除了最后一对双引号之外,前面的所有双引号里的最后一条指令后面都要有一个分号(;)或( )或( \t);比如,下面的内联汇编语句都是合法的:
<code>
    __asm__("movl %eax,%ebx
             sti "
             "popl %edi;"
             "subl %ecx,%bx");
    __asm__("movl %eax,%ebx; sti \t"
            "popl %edi; subl %ecx,%ebx");
    __asm__("movl %eax,%ebx; sti \t popl %edi "
            "subl %ecx,%ebx");
</code></p>

<h4>二、带有C/C++表达式的内联汇编</h4>

<p>GCC允许你通过C/C++表达式指定内联汇编中"instruction list"中的指令的输入和输出,你甚至可以不关心到底使用哪些寄存器,完全依靠GCC来安排和指定;这一点可以让程序员免去考虑有限的寄存器的使用,也可以提高目标代码的效率;</p>

<h5>1.带有C/C++表达式的内联汇编语句的格式:</h5>

<p><code>__asm__ [__volatile__]("instruction list":Output:Input:Clobber/Modify);</code><br/>
圆括号中的内容被冒号":&ldquo;分为四个部分:<br/>
A.  如果第四部分的"Clobber/Modify"可以为空;如果"Clobber/Modify"为空,则其前面的冒号(:)必须省略;比如:语句  <code>__asm__("movl %%eax,%%ebx":"=b"(foo):"a"(inp):);</code>是非法的,而语句<code>__asm__("movl  %%eax,%%ebx":"=b"(foo):"a"(inp));</code>则是合法的;<br/>
B.如果第一部分的"instruction list"为空,则input、output、Clobber/Modify可以为空,也可以不为空;比如,语句<code>__asm__("":::"memory");</code>和语句<code>__asm__(""::);</code>都是合法的写法;<br/>
C.   如果Output、Input和Clobber/Modify都为空,那么,Output、Input之前的冒号(:)可以省略,也可以不省略（也就是说 可以留下两个冒号，一个冒号，和零个冒号，但零个冒号表示的不是扩展汇编，而是基本汇编);如果都省略,则此汇编就退化为一个基本汇编,否则,仍然是一个 带有C/C++表达式的内联汇编,此时"instruction  list"中的寄存器的写法要遵循相关规定,比如:寄存器名称前面必须使用两个百分号(%%);基本内联汇编中的寄存器名称前面只有一个百分号(%);比 如,语句<code>__asm__("movl %%eax,%%ebx"::);__asm__("movl  %%eax,%%ebx":);</code>和语句<code>__asm__("movl %%eax,%%ebx");</code>都是正确的写法,而语句<code>__asm__("movl  %eax,%ebx"::);__asm__("movl %eax,%ebx":);</code>和语句<code>__asm__("movl  %%eax,%%ebx");</code>都是错误的写法;<br/>
D.如果Input、Clobber/Modify为空,但Output不为空,则,Input前 面的冒号(:)可以省略,也可以不省略;比如,语句 <code>__asm__("movl  %%eax,%%ebx":"=b"(foo):);</code>和语句<code>__asm__("movl %%eax,%%ebx":"=b"(foo));</code>都是正确的;<br/>
E.   如果后面的部分不为空,而前面的部分为空,则,前面的冒号(:)都必须保留,否则无法说明不为空的部分究竟是第几部分;比 如,Clobber/Modify、Output为空,而Input不为空,则Clobber/Modify前面的冒号必须省略,而Output前面的冒 号必须保留;如果Clobber/Modify不为空,而Input和Output都为空,则Input和Output前面的冒号都必须保留;比如,语句 <code>__asm__("movl %%eax,%%ebx"::"a"(foo));</code>和<code>__asm__("movl  %%eax,%%ebx":::"ebx");</code><br/>
注意:基本内联汇编中的寄存器名称前面只能有一个百分号(%),而带有C/C++表达式的内联汇编中的寄存器（即扩展汇编）名称前面必须有两个百分号(%%);</p>

<h5>2.Output:</h5>

<p>Output部分用来指定当前内联汇编语句的输出,称为输出表达式;<br/>
格式为: &ldquo;操作约束&rdquo;(输出表达式)<br/>
例如:<br/>
<code>__asm__("movl %%cr0,%1":"=a"(cr0));</code> //注意：后面的cr0是个变量，不是寄存器</p>

<p>这个语句中的Output部分就是(&ldquo;=a&rdquo;(cr0)),它是一个操作表达式,指定了一个内联汇编语句的输出部分;<br/>
Output部分由两个部分组成:由双引号括起来的部分和由圆括号括起来的部分,这两个部分是一个Output部分所不可缺少的部分;</p>

<p>用 双引号括起来的部分就是C/C++表达式,它用于保存当前内联汇编语句的一个输出值,其操作就是C/C++赋值语句"=&ldquo;的左值部分,因此,圆括号中指定 的表达式只能是C  /C++中赋值语句的左值表达式,即:放在等号=左边的表达式;也就是说,Output部分只能作为C/C++赋值操作左边的表达式使用;</p>

<p>用双引 号括起来的部分指定了C/C++中赋值表达式的右值来源;这个部分被称作是"操作约束"(Operation  Constraint),也可以称为"输出约束";在这个例子中的操作约束是"=a",这个操作约束包含两个组成部分:等号(=)和字母a,其中,等号  (=)说明圆括号中的表达式cr0是一个只写的表达式,只能被用作当前内联汇编语句的输出,而不能作为输入;字母a是寄存器EAX/AX/AL的缩写,说 明cr0的值要从寄存器EAX中获取,也就是说cr0(变量)=%eax,最终这一点被转化成汇编指令就是:movl  %eax,address_of_cr0;</p>

<p>注意:很多文档中都声明,所有输出操作的的操作约束都必须包含一个等号(=),但是GCC的文档中却明 确地声明,并非如此;因为等号(=)约束说明当前的表达式是一个只写的,但是还有另外一个符号:加号(+),也可以用来说明当前表达式是可读可写的;如果 一个操作约束中没有给出这两个符号中的任何一个,则说明当前表达式是只读的;因此,对于输出操作来说,肯定必须是可写的,而等号(=)和加号(+)都可表 示可写,只不过加号(+)同时也可以表示可读;所以, 对于一个输出操作来说,其操作约束中只要包含等号(=)或加号(+)中的任意一个就可以了;</p>

<p>等 号(=)与加号(+)的区别:等号(=)表示当前表达式是一个纯粹的输出操作,而加号(+)则表示当前表达式不仅仅是一个输出操作,还是一个输入操作;  但无论是等号(=)还是加号(+),所表示的都是可写,只能用于输出,只能出现在Output部分,而不能出现在Input部分;</p>

<p>在Output部分可以出现多个输出操作表达式,多个输出操作表达式之间必须用逗号(,)隔开;</p>

<h5>3、Input:</h5>

<p>Input部分用来指定当前内联汇编语句的输入，称为输入表达式;<br/>
格式为: &ldquo;操作约束&rdquo;(输入表达式)<br/>
例如:<br/>
<code>__asm__("movl %0,%%db7"::"a"(cpu-&gt;db7));</code><br/>
其中,表达式"a"(cpu->db7)就称为输入表达式,用于表示一个对当前内联汇编的输入;<br/>
Input同样也由两部分组成:由双引号括起来的部分和由圆括号括起来的部分;这两个部分对于当前内联汇编语句的输入来说也是必不可少的;<br/>
在这个例子中,由双引号括起来的部分是"a",用圆括号括起来的部分是(cpu->db7);<br/>
用双引号括起来的部分就是C/C++表达式,它为当前内联汇编语句提供一个输入值;在这里,圆括号中的表达式cpu->db7是一个C/C++语言的表达式,所以,Input可以是一个变量、一个数字,还可以是一个复杂的表达式(如:a+b/c*d);<br/>
例如:（注意：下面例子和上面那个例子不等价）<br/>
<code>__asm__("movl %0,%%db7"::"a"(foo));__asm__("movl %0,%%db7"::"a"(0x12345));__asm__("movl %0,%%db7"::"a"(va:vb/vc));</code><br/>
用 双引号括起来的部分就是C/C++中赋值表达式,用于约束当前内联汇编语句中的当前输入;这个部分也成为"操作约束",也可以成为是"输入约束";与输出 表达式中的操作约束不同的是,输入表达式中的操作约束不允许指定等号(=)约束或加号(+)约束,也就是说,它只能是只读的;约束中必须指定一个寄存器约 束;例子中的字母a表示当前输入变量cpu->db7要通过寄存器EAX输入到当前内联汇编语句中;</p>

<h4>三、操作约束:Operation Constraint</h4>

<p>操作约束只会出现在带有C/C++表达式的内联汇编语句中;<br/>
每一个Input和Output表达式都必须指定自己的操作约束Operation Constraint;约束的类型有:寄存器约束、内存约束、立即数约束、通用约束;<br/>
操作表达式的格式:<br/>
&ldquo;约束&rdquo;(C/C++表达式)<br/>
即:&ldquo;Constraint&rdquo;(C/C++ expression)</p>

<h5>1.寄存器约束:</h5>

<p>当你的输入或输出需要借助于一个寄存器时,你需要为其指定一个寄存器约束;<br/>
可以直接指定一个寄存器名字;比如:<br/>
<code>__asm__ __volatile__("movl %0,%%cr0"::"eax"(cr0));</code><br/>
也可以指定寄存器的缩写名称;比如:<br/>
<code>__asm__ __volatile__("movl %0,%%cr0"::"a"(cr0));</code><br/>
如果指定的是寄存器的缩写名称,比如:字母a;那么,GCC将会根据当前操作表达式中C/C++表达式的宽度来决定使用%eax、%ax还是%al;比如:<br/>
<code>
unsigned short __shrt;
__asm__ __volatile__("movl %0,%%bx"::"a"(__shrt));
</code>
由于变量__shrt是16位无符号类型，占两个字节,所以,编译器编译出来的汇编代码中,则会让此变量使用寄存器%ax;<br/>
无论是Input还是Output操作约束,都可以使用寄存器约束;<br/>
<code>
Some other constraints used are:
"m" : A memory operand is allowed, with any kind of address that the machine supports in general.
"o"  : A memory operand is allowed, but only if the address is offsettable.  ie, adding a small offset to the address gives a valid address.
"V" :  A memory operand that is not offsettable. In other words, anything that  would fit the `m’ constraint but not the `o’constraint.
"i" : An  immediate integer operand (one with constant value) is allowed. This  includes symbolic constants whose values will be known only at assembly  time.
"n" : An immediate integer operand with a known numeric value  is allowed. Many systems cannot support assembly-time constants for  operands less than a word wide. Constraints for these operands should  use ’n’ rather than ’i’.
"g" : Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.
Following constraints are x86 specific.
"r" : Register operand constraint, look table given above.
"q" : Registers a, b, c or d.
"I" : Constant in range 0 to 31 (for 32-bit shifts).
"J" : Constant in range 0 to 63 (for 64-bit shifts).
"K" : 0xff.
"L" : 0xffff.
"M" : 0, 1, 2, or 3 (shifts for lea instruction).
"N" : Constant in range 0 to 255 (for out instruction).
"f" : Floating point register
"t" : First (top of stack) floating point register
"u" : Second floating point register
"A"  : Specifies the `a’ or `d’ registers. This is primarily useful for  64-bit integer values intended to be returned with the `d’ register  holding the most significant bits and the `a’ register holding the least  significant bits.
</code></p>

<h5>2.内存约束:</h5>

<p>如果一个Input/Output操作表达式的C/C++表达式表现为一个内存地址(指针变量),不想借助于任何寄存器,则可以使用内存约束;比如:<br/>
<code>__asm__("lidt %0":"=m"(__idt_addr));或__asm__("lidt %0"::"m"(__idt_addr));</code><br/>
内存约束使用约束名"m",表示的是使用系统支持的任何一种内存方式,不需要借助于寄存器;<br/>
使 用内存约束方式进行输入输出时,由于不借助于寄存器,所以,GCC不会按照你的声明对其做任何的输入输出处理;GCC只会直接拿来使用,对这个  C/C++ 表达式而言,究竟是输入还是输出,完全依赖于你写在"instruction  list"中的指令对其操作的方式;所以,不管你把操作约束和操作表达式放在Input部分还是放在Output部分,GCC编译生成的汇编代码都是一样 的,程序的执行结果也都是正确的;本来我们将一个操作表达式放在Input或Output部分是希望GCC能为我们自动通过寄存器将表达式的值输入或输 出;既然对于内存约束类型的操作表达式来说,GCC不会为它做任何事情,那么放在哪里就无所谓了;但是从程序员的角度来看,为了增强代码的可读性,最好能 够把它放在符合实际情况的地方;</p>

<h5>3.立即数约束:</h5>

<p>如果一个Input/Output操作表达式的C/C++表达式是一个数字常数,不想借助于任何寄存器或内存,则可以使用立即数约束;<br/>
由于立即数在C/C++表达式中只能作为右值使用,所以,对于使用立即数约束的表达式而言,只能放在Input部分;比如:<br/>
<code>__asm__ __volatile__("movl %0,%%eax"::"i"(100));</code><br/>
立即数约束使用约束名"i"表示输入表达式是一个整数类型的立即数,不需要借助于任何寄存器,只能用于Input部分;使用约束名"f &ldquo;表示输入表达式是一个浮点数类型的立即数,不需要借助于任何寄存器,只能用于Input部分;</p>

<h5>4.通用约束:</h5>

<p>约束名"g"可以用于输入和输出,表示可以使用通用寄存器、内存、立即数等任何一种处理方式;<br/>
约束名"0,1,2,3,4,5,6,7,8,9"只能用于输入,表示与第n个操作表达式使用相同的寄存器/内存;<br/>
通用约束"g"是一个非常灵活的约束,当程序员认为一个C/C++表达式在实际操作中,无论使用寄存器方式、内存方式还是立即数方式都无所谓时,或者程序员想实现一个灵活的模板,以让GCC可以根据不同的C/C++表达式生成不同的访问方式时,就可以使用通用约束g;<br/>
例如:<br/>
<code>#define JUST_MOV(foo) __asm__("movl %0,%%eax"::"g"(foo))</code><br/>
则JUST_MOV(100)和JUST_MOV(var)就会让编译器产生不同的汇编代码;<br/>
对于JUST_MOV(100)的汇编代码为:<br/>
<code>
    #APP
     movl $100,%eax      #立即数方式;
    #NO_APP
</code>
对于JUST_MOV(var)的汇编代码为:
<code>
    #APP
    movl 8(%ebp),%eax #内存方式的"o"方式，参见上文
    #NO_APP
</code>
像这样的效果,就是通用约束g的作用;</p>

<h5>5.修饰符:</h5>

<p>等号(=)和加号(+)作为修饰符,只能用于Output部分;等号(=)表示当前输出表达式的属性为只写,加号(+)表示当前输出表达式的属性为可读可写;这两个修饰符用于约束对输出表达式的操作,它们俩被写在输出表达式的约束部分中,并且只能写在第一个字符的位置;</p>

<p>符 号&amp;也写在输出表达式的约束部分,用于约束寄存器的分配,但是只能写在约束部分的第二个字符的位置上;用符号&amp;进行修饰时,等于向  GCC  声明:&ldquo;GCC不得为任何Input操作表达式分配与此Output操作表达式相同的寄存器&rdquo;;其原因是修饰符&amp;意味着被其修饰的Output操 作表达式要在所有的Input操作表达式被输入之前输出;即:GCC会先使用输出值对被修饰符&amp;修饰的Output操作表达式进行填充,然后才对  Input操作表达式进行输入;这样的话,如果［不］（原文错误，须去掉‘不’）使用修饰符&amp;对Output操作表达式进行修饰,一旦后面的  Input操作表达式使用了与  Output操作表达式相同的寄存器,就会产生输入输出数据混乱的情况;相反,如果没有用修饰符&amp;修饰输出操作表达式,那么,就意味着GCC会先 把Input操作表达式的值输入到选定的寄存器中,然后经过处理,最后才用输出值填充对应的Output操作表达式;</p>

<p>所以,修饰符&amp;的作 用就是要求GCC编译器为所有的Input操作表达式分配别的寄存器,而不会分配与被修饰符&amp;修饰的Output操作表达式相同的寄存器;修饰 符&amp;也写在操作约束中,即:&amp;约束;由于GCC已经规定加号(+)或等号(=)占据约束的第一个字符,那么&amp;  amp;约束只能占用第二个字符;</p>

<p>例如:
<code>
    int __out, __in1, __in2;
    __asm__("popl %0 \t"
            "movl %1,%%esi \t"
            "movl %2,%%edi \t"
            :"=&amp;a"(__out)
            :"r"(__in1),"r"(__in2));
</code>
注 意:  如果一个Output操作表达式的寄存器约束被指定为某个寄存器,只有当至少存在一个Input操作表达式的寄存器约束为可选约束(意思是GCC可以从多 个寄存器中选取一个,例如你选用"r"约束而不是"b"约束)时,比如"r"或"g"时,此Output操作表达式使用符号&amp;修饰才有意义;如果 你为所有的 Input操作表达式指定了固定的寄存器,或使用内存/立即数约束时,则此Output操作表达式使用符号&amp;修饰没有任何意义;<br/>
比如:
<code>
    __asm__("popl %0 \t"
            "movl %1,%esi \t"
            "movl %2,%edi \t"
            :"=&amp;a"(__out)
            :"m"(__in1),"c"(__in2));
</code>
此例中的Output操作表达式完全没有必要使用符号&amp;来修饰,因为<code>__in1</code>和<code>__in2</code>被分别指定了使用了内存方式和固定的寄存器（ecx),GCC无从选择;<br/>
如果你已经为某个Output操作表达式指定了修饰符&amp;,并指定了固定的寄存器,那么,就不能再为任何Input操作表达式指定这个寄存器了,否则会出现编译报错;<br/>
比如:<br/>
<code>__asm__("popl %0; movl %1,%%esi; movl %2,%%edi;":"=&amp;a"(__out):"a"(__in1),"c"(__in2));</code><br/>
对这条语句的编译就会报错;<br/>
相反,你也可以为Output指定可选约束,比如"r"或"g"等,让GCC为此Output操作表达式选择合适的寄存器,或使用内存方式,GCC在选择的时候,会排除掉已经被Input操作表达式所使用过的所有寄存器,然后在剩下的寄存器中选择,或者干脆使用内存方式;<br/>
比如:<br/>
<code>__asm__("popl %0; movl %1,%%esi; movl %2,%%edi;":"=&amp;r"(__out):"a"(__in1),"c"(__in2));</code><br/>
这三个修饰符只能用在Output操作表达式中,而修饰符%则恰恰相反,它只能用在Input操作表达式中;<br/>
修饰符%用于向GCC声明:&ldquo;当前Input操作表达式中的C/C++表达式可以与下一个Input操作表达式中的C/C++表达式互换&rdquo;;这个修饰符一般用于符合交换律运算的地方;比如:加、乘、按位与&amp;、按位或|等等;<br/>
例如:<br/>
<code>__asm__("addl %1,%0 \t":"=r"(__out):"%r"(__in1),"0"(__in2));</code><br/>
其中,<code>"0"(__in2)</code>表示使用与第一个Input操作表达式(&ldquo;r&rdquo;(__in1))相同的寄存器或内存;<br/>
由于使用符号%修饰<code>__in1</code>的寄存器方式r,那么就表示,<code>__in1</code>与<code>__in2</code>可以互换位置;加法的两个操作数交换位置之后,和不变;<br/>
<code>
修饰符  I/O  意义
=        O    表示此Output操作表达式是只写的
+        O    表示此Output操作表达式是可读可写的
&amp;        O    表示此Output操作表达式独占为其指定的寄存器
%        I    表示此Input操作表达式中的C/C++表达式可以与下一个Input操作表达式中的C/C++表达式互换
</code></p>

<h4>四、占位符</h4>

<p>每一个占位符对应一个Input/Output操作表达式;<br/>
带C/C++表达式的内联汇编中有两种占位符:序号占位符和名称占位符;</p>

<h5>1.序号占位符:</h5>

<p>GCC   规定:一个内联汇编语句中最多只能有10个Input/Output操作表达式,这些操作表达式按照他们被列出来的顺序依次赋予编号0到9;对于占位符中 的数字而言,与这些编号是对应的;比如:占位符%0对应编号为0的操作表达式,占位符%1对应编号为1的操作表达式,依次类推;</p>

<p>由于占位符前面要有一个百分号%,为了去边占位符与寄存器,GCC规定:在带有C/C++表达式的内联汇编语句的指令列表里列出的寄存器名称前面必须使用两个百分号(%%),一区别于占位符语法;
GCC对占位符进行编译的时候,会将每一个占位符替换为对应的Input/Output操作表达式所指定的寄存器/内存/立即数;</p>

<p>例如:<br/>
<code>__asm__("addl %1,%0 \t":"=a"(__out):"m"(__in1),"a"(__in2));</code><br/>
这 个语句中,%0对应Output操作表达式<code>"=a"(__out)</code>,而<code>"=a"(__out)</code>指定的寄存器是%eax,所以,占位符%0被替换 为%eax;占位符%1对应Input操作表达式<code>"m"(__in1),</code>而<code>"m"(__in1)</code>被指定为内存,所以,占位符%1被替换位__in1的内存 地址;</p>

<p>用一句话描述:序号占位符就是前面描述的%0、%1、%2、%3、%4、%5、%6、%7、%8、%9;其中,每一个占位符对应一个Input/Output的C/C++表达式;</p>

<h5>2.名称占位符:</h5>

<p>由于GCC中限制这种占位符的个数最多只能由这10个,这也就限制了Input/Output操作表达式中C/C++表达式的数量做多只能有10个;如果需要的C/C++表达式的数量超过10个,那么,这些需要占位符就不够用了;
GCC内联汇编提供了名称占位符来解决这个问题;即:使用一个名字字符串与一个C/C++表达式对应;这个名字字符串就称为名称占位符;而这个名字通常使用与C/C++表达式中的变量完全相同的名字;
使用名字占位符时,内联汇编的Input/Output操作表达式中的C/C++表达式的格式如下:<br/>
[name] &ldquo;constraint&rdquo;(变量)<br/>
此时,指令列表中的占位符的书写格式如下:<br/>
%[name]<br/>
这个格式等价于序号占位符中的%0,%1,$2等等;<br/>
使用名称占位符时,一个name对应一个变量;<br/>
例如:<br/>
<code>
    __asm__("imull %[value1],%[value2]"
            :[value2] "=r"(data2)
            :[value1] "r"(data1),"0"(data2));
</code>
此例中,名称占位符value1就对应变量data1,名称占位符value2对应变量data2;GCC编译的时候,同样会把这两个占位符分别替换成对应的变量所使用的寄存器/内存地址/立即数;而且也增强了代码的可读性;
这个例子,使用序号占位符的写法如下:
<code>
    __asm__("imull %1,%0"
            :"=r"(data2)
            :"r"(data1),"0"(data2));
</code></p>

<h4>五、寄存器/内存修改标示(Clobber/Modify)</h4>

<p>有时候,当你想通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改,希望GCC在编译时能够将这一点考虑进去;那么你就可以在Clobber/Modify部分声明这些寄存器或内存;</p>

<h5>1.寄存器修改通知:</h5>

<p>这 种情况一般发生在一个寄存器出现在指令列表中,但又不是Input/Output操作表达式所指定的,也不是在一些Input/Output操作表达式中 使用"r"或"g"约束时由GCC选择的,同时,此寄存器被指令列表中的指令所修改,而这个寄存器只供当前内联汇编语句使用的情况;比如:<br/>
<code>__asm__("movl %0,%%ebx"::"a"(__foo):"bx");</code><br/>
//这个内联汇编语句中,%ebx出现在指令列表中,并且被指令修改了,但是却未被任何Input/Output操作表达式是所指定,所以,你需要在Clobber/Modify部分指定"bx",以让GCC知道这一点;</p>

<p>因 为你在Input/Output操作表达式中指定的寄存器,或当你为一些Input/Output操作表达式使用"r"/&ldquo;g"约束,让GCC为你选择一 个寄存器时,GCC对这些寄存器的状态是非常清楚的,它知道这些寄存器是被修改的,你根本不需要在Clobber/Modify部分声明它们;但除此之 外,GCC对剩下的寄存器中哪些会被当前内联汇编语句所修改则一无所知;所以,如果你真的在当前内联汇编指令中修改了它们,那么就最好在  Clobber/Modify部分声明它们,让GCC针对这些寄存器做相应的处理;否则,有可能会造成寄存器不一致,从而造成程序执行错误;</p>

<p>在Clobber/Modify部分声明这些寄存器的方法很简单,只需要将寄存器的名字用双引号括起来就可以;如果要声明多个寄存器,则相邻两个寄存器名字之间用逗号隔开;</p>

<p>例如:<br/>
<code>__asm__("movl %0,%%ebx; popl %%ecx"::"a"(__foo):"bx","cx");</code><br/>
这个语句中,声明了bx和cx,告诉GCC:寄存器%ebx和%ecx可能会被修改,要求GCC考虑这个因素;<br/>
寄存器名称串:<br/>
<code>
"al"/"ax"/"eax":代表寄存器%eax
"bl"/"bx"/"ebx":代表寄存器%ebx
"cl"/"cx"/"ecx":代表寄存器%ecx
"dl"/"dx"/"edx":代表寄存器%edx
"si"/"esi":代表寄存器%esi
"di"/"edi":代表寄存器%edi
</code>
所以,只需要使用"ax",&ldquo;bx&rdquo;,&ldquo;cx&rdquo;,&ldquo;dx&rdquo;,&ldquo;si&rdquo;,&ldquo;di"就可以了,因为他们都代表对应的寄存器;<br/>
如 果你在一个内敛汇编语句的Clobber/Modify部分向GCC声明了某个寄存器内存发生了改变,GCC在编译时,如果发现这个被声明的寄存器的内容 在此内联汇编之后还要继续使用,那么,GCC会首先将此寄存器的内容保存起来,然后在此内联汇编语句的相关代码生成之后,再将其内容回复;</p>

<p>另外需 要注意的是,如果你在Clobber/Modify部分声明了一个寄存器,那么这个寄存器将不能再被用作当前内敛汇编语句的Input  /Output操作表达式的寄存器约束,如果Input/Output操作表达式的寄存器约束被指定为"r"/&ldquo;g&rdquo;,GCC也不会选择已经被声明在  Clobber /Modify部分中的寄存器;</p>

<p>例如:<br/>
<code>__asm__("movl %0,%%ebx"::"a"(__foo):"ax","bx");</code><br/>
这条语句中的Input操作表达式"a"(__foo)中已经指定了寄存器%eax,那么在Clobber/Modify部分中个列出的"ax"就是非法的;编译时,GCC会报错;</p>

<h5>2.内存修改通知:</h5>

<p>除 了寄存器的内容会被修改之外,内存的内容也会被修改;如果一个内联汇编语句的指令列表中的指令对内存进行了修改,或者在此内联汇编出现的地方,内存内容可 能发生改变,而被改变的内存地址你没有在其Output操作表达式中使用"m"约束,这种情况下,你需要使用在Clobber/Modify部分使用字符 串"memory"向GCC声明:&ldquo;在这里,内存发生了,或可能发生了改变&rdquo;;</p>

<p>例如:
<code>
    void* memset(void* s, char c, size_t count)
    {
      __asm__("cld \d"
              "rep \t"
              "stosb"
              :/*no output*/
              :"a"(c),"D"(s),"c"(count)
              :"cx","di","memory");
      return s;
    }
</code>
  如果一个内联汇编语句的Clobber/Modify部分存在"memory",那么GCC会保证在此内联汇编之前,如果某个内存的内容被装入了寄存器,  那么,在这个内联汇编之后,如果需要使用这个内存处的内容,就会直接到这个内存处重新读取,而不是使用被存放在寄存器中的拷贝;因为这个时候寄存器中的拷 贝很可能已经和内存处的内容不一致了;</p>

<h5>3.标志寄存器修改通知:</h5>

<p>当一个内联汇编中包含影响标志寄存器eflags的条件,那么也需要在Clobber/Modify部分中使用"cc"来向GCC声明这一点;</p>
]]></content>
  </entry>
  
</feed>
