<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug~mark | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug~mark/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-09-22T11:40:38+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Machine Check Exception]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/09/02/debug-mce/"/>
    <updated>2015-09-02T16:53:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/09/02/debug-mce</id>
    <content type="html"><![CDATA[<p>dmesg显示
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;sbridge: HANDLING MCE MEMORY ERROR
</span><span class='line'>CPU 0: Machine Check Exception: 0 Bank 5: 8c00004000010093
</span><span class='line'>TSC 0 ADDR 67081b300 MISC 2140040486 PROCESSOR 0:206d7 TIME 1441181676 SOCKET 0 APIC 0
</span><span class='line'>EDAC MC0: CE row 2, channel 0, label "CPU_SrcID#0_Channel#3_DIMM#0": 1 Unknown error(s): memory read on FATAL area : cpu=0 Err=0001:0093 (ch=3), addr= 0x67081b300 =&gt; socket=0, Channel=3(mask=8), rank=0
</span><span class='line'>
</span><span class='line'>...
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>保存4行log为mlog
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# mcelog --ascii &lt; /tmp/mlog
</span><span class='line'>WARNING: with --dmi mcelog --ascii must run on the same machine with the
</span><span class='line'> same BIOS/memory configuration as where the machine check occurred.
</span><span class='line'>sbridge: HANDLING MCE MEMORY ERROR
</span><span class='line'>CPU 0: Machine Check Exception: 0 Bank 5: 8c00004000010093
</span><span class='line'>HARDWARE ERROR. This is *NOT* a software problem!
</span><span class='line'>Please contact your hardware vendor
</span><span class='line'>Wed Sep  2 16:14:36 2015
</span><span class='line'>CPU 0 BANK 5 MISC 2140040486 ADDR 67081b300
</span><span class='line'>STATUS 8c00004000010093 MCGSTATUS 0
</span><span class='line'>CPUID Vendor Intel Family 6 Model 45
</span><span class='line'>WARNING: SMBIOS data is often unreliable. Take with a grain of salt!
</span><span class='line'>&lt;24&gt; DIMM 1333 Mhz Res13 Width 72 Data Width 64 Size 16 GB
</span><span class='line'>Device Locator: Node0_Channel2_Dimm0
</span><span class='line'>Bank Locator: Node0_Bank0
</span><span class='line'>Manufacturer: Hynix Semiconducto
</span><span class='line'>Serial Number: 40743B5A
</span><span class='line'>Asset Tag: Dimm2_AssetTag
</span><span class='line'>Part Number: HMT42GR7BFR4A-PB
</span><span class='line'>TSC 0 ADDR 67081b300 MISC 2140040486 PROCESSOR 0:206d7 TIME 1441181676 SOCKET 0 APIC 0
</span><span class='line'>EDAC MC0: CE row 2, channel 0, label "CPU_SrcID#0_Channel#3_DIMM#0": 1 Unknown error(s): memory read on FATAL area : cpu=0 Err=0001:0093 (ch=3), addr = 0x67081b300 =&gt; socket=0, Channel=3(mask=8), rank=0
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>根据  
</span><span class='line'>Part Number: HMT42GR7BFR4A-PB  
</span><span class='line'>Serial Number: 40743B5A  
</span><span class='line'>
</span><span class='line'>在lshw中找相应硬件
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;...
</span><span class='line'>
</span><span class='line'> *-memory:0
</span><span class='line'>      description: System Memory
</span><span class='line'>      physical id: 2d
</span><span class='line'>      slot: System board or motherboard
</span><span class='line'>    *-bank:0
</span><span class='line'>         description: DIMM 1333 MHz (0.8 ns)
</span><span class='line'>         product: HMT42GR7BFR4A-PB
</span><span class='line'>         vendor: Hynix Semiconducto
</span><span class='line'>         physical id: 0
</span><span class='line'>         serial: 905D21AE
</span><span class='line'>         slot: Node0_Channel1_Dimm0
</span><span class='line'>         size: 16GiB
</span><span class='line'>         width: 64 bits
</span><span class='line'>         clock: 1333MHz (0.8ns)
</span><span class='line'>    *-bank:1
</span><span class='line'>         description: DIMM Synchronous [empty]
</span><span class='line'>         product: A1_Dimm1_PartNumber
</span><span class='line'>         vendor: Dimm1_Manufacturer
</span><span class='line'>         physical id: 1
</span><span class='line'>         serial: Dimm1_SerNum
</span><span class='line'>         slot: Node0_Channel1_Dimm1
</span><span class='line'>         width: 64 bits
</span><span class='line'>    *-bank:2
</span><span class='line'>         description: DIMM 1333 MHz (0.8 ns)
</span><span class='line'>         product: HMT42GR7BFR4A-PB
</span><span class='line'>         vendor: Hynix Semiconducto
</span><span class='line'>         physical id: 2
</span><span class='line'>         serial: 40743B5A
</span><span class='line'>         slot: Node0_Channel2_Dimm0
</span><span class='line'>         size: 16GiB
</span><span class='line'>         width: 64 bits
</span><span class='line'>         clock: 1333MHz (0.8ns)
</span><span class='line'>
</span><span class='line'>    ...
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[ixgbe两个合并包功能]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/08/21/debug-ixgbe/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-08-21T15:29:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/08/21/debug-ixgbe&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://downloadmirror.intel.com/22919/eng/README.txt"&gt;http://downloadmirror.intel.com/22919/eng/README.txt&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://www.360doc.com/content/12/1101/17/9008018_245137867.shtml"&gt;http://www.360doc.com/content/12/1101/17/9008018_245137867.shtml&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;      LRO
</span><span class='line'>  ---
</span><span class='line'>  Large Receive Offload (LRO) is a technique for increasing inbound throughput
</span><span class='line'>  of high-bandwidth network connections by reducing CPU overhead. It works by
</span><span class='line'>  aggregating multiple incoming packets from a single stream into a larger 
</span><span class='line'>  buffer before they are passed higher up the networking stack, thus reducing
</span><span class='line'>  the number of packets that have to be processed. LRO combines multiple 
</span><span class='line'>  Ethernet frames into a single receive in the stack, thereby potentially 
</span><span class='line'>  decreasing CPU utilization for receives. 
</span><span class='line'>
</span><span class='line'>  IXGBE_NO_LRO is a compile time flag. The user can enable it at compile
</span><span class='line'>  time to remove support for LRO from the driver. The flag is used by adding 
</span><span class='line'>  CFLAGS_EXTRA="-DIXGBE_NO_LRO" to the make file when it's being compiled. 
</span><span class='line'>
</span><span class='line'>     make CFLAGS_EXTRA="-DIXGBE_NO_LRO" install
</span><span class='line'>
</span><span class='line'>  You can verify that the driver is using LRO by looking at these counters in 
</span><span class='line'>  ethtool:
</span><span class='line'>
</span><span class='line'>  lro_flushed - the total number of receives using LRO.
</span><span class='line'>  lro_aggregated - counts the total number of Ethernet packets that were combined.
</span><span class='line'>
</span><span class='line'>  NOTE: IPv6 and UDP are not supported by LRO.
</span><span class='line'>
</span><span class='line'>  HW RSC
</span><span class='line'>  ------
</span><span class='line'>  82599 and X540-based adapters support HW based receive side coalescing (RSC) 
</span><span class='line'>  which can merge multiple frames from the same IPv4 TCP/IP flow into a single
</span><span class='line'>  structure that can span one or more descriptors. It works similarly to SW
</span><span class='line'>  Large receive offload technique. By default HW RSC is enabled and SW LRO 
</span><span class='line'>  cannot be used for 82599 or X540-based adapters unless HW RSC is disabled.
</span><span class='line'>
</span><span class='line'>  IXGBE_NO_HW_RSC is a compile time flag. The user can enable it at compile 
</span><span class='line'>  time to remove support for HW RSC from the driver. The flag is used by adding 
</span><span class='line'>  CFLAGS_EXTRA="-DIXGBE_NO_HW_RSC" to the make file when it's being compiled.
</span><span class='line'>
</span><span class='line'>     make CFLAGS_EXTRA="-DIXGBE_NO_HW_RSC" install
</span><span class='line'>
</span><span class='line'>  You can verify that the driver is using HW RSC by looking at the counter in 
</span><span class='line'>  ethtool:
</span><span class='line'>
</span><span class='line'>     hw_rsc_count - counts the total number of Ethernet packets that were being
</span><span class='line'>     combined.
</span><span class='line'>
</span><span class='line'>    ...
</span><span class='line'>
</span><span class='line'>max_vfs
</span><span class='line'>-------
</span><span class='line'>Valid Range:   1-63
</span><span class='line'>Default Value: 0
</span><span class='line'>
</span><span class='line'>  If the value is greater than 0 it will also force the VMDq parameter to be 1
</span><span class='line'>  or more.
</span><span class='line'>
</span><span class='line'>  This parameter adds support for SR-IOV.  It causes the driver to spawn up to 
</span><span class='line'>  max_vfs worth of virtual function.  
</span><span class='line'>
</span><span class='line'>  NOTE: When either SR-IOV mode or VMDq mode is enabled, hardware VLAN 
</span><span class='line'>  filtering and VLAN tag stripping/insertion will remain enabled.
</span><span class='line'>  Please remove the old VLAN filter before the new VLAN filter is added.
</span><span class='line'>  For example, 
</span><span class='line'>
</span><span class='line'>    ip link set eth0 vf 0 vlan 100     // set vlan 100 for VF 0
</span><span class='line'>    ip link set eth0 vf 0 vlan 0       // Delete vlan 100 
</span><span class='line'>    ip link set eth0 vf 0 vlan 200     // set a new vlan 200 for VF 0
</span><span class='line'>
</span><span class='line'>The parameters for the driver are referenced by position.  So, if you have a 
</span><span class='line'>dual port 82599 or X540-based adapter and you want N virtual functions per 
</span><span class='line'>port, you must specify a number for each port with each parameter separated by
</span><span class='line'>a comma.
</span><span class='line'>
</span><span class='line'>For example:
</span><span class='line'>  modprobe ixgbe max_vfs=63,63
</span><span class='line'>
</span><span class='line'>NOTE: If both 82598 and 82599 or X540-based adapters are installed on the same 
</span><span class='line'>machine, you must be careful in loading the driver with the parameters. 
</span><span class='line'>Depending on system configuration, number of slots, etc. it's impossible to 
</span><span class='line'>predict in all cases where the positions would be on the command line and the 
</span><span class='line'>user will have to specify zero in those positions occupied by an 82598 port.
</span><span class='line'>
</span><span class='line'>With kernel 3.6, the driver supports the simultaneous usage of max_vfs and DCB 
</span><span class='line'>features, subject to the constraints described below. Prior to kernel 3.6, the 
</span><span class='line'>driver did not support the simultaneous operation of max_vfs &gt; 0 and the DCB 
</span><span class='line'>features (multiple traffic classes utilizing Priority Flow Control and Extended 
</span><span class='line'>Transmission Selection).
</span><span class='line'>
</span><span class='line'>When DCB is enabled, network traffic is transmitted and received through multiple 
</span><span class='line'>traffic classes (packet buffers in the NIC). The traffic is associated with a 
</span><span class='line'>specific class based on priority, which has a value of 0 through 7 used in the 
</span><span class='line'>VLAN tag. When SR-IOV is not enabled, each traffic class is associated with a set 
</span><span class='line'>of RX/TX descriptor queue pairs. The number of queue pairs for a given traffic 
</span><span class='line'>class depends on the hardware configuration. When SR-IOV is enabled, the descriptor 
</span><span class='line'>queue pairs are grouped into pools. The Physical Function (PF) and each Virtual 
</span><span class='line'>Function (VF) is allocated a pool of RX/TX descriptor queue pairs. When multiple 
</span><span class='line'>traffic classes are configured (for example, DCB is enabled), each pool contains a 
</span><span class='line'>queue pair from each traffic class. When a single traffic class is configured in 
</span><span class='line'>the hardware, the pools contain multiple queue pairs from the single traffic class.
</span><span class='line'>
</span><span class='line'>The number of VFs that can be allocated depends on the number of traffic classes 
</span><span class='line'>that can be enabled. The configurable number of traffic classes for each enabled 
</span><span class='line'>VF is as follows:
</span><span class='line'>
</span><span class='line'>  0 - 15 VFs = Up to 8 traffic classes, depending on device support
</span><span class='line'>
</span><span class='line'>  16 - 31 VFs = Up to 4 traffic classes
</span><span class='line'>
</span><span class='line'>  32 - 63 = 1 traffic class 
</span><span class='line'>
</span><span class='line'>When VFs are configured, the PF is allocated one pool as well. The PF supports 
</span><span class='line'>the DCB features with the constraint that each traffic class will only use a 
</span><span class='line'>single queue pair. When zero VFs are configured, the PF can support multiple 
</span><span class='line'>queue pairs per traffic class.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如果编译时disable了LRO，但没有disable RSC，可以用 ethtool -C eth2 rx-usecs 0 临时解决，或用 max_vfs=1 ？？？&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="https://bugzilla.redhat.com/show_bug.cgi?id=680998"&gt;https://bugzilla.redhat.com/show_bug.cgi?id=680998&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>Chris Wright has this board in hands, here the comment from him:
</span><span class='line'>&gt; OK, disabling hw RSC with 'ethtool -C eth2 rx-usecs 0' (thanks
</span><span class='line'>&gt; Herbert!) is bringing this back for me (something like ~1800 Mb/s).
</span><span class='line'>&gt; This is roughly what booting with max_vfs=1 should have done, so I'm not
</span><span class='line'>&gt; sure why that didn't work.
</span><span class='line'>
</span><span class='line'>Note that disabling coalescing with ethtool results in better, 
</span><span class='line'>though still poor performance as would be expected since we're disabling coalescing. 
</span><span class='line'>The "max_vfs=1" parameter disables RSC as a side-effect and 
</span><span class='line'>doesn't have the performance hit that disabling interrupt coalescing on the NIC does. 
</span><span class='line'>In internal testing, "max_vfs=1" results in ~2.5x better performance than using ethtool.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[tcp_collapse do not copy headers]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/05/15/debug-mark-tcp_collapse-bug/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-05-15T10:08:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/05/15/debug-mark-tcp_collapse-bug&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;pre&gt;&lt;code&gt;    commit b3d6cb92fd190d720a01075c4d20cdca896663fc
</span><span class='line'>Author: Eric Dumazet &lt;edumazet@google.com&gt;
</span><span class='line'>Date:   Mon Sep 15 04:19:53 2014 -0700
</span><span class='line'>
</span><span class='line'>    tcp: do not copy headers in tcp_collapse()
</span><span class='line'>
</span><span class='line'>    tcp_collapse() wants to shrink skb so that the overhead is minimal.
</span><span class='line'>
</span><span class='line'>    Now we store tcp flags into TCP_SKB_CB(skb)-&gt;tcp_flags, we no longer
</span><span class='line'>    need to keep around full headers.
</span><span class='line'>    Whole available space is dedicated to the payload.
</span><span class='line'>
</span><span class='line'>    Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
</span><span class='line'>    Acked-by: Neal Cardwell &lt;ncardwell@google.com&gt;
</span><span class='line'>    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
</span><span class='line'>index 228bf0c..ea92f23 100644
</span><span class='line'>--- a/net/ipv4/tcp_input.c
</span><span class='line'>+++ b/net/ipv4/tcp_input.c
</span><span class='line'>@@ -4535,26 +4535,13 @@ restart:
</span><span class='line'>        return;
</span><span class='line'>
</span><span class='line'>    while (before(start, end)) {
</span><span class='line'>+       int copy = min_t(int, SKB_MAX_ORDER(0, 0), end - start);
</span><span class='line'>        struct sk_buff *nskb;
</span><span class='line'>-       unsigned int header = skb_headroom(skb);
</span><span class='line'>-       int copy = SKB_MAX_ORDER(header, 0);
</span><span class='line'>
</span><span class='line'>-       /* Too big header? This can happen with IPv6. */
</span><span class='line'>-       if (copy &lt; 0)
</span><span class='line'>-           return;
</span><span class='line'>-       if (end - start &lt; copy)
</span><span class='line'>-           copy = end - start;
</span><span class='line'>-       nskb = alloc_skb(copy + header, GFP_ATOMIC);
</span><span class='line'>+       nskb = alloc_skb(copy, GFP_ATOMIC);
</span><span class='line'>        if (!nskb)
</span><span class='line'>            return;
</span><span class='line'>
</span><span class='line'>-       skb_set_mac_header(nskb, skb_mac_header(skb) - skb-&gt;head);
</span><span class='line'>-       skb_set_network_header(nskb, (skb_network_header(skb) -
</span><span class='line'>-                         skb-&gt;head));
</span><span class='line'>-       skb_set_transport_header(nskb, (skb_transport_header(skb) -
</span><span class='line'>-                       skb-&gt;head));
</span><span class='line'>-       skb_reserve(nskb, header);
</span><span class='line'>-       memcpy(nskb-&gt;head, skb-&gt;head, header);
</span><span class='line'>        memcpy(nskb-&gt;cb, skb-&gt;cb, sizeof(skb-&gt;cb));
</span><span class='line'>        TCP_SKB_CB(nskb)-&gt;seq = TCP_SKB_CB(nskb)-&gt;end_seq = start;
</span><span class='line'>        __skb_queue_before(list, skb, nskb);
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这个改进无形中修了一个BUG，但是这BUG正常情况下不会触发，除非我们对skb进行改动导致skb-&gt;data - skb-&gt;head = 4k时，如果此时内存紧张，且满足tcp_collapse合并条件才触发。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;BUG：
</span><span class='line'>tcp_collapse代码中有：</span></code></pre></td></tr></table></div></figure>
        while (before(start, end)) {
            struct sk_buff *nskb;
            unsigned int header = skb_headroom(skb);
            int copy = SKB_MAX_ORDER(header, 0);</p>

<pre><code>        /* Too big header? This can happen with IPv6. */
        if (copy &lt; 0) 
            return;

        ......

        /* Copy data, releasing collapsed skbs. */
        while (copy &gt; 0) { 
            int offset = start - TCP_SKB_CB(skb)-&gt;seq;
            int size = TCP_SKB_CB(skb)-&gt;end_seq - start;
</code></pre>

<pre><code>
也就是说如果header = 4k，那么copy = 0，那么会一直申请len=0的skb插入到receive队列，直到申请skb失败。这样就会造成tcp_recvmsg出错
</code></pre>

<pre><code>        skb_queue_walk(&amp;sk-&gt;sk_receive_queue, skb) {
            /* Now that we have two receive queues this
             * shouldn't happen.
             */
            if (WARN(before(*seq, TCP_SKB_CB(skb)-&gt;seq),
                 KERN_INFO "recvmsg bug: copied %X "
                       "seq %X rcvnxt %X fl %X\n", *seq,
                       TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt,
                       flags))
                break;

            offset = *seq - TCP_SKB_CB(skb)-&gt;seq;
            if (tcp_hdr(skb)-&gt;syn)
                offset--;
            if (offset &lt; skb-&gt;len)
                goto found_ok_skb;
            if (tcp_hdr(skb)-&gt;fin)
                goto found_fin_ok;
            WARN(!(flags &amp; MSG_PEEK), KERN_INFO "recvmsg bug 2: "
                    "copied %X seq %X rcvnxt %X fl %X\n",
                    *seq, TCP_SKB_CB(skb)-&gt;seq,
                    tp-&gt;rcv_nxt, flags);
        }
</code></pre>

<pre><code>因为offset = 0, len = 0, if (offset &lt; skb-&gt;len)就不符合，报WARN。而且如果申请的len=0的skb过多，会导致一直在这里循环，因为WARN有打印堆栈，执行很慢。

错误如下：
</code></pre>

<pre><code>WARNING: at net/ipv4/tcp.c:1457 tcp_recvmsg+0x96a/0xc20() (Tainted: G   W  ---------------   )
Hardware name: PowerEdge R620
Modules linked in: sha256_generic ws_st_tcp_cubic(U) ws_st(U) autofs4 i2c_dev i2c_core bonding 8021q garp stp llc be2iscsi iscsi_boot_sysfs ib]
Pid: 6964, comm: squid Tainted: G        W  ---------------    2.6.32-358.6.1.x86_64 #1
Call Trace:
 [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
 [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
 [&lt;ffffffff81069aa8&gt;] ? warn_slowpath_common+0x98/0xc0
 [&lt;ffffffff81069bce&gt;] ? warn_slowpath_fmt+0x6e/0x70
 [&lt;ffffffff814ce08e&gt;] ? _spin_lock_bh+0x2e/0x40
 [&lt;ffffffff813fea53&gt;] ? skb_release_data+0xb3/0x100
 [&lt;ffffffff813feb56&gt;] ? __kfree_skb+0x46/0xa0
 [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
 [&lt;ffffffff813f93c7&gt;] ? sock_common_recvmsg+0x37/0x50
 [&lt;ffffffff813f6b05&gt;] ? sock_aio_read+0x185/0x190
 [&lt;ffffffff81171912&gt;] ? do_sync_read+0xf2/0x130
 [&lt;ffffffff81090e60&gt;] ? autoremove_wake_function+0x0/0x40
 [&lt;ffffffff811b4a2c&gt;] ? sys_epoll_wait+0x21c/0x3f0
 [&lt;ffffffff8120b3b6&gt;] ? security_file_permission+0x16/0x20
 [&lt;ffffffff81171bab&gt;] ? vfs_read+0x18b/0x1a0
 [&lt;ffffffff81172df5&gt;] ? sys_read+0x55/0x90
 [&lt;ffffffff8100af72&gt;] ? system_call_fastpath+0x16/0x1b
---[ end trace ef9663ba0fc61730 ]---
------------[ cut here ]------------
WARNING: at net/ipv4/tcp.c:1457 tcp_recvmsg+0x96a/0xc20() (Tainted: G        W  ---------------   )
Hardware name: PowerEdge R620
Modules linked in: sha256_generic ws_st_tcp_cubic(U) ws_st(U) autofs4 i2c_dev i2c_core bonding 8021q garp stp llc be2iscsi iscsi_boot_sysfs ib]
Pid: 6964, comm: squid Tainted: G        W  ---------------    2.6.32-358.6.1.x86_64 #1
Call Trace:
 [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
 [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
 [&lt;ffffffff81069aa8&gt;] ? warn_slowpath_common+0x98/0xc0
 [&lt;ffffffff81069bce&gt;] ? warn_slowpath_fmt+0x6e/0x70
 [&lt;ffffffff814ce08e&gt;] ? _spin_lock_bh+0x2e/0x40
 [&lt;ffffffff813fea53&gt;] ? skb_release_data+0xb3/0x100
 [&lt;ffffffff813feb56&gt;] ? __kfree_skb+0x46/0xa0
 [&lt;ffffffff8144f1ca&gt;] ? tcp_recvmsg+0x96a/0xc20
 [&lt;ffffffff813f93c7&gt;] ? sock_common_recvmsg+0x37/0x50
 [&lt;ffffffff813f6b05&gt;] ? sock_aio_read+0x185/0x190
 [&lt;ffffffff81171912&gt;] ? do_sync_read+0xf2/0x130
 [&lt;ffffffff81090e60&gt;] ? autoremove_wake_function+0x0/0x40
 [&lt;ffffffff811b4a2c&gt;] ? sys_epoll_wait+0x21c/0x3f0
 [&lt;ffffffff8120b3b6&gt;] ? security_file_permission+0x16/0x20
 [&lt;ffffffff81171bab&gt;] ? vfs_read+0x18b/0x1a0
 [&lt;ffffffff81172df5&gt;] ? sys_read+0x55/0x90
 [&lt;ffffffff8100af72&gt;] ? system_call_fastpath+0x16/0x1b
---[ end trace ef9663ba0fc61731 ]---
------------[ cut here ]------------

.......
</code></pre>

<pre><code>
如果skb申请的不多，很快就能看到tcp_cleanup_rbuf的WARN，仔细观察会发现，这里打印的end_seq和上面的seq是一样的。
</code></pre>

<pre><code>void tcp_cleanup_rbuf(struct sock *sk, int copied)
{
    struct tcp_sock *tp = tcp_sk(sk);
    int time_to_ack = 0;

#if TCP_DEBUG
    struct sk_buff *skb = skb_peek(&amp;sk-&gt;sk_receive_queue);

    WARN(skb &amp;&amp; !before(tp-&gt;copied_seq, TCP_SKB_CB(skb)-&gt;end_seq),
         KERN_INFO "cleanup rbuf bug: copied %X seq %X rcvnxt %X\n",
         tp-&gt;copied_seq, TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;rcv_nxt);
#endif
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tcp_read_sock BUG]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/11/debug-mark-tcp_read_sock_bug/"/>
    <updated>2015-05-11T10:17:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/11/debug-mark-tcp_read_sock_bug</id>
    <content type="html"><![CDATA[<pre><code>    commit baff42ab1494528907bf4d5870359e31711746ae
    Author: Steven J. Magnani &lt;steve@digidescorp.com&gt;
    Date:   Tue Mar 30 13:56:01 2010 -0700

        net: Fix oops from tcp_collapse() when using splice()

        tcp_read_sock() can have a eat skbs without immediately advancing copied_seq.
        This can cause a panic in tcp_collapse() if it is called as a result
        of the recv_actor dropping the socket lock.

        A userspace program that splices data from a socket to either another
        socket or to a file can trigger this bug.

        Signed-off-by: Steven J. Magnani &lt;steve@digidescorp.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
</code></pre>

<pre><code>    diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
    index 6afb6d8..2c75f89 100644
    --- a/net/ipv4/tcp.c
    +++ b/net/ipv4/tcp.c
    @@ -1368,6 +1368,7 @@ int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,
            sk_eat_skb(sk, skb, 0);
            if (!desc-&gt;count)
                break;
    +       tp-&gt;copied_seq = seq;
        }
        tp-&gt;copied_seq = seq;
</code></pre>

<p>如果在tcp_read_sock中sk_eat_skb时copied_seq没有及时一起修改的话，就会出现copied_seq小于sk_write_queue队列第一个包的seq。<br/>
tcp_read_sock的recv_actor指向的函数(比如tcp_splice_data_recv)是有可能释放sk锁的，如果这时进入收包软中断且内存紧张调用tcp_collapse，<br/>
tcp_collapse中：<br/>
```
    start = copied_seq
    &hellip;
    int offset = start - TCP_SKB_CB(skb)->seq;</p>

<pre><code>BUG_ON(offset &lt; 0);
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tcp_match_skb_to_sack BUG]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/11/debug-mark-tcp_match_skb_to_sack_bug/"/>
    <updated>2015-05-11T10:09:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/11/debug-mark-tcp_match_skb_to_sack_bug</id>
    <content type="html"><![CDATA[<pre><code>    commit 2cd0d743b05e87445c54ca124a9916f22f16742e
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Wed Jun 18 21:15:03 2014 -0400

        tcp: fix tcp_match_skb_to_sack() for unaligned SACK at end of an skb

        If there is an MSS change (or misbehaving receiver) that causes a SACK
        to arrive that covers the end of an skb but is less than one MSS, then
        tcp_match_skb_to_sack() was rounding up pkt_len to the full length of
        the skb ("Round if necessary..."), then chopping all bytes off the skb
        and creating a zero-byte skb in the write queue.

        This was visible now because the recently simplified TLP logic in
        bef1909ee3ed1c ("tcp: fixing TLP's FIN recovery") could find that 0-byte
        skb at the end of the write queue, and now that we do not check that
        skb's length we could send it as a TLP probe.

        Consider the following example scenario:

         mss: 1000
         skb: seq: 0 end_seq: 4000  len: 4000
         SACK: start_seq: 3999 end_seq: 4000

        The tcp_match_skb_to_sack() code will compute:

         in_sack = false
         pkt_len = start_seq - TCP_SKB_CB(skb)-&gt;seq = 3999 - 0 = 3999
         new_len = (pkt_len / mss) * mss = (3999/1000)*1000 = 3000
         new_len += mss = 4000

        Previously we would find the new_len &gt; skb-&gt;len check failing, so we
        would fall through and set pkt_len = new_len = 4000 and chop off
        pkt_len of 4000 from the 4000-byte skb, leaving a 0-byte segment
        afterward in the write queue.

        With this new commit, we notice that the new new_len &gt;= skb-&gt;len check
        succeeds, so that we return without trying to fragment.

        Fixes: adb92db857ee ("tcp: Make SACK code to split only at mss boundaries")
        Reported-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Cc: Eric Dumazet &lt;edumazet@google.com&gt;
        Cc: Yuchung Cheng &lt;ycheng@google.com&gt;
        Cc: Ilpo Jarvinen &lt;ilpo.jarvinen@helsinki.fi&gt;
        Acked-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
</code></pre>

<pre><code>    diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
    index 40661fc..b5c2375 100644
    --- a/net/ipv4/tcp_input.c
    +++ b/net/ipv4/tcp_input.c
    @@ -1162,7 +1162,7 @@ static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,
                unsigned int new_len = (pkt_len / mss) * mss;
                if (!in_sack &amp;&amp; new_len &lt; pkt_len) {
                    new_len += mss;
    -               if (new_len &gt; skb-&gt;len)
    +               if (new_len &gt;= skb-&gt;len)
                        return 0;
                }
                pkt_len = new_len;
</code></pre>
]]></content>
  </entry>
  
</feed>
