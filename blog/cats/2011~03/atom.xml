<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2011~03 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2011~03/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-03-04T18:50:24+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[dancing links code 6-7]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/03/27/alg-dancing-links-source3/"/>
    <updated>2011-03-27T14:22:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/03/27/alg-dancing-links-source3</id>
    <content type="html"><![CDATA[<h5>六、pku 3074</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;
    #include&lt;math.h&gt;
    #include&lt;string.h&gt;

    using namespace std;

    const int MAXN = 1005;
    int L[MAXN*MAXN], R[MAXN*MAXN], U[MAXN*MAXN], D[MAXN*MAXN];
    int S[MAXN];
    int Col[MAXN*MAXN], Row[MAXN*MAXN],Ans[MAXN],ans,limit,up;

    void Remove(int c) {
        L[R[c]] = L[c];
        R[L[c]] = R[c];
        for (int i = D[c]; i != c; i = D[i])
            for (int j = R[i]; j != i; j = R[j]) {
                U[D[j]] = U[j];
                D[U[j]] = D[j];
                -- S[Col[j]];
            }
    }

    void Resume(int c) {
        for (int i = U[c]; i != c; i = U[i])
            for (int j = L[i]; j != i; j = L[j]) {
                U[D[j]] = j;
                D[U[j]] = j;
                ++ S[Col[j]];
            }
        L[R[c]] = c;
        R[L[c]] = c;
    }

    bool dfs(int depth) {
        if(R[0] == 0) { if(depth &gt; ans)ans = depth; return true; }
        int i, j, c, minnum = 1000000000;
        for (i = R[0]; i != 0; i = R[i]) {
            if (S[i] &lt; minnum) {
                minnum = S[i];
                c = i;
            }
        }
        Remove(c);
        for (i = U[c]; i != c; i = U[i]) {
            Ans[depth] = Row[i];
            for (j = R[i]; j != i; j = R[j]) Remove(Col[j]);
            if (dfs(depth + 1)) return true;
            for (j = L[i]; j != i; j = L[j]) Resume(Col[j]);
        }
        Resume(c);
        return false;
    }

    int solve(int n, int m, int DL[][MAXN]) {
        for (int i = 0; i &lt;= m; i ++) {
            L[i] = i - 1;
            R[i] = i + 1;
            U[i] = D[i] = i;
        }
        L[0] = m;
        R[m] = 0;
        int cnt = m + 1;
        memset(S, 0, sizeof (S));
        for (int i = 1; i &lt;= n; i ++) {
            int head = cnt, tail = cnt;
            for (int c = 1; c &lt;= m; c ++) if (DL[i][c]) {
                S[c] ++;
                Row[cnt] = i;
                Col[cnt] = c;
                U[D[c]] = cnt;
                D[cnt] = D[c];
                U[cnt] = c;
                D[c] = cnt;
                L[cnt] = tail;
                R[tail] = cnt;
                R[cnt] = head;
                L[head] = cnt;
                tail = cnt;
                cnt ++;
            }
        }
        if (dfs(0)) return true;
        return false;
    }

    int mark[MAXN][MAXN],x[MAXN],y[MAXN],z[MAXN];

    int main()
    {
        int i,j,k,l,n,m,T,boo,row,col,a[33][33],low,ok1[13][13],ok2[13][13],ok3[13][13],x1,y1,ii,jj;
        int id1[13][13],id2[13][13],id3[13][13],ok[13][13][13];

        char ch[999];
        while(scanf("%s",ch) != EOF &amp;&amp; strcmp(ch,"end") != 0)
        {
            k = 0;
            for(i=1;i&lt;=9;i++)
                for(j=1;j&lt;=9;j++)
                {
                    if(ch[k] != '.') a[i][j] = ch[k] - '0'; else a[i][j] = -1; k++;
                }


            for(i=1;i&lt;=9;i++)
                for(j=1;j&lt;=9;j++)
                if(a[i][j] == -1)
                    for(k=1;k&lt;=9;k++)
                    {
                        boo = 1;
                        for(l=1;l&lt;=9;l++)if(a[l][j] == k)boo = 0;
                        for(l=1;l&lt;=9;l++)if(a[i][l] == k)boo = 0;
                        x1 = (i-1)/3*3+1; y1 = (j-1)/3*3+1;

                        for(ii=x1;ii&lt;x1+3;ii++)
                            for(jj=y1;jj&lt;y1+3;jj++)
                            if(a[ii][jj] == k)boo = 0;

                        ok[i][j][k] = boo;
                    }

            row = 0; col = 0;
            for(j=1;j&lt;=9;j++)
                for(k=1;k&lt;=9;k++)
                {
                    boo = 1;
                    for(i=1;i&lt;=9;i++)if(a[i][j] == k)boo = 0;
                    if(boo == 1)
                    {
                        col++; id1[j][k] = col;
                    }
                    else
                        id1[j][k] = -1;
                }

            for(i=1;i&lt;=9;i++)
                for(k=1;k&lt;=9;k++)
                {
                    boo = 1;
                    for(j=1;j&lt;=9;j++)if(a[i][j] == k)boo = 0;
                    if(boo == 1)
                    {
                        col++; id2[i][k] = col;
                    }
                    else
                        id2[i][k] = -1;
                }

            for(i=1;i&lt;=9;i++)
            {
                x1 = (i-1)/3*3+1; y1 = (i-1)%3*3+1;
                for(k=1;k&lt;=9;k++)
                {
                    boo = 1;
                    for(ii=x1;ii&lt;x1+3;ii++)
                        for(jj=y1;jj&lt;y1+3;jj++)
                        if(a[ii][jj] == k)boo = 0;
                    if(boo == 1)
                    {
                        col++; id3[i][k] = col;
                    }
                    else id3[i][k] = -1;
                }
            }

            for(i=1;i&lt;=9;i++)
                for(j=1;j&lt;=9;j++)
                if(a[i][j] == -1)
                    for(k=1;k&lt;=9;k++)
                    if(ok[i][j][k] == 1)
                    {
                        row++; x[row] = i-1; y[row] = j-1; z[row] = k;
                        for(ii=1;ii&lt;=col;ii++)mark[row][ii] = 0;

                        mark[row][id1[j][k]] = 1;
                        mark[row][id2[i][k]] = 1;
                        mark[row][id3[(i-1)/3*3+(j-1)/3+1][k]] = 1;
                    }

            int rr=0;
            for(i=1;i&lt;=9;i++)
                for(j=1;j&lt;=9;j++)
                if(a[i][j] == -1)
                {
                    col++; for(k=1;k&lt;=row;k++)mark[k][col] = 0;
                    for(k=1;k&lt;=9;k++)
                    if(ok[i][j][k] == 1)
                    {
                        rr++; mark[rr][col] = 1;
                    }
                }

            ans = 0;
            k = solve(row, col, mark);

            for(i=0;i&lt;ans;i++)
            {
                ch[x[Ans[i]]*9+y[Ans[i]]] = z[Ans[i]] + 48;
            }
            printf("%s\n",ch);

        }
        return 0;
    }
</code></pre>

<hr />

<h5>七、pku 3076</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;
    #include&lt;math.h&gt;
    #include&lt;string.h&gt;

    using namespace std;

    const int MAXN = 2005;
    int L[MAXN*MAXN], R[MAXN*MAXN], U[MAXN*MAXN], D[MAXN*MAXN];
    int S[MAXN];
    int Col[MAXN*MAXN], Row[MAXN*MAXN],Ans[MAXN],ans,limit,up;


    void Remove(int c) {
        L[R[c]] = L[c];
        R[L[c]] = R[c];
        for (int i = D[c]; i != c; i = D[i])
            for (int j = R[i]; j != i; j = R[j]) {
                U[D[j]] = U[j];
                D[U[j]] = D[j];
                -- S[Col[j]];
            }
    }

    void Resume(int c) {
        for (int i = U[c]; i != c; i = U[i])
            for (int j = L[i]; j != i; j = L[j]) {
                U[D[j]] = j;
                D[U[j]] = j;
                ++ S[Col[j]];
            }
        L[R[c]] = c;
        R[L[c]] = c;
    }

    bool dfs(int depth) {
        // printf("ddd = %d  R0 = %d\n",depth,R[0]);
        if(R[0] == 0) { if(depth &gt; ans)ans = depth; return true; }
        int i, j, c, minnum = 1000000000;
        for (i = R[0]; i != 0; i = R[i]) {
            if (S[i] &lt; minnum) {
                minnum = S[i];
                c = i;
            }
        }
        Remove(c);
        for (i = U[c]; i != c; i = U[i]) {
            Ans[depth] = Row[i];
            for (j = R[i]; j != i; j = R[j]) Remove(Col[j]);
            if (dfs(depth + 1)) return true;
            for (j = L[i]; j != i; j = L[j]) Resume(Col[j]);
        }
        Resume(c);
        return false;
    }

    int solve(int n, int m, int DL[][MAXN]) {
        for (int i = 0; i &lt;= m; i ++) {
            L[i] = i - 1;
            R[i] = i + 1;
            U[i] = D[i] = i;
        }
        L[0] = m;
        R[m] = 0;
        int cnt = m + 1;
        memset(S, 0, sizeof (S));
        for (int i = 1; i &lt;= n; i ++) {
            int head = cnt, tail = cnt;
            for (int c = 1; c &lt;= m; c ++) if (DL[i][c]) {
                S[c] ++;
                Row[cnt] = i;
                Col[cnt] = c;
                U[D[c]] = cnt;
                D[cnt] = D[c];
                U[cnt] = c;
                D[c] = cnt;
                L[cnt] = tail;
                R[tail] = cnt;
                R[cnt] = head;
                L[head] = cnt;
                tail = cnt;
                cnt ++;
            }
        }
        if (dfs(0)) return true;
        return false;
    }


    int mark[MAXN][MAXN],x[MAXN],y[MAXN],z[MAXN];
    int id1[33][33],id2[33][33],id3[33][33],ok[33][33][33];

    int main()
    {
        int i,j,k,l,n,m,T,boo,row,col,a[33][33],low,ok1[33][33],ok2[33][33],ok3[33][33],x1,y1,ii,jj;

        char ch[999],cas=0;
        while(scanf("%s",ch) != EOF)
        {
            cas++; if(cas &gt; 1)printf("\n");
            k = 16;
            for(i=1;i&lt;16;i++)
            {
                scanf("%s",ch+k);
                k += 16;
            }//printf("safdsadfsdf\n");

            k = 0;
            for(i=1;i&lt;=16;i++)
                for(j=1;j&lt;=16;j++)
                {
                    if(ch[k] != '-') a[i][j] = ch[k] - 'A'+1; else a[i][j] = -1; k++;
                }

            for(i=1;i&lt;=16;i++)
                for(j=1;j&lt;=16;j++)
                if(a[i][j] == -1)
                    for(k=1;k&lt;=16;k++)
                    {
                        boo = 1;
                        for(l=1;l&lt;=16;l++)if(a[l][j] == k)boo = 0;
                        for(l=1;l&lt;=16;l++)if(a[i][l] == k)boo = 0;
                        x1 = (i-1)/4*4+1; y1 = (j-1)/4*4+1;

                        for(ii=x1;ii&lt;x1+4;ii++)
                            for(jj=y1;jj&lt;y1+4;jj++)
                            if(a[ii][jj] == k)boo = 0;

                        ok[i][j][k] = boo;
                    }

            row = 0; col = 0;
            for(j=1;j&lt;=16;j++)
                for(k=1;k&lt;=16;k++)
                {
                    boo = 1;
                    for(i=1;i&lt;=16;i++)if(a[i][j] == k)boo = 0;
                    if(boo == 1)
                    {
                        col++; id1[j][k] = col;
                    }
                    else
                        id1[j][k] = -1;
                }

            for(i=1;i&lt;=16;i++)
                for(k=1;k&lt;=16;k++)
                {
                    boo = 1;
                    for(j=1;j&lt;=16;j++)if(a[i][j] == k)boo = 0;
                    if(boo == 1)
                    {
                        col++; id2[i][k] = col;
                    }
                    else
                        id2[i][k] = -1;
                }

            for(i=1;i&lt;=16;i++)
            {
                x1 = (i-1)/4*4+1; y1 = (i-1)%4*4+1;
                for(k=1;k&lt;=16;k++)
                {
                    boo = 1;
                    for(ii=x1;ii&lt;x1+4;ii++)
                        for(jj=y1;jj&lt;y1+4;jj++)
                        if(a[ii][jj] == k)boo = 0;
                    if(boo == 1)
                    {
                        col++; id3[i][k] = col;
                    }
                    else id3[i][k] = -1;
                }
            }

            for(i=1;i&lt;=16;i++)
                for(j=1;j&lt;=16;j++)
            if(a[i][j] == -1)
                for(k=1;k&lt;=16;k++)
            if(ok[i][j][k] == 1)
            {
                row++; x[row] = i-1; y[row] = j-1; z[row] = k;
                //if(i == 1 &amp;&amp; j == 7 &amp;&amp; k == 4)printf("row ===== %d\n",row);
                for(ii=1;ii&lt;=col;ii++)mark[row][ii] = 0;

                mark[row][id1[j][k]] = 1;
                mark[row][id2[i][k]] = 1;
                mark[row][id3[(i-1)/4*4+(j-1)/4+1][k]] = 1;
            }

            int rr=0;
            for(i=1;i&lt;=16;i++)
                for(j=1;j&lt;=16;j++)
                if(a[i][j] == -1)
                {
                    col++; for(k=1;k&lt;=row;k++)mark[k][col] = 0;
                    for(k=1;k&lt;=16;k++)
                    if(ok[i][j][k] == 1)
                    {
                        rr++; mark[rr][col] = 1;
                    }
                }


            //printf("%d %d\n",row,col);
            //freopen("out.txt","w",stdout);

        /* for(i=1;i&lt;=row;i++)
            {
                printf("%d %d %d   ",x[i],y[i],z[i]);
                for(j=1;j&lt;=col;j++)
                printf("%d ",mark[i][j]);
                printf("\n");
            }*/
            //fclose(stdout);

            ans = 0;
            k = solve(row, col, mark);

        // printf("%d k = %d %d %d\n",ans,id1[7][4],id2[1][4],id3[3][4]);

            for(i=0;i&lt;ans;i++)
            {
            // printf("%d   %d %d %d\n",Ans[i],x[Ans[i]],y[Ans[i]],z[Ans[i]]);
                ch[x[Ans[i]]*16+y[Ans[i]]] = z[Ans[i]] + 'A'-1;
            }
            //printf("\n");*/

            for(i=0;i&lt;16*16;i++)
            {
                printf("%c",ch[i]);
                if(i!=0 &amp;&amp; (i+1)%16 == 0)printf("\n");
            }
        }
        return 0;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dancing links code 4-5]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/03/27/alg-dancing-links-source2/"/>
    <updated>2011-03-27T14:21:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/03/27/alg-dancing-links-source2</id>
    <content type="html"><![CDATA[<h5>四、hdu 3663</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;
    #include&lt;math.h&gt;
    #include&lt;string.h&gt;

    using namespace std;

    int n,m,DD,a[66][66],s[66],f[66],id[66][6];

    const int MAXN = 1005;

    int L[MAXN*MAXN], R[MAXN*MAXN], U[MAXN*MAXN], D[MAXN*MAXN];
    int S[MAXN];
    int Col[MAXN*MAXN], Row[MAXN*MAXN],Ans[MAXN],ans,limit,up;


    void Remove(int c) {
        L[R[c]] = L[c];
        R[L[c]] = R[c];
        for (int i = D[c]; i != c; i = D[i])
        for (int j = R[i]; j != i; j = R[j]) {
            U[D[j]] = U[j];
            D[U[j]] = D[j];
            -- S[Col[j]];
        }
    }
    void Resume(int c) {
        for (int i = U[c]; i != c; i = U[i])
        for (int j = L[i]; j != i; j = L[j]) {
            U[D[j]] = j;
            D[U[j]] = j;
            ++ S[Col[j]];
        }
        L[R[c]] = c;
        R[L[c]] = c;
    }

    bool dfs(int depth) {
    //    printf("ddd = %d  R0 = %d\n",depth,R[0]);
        if(R[0] == 0) { if(depth &gt; ans)ans = depth; return true; }
        int i, j, c, minnum = 1000000000;
        for (i = R[0]; i != 0; i = R[i]) {
            if (S[i] &lt; minnum) {
                minnum = S[i];
                c = i;
            }
        }
        Remove(c);
        for (i = U[c]; i != c; i = U[i]) {
            Ans[depth] = Row[i];
            for (j = R[i]; j != i; j = R[j]) Remove(Col[j]);
            if (dfs(depth + 1)) return true;
            for (j = L[i]; j != i; j = L[j]) Resume(Col[j]);
        }
        Resume(c);
        return false;
    }
    int solve(int n, int m, int DL[][MAXN]) {
        for (int i = 0; i &lt;= m; i ++) {
            L[i] = i - 1;
            R[i] = i + 1;
            U[i] = D[i] = i;
        }
        L[0] = m;
        R[m] = 0;
        int cnt = m + 1;
        memset(S, 0, sizeof (S));
        for (int i = 1; i &lt;= n; i ++) {
            int head = cnt, tail = cnt;
            for (int c = 1; c &lt;= m; c ++) if (DL[i][c]) {
                S[c] ++;
                Row[cnt] = i;
                Col[cnt] = c;
                U[D[c]] = cnt;
                D[cnt] = D[c];
                U[cnt] = c;
                D[c] = cnt;
                L[cnt] = tail;
                R[tail] = cnt;
                R[cnt] = head;
                L[head] = cnt;
                tail = cnt;
                cnt ++;
            }
        }
        if (dfs(0)) return true;
        return false;
    }


    int mark[MAXN][MAXN],x[MAXN],y[MAXN],z[MAXN];

    int main()
    {
        int i,j,k,l,row,col,g;
        while(scanf("%d %d %d",&amp;n,&amp;m,&amp;DD) != EOF)
        {
            for(i=1;i&lt;=n;i++)
                for(j=1;j&lt;=n;j++)
                {
                    a[i][j] = 0;
                    if(i == j)a[i][j] = 1;
                }
            while(m--) {
                scanf("%d %d",&amp;j,&amp;k);
                a[j][k] = a[k][j] = 1;
            }
            for(i=1;i&lt;=n;i++)scanf("%d %d",&amp;s[i],&amp;f[i]);

            col = 0;
            for(i=1;i&lt;=n;i++)
                for(j=1;j&lt;=DD;j++)
                    id[i][j] = ++col;

            row = 0;
            for(i=1;i&lt;=n;i++)
            {
                for(j=s[i];j&lt;=f[i];j++)
                    for(k=j;k&lt;=f[i];k++)
                    {
                        row++; x[row] = j; y[row] = k; z[row] = i;
                        for(l=1;l&lt;=col;l++)mark[row][l] = 0;

                        for(l=1;l&lt;=n;l++)if(a[i][l] == 1)
                        {
                            for(g=j;g&lt;=k;g++) mark[row][id[l][g]] = 1;
                        }
                    }
            }

            int rr=0;

            for(i=1;i&lt;=n;i++)
            {
                col++;
                for(j=1;j&lt;=row;j++)mark[j][col] = 0;

                for(j=s[i];j&lt;=f[i];j++)
                    for(k=j;k&lt;=f[i];k++)
                    {
                        rr++;
                        mark[rr][col] = 1;
                    }
            }

            int TT = row;
            for(i=1;i&lt;=n;i++)
            {
                row++;
                for(j=1;j&lt;=col;j++)mark[row][j] = 0;
                mark[row][col-n+i] = 1;
            }

            ans = 0;

            k = solve(row, col, mark);

            if(k == 0)
                printf("No solution\n");
            else
            {
                for(i=1;i&lt;=n;i++)s[i] = f[i] = 0;
                for(i=0;i&lt;ans;i++)
                if(Ans[i] &lt;= TT)
                {
                    s[z[Ans[i]]] = x[Ans[i]];
                    f[z[Ans[i]]] = y[Ans[i]];
                }
                for(i=1;i&lt;=n;i++)printf("%d %d\n",s[i],f[i]);
            }
            printf("\n");
        }
        return 0;
    }
</code></pre>

<h5>五、hdu 2995</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;
    #include&lt;math.h&gt;
    #include&lt;string.h&gt;

    using namespace std;

    const int MAXN = 225;
    int L[MAXN*MAXN], R[MAXN*MAXN], U[MAXN*MAXN], D[MAXN*MAXN];
    int S[MAXN];
    int Col[MAXN*MAXN];
    int limit;

    void Remove(int x) {
        for (int i = D[x]; i != x; i = D[i]) {
            L[R[i]] = L[i];
            R[L[i]] = R[i];
        }
    }
    void Resume(int x) {
        for (int i = U[x]; i != x; i = U[i]) {
            L[R[i]] = R[L[i]] = i;
        }
    }
    int Hash() {
        int ans = 0;
        bool hash[MAXN] = {0};
        for (int c = R[0]; c != 0; c = R[c])
        if (! hash[c]) {
            hash[c] = true;
            ans ++;
            for (int i = D[c]; i != c; i = D[i])
                for (int j = R[i]; j != i; j = R[j])
                    hash[Col[j]] = true;
        }
        return ans;
    }

    bool dfs(int depth) {
        if (depth + Hash() &gt; limit) return false;
        if (R[0] == 0) return true;
        int i, j, c, minnum = 2000000000;
        for (i = R[0]; i != 0; i = R[i]) {
            if (S[i] &lt; minnum) {
                minnum = S[i];
                c = i;
            }
        }
        for (i = U[c]; i != c; i = U[i]) {
            Remove(i);
            for (j = R[i]; j != i; j = R[j]) Remove(j);
            if (dfs(depth + 1)) {
                for (j = L[i]; j != i; j = L[j]) Resume(j);
                Resume(i);
                return true;
            }
            for (j = L[i]; j != i; j = L[j]) Resume(j);
            Resume(i);
        }
        return false;
    }

    int solve(int n, int m, int DL[][MAXN], int maxdepth) {
        if (maxdepth &gt; n) maxdepth = n;
        for (int i = 0; i &lt;= m; i ++) {
            L[i] = i - 1;
            R[i] = i + 1;
            U[i] = D[i] = i;
        }
        L[0] = m;
        R[m] = 0;
        int cnt = m + 1;
        memset(S, 0, sizeof (S));
        for (int i = 1; i &lt;= n; i ++) {
            int head = cnt, tail = cnt;
            for (int c = 1; c &lt;= m; c ++) if (DL[i][c]) {
                S[c] ++;
                Col[cnt] = c;
                U[D[c]] = cnt;
                D[cnt] = D[c];
                U[cnt] = c;
                D[c] = cnt;
                L[cnt] = tail;
                R[tail] = cnt;
                R[cnt] = head;
                L[head] = cnt;
                tail = cnt;
                cnt ++;
            }
        }
        int best = 0, worst = maxdepth;
        /*while (best &lt;= worst) {
            limit = (worst + best) &gt;&gt; 1;
            if (dfs(0)) worst = limit - 1;
            else best = limit + 1;
        }*/
        limit = maxdepth;
        if(dfs(0))best = maxdepth;
        else
            best = maxdepth+1;
        return best;
    }

    int x[155],y[155];

    int dij(int i, int j)
    {
        int d1 = (x[i]-x[j])*(x[i]-x[j]);
        int d2 = (y[i]-y[j])*(y[i]-y[j]);
        return d1+d2;
    }

    int main()
    {
        int i,j,k,l,row,col,n,m,low,up,mid,mark[MAXN][MAXN],d[55][55],T,b[3000],top;

        scanf("%d",&amp;T);
        while(T--)
        {
            scanf("%d %d %d",&amp;n,&amp;row,&amp;m);

            for(i=1;i&lt;=n+row;i++)
                scanf("%d %d",&amp;x[i],&amp;y[i]);

            low = 1; up = 1000000000;

            while(low &lt; up)
            {
                for(i=1;i&lt;=row;i++)
                    for(j=1;j&lt;=n;j++)mark[i][j] = 0;

                mid = (low + up)&gt;&gt;1;
                for(i=1;i&lt;=row;i++)
                    for(j=1;j&lt;=n;j++)if(dij(i+n,j) &lt;= mid)mark[i][j] = 1;

                if(solve(row, n, mark, m) &gt; m)low = mid+1; else up = mid;
            }
            mid = (low + up)&gt;&gt;1;
            printf("%.6lf\n",sqrt(1.0*mid));
        }
        return 0;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dancing links code 1-3]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/03/27/alg-dancing-links-source1/"/>
    <updated>2011-03-27T14:20:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/03/27/alg-dancing-links-source1</id>
    <content type="html"><![CDATA[<h5>一、fzu 1686</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;

    using namespace std;

    const int MAXN = 225;
    int L[MAXN*MAXN], R[MAXN*MAXN], U[MAXN*MAXN], D[MAXN*MAXN];
    int S[MAXN];
    int Col[MAXN*MAXN];
    int limit;

    void Remove(int x) {
        for (int i = D[x]; i != x; i = D[i]) {
            L[R[i]] = L[i];
            R[L[i]] = R[i];
        }
    }
    void Resume(int x) {
        for (int i = U[x]; i != x; i = U[i]) {
            L[R[i]] = R[L[i]] = i;
        }
    }
    int Hash() {
        int ans = 0;
        bool hash[MAXN] = {0};
        for (int c = R[0]; c != 0; c = R[c])
        if (! hash[c]) {
            hash[c] = true;
            ans ++;
            for (int i = D[c]; i != c; i = D[i])
                for (int j = R[i]; j != i; j = R[j])
                    hash[Col[j]] = true;
        }
        return ans;
    }

    bool dfs(int depth) {
        if (depth + Hash() &gt; limit) return false;
        if (R[0] == 0) return true;
        int i, j, c, minnum = INT_MAX;
        for (i = R[0]; i != 0; i = R[i]) {
            if (S[i] &lt; minnum) {
                minnum = S[i];
                c = i;
            }
        }
        for (i = U[c]; i != c; i = U[i]) {
            Remove(i);
            for (j = R[i]; j != i; j = R[j]) Remove(j);
            if (dfs(depth + 1)) {
                for (j = L[i]; j != i; j = L[j]) Resume(j);
                Resume(i);
                return true;
            }
            for (j = L[i]; j != i; j = L[j]) Resume(j);
            Resume(i);
        }
        return false;
    }

    int solve(int n, int m, int DL[][MAXN], int maxdepth) {
        if (maxdepth &gt; n) maxdepth = n;
        for (int i = 0; i &lt;= m; i ++) {
            L[i] = i - 1;
            R[i] = i + 1;
            U[i] = D[i] = i;
        }
        L[0] = m;
        R[m] = 0;
        int cnt = m + 1;
        memset(S, 0, sizeof (S));
        for (int i = 1; i &lt;= n; i ++) {
            int head = cnt, tail = cnt;
            for (int c = 1; c &lt;= m; c ++) if (DL[i][c]) {
                S[c] ++;
                Col[cnt] = c;
                U[D[c]] = cnt;
                D[cnt] = D[c];
                U[cnt] = c;
                D[c] = cnt;
                L[cnt] = tail;
                R[tail] = cnt;
                R[cnt] = head;
                L[head] = cnt;
                tail = cnt;
                cnt ++;
            }
        }
        int best = 0, worst = maxdepth;
        while (best &lt;= worst) {
            limit = (worst + best) &gt;&gt; 1;
            if (dfs(0)) worst = limit - 1;
            else best = limit + 1;
        }
        return best;
    }

    int main()
    {
        int i,j,k,l,row,col,n,m,n1,m1,mark[MAXN][MAXN],a[33][33],id[33][33];

        while(scanf("%d %d",&amp;n,&amp;m) != EOF)
        {
            col = 0;
            for(i=1;i&lt;=n;i++)
                for(j=1;j&lt;=m;j++)
                {
                    scanf("%d",&amp;a[i][j]);
                    id[i][j] = -1;
                    if(a[i][j] == 1) { col++; id[i][j] = col; }
                }
            scanf("%d %d",&amp;n1,&amp;m1);

            row = 0;
            for(i=1;i&lt;=n-n1+1;i++)
                for(j=1;j&lt;=m-m1+1;j++)
                {
                    row++;
                    for(k=1;k&lt;=col;k++)mark[row][k] = 0;

                    for(k=i;k&lt;i+n1;k++)
                        for(l=j;l&lt;j+m1;l++)
                        if(id[k][l] &gt; 0)
                            mark[row][id[k][l]] = 1;
                }

            printf("%d\n",solve(row, col, mark, row));
        }
        return 0;
    }
</code></pre>

<hr />

<h5>二、zju 3209</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;
    #include&lt;math.h&gt;
    #include&lt;string.h&gt;

    using namespace std;

    const int MAXN = 1005;
    int L[MAXN*MAXN], R[MAXN*MAXN], U[MAXN*MAXN], D[MAXN*MAXN];
    int S[MAXN];
    int Col[MAXN*MAXN], Row[MAXN*MAXN],ans,limit,up;


    void Remove(int c) {
        L[R[c]] = L[c];
        R[L[c]] = R[c];
        for (int i = D[c]; i != c; i = D[i])
        for (int j = R[i]; j != i; j = R[j]) {
            U[D[j]] = U[j];
            D[U[j]] = D[j];
            -- S[Col[j]];
        }
    }
    void Resume(int c) {
        for (int i = U[c]; i != c; i = U[i])
        for (int j = L[i]; j != i; j = L[j]) {
            U[D[j]] = j;
            D[U[j]] = j;
            ++ S[Col[j]];
        }
        L[R[c]] = c;
        R[L[c]] = c;
    }

    bool dfs(int depth) {
        if (depth &gt;= ans) return true;

        if(R[0] == 0) { if(depth &lt; ans)ans = depth;  return true; }

        int i, j, c, minnum = 2000000000, flag = 0;
        for (i = R[0]; i != 0; i = R[i]) {
            if (S[i] &lt; minnum) {
                minnum = S[i];
                c = i;
            }
        }
        Remove(c);
        for (i = U[c]; i != c; i = U[i]) {
            //如果需要的话，在这里记录一组解(Ans[depth] = Row[i])
            for (j = R[i]; j != i; j = R[j]) Remove(Col[j]);
            if (dfs(depth + 1)) flag = 1; //return true;
            for (j = L[i]; j != i; j = L[j]) Resume(Col[j]);
        }
        Resume(c);
        return flag;//false;
    }
    int solve(int n, int m, int DL[][MAXN]) {
        for (int i = 0; i &lt;= m; i ++) {
            L[i] = i - 1;
            R[i] = i + 1;
            U[i] = D[i] = i;
        }
        L[0] = m;
        R[m] = 0;
        int cnt = m + 1;
        memset(S, 0, sizeof (S));
        for (int i = 1; i &lt;= n; i ++) {
            int head = cnt, tail = cnt;
            for (int c = 1; c &lt;= m; c ++) if (DL[i][c]) {
                S[c] ++;
                Row[cnt] = i;
                Col[cnt] = c;
                U[D[c]] = cnt;
                D[cnt] = D[c];
                U[cnt] = c;
                D[c] = cnt;
                L[cnt] = tail;
                R[tail] = cnt;
                R[cnt] = head;
                L[head] = cnt;
                tail = cnt;
                cnt ++;
            }
        }
        if (dfs(0)) return true;
        return false;
    }

    int mark[MAXN][MAXN];

    int main()
    {
        int i,j,k,l,n,m,T,row,col,x1,x2,y1,y2,id[33][33],low;
        scanf("%d",&amp;T);
        while(T--)
        {
            scanf("%d %d %d",&amp;n,&amp;m,&amp;row);
            col = 0;
            for(i=1;i&lt;=n;i++)
                for(j=1;j&lt;=m;j++)
                {
                    col++; id[i][j] = col;
                }

            for(i=1;i&lt;=row;i++)
                for(j=1;j&lt;=col;j++)mark[i][j] = 0;

            for(i=1;i&lt;=row;i++)
            {
                scanf("%d %d %d %d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
                x1++; y1++;
                for(k=x1;k&lt;=x2;k++)
                    for(l=y1;l&lt;=y2;l++)
                    mark[i][id[k][l]] = 1;
            }

            ans = 1000000000;
            if(!solve(row, col, mark))ans = -1;

            printf("%d\n",ans);
        }
        return 0;
    }
</code></pre>

<hr />

<h5>三、hdu 3529</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;

    using namespace std;

    const int MAXN = 225;
    int L[MAXN*MAXN], R[MAXN*MAXN], U[MAXN*MAXN], D[MAXN*MAXN];
    int S[MAXN];
    int Col[MAXN*MAXN];
    int limit;

    void Remove(int x) {
        for (int i = D[x]; i != x; i = D[i]) {
            L[R[i]] = L[i];
            R[L[i]] = R[i];
        }
    }
    void Resume(int x) {
        for (int i = U[x]; i != x; i = U[i]) {
            L[R[i]] = R[L[i]] = i;
        }
    }
    int Hash() {
        int ans = 0;
        bool hash[MAXN] = {0};
        for (int c = R[0]; c != 0; c = R[c])
        if (! hash[c]) {
            hash[c] = true;
            ans ++;
            for (int i = D[c]; i != c; i = D[i])
            for (int j = R[i]; j != i; j = R[j])
            hash[Col[j]] = true;
        }
        return ans;
    }

    bool dfs(int depth) {
        if (depth + Hash() &gt; limit) return false;
        if (R[0] == 0) return true;
        int i, j, c, minnum = 2000000000;
        for (i = R[0]; i != 0; i = R[i]) {
            if (S[i] &lt; minnum) {
                minnum = S[i];
                c = i;
            }
        }
        for (i = U[c]; i != c; i = U[i]) {
            Remove(i);
            for (j = R[i]; j != i; j = R[j]) Remove(j);
            if (dfs(depth + 1)) {
                for (j = L[i]; j != i; j = L[j]) Resume(j);
                Resume(i);
                return true;
            }
            for (j = L[i]; j != i; j = L[j]) Resume(j);
            Resume(i);
        }
        return false;
    }

    int solve(int n, int m, int DL[][MAXN], int maxdepth) {
        if (maxdepth &gt; n) maxdepth = n;
        for (int i = 0; i &lt;= m; i ++) {
                L[i] = i - 1;
                R[i] = i + 1;
                U[i] = D[i] = i;
            }
            L[0] = m;
            R[m] = 0;
            int cnt = m + 1;
            memset(S, 0, sizeof (S));
            for (int i = 1; i &lt;= n; i ++) {
                int head = cnt, tail = cnt;
                for (int c = 1; c &lt;= m; c ++) if (DL[i][c]) {
                    S[c] ++;
                    Col[cnt] = c;
                    U[D[c]] = cnt;
                    D[cnt] = D[c];
                    U[cnt] = c;
                    D[c] = cnt;
                    L[cnt] = tail;
                    R[tail] = cnt;
                    R[cnt] = head;
                    L[head] = cnt;
                    tail = cnt;
                    cnt ++;
                }
            }
            int best = 0, worst = maxdepth;
            while (best &lt;= worst) {
            limit = (worst + best) &gt;&gt; 1;
            if (dfs(0)) worst = limit - 1;
            else best = limit + 1;
        }
        return best;
    }

    int n,m,M[MAXN][MAXN];

    int main()
    {
        int i,j,k,l,row,col,idr[33][33],idc[33][33];

        char ch[33][33];
        while(scanf("%d %d",&amp;n,&amp;m) != EOF)
        {
            for(i=1;i&lt;=n;i++) scanf("%s",ch[i]+1);

            row = col = 0;

            for(i=1;i&lt;=n;i++)
                for(j=1;j&lt;=m;j++)
                if(ch[i][j] == '.') idr[i][j] = ++row;
                else
                if(ch[i][j] == '#') idc[i][j] = ++col;

            for(i=0;i&lt;=row;i++) for(j=0;j&lt;=col;j++) M[i][j] = 0;

            for(i=1;i&lt;=n;i++)
                for(j=1;j&lt;=m;j++)
                if(ch[i][j] == '.')
                {
                    k = i-1; l = j; while(k &gt; 0 &amp;&amp; ch[k][l] == '.') k--;
                    if(k &gt; 0 &amp;&amp; ch[k][l] == '#') M[idr[i][j]][idc[k][l]] = 1;

                    k = i+1; l = j; while(k &lt;= n &amp;&amp; ch[k][l] == '.') k++;
                    if(k &lt;= n &amp;&amp; ch[k][l] == '#') M[idr[i][j]][idc[k][l]] = 1;

                    k = i; l = j-1; while(l &gt; 0 &amp;&amp; ch[k][l] == '.') l--;
                    if(l &gt; 0 &amp;&amp; ch[k][l] == '#') M[idr[i][j]][idc[k][l]] = 1;

                    k = i; l = j+1; while(l &lt;= m &amp;&amp; ch[k][l] == '.') l++;
                    if(l &lt;= m &amp;&amp; ch[k][l] == '#') M[idr[i][j]][idc[k][l]] = 1;
                }

            int ans = solve(row, col, M, col);
            printf("%d\n",ans);
        }
        return 0;  
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dancing links]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/03/24/alg-dancing-links/"/>
    <updated>2011-03-24T23:12:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/03/24/alg-dancing-links</id>
    <content type="html"><![CDATA[<p>Knuth Dancing_Links 中文版 <a href="http://www.docin.com/p-31928825.html">http://www.docin.com/p-31928825.html</a></p>

<p><a href="http://acm.fzu.edu.cn/problem.php?pid=1686">http://acm.fzu.edu.cn/problem.php?pid=1686</a></p>

<p><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3209">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3209</a></p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3529">http://acm.hdu.edu.cn/showproblem.php?pid=3529</a></p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3663">http://acm.hdu.edu.cn/showproblem.php?pid=3663</a></p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2295">http://acm.hdu.edu.cn/showproblem.php?pid=2295</a></p>

<p><a href="http://poj.org/problem?id=3074">http://poj.org/problem?id=3074</a></p>

<p><a href="http://poj.org/problem?id=3076">http://poj.org/problem?id=3076</a></p>

<h5>// fzu 1686</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;

    using namespace std;

    const int MAXN = 225;
    int L[MAXN*MAXN], R[MAXN*MAXN], U[MAXN*MAXN], D[MAXN*MAXN];
    int S[MAXN];
    int Col[MAXN*MAXN];
    int limit;

    void Remove(int x) {
        for (int i = D[x]; i != x; i = D[i]) {
        L[R[i]] = L[i];
        R[L[i]] = R[i];
        }
    }
    void Resume(int x) {
        for (int i = U[x]; i != x; i = U[i]) {
        L[R[i]] = R[L[i]] = i;
        }
    }
    int Hash() {
        int ans = 0;
        bool hash[MAXN] = {0};
        for (int c = R[0]; c != 0; c = R[c])
        if (! hash[c]) {
            hash[c] = true;
            ans ++;
            for (int i = D[c]; i != c; i = D[i])
            for (int j = R[i]; j != i; j = R[j])
            hash[Col[j]] = true;
        }
        return ans;
    }

    bool dfs(int depth) {
        if (depth + Hash() &gt; limit) return false;
        if (R[0] == 0) return true;
        int i, j, c, minnum = INT_MAX;
        for (i = R[0]; i != 0; i = R[i]) {
            if (S[i] &lt; minnum) {
                minnum = S[i];
                c = i;
            }
        }
        for (i = U[c]; i != c; i = U[i]) {
                Remove(i);
                for (j = R[i]; j != i; j = R[j]) Remove(j);
                if (dfs(depth + 1)) {
                for (j = L[i]; j != i; j = L[j]) Resume(j);
                Resume(i);
                return true;
            }
            for (j = L[i]; j != i; j = L[j]) Resume(j);
            Resume(i);
        }
        return false;
    }

    int solve(int n, int m, int DL[][MAXN], int maxdepth) {
        if (maxdepth &gt; n) maxdepth = n;
        for (int i = 0; i &lt;= m; i ++) {
            L[i] = i - 1;
            R[i] = i + 1;
            U[i] = D[i] = i;
        }
        L[0] = m;
        R[m] = 0;
        int cnt = m + 1;
        memset(S, 0, sizeof (S));
        for (int i = 1; i &lt;= n; i ++) {
            int head = cnt, tail = cnt;
            for (int c = 1; c &lt;= m; c ++) if (DL[i][c]) {
                S[c] ++;
                Col[cnt] = c;
                U[D[c]] = cnt;
                D[cnt] = D[c];
                U[cnt] = c;
                D[c] = cnt;
                L[cnt] = tail;
                R[tail] = cnt;
                R[cnt] = head;
                L[head] = cnt;
                tail = cnt;
                cnt ++;
            }
        }
        int best = 0, worst = maxdepth;
        while (best &lt;= worst) {
            limit = (worst + best) &gt;&gt; 1;
            if (dfs(0)) worst = limit - 1;
            else best = limit + 1;
        }
        return best;
    }

    int main()
    {
        int i,j,k,l,row,col,n,m,n1,m1,mark[MAXN][MAXN],a[33][33],id[33][33];

        while(scanf("%d %d",&amp;n,&amp;m) != EOF)
        {
            col = 0;
            for(i=1;i&lt;=n;i++)
                for(j=1;j&lt;=m;j++)
                {
                    scanf("%d",&amp;a[i][j]);
                    id[i][j] = -1;
                    if(a[i][j] == 1) { col++; id[i][j] = col; }
                }
            scanf("%d %d",&amp;n1,&amp;m1);

            row = 0;
            for(i=1;i&lt;=n-n1+1;i++)
                for(j=1;j&lt;=m-m1+1;j++)
                {
                    row++;
                    for(k=1;k&lt;=col;k++)mark[row][k] = 0;

                    for(k=i;k&lt;i+n1;k++)
                        for(l=j;l&lt;j+m1;l++)
                        if(id[k][l] &gt; 0)
                            mark[row][id[k][l]] = 1;
                }

            printf("%d\n",solve(row, col, mark, row));
        }
        return 0;
    }
</code></pre>

<h5>// hdu 2295</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;
    #include&lt;math.h&gt;
    #include&lt;string.h&gt;

    using namespace std;

    const int MAXN = 225;
    int L[MAXN*MAXN], R[MAXN*MAXN], U[MAXN*MAXN], D[MAXN*MAXN];
    int S[MAXN];
    int Col[MAXN*MAXN];
    int limit;

    void Remove(int x) {
        for (int i = D[x]; i != x; i = D[i]) {
        L[R[i]] = L[i];
        R[L[i]] = R[i];
        }
    }
    void Resume(int x) {
        for (int i = U[x]; i != x; i = U[i]) {
        L[R[i]] = R[L[i]] = i;
        }
    }
    int Hash() {
        int ans = 0;
        bool hash[MAXN] = {0};
        for (int c = R[0]; c != 0; c = R[c])
        if (! hash[c]) {
            hash[c] = true;
            ans ++;
            for (int i = D[c]; i != c; i = D[i])
            for (int j = R[i]; j != i; j = R[j])
            hash[Col[j]] = true;
        }
        return ans;
    }

    bool dfs(int depth) {
        if (depth + Hash() &gt; limit) return false;
        if (R[0] == 0) return true;
        int i, j, c, minnum = 2000000000;
        for (i = R[0]; i != 0; i = R[i]) {
            if (S[i] &lt; minnum) {
                minnum = S[i];
                c = i;
            }
        }
        for (i = U[c]; i != c; i = U[i]) {
                Remove(i);
                for (j = R[i]; j != i; j = R[j]) Remove(j);
                if (dfs(depth + 1)) {
                for (j = L[i]; j != i; j = L[j]) Resume(j);
                Resume(i);
                return true;
            }
            for (j = L[i]; j != i; j = L[j]) Resume(j);
            Resume(i);
        }
        return false;
    }

    int solve(int n, int m, int DL[][MAXN], int maxdepth) {
        if (maxdepth &gt; n) maxdepth = n;
        for (int i = 0; i &lt;= m; i ++) {
            L[i] = i - 1;
            R[i] = i + 1;
            U[i] = D[i] = i;
        }
        L[0] = m;
        R[m] = 0;
        int cnt = m + 1;
        memset(S, 0, sizeof (S));
        for (int i = 1; i &lt;= n; i ++) {
            int head = cnt, tail = cnt;
            for (int c = 1; c &lt;= m; c ++) if (DL[i][c]) {
                S[c] ++;
                Col[cnt] = c;
                U[D[c]] = cnt;
                D[cnt] = D[c];
                U[cnt] = c;
                D[c] = cnt;
                L[cnt] = tail;
                R[tail] = cnt;
                R[cnt] = head;
                L[head] = cnt;
                tail = cnt;
                cnt ++;
            }
        }
        int best = 0, worst = maxdepth;
        /*while (best &lt;= worst) {
            limit = (worst + best) &gt;&gt; 1;
            if (dfs(0)) worst = limit - 1;
            else best = limit + 1;
        }*/
        limit = maxdepth;
        if(dfs(0))best = maxdepth;
        else
            best = maxdepth+1;
        return best;
    }

    int x[155],y[155];

    int dij(int i, int j)
    {
        int d1 = (x[i]-x[j])*(x[i]-x[j]);
        int d2 = (y[i]-y[j])*(y[i]-y[j]);
        return d1+d2;
    }

    int main()
    {
        int i,j,k,l,row,col,n,m,low,up,mid,mark[MAXN][MAXN],d[55][55],T,b[3000],top;


        scanf("%d",&amp;T);
        while(T--)
        {
            scanf("%d %d %d",&amp;n,&amp;row,&amp;m);

            for(i=1;i&lt;=n+row;i++)
                scanf("%d %d",&amp;x[i],&amp;y[i]);

            low = 1; up = 1000000000;

            while(low &lt; up)
            {
                for(i=1;i&lt;=row;i++)
                    for(j=1;j&lt;=n;j++)mark[i][j] = 0;

                mid = (low + up)&gt;&gt;1;
                for(i=1;i&lt;=row;i++)
                    for(j=1;j&lt;=n;j++)if(dij(i+n,j) &lt;= mid)mark[i][j] = 1;

                if(solve(row, n, mark, m) &gt; m)low = mid+1; else up = mid;
            }
            mid = (low + up)&gt;&gt;1;
            printf("%.6lf\n",sqrt(1.0*mid));
        }
        return 0;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[划分树--查询区间k-th number code]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/03/23/alg-ds-div-tree-source/"/>
    <updated>2011-03-23T23:14:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/03/23/alg-ds-div-tree-source</id>
    <content type="html"><![CDATA[<h5>一、pku_2104</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;

    #define N 100000+100
    #define M 21  // log(N)

    using namespace std;

    struct Node {
        int val,id;
    } a[N];

    int n,m,tr[M][N];

    int cmp(Node aa, Node bb) {
        if(aa.val &lt; bb.val || (aa.val == bb.val &amp;&amp; aa.id &lt; bb.id)) return 1;
        return 0;
    }

    void build_tree(int dep, int s, int t)
    {
        if(s &gt;= t) return;

        int i,j,k,mid = (s+t)/2;
        j = s; k = mid+1;

        for(i=s;i&lt;=t;i++)
        {
            if(tr[dep][i] &lt;= mid)
                tr[dep+1][j++] = tr[dep][i];
            else
                tr[dep+1][k++] = tr[dep][i];

            tr[dep][i] = j-1;
        }

        build_tree(dep+1, s, mid);
        build_tree(dep+1, mid+1, t);
    }

    int find_tree(int dep, int s, int t, int i, int j, int k)
    {
        if(s == t) return s;
        int ci, mid = (s+t)/2;

        int v = tr[dep][j]-(s-1);
        if(i &gt; s) v = tr[dep][j] - tr[dep][i-1];

        if(v &gt;= k)
        {
            ci = s; if(i &gt; s) ci = tr[dep][i-1]+1;
            return find_tree(dep+1, s, mid, ci, tr[dep][j], k);
        }
        else
        {
            ci = mid+1; if(i &gt; s) ci = mid+1 + (i-1)-tr[dep][i-1];
            return find_tree(dep+1, mid+1, t, ci, mid+j-tr[dep][j], k-v);
        }
        return 0;
    }

    int main()
    {
        int i,j,k,ans;
        while(scanf("%d %d",&amp;n,&amp;m) != EOF)
        {
            for(i=1;i&lt;=n;i++) {
                scanf("%d",&amp;a[i].val); a[i].id = i;
            }

            sort(a+1, a+1+n, cmp);
            for(i=1;i&lt;=n;i++) tr[0][a[i].id] = i;

            build_tree(0, 1, n);

            while(m--)
            {
                scanf("%d %d %d",&amp;i,&amp;j,&amp;k);
                ans = find_tree(0, 1, n, i, j, k);
                printf("%d\n",a[ans].val);
            }
        }
        return 0;
    }
</code></pre>

<hr />

<h5>二、hdu_2665</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;

    #define N 100000+100
    #define M 21  // log(N)

    using namespace std;

    struct Node {
        int val,id;
    } a[N];

    int n,m,tr[M][N];

    int cmp(Node aa, Node bb) {
        if(aa.val &lt; bb.val || (aa.val == bb.val &amp;&amp; aa.id &lt; bb.id)) return 1;
        return 0;
    }

    void build_tree(int dep, int s, int t)
    {
        if(s &gt;= t) return;

        int i,j,k,mid = (s+t)/2;
        j = s; k = mid+1;

        for(i=s;i&lt;=t;i++)
        {
            if(tr[dep][i] &lt;= mid)
                tr[dep+1][j++] = tr[dep][i];
            else
                tr[dep+1][k++] = tr[dep][i];

            tr[dep][i] = j-1;
        }

        build_tree(dep+1, s, mid);
        build_tree(dep+1, mid+1, t);
    }

    int find_tree(int dep, int s, int t, int i, int j, int k)
    {
        if(s == t) return s;
        int ci, mid = (s+t)/2;

        int v = tr[dep][j]-(s-1);
        if(i &gt; s) v = tr[dep][j] - tr[dep][i-1];

        if(v &gt;= k)
        {
            ci = s; if(i &gt; s) ci = tr[dep][i-1]+1;
            return find_tree(dep+1, s, mid, ci, tr[dep][j], k);
        }
        else
        {
            ci = mid+1; if(i &gt; s) ci = mid+1 + (i-1)-tr[dep][i-1];
            return find_tree(dep+1, mid+1, t, ci, mid+j-tr[dep][j], k-v);
        }
        return 0;
    }

    int main()
    {
        int i,j,k,ans,T;
        scanf("%d",&amp;T);
        while(T--)
        {
            scanf("%d %d",&amp;n,&amp;m);
            for(i=1;i&lt;=n;i++) {
                scanf("%d",&amp;a[i].val); a[i].id = i;
            }

            sort(a+1, a+1+n, cmp);
            for(i=1;i&lt;=n;i++) tr[0][a[i].id] = i;

            build_tree(0, 1, n);

            while(m--)
            {
                scanf("%d %d %d",&amp;i,&amp;j,&amp;k);
                ans = find_tree(0, 1, n, i, j, k);
                printf("%d\n",a[ans].val);
            }
        }
        return 0;
    }
</code></pre>

<hr />

<h5>三、hdu_3727</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;

    #define N 100000+100
    #define M 21  // log(N)

    typedef long long LL;

    using namespace std;

    struct Input {
        int sta,s,t,k;
    } q[N+N+N];

    struct Node {
        int val,id;
    } a[N];

    int n,m,tr[M][N],C[N],b[N];

    int cmp(Node aa, Node bb) {
        if(aa.val &lt; bb.val || (aa.val == bb.val &amp;&amp; aa.id &lt; bb.id)) return 1;
        return 0;
    }

    int lowbit(int x) {
        return x&amp;(-x);
    }

    void change(int x, int y) {
        while(x &lt;= n) {
            C[x] += y; x += lowbit(x);
        }
    }

    int cal(int x) {
        int t=0;
        while(x &gt; 0) {
            t += C[x]; x -= lowbit(x);
        }
        return t;
    }

    void build_tree(int dep, int s, int t)
    {
        if(s &gt;= t) return;

        int i,j,k,mid = (s+t)/2;
        j = s; k = mid+1;

        for(i=s;i&lt;=t;i++)
        {
            if(tr[dep][i] &lt;= mid)
                tr[dep+1][j++] = tr[dep][i];
            else
                tr[dep+1][k++] = tr[dep][i];

            tr[dep][i] = j-1;
        }

        build_tree(dep+1, s, mid);
        build_tree(dep+1, mid+1, t);
    }

    int find_tree(int dep, int s, int t, int i, int j, int k)
    {
        if(s == t) return s;
        int ci, mid = (s+t)/2;

        int v = tr[dep][j]-(s-1);
        if(i &gt; s) v = tr[dep][j] - tr[dep][i-1];

        if(v &gt;= k)
        {
            ci = s; if(i &gt; s) ci = tr[dep][i-1]+1;
            return find_tree(dep+1, s, mid, ci, tr[dep][j], k);
        }
        else
        {
            ci = mid+1; if(i &gt; s) ci = mid+1 + (i-1)-tr[dep][i-1];
            return find_tree(dep+1, mid+1, t, ci, mid+j-tr[dep][j], k-v);
        }
        return 0;
    }

    int main()
    {
        int i,k,T,low,up,mid,cas=0;
        LL ans[5];
        char ch[33];

        while(scanf("%d",&amp;T) != EOF)
        {

            n = 0; m = 0;
            for(i=1;i&lt;=T;i++)
            {
                scanf("%s", ch);
                if(ch[0] == 'I')
                {
                    q[i].sta = 0;
                    n++; scanf("%d", &amp;a[n].val); a[n].id = n;
                }
                else
                {
                    q[i].sta = ch[6] - 48;
                    if(ch[6] == '1') scanf("%d %d %d",&amp;q[i].s,&amp;q[i].t,&amp;q[i].k);
                    else
                        scanf("%d",&amp;q[i].k);
                }
            }

            sort(a+1, a+1+n, cmp);
            for(i=1;i&lt;=n;i++)
            {
                b[a[i].id] = tr[0][a[i].id] = i;
                C[i] = 0;
            }
            C[0] = 0;

            build_tree(0, 1, n);

            ans[1] = ans[2] = ans[3] = 0;

            m = 0;

            for(i=1;i&lt;=T;i++)
            {
                if(q[i].sta == 0)
                {
                    m++;
                    change(b[m], 1);
                }
                else
                if(q[i].sta == 1)
                {
                    k = find_tree(0, 1, n, q[i].s, q[i].t, q[i].k);
                    ans[1] += a[k].val;
                }
                else
                if(q[i].sta == 2)
                {
                    low = 1; up = n;
                    while(low &lt; up) {
                        mid = (low + up)/2;
                        if(a[mid].val &lt; q[i].k) low = mid+1; else up = mid;
                    }
                    mid = (low + up)/2;
                    ans[2] += cal(mid);
                }
                else
                if(q[i].sta == 3)
                {
                    low = 1; up = n;
                    while(low &lt; up) {
                        mid = (low + up)/2;
                        if(cal(mid) &lt; q[i].k) low = mid+1; else up = mid;
                    }
                    mid = (low + up)/2;
                    ans[3] += a[mid].val;
                }
            }
            cas++;
            printf("Case %d:\n%lld\n%lld\n%lld\n",cas,ans[1],ans[2],ans[3]);
        }
        return 0;
    }
</code></pre>

<hr />

<h5>四、hdu_3473</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;

    #define N 100000+100
    #define M 21  // log(N)

    typedef long long LL;

    using namespace std;

    struct Node {
        int val,id;
    } a[N];

    int n,m,pos,tr[M][N];
    LL less,more, sum[M][N];

    int cmp(Node aa, Node bb) {
        if(aa.val &lt; bb.val || (aa.val == bb.val &amp;&amp; aa.id &lt; bb.id)) return 1;
        return 0;
    }

    void build_tree(int dep, int s, int t)
    {
        if(s &gt;= t) return;

        int i,j,k, mid = (s+t)/2;
        LL s1,s2;

        j = s; k = mid+1;
        s1 = s2 = 0;

        for(i=s;i&lt;=t;i++)
        {
            if(tr[dep][i] &lt;= mid)
            {
                s1 += a[tr[dep][i]].val;
                sum[dep][j] = s1;
                tr[dep+1][j++] = tr[dep][i];
            }
            else
            {
                s2 += a[tr[dep][i]].val;
                sum[dep][k] = s2;
                tr[dep+1][k++] = tr[dep][i];
            }

            tr[dep][i] = j-1;
        }

        build_tree(dep+1, s, mid);
        build_tree(dep+1, mid+1, t);
    }

    void find_tree(int dep, int s, int t, int i, int j, int k)
    {
        if(s == t) { pos = s; return ; }
        int ci,cj,  mid = (s+t)/2;
        LL s1,s2;

        int v = tr[dep][j]-(s-1);
        if(i &gt; s) v = tr[dep][j] - tr[dep][i-1];

        if(v &gt;= k)
        {
            ci = s; if(i &gt; s) ci = tr[dep][i-1]+1;
            find_tree(dep+1, s, mid, ci, tr[dep][j], k);


            if(i == s) ci = 0; else ci = (i-1)-tr[dep][i-1];
            if(ci == 0) s1 = 0; else s1 = sum[dep][mid+ci];

            cj = j-tr[dep][j];
            if(cj == 0) s2 = 0; else s2 = sum[dep][mid+cj];

            more += (s2-s1);
        }
        else
        {
            ci = mid+1; if(i &gt; s) ci = mid+1 + (i-1)-tr[dep][i-1];
            find_tree(dep+1, mid+1, t, ci, mid+j-tr[dep][j], k-v);


            if(i &gt; s) ci = tr[dep][i-1]; else ci = s-1;
            if(ci &lt; s) s1 = 0; else s1 = sum[dep][ci];

            cj = tr[dep][j]; 
            if(cj &lt; s) s2 = 0; else s2 = sum[dep][cj];

            less += (s2-s1);
        }
    }

    int main()
    {
        int i,j,k,T,cas=0;
        scanf("%d",&amp;T);
        while(T--)
        {
            scanf("%d",&amp;n);
            for(i=1;i&lt;=n;i++) {
                scanf("%d",&amp;a[i].val); a[i].id = i;
            }

            sort(a+1, a+1+n, cmp);

            sum[0][0] = 0;
            for(i=1;i&lt;=n;i++)
            {
                tr[0][a[i].id] = i;
                sum[0][i] = sum[0][i-1] + a[i].val;
            }

            build_tree(0, 1, n);

            cas++;
            printf("Case #%d:\n", cas);

            scanf("%d",&amp;m);
            while(m--)
            {
                scanf("%d %d",&amp;i,&amp;j);
                i++; j++; k = (j-i+2)/2;
                less = 0; more = 0;
                find_tree(0, 1, n, i, j, k);

                //printf("%d %lld %lld\n",a[pos].val,less,more);

                printf("%lld\n", (LL)(k-1)*(LL)a[pos].val-less + more-(LL)(j-i+1-k)*(LL)a[pos].val);
            }
            printf("\n");
        }
        return 0;
    }
</code></pre>
]]></content>
  </entry>
  
</feed>
