<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug~base | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug~base/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2016-03-21T12:31:12+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[debuginfo 编译速度]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/11/26/debug-spec/"/>
    <updated>2015-11-26T11:30:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/11/26/debug-spec</id>
    <content type="html"><![CDATA[<p>Have a look into /usr/lib/rpm/macros:
<code>
    #       Compression type and level for source/binary package payloads.
    #               "w9.gzdio"      gzip level 9 (default).
    #               "w9.bzdio"      bzip2 level 9.
    #               "w7.xzdio"      xz level 7, xz's default.
    #               "w7.lzdio"      lzma-alone level 7, lzma's default
    #
    #%_source_payload       w9.gzdio
    #%_binary_payload       w9.gzdio
</code></p>

<p>binkernel.spec中加入
<code>
    %_source_payload       w5.gzdio
    %_binary_payload       w5.gzdio
</code>
略微降低压缩率，大大提高打包速度。kernel增加600K，debuginfo增加3M，时间从14分钟降至2分钟内</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CC_STACKPROTECTOR防内核堆栈溢出补丁分析]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/11/17/debug-CC_STACKPROTECTOR/"/>
    <updated>2015-11-17T16:01:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/11/17/debug-CC_STACKPROTECTOR</id>
    <content type="html"><![CDATA[<p><a href="http://blog.aliyun.com/1126">http://blog.aliyun.com/1126</a></p>

<p>内核堆栈溢出通常有两种情况。一种是函数调用栈超出了内核栈THREAD_SIZE的大小， 这是栈底越界，另一种是栈上缓冲越界访问，这是栈顶越界。</p>

<h4>检测栈底越界</h4>

<p>以arm平台为例，内核栈THREAD_SIZE为8K,当调用栈层次过多或某调用栈上分配过大的 空间，就会导致它越界。越界后struct thread_info结构可能被破坏，轻则内核 panic，重则内核数据被覆盖仍继续运行。</p>

<h4>检测栈顶越界</h4>

<p>对于栈顶越界，gcc提供了支持。打开内核配置CONFIG_CC_STACKPROTECTOR后，会打 开编译选项-fstack-protector.</p>

<hr />

<p>  CC_STACKPROTECT补丁是Tejun Heo在09年给主线kernel提交的一个用来防止内核堆栈溢出的补丁。默认的config是将这个选项关闭的，可以在编译内核的时候， 修改.config文件为CONFIG_CC_STACKPROTECTOR=y来启用。未来飞天内核可以将这个选项开启来防止利用内核stack溢出的0day攻击。这个补丁的防溢出原理是： 在进程启动的时候， 在每个buffer的后面放置一个预先设置好的stack canary，你可以把它理解成一个哨兵， 当buffer发生缓冲区溢出的时候， 肯定会破坏stack canary的值， 当stack canary的值被破坏的时候， 内核就会直接当机。那么是怎么判断stack canary被覆盖了呢？ 其实这个事情是gcc来做的，内核在编译的时候给gcc加了个-fstack-protector参数， 我们先来研究下这个参数是做什么用的。</p>

<p>先写个简单的有溢出的程序：</p>

<pre><code>    [wzt@localhost csaw]$ cat test.c

    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    void test(void)
    {
        char buff[64];

        memset(buff, 0x41, 128);     //向64大小的buffer拷贝128字节， 肯定会发生缓冲区溢出。
    }

    int main(void)
    {
        test();

        return 0;
    }
</code></pre>

<pre><code>    [wzt@localhost csaw]$ gcc -o test test.c
    [wzt@localhost csaw]$ ./test
    段错误
</code></pre>

<p>反汇编看看：</p>

<pre><code>    [wzt@localhost csaw]$ objdump -d test &gt; hex

    08048384 &lt;test&gt;:
     8048384:       55                      push   %ebp
     8048385:       89 e5                   mov    %esp,%ebp
     8048387:       83 ec 58                sub    $0x58,%esp
     804838a:       c7 44 24 08 80 00 00    movl   $0x80,0x8(%esp)
     8048391:       00
     8048392:       c7 44 24 04 41 00 00    movl   $0x41,0x4(%esp)
     8048399:       00
     804839a:       8d 45 c0                lea    0xffffffc0(%ebp),%eax
     804839d:       89 04 24                mov    %eax,(%esp)
     80483a0:       e8 e3 fe ff ff          call   8048288 &lt;memset@plt&gt;
     80483a5:       c9                      leave
     80483a6:       c3                      ret
</code></pre>

<p>没什么特别的，我们在加上-fstack-protector参数看看：</p>

<pre><code>    [wzt@localhost csaw]$ gcc -o test test.c -fstack-protector
    [wzt@localhost csaw]$ ./test
    *** stack smashing detected ***: ./test terminated
    已放弃
</code></pre>

<p>这次程序打印了一条堆栈被溢出的信息，然后就自动退出了。</p>

<p>在反汇编看下：</p>

<pre><code>    [wzt@localhost csaw]$ objdump -d test &gt; hex1

    080483d4 &lt;test&gt;:
     80483d4:       55                      push   %ebp
     80483d5:       89 e5                   mov    %esp,%ebp
     80483d7:       83 ec 68                sub    $0x68,%esp
     80483da:       65 a1 14 00 00 00       mov    %gs:0x14,%eax
     80483e0:       89 45 fc                mov    %eax,0xfffffffc(%ebp)
     80483e3:       31 c0                   xor    %eax,%eax
     80483e5:       c7 44 24 08 80 00 00    movl   $0x80,0x8(%esp)
     80483ec:       00
     80483ed:       c7 44 24 04 41 00 00    movl   $0x41,0x4(%esp)
     80483f4:       00
     80483f5:       8d 45 bc                lea    0xffffffbc(%ebp),%eax
     80483f8:       89 04 24                mov    %eax,(%esp)
     80483fb:       e8 cc fe ff ff          call   80482cc &lt;memset@plt&gt;
     8048400:       8b 45 fc                mov    0xfffffffc(%ebp),%eax
     8048403:       65 33 05 14 00 00 00    xor    %gs:0x14,%eax
     804840a:       74 05                   je     8048411 &lt;test+0x3d&gt;
     804840c:       e8 db fe ff ff          call   80482ec &lt;__stack_chk_fail@plt&gt;
     8048411:       c9                      leave
     8048412:       c3                      ret
</code></pre>

<p>使用-fstack-protector参数后， gcc在函数的开头放置了几条汇编代码：</p>

<pre><code>     80483d7:       83 ec 68                sub    $0x68,%esp
     80483da:       65 a1 14 00 00 00       mov    %gs:0x14,%eax
     80483e0:       89 45 fc                mov    %eax,0xfffffffc(%ebp)
</code></pre>

<p>将代码段gs偏移0×14内存处的值赋值给了ebp-4， 也就是第一个变量值的后面。</p>

<p>在call完memeset后，有如下汇编代码：</p>

<pre><code>     80483fb:       e8 cc fe ff ff          call   80482cc &lt;memset@plt&gt;
     8048400:       8b 45 fc                mov    0xfffffffc(%ebp),%eax
     8048403:       65 33 05 14 00 00 00    xor    %gs:0x14,%eax
     804840a:       74 05                   je     8048411 &lt;test+0x3d&gt;
     804840c:       e8 db fe ff ff          call   80482ec &lt;__stack_chk_fail@plt&gt;
</code></pre>

<p>在memset后，gcc要检查这个操作是否发生了堆栈溢出, 将保存在ebp-4的这个值与原来的值对比一下，如果不相同， 说明堆栈发生了溢出，那么就会执行stack_chk_fail这个函数， 这个函数是glibc实现的，打印出上面看到的信息， 然后进程退出。</p>

<p>从这个例子中我们可以看出gcc使用了-fstack-protector参数后，会自动检查堆栈是否发生了溢出， 但是有一个前提就是内核要给每个进程提前设置好一个检测值放置在%gs:0×14位置处，这个值称之为stack canary。所以我们可以看到防止堆栈溢出是由内核和gcc共同来完成的。</p>

<p>gcc的任务就是放置几条汇编代码， 然后和%gs:0×14位置处的值进行对比即可。 主要任务还是内核如何来设置stack canary， 也是CC_STACKPROTECTOR补丁要实现的目的， 下面我们仔细来看下这个补丁是如何实现的。</p>

<p>既然gcc硬性规定了stack canary必须在%gs的某个偏移位置处， 那么内核也必须按着这个规定来设置。</p>

<p>对于32位和64位内核， gs寄存器有着不同的功能。</p>

<p>64位内核gcc要求stack canary是放置在gs段的40偏移处， 并且gs寄存器在每cpu变量中是共享的，每cpu变量irq_stack_union的结构如下：</p>

<pre><code>    arch/x86/include/asm/processor.h

    union irq_stack_union {
        char irq_stack[IRQ_STACK_SIZE];
        /*
         * GCC hardcodes the stack canary as %gs:40.  Since the
         * irq_stack is the object at %gs:0, we reserve the bottom
         * 48 bytes of the irq stack for the canary. 
         */
        struct {
            char gs_base[40];
            unsigned long stack_canary;
        };
    };

    DECLARE_PER_CPU_FIRST(union irq_stack_union, irq_stack_union);
</code></pre>

<p>gs_base只是一个40字节的站位空间， stack_canary就紧挨其后。并且在应用程序进出内核的时候，内核会使用swapgs指令自动更换gs寄存器的内容。</p>

<p>32位下就稍微有点复杂了。由于某些处理器在加载不同的段寄存器时很慢， 所以内核使用fs段寄存器替换了gs寄存器。 但是gcc在使用-fstack-protector的时候， 还要用到gs段寄存器， 所以内核还要管理gs寄存器，我们要把CONFIG_X86_32_LAZY_GS选项关闭， gs也只在进程切换的时候才改变。 32位用每cpu变量stack_canary保存stack canary。</p>

<pre><code>    struct stack_canary {
        char __pad[20];         /* canary at %gs:20 */
        unsigned long canary;
    };      
    DECLARE_PER_CPU_ALIGNED(struct stack_canary, stack_canary);
</code></pre>

<p>内核是处于保护模式的， 因此gs寄存器就变成了保护模式下的段选子，在GDT表中也要有相应的设置：</p>

<pre><code>    diff --git a/arch/x86/include/asm/segment.h b/arch/x86/include/asm/segment.h
    index 1dc1b51..14e0ed8 100644 (file)
    --- a/arch/x86/include/asm/segment.h
    +++ b/arch/x86/include/asm/segment.h
    @@ -61,7 +61,7 @@
      *
      *  26 - ESPFIX small SS
      *  27 - per-cpu                       [ offset to per-cpu data area ]
    - *  28 - unused
    + *  28 - stack_canary-20               [ for stack protector ]
      *  29 - unused
      *  30 - unused
      *  31 - TSS for double fault handler
    @@ -95,6 +95,13 @@
     #define __KERNEL_PERCPU 0
     #endif

    +#define GDT_ENTRY_STACK_CANARY         (GDT_ENTRY_KERNEL_BASE + 16)
    +#ifdef CONFIG_CC_STACKPROTECTOR
    +#define __KERNEL_STACK_CANARY          (GDT_ENTRY_STACK_CANARY * 8)
    +#else
    +#define __KERNEL_STACK_CANARY          0
    +#endif
    +
     #define GDT_ENTRY_DOUBLEFAULT_TSS      31
</code></pre>

<p>GDT表中的第28个表项用来定为stack canary所在的段。</p>

<pre><code>    #define GDT_STACK_CANARY_INIT                                           \
            [GDT_ENTRY_STACK_CANARY] = GDT_ENTRY_INIT(0x4090, 0, 0x18),
</code></pre>

<p>GDT_STACK_CANARY_INIT在刚进入保护模式的时候被调用， 这个段描述符项被设置为基地址为0， 段大小设为24，因为只在基地址为0， 偏移为0×14处放置一个4bytes的stack canary， 所以24字节正好。不理解的同学可以看看intel保护模式的手册， 对着段描述符结构一个个看就行了。</p>

<p>在进入保护模式后， start_kernel()会调用boot_init_stack_canary()来初始话一个stack canary。</p>

<pre><code>    /*      
     * Initialize the stackprotector canary value.
     *
     * NOTE: this must only be called from functions that never return,
     * and it must always be inlined.
     */
    static __always_inline void boot_init_stack_canary(void)
    {
        u64 canary;
        u64 tsc;

    #ifdef CONFIG_X86_64
        BUILD_BUG_ON(offsetof(union irq_stack_union, stack_canary) != 40);
    #endif
        /*
         * We both use the random pool and the current TSC as a source
         * of randomness. The TSC only matters for very early init,
         * there it already has some randomness on most systems. Later
         * on during the bootup the random pool has true entropy too.
         */
        get_random_bytes(&amp;canary, sizeof(canary));
        tsc = __native_read_tsc();
        canary += tsc + (tsc &lt;&lt; 32UL);

        current-&gt;stack_canary = canary;
    #ifdef CONFIG_X86_64
        percpu_write(irq_stack_union.stack_canary, canary);
    #else
        percpu_write(stack_canary.canary, canary);
    #endif
    }
</code></pre>

<p>随机出了一个值赋值给每cpu变量， 32位是stack_canary, 64位是irq_stack_union。</p>

<p>内核在进一步初始化cpu的时候，会调用setup_stack_canary_segment()来设置每个cpu的GDT的stack canary描述符项：</p>

<p>start_kernel()->setup_per_cpu_areas()->setup_stack_canary_segment：</p>

<pre><code>    static inline void setup_stack_canary_segment(int cpu)
    {
    #ifdef CONFIG_X86_32
        unsigned long canary = (unsigned long)&amp;per_cpu(stack_canary, cpu);
        struct desc_struct *gdt_table = get_cpu_gdt_table(cpu);
        struct desc_struct desc;

        desc = gdt_table[GDT_ENTRY_STACK_CANARY];
        set_desc_base(&amp;desc, canary);
        write_gdt_entry(gdt_table, GDT_ENTRY_STACK_CANARY, &amp;desc, DESCTYPE_S);
    #endif
    }
</code></pre>

<p>在内核刚进入保护模式的时候, stack canary描述符的基地址被初始化为0， 现在在cpu初始化的时候要重新设置为每cpu变量stack_canary的地址， 而不是变量保存的值。通过这些设置当内核代码在访问%gs:0×14的时候， 就会访问stack canry保存的值。注意：setup_stack_canary_segment是针对32位内核做设置， 因为64位内核中的irq_stack_union是每cpu共享的， 不用针对每个cpu单独设置。 然后就可以调用switch_to_new_gdt(cpu);来加载GDT表和加载gs寄存器。</p>

<p>经过上述初始化过程，在内核代码里访问%gs:0×14就可以定位stack canary的值了， 那么每个进程的stack canary是什么时候设置的呢？</p>

<p>在内核启动一个进程的时候， 会把gs寄存器的值设为KERNEL_STACK_CANARY</p>

<pre><code>    --- a/arch/x86/kernel/process_32.c
    +++ b/arch/x86/kernel/process_32.c
    @@ -212,6 +212,7 @@ int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
            regs.ds = __USER_DS;
            regs.es = __USER_DS;
            regs.fs = __KERNEL_PERCPU;
    +       regs.gs = __KERNEL_STACK_CANARY;
            regs.orig_ax = -1;
            regs.ip = (unsigned long) kernel_thread_helper;
            regs.cs = __KERNEL_CS | get_kernel_rpl();
</code></pre>

<p>内核在fork一个进程的时候， 有如下操作：</p>

<pre><code>    static struct task_struct *dup_task_struct(struct task_struct *orig)
    {
    #ifdef CONFIG_CC_STACKPROTECTOR
        tsk-&gt;stack_canary = get_random_int();
    #endif
    }
</code></pre>

<p>随机初始化了一个stack_canary保存在task_struct结构中的stack_canary变量中。当进程在切换的时候， 通过switch宏把新进程的stack canary保存在每cpu变量stack_canary中， 当前进程的stack_canary也保存在一个每cpu变量中，完成stack canary的切换。</p>

<pre><code>    diff --git a/arch/x86/include/asm/system.h b/arch/x86/include/asm/system.h
    index 79b98e5..2692ee8 100644 (file)
    --- a/arch/x86/include/asm/system.h
    +++ b/arch/x86/include/asm/system.h
    @@ -23,6 +23,22 @@ struct task_struct *__switch_to(struct task_struct *prev,

     #ifdef CONFIG_X86_32

    +#ifdef CONFIG_CC_STACKPROTECTOR
    +#define __switch_canary                                                \
    +       "movl "__percpu_arg([current_task])",%%ebx\n\t"                 \
    +       "movl %P[task_canary](%%ebx),%%ebx\n\t"                         \
    +       "movl %%ebx,"__percpu_arg([stack_canary])"\n\t"
    +#define __switch_canary_oparam                                         \
    +       , [stack_canary] "=m" (per_cpu_var(stack_canary))
    +#define __switch_canary_iparam                                         \
    +       , [current_task] "m" (per_cpu_var(current_task))                \
    +       , [task_canary] "i" (offsetof(struct task_struct, stack_canary))
    +#else  /* CC_STACKPROTECTOR */
    +#define __switch_canary
    +#define __switch_canary_oparam
    +#define __switch_canary_iparam
    +#endif /* CC_STACKPROTECTOR */
    +
     /*
      * Saving eflags is important. It switches not only IOPL between tasks,
      * it also protects other tasks from NT leaking through sysenter etc.
    @@ -46,6 +62,7 @@ do {                                                  \
                         "pushl %[next_ip]\n\t"     /* restore EIP   */     \
                         "jmp __switch_to\n"        /* regparm call  */     \
                         "1:\t"                                             \
    +                    __switch_canary                                    \
                         "popl %%ebp\n\t"           /* restore EBP   */     \
                         "popfl\n"                  /* restore flags */     \
                                                                            \
    @@ -58,6 +75,8 @@ do {                                                  \
                           "=b" (ebx), "=c" (ecx), "=d" (edx),              \
                           "=S" (esi), "=D" (edi)                           \
                                                                            \
    +                      __switch_canary_oparam                           \
    +                                                                       \
                           /* input parameters: */                          \
                         : [next_sp]  "m" (next-&gt;thread.sp),                \
                           [next_ip]  "m" (next-&gt;thread.ip),                \
    @@ -66,6 +85,8 @@ do {                                                  \
                           [prev]     "a" (prev),                           \
                           [next]     "d" (next)                            \
                                                                            \
    +                      __switch_canary_iparam                           \
    +                                                                       \
                         : /* reloaded segment registers */                 \
                            "memory");                                      \
     } while (0)
</code></pre>

<p>前面讲过当gcc检测到堆栈溢出的时候， 会调用glibc的stack_chk_fail函数， 但是当内核堆栈发生溢出的时候，不能调用glibc的函数，所以内核自己实现了一个stack_chk_fail函数：</p>

<p>kernel/panic.c</p>

<pre><code>    #ifdef CONFIG_CC_STACKPROTECTOR

    /*
     * Called when gcc's -fstack-protector feature is used, and
     * gcc detects corruption of the on-stack canary value
     */
    void __stack_chk_fail(void)
    {
        panic("stack-protector: Kernel stack is corrupted in: %p\n",
             __builtin_return_address(0));
    }
    EXPORT_SYMBOL(__stack_chk_fail);

    #endif
</code></pre>

<p>当内核堆栈发生溢出的时候，就会执行stack_chk_fail函数， 内核当机。</p>

<p>这就是这个补丁的原理，不懂的同学请参考：</p>

<p><a href="http://git.kernel.org/?p=linux/kernel/git/next/linux-next.git;a=commitdiff;h=60a5317ff0f42dd313094b88f809f63041568b08">http://git.kernel.org/?p=linux/kernel/git/next/linux-next.git;a=commitdiff;h=60a5317ff0f42dd313094b88f809f63041568b08</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Universal Build-ID]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/09/12/compiler-build-id/"/>
    <updated>2014-09-12T18:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/09/12/compiler-build-id</id>
    <content type="html"><![CDATA[<p><a href="http://fedoraproject.org/wiki/Summer_Coding_2010_ideas_-_Universal_Build-ID">http://fedoraproject.org/wiki/Summer_Coding_2010_ideas_-_Universal_Build-ID</a></p>

<h4>Summary</h4>

<p>  Build-IDs are currently being put into binaries, shared libraries, core files and related debuginfo files to uniquely identify the build a user or developer is working with. There are a couple of conventions in place to use this information to identify &ldquo;currently running&rdquo; or &ldquo;distro installed&rdquo; builds. This helps with identifying what was being run and match it to the corresponding package, sources and debuginfo for tools that want to help the user show what is going on (at the moment mostly when things break). We would like to extend this to a more universial approach, that helps people identify historical, local, non- or cross-distro or organisational builds. So that Build-IDs become useful outside the current &ldquo;static&rdquo; setup and retain information over time and across upgrades.</p>

<h3>Build-ID background</h3>

<p>  Build-IDs are unique identifiers of &ldquo;builds&rdquo;. A build is an executable, a shared library, the kernel, a module, etc. You can also find the build-id in a running process, a core file or a separate debuginfo file.</p>

<p>  The main idea behind Build-IDs is to make elf files &ldquo;self-identifying&rdquo;. This means that when you have a Build-ID it should uniquely identify a final executable or shared library. The default Build-ID calculation (done through ld &ndash;build-id, see the ld manual) calculates a sha1 hash (160 bits/20 bytes) based on all the ELF header bits and section contents in the file. Which means that it is unique among the set of meaningful contents for ELF files and identical when the output file would otherwise have been identical. GCC now passes &ndash;build-id to the linker by default.</p>

<p>  When an executable or shared library is loaded into memory the Build-ID will also be loaded into memory, a core dump of a process will also have the Build-IDs of the executable and the shared libraries embedded. And when separating debuginfo from the main executable or shared library into .debug files the original Build-ID will also be copied over. This means it is easy to match a core file or a running process to the original executable and shared library builds. And that matching those against the debuginfo files that provide more information for introspection and debugging should be trivial.</p>

<p>  Fedora has had full support for build-ids since Fedora Core 8: <a href="https://fedoraproject.org/wiki/Releases/FeatureBuildId">https://fedoraproject.org/wiki/Releases/FeatureBuildId</a></p>

<h4>Getting Build-IDs</h4>

<p>  A simple way to get the build-id(s) is through eu-unstrip (part of elfutils).</p>

<p>build-id from an executable, shared library or separate debuginfo file:<br/>
$ eu-unstrip -n -e &lt;exec|.sharedlib|.debug></p>

<p>build-ids of an executable and all shared libraries from a core file:<br/>
$ eu-unstrip -n &ndash;core <corefile></p>

<p>build-ids of an executable and all shared libraries of a running process:<br/>
$ eu-unstrip -n &ndash;pid <pid></p>

<p>build-id of the running kernel and all loaded modules:<br/>
$ eu-unstrip -n -k</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oops打印Tainted信息]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/07/16/debug-oops/"/>
    <updated>2014-07-16T15:58:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/07/16/debug-oops</id>
    <content type="html"><![CDATA[<p>检查一下上面的Oops，看看Linux内核还有没有给我们留下其他的有用信息。
<code>
Oops: 0002 [#1]
</code>
* 这里面，0002表示Oops的错误代码（写错误，发生在内核空间），#1表示这个错误发生一次。</p>

<p>Oops的错误代码根据错误的原因会有不同的定义，本文中的例子可以参考下面的定义（如果发现自己遇到的Oops和下面无法对应的话，最好去内核代码里查找）：
<code>
 * error_code:
 *      bit 0 == 0 means no page found, 1 means protection fault
 *      bit 1 == 0 means read, 1 means write
 *      bit 2 == 0 means kernel, 1 means user-mode
 *      bit 3 == 0 means data, 1 means instruction
</code>
有时候，Oops还会打印出Tainted信息。这个信息用来指出内核是因何种原因被tainted（直译为“玷污”）。具体的定义如下：
<code>
  1: 'G' if all modules loaded have a GPL or compatible license, 'P' if any proprietary module has been loaded.  Modules without a MODULE_LICENSE or with a MODULE_LICENSE that is not recognised by insmod as GPL compatible are assumed to be proprietary.
  2: 'F' if any module was force loaded by "insmod -f", ' ' if all modules were loaded normally.
  3: 'S' if the oops occurred on an SMP kernel running on hardware that hasn't been certified as safe to run multiprocessor. Currently this occurs only on various Athlons that are not SMP capable.
  4: 'R' if a module was force unloaded by "rmmod -f", ' ' if all modules were unloaded normally.
  5: 'M' if any processor has reported a Machine Check Exception, ' ' if no Machine Check Exceptions have occurred.
  6: 'B' if a page-release function has found a bad page reference or some unexpected page flags.
  7: 'U' if a user or user application specifically requested that the Tainted flag be set, ' ' otherwise.
  8: 'D' if the kernel has died recently, i.e. there was an OOPS or BUG.
  9: 'A' if the ACPI table has been overridden.
 10: 'W' if a warning has previously been issued by the kernel. (Though some warnings may set more specific taint flags.)
 11: 'C' if a staging driver has been loaded.
 12: 'I' if the kernel is working around a severe bug in the platform firmware (BIOS or similar).
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[abrt 应用程序core dump]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/06/18/debug-abrt/"/>
    <updated>2014-06-18T16:26:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/06/18/debug-abrt</id>
    <content type="html"><![CDATA[<h4>一、安装</h4>

<pre><code>yum install abrt
</code></pre>

<h4>二、设置</h4>

<pre><code>ulimit -c
ulimit -c unlimited
</code></pre>

<h4>三、常见错误</h4>

<pre><code>1、ERROR
$ tail -f /var/log/message
abrtd: Package 'XXX' isn't signed with proper key

$ vim /etc/abrt/abrt.conf
OR
$ vim /etc/abrt/abrt-action-save-package-data.conf
OpenGPGCheck = no

2、ERROR
tail -f /var/log/message
abrtd: Duplicate: UUID

Whenever a problem is detected, ABRT compares it with all 
existing problem data and determines whether that same problem 
has been recorded. If it has been, the existing problem data 
is updated and the most recent (duplicate) problem is not recorded again.

3、
ProcessUnpackaged = &lt;yes/no&gt;
This directive tells ABRT whether to process crashes 
in executables that do not belong to any package.   
</code></pre>

<hr />

<h4>abrt</h4>

<p><a href="http://docs.fedoraproject.org/en-US/Fedora/14/html/Deployment_Guide/configuring.html">http://docs.fedoraproject.org/en-US/Fedora/14/html/Deployment_Guide/configuring.html</a><br/>
<a href="https://fedorahosted.org/releases/a/b/abrt/Deployment_Guide.html">https://fedorahosted.org/releases/a/b/abrt/Deployment_Guide.html</a></p>

<pre><code>21.6. Configuring ABRT

ABRT's main configuration file is /etc/abrt/abrt.conf. 
ABRT plugins can be configured through their config files, 
located in the /etc/abrt/plugins/ directory.

After changing and saving the abrt.conf configuration file, 
you must restart the abrtd daemon—as root—for the new settings to take effect:

~]# service abrtd restart

The following configuration directives are currently supported in /etc/abrt/abrt.conf.

[ Common ] Section DirectivesOpenGPGCheck = &lt;yes/no&gt;

Setting the OpenGPGCheck directive to yes (the default setting) tells 
ABRT to only analyze and handle crashes in applications provided by 
packages which are signed by the GPG keys whose locations are listed 
in the /etc/abrt/gpg_keys file. Setting OpenGPGCheck to no tells 
ABRT to catch crashes in all programs.

BlackList = nspluginwrapper, valgrind, strace, avant-window-navigator, [&lt;additional_packages&gt; ]

Crashes in packages and binaries listed after the BlackList directive 
will not be handled by ABRT. If you want ABRT to ignore other packages 
and binaries, list them here separated by commas.

ProcessUnpackaged = &lt;yes/no&gt;

This directive tells ABRT whether to process crashes in executables 
that do not belong to any package.  

BlackListedPaths = /usr/share/doc/*, */example*

Crashes in executables in these paths will be ignored by ABRT.

Database = SQLite3

This directive instructs ABRT to store its crash data in the SQLite3 database. 
Other databases are not currently supported. However, 
ABRT's plugin architecture allows for future support for alternative databases.

#WatchCrashdumpArchiveDir = /var/spool/abrt-upload/

This directive is commented out by default. 
Enable (uncomment) it if you want abrtd to auto-unpack crashdump tarballs 
which appear in the specified directory — in this case /var/spool/abrt-upload/ — 
(for example, uploaded via ftp, scp, etc.). You must ensure that whatever 
directory you specify in this directive exists and is writable for abrtd. 
abrtd will not create it automatically.

MaxCrashReportsSize = &lt;size_in_megabytes&gt;

This option sets the amount of storage space, in megabytes, 
used by ABRT to store all crash information from all users. 
The default setting is 1000 MB. Once the quota specified here has been met, 
ABRT will continue catching crashes, and in order to make room for the new crash dumps, 
it will delete the oldest and largest ones.

ActionsAndReporters = SOSreport, [&lt;additional_plugins&gt; ]

This option tells ABRT to run the specified plugin(s) immediately 
after a crash is detected and saved. For example, the SOSreport plugin runs 
the sosreport tool which adds the data collected by it to the created crash dump. 
You can turn this behavior off by commenting out this line. For further fine-tuning,
 you can add SOSreport (or any other specified plugin) to either the CCpp or 
Python options to make ABRT run sosreport (or any other specified plugin) after 
any C and C++ or Python applications crash, respectively. For more information 
on various Action and Reporter plugins, refer to Section 21.3, “ ABRT Plugins”

[ AnalyzerActionsAndReporters ] Section Directives

This section allows you to associate certain analyzer actions and reporter 
actions to run when ABRT catches kernel oopses or crashes in C, C++ or Python programs. 
The actions and reporters specified in any of the directives below will run only 
if you run abrt-gui or abrt-cli and report the crash that occurred. 
If you do not specify any actions and reporters in these directives, 
you will not be able to report a crash via abrt-gui or abrt-cli. 
The order of actions and reporters is important. Commenting out a directive, 
will cause ABRT not to catch the crashes associated with that directive. 
For example, commenting out the Kerneloops line will cause ABRT not to catch kernel oopses.

Kerneloops = RHTSupport, Logger

This directive specifies that, for kernel oopses, 
both the RHTSupport and Logger reporters will be run.

CCpp = RHTSupport, Logger

This directive specifies that, when C or C++ program crashes occur, 
both the RHTSupport and Logger reporters will be run.

Python = RHTSupport, Logger

This directive specifies that, when Python program crashes occur, 
both the RHTSupport and Logger reporters will be run.

Each of these destinations' details can be specified in the corresponding 
plugins/*.conf file. For example, plugins/RHTSupport.conf specifies 
which RHTSupport URL to use (set to https://api.access.redhat.com/rs by default), 
the user's login name, password for logging in to the RHTSupport site, 
etc. All these options can also be configured through the abrt-gui application
 (for more information on plugin configuration refer to Section 21.3, “ ABRT Plugins”).

[ Cron ] Section Directives &lt;time&gt; = &lt;action_to_run&gt;

The [ Cron ] section of abrt.conf allows you to specify the exact time, 
or elapsed amount of time between, when ABRT should run a certain action, 
such as scanning for kernel oopses or performing file transfers. 
You can list further actions to run by appending them to the end of this section.

Example 21.1. [ Cron ] section of /etc/abrt/abrt.conf

# Which Action plugins to run repeatedly
[ Cron ]
# h:m - at h:m
# s - every s seconds
120 = KerneloopsScanner
#02:00 = FileTransfer


The format for an entry is either 
&lt;time_in_seconds&gt; = &lt;action_to_run&gt; or &lt;hh:mm&gt; = &lt;action_to_run&gt; , 
where hh (hour) is in the range 00-23 
(all hours less than 10 should be zero-filled, i.e. preceded by a 0), 
and mm (minute) is 00-59, zero-filled likewise. 
</code></pre>
]]></content>
  </entry>
  
</feed>
