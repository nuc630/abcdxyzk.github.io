<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2015~03 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2015~03/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-07-21T17:24:08+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[内核网络设备的注册与初始化(eth0...)]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/03/27/kernel-net-netdevice/"/>
    <updated>2015-03-27T17:56:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/03/27/kernel-net-netdevice</id>
    <content type="html"><![CDATA[<h4>找到eth0&hellip;之类的设备的数据结构</h4>

<pre><code>    # crash vmlinux

    p init_net
    找到：
      dev_base_head = {
        next = 0xffff88003e48b070, 
        prev = 0xffff880037582070
      },
    next 就是 struct net_device *dev; 中 dev-&gt;dev_list;
    算算 dev_list 在 dev 中的偏移为0x50（可能会不同）

    struct net_device 0xffff88003e48b020
    然后根据 dev中的dev_list.next取下一个net_device
      dev_list = {
        next = 0xffff880037582070, 
        prev = 0xffffffff81b185b0
      },
</code></pre>

<h4>找到net_device对应的XXX_adapter, 如ixgbe_adapter</h4>

<p>ixgbe模块在申请net_device时会把需要预留给ixgbe_adapter的空间大小传给alloc_etherdev
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
<span class='line-number'>571</span>
<span class='line-number'>572</span>
<span class='line-number'>573</span>
<span class='line-number'>574</span>
<span class='line-number'>575</span>
<span class='line-number'>576</span>
<span class='line-number'>577</span>
<span class='line-number'>578</span>
<span class='line-number'>579</span>
<span class='line-number'>580</span>
<span class='line-number'>581</span>
<span class='line-number'>582</span>
<span class='line-number'>583</span>
<span class='line-number'>584</span>
<span class='line-number'>585</span>
<span class='line-number'>586</span>
<span class='line-number'>587</span>
<span class='line-number'>588</span>
<span class='line-number'>589</span>
<span class='line-number'>590</span>
<span class='line-number'>591</span>
<span class='line-number'>592</span>
<span class='line-number'>593</span>
<span class='line-number'>594</span>
<span class='line-number'>595</span>
<span class='line-number'>596</span>
<span class='line-number'>597</span>
<span class='line-number'>598</span>
<span class='line-number'>599</span>
<span class='line-number'>600</span>
<span class='line-number'>601</span>
<span class='line-number'>602</span>
<span class='line-number'>603</span>
<span class='line-number'>604</span>
<span class='line-number'>605</span>
<span class='line-number'>606</span>
<span class='line-number'>607</span>
<span class='line-number'>608</span>
<span class='line-number'>609</span>
<span class='line-number'>610</span>
<span class='line-number'>611</span>
<span class='line-number'>612</span>
<span class='line-number'>613</span>
<span class='line-number'>614</span>
<span class='line-number'>615</span>
<span class='line-number'>616</span>
<span class='line-number'>617</span>
<span class='line-number'>618</span>
<span class='line-number'>619</span>
<span class='line-number'>620</span>
<span class='line-number'>621</span>
<span class='line-number'>622</span>
<span class='line-number'>623</span>
<span class='line-number'>624</span>
<span class='line-number'>625</span>
<span class='line-number'>626</span>
<span class='line-number'>627</span>
<span class='line-number'>628</span>
<span class='line-number'>629</span>
<span class='line-number'>630</span>
<span class='line-number'>631</span>
<span class='line-number'>632</span>
<span class='line-number'>633</span>
<span class='line-number'>634</span>
<span class='line-number'>635</span>
<span class='line-number'>636</span>
<span class='line-number'>637</span>
<span class='line-number'>638</span>
<span class='line-number'>639</span>
<span class='line-number'>640</span>
<span class='line-number'>641</span>
<span class='line-number'>642</span>
<span class='line-number'>643</span>
<span class='line-number'>644</span>
<span class='line-number'>645</span>
<span class='line-number'>646</span>
<span class='line-number'>647</span>
<span class='line-number'>648</span>
<span class='line-number'>649</span>
<span class='line-number'>650</span>
<span class='line-number'>651</span>
<span class='line-number'>652</span>
<span class='line-number'>653</span>
<span class='line-number'>654</span>
<span class='line-number'>655</span>
<span class='line-number'>656</span>
<span class='line-number'>657</span>
<span class='line-number'>658</span>
<span class='line-number'>659</span>
<span class='line-number'>660</span>
<span class='line-number'>661</span>
<span class='line-number'>662</span>
<span class='line-number'>663</span>
<span class='line-number'>664</span>
<span class='line-number'>665</span>
<span class='line-number'>666</span>
<span class='line-number'>667</span>
<span class='line-number'>668</span>
<span class='line-number'>669</span>
<span class='line-number'>670</span>
<span class='line-number'>671</span>
<span class='line-number'>672</span>
<span class='line-number'>673</span>
<span class='line-number'>674</span>
<span class='line-number'>675</span>
<span class='line-number'>676</span>
<span class='line-number'>677</span>
<span class='line-number'>678</span>
<span class='line-number'>679</span>
<span class='line-number'>680</span>
<span class='line-number'>681</span>
<span class='line-number'>682</span>
<span class='line-number'>683</span>
<span class='line-number'>684</span>
<span class='line-number'>685</span>
<span class='line-number'>686</span>
<span class='line-number'>687</span>
<span class='line-number'>688</span>
<span class='line-number'>689</span>
<span class='line-number'>690</span>
<span class='line-number'>691</span>
<span class='line-number'>692</span>
<span class='line-number'>693</span>
<span class='line-number'>694</span>
<span class='line-number'>695</span>
<span class='line-number'>696</span>
<span class='line-number'>697</span>
<span class='line-number'>698</span>
<span class='line-number'>699</span>
<span class='line-number'>700</span>
<span class='line-number'>701</span>
<span class='line-number'>702</span>
<span class='line-number'>703</span>
<span class='line-number'>704</span>
<span class='line-number'>705</span>
<span class='line-number'>706</span>
<span class='line-number'>707</span>
<span class='line-number'>708</span>
<span class='line-number'>709</span>
<span class='line-number'>710</span>
<span class='line-number'>711</span>
<span class='line-number'>712</span>
<span class='line-number'>713</span>
<span class='line-number'>714</span>
<span class='line-number'>715</span>
<span class='line-number'>716</span>
<span class='line-number'>717</span>
<span class='line-number'>718</span>
<span class='line-number'>719</span>
<span class='line-number'>720</span>
<span class='line-number'>721</span>
<span class='line-number'>722</span>
<span class='line-number'>723</span>
<span class='line-number'>724</span>
<span class='line-number'>725</span>
<span class='line-number'>726</span>
<span class='line-number'>727</span>
<span class='line-number'>728</span>
<span class='line-number'>729</span>
<span class='line-number'>730</span>
<span class='line-number'>731</span>
<span class='line-number'>732</span>
<span class='line-number'>733</span>
<span class='line-number'>734</span>
<span class='line-number'>735</span>
<span class='line-number'>736</span>
<span class='line-number'>737</span>
<span class='line-number'>738</span>
<span class='line-number'>739</span>
<span class='line-number'>740</span>
<span class='line-number'>741</span>
<span class='line-number'>742</span>
<span class='line-number'>743</span>
<span class='line-number'>744</span>
<span class='line-number'>745</span>
<span class='line-number'>746</span>
<span class='line-number'>747</span>
<span class='line-number'>748</span>
<span class='line-number'>749</span>
<span class='line-number'>750</span>
<span class='line-number'>751</span>
<span class='line-number'>752</span>
<span class='line-number'>753</span>
<span class='line-number'>754</span>
<span class='line-number'>755</span>
<span class='line-number'>756</span>
<span class='line-number'>757</span>
<span class='line-number'>758</span>
<span class='line-number'>759</span>
<span class='line-number'>760</span>
<span class='line-number'>761</span>
<span class='line-number'>762</span>
<span class='line-number'>763</span>
<span class='line-number'>764</span>
<span class='line-number'>765</span>
<span class='line-number'>766</span>
<span class='line-number'>767</span>
<span class='line-number'>768</span>
<span class='line-number'>769</span>
<span class='line-number'>770</span>
<span class='line-number'>771</span>
<span class='line-number'>772</span>
<span class='line-number'>773</span>
<span class='line-number'>774</span>
<span class='line-number'>775</span>
<span class='line-number'>776</span>
<span class='line-number'>777</span>
<span class='line-number'>778</span>
<span class='line-number'>779</span>
<span class='line-number'>780</span>
<span class='line-number'>781</span>
<span class='line-number'>782</span>
<span class='line-number'>783</span>
<span class='line-number'>784</span>
<span class='line-number'>785</span>
<span class='line-number'>786</span>
<span class='line-number'>787</span>
<span class='line-number'>788</span>
<span class='line-number'>789</span>
<span class='line-number'>790</span>
<span class='line-number'>791</span>
<span class='line-number'>792</span>
<span class='line-number'>793</span>
<span class='line-number'>794</span>
<span class='line-number'>795</span>
<span class='line-number'>796</span>
<span class='line-number'>797</span>
<span class='line-number'>798</span>
<span class='line-number'>799</span>
<span class='line-number'>800</span>
<span class='line-number'>801</span>
<span class='line-number'>802</span>
<span class='line-number'>803</span>
<span class='line-number'>804</span>
<span class='line-number'>805</span>
<span class='line-number'>806</span>
<span class='line-number'>807</span>
<span class='line-number'>808</span>
<span class='line-number'>809</span>
<span class='line-number'>810</span>
<span class='line-number'>811</span>
<span class='line-number'>812</span>
<span class='line-number'>813</span>
<span class='line-number'>814</span>
<span class='line-number'>815</span>
<span class='line-number'>816</span>
<span class='line-number'>817</span>
<span class='line-number'>818</span>
<span class='line-number'>819</span>
<span class='line-number'>820</span>
<span class='line-number'>821</span>
<span class='line-number'>822</span>
<span class='line-number'>823</span>
<span class='line-number'>824</span>
<span class='line-number'>825</span>
<span class='line-number'>826</span>
<span class='line-number'>827</span>
<span class='line-number'>828</span>
<span class='line-number'>829</span>
<span class='line-number'>830</span>
<span class='line-number'>831</span>
<span class='line-number'>832</span>
<span class='line-number'>833</span>
<span class='line-number'>834</span>
<span class='line-number'>835</span>
<span class='line-number'>836</span>
<span class='line-number'>837</span>
<span class='line-number'>838</span>
<span class='line-number'>839</span>
<span class='line-number'>840</span>
<span class='line-number'>841</span>
<span class='line-number'>842</span>
<span class='line-number'>843</span>
<span class='line-number'>844</span>
<span class='line-number'>845</span>
<span class='line-number'>846</span>
<span class='line-number'>847</span>
<span class='line-number'>848</span>
<span class='line-number'>849</span>
<span class='line-number'>850</span>
<span class='line-number'>851</span>
<span class='line-number'>852</span>
<span class='line-number'>853</span>
<span class='line-number'>854</span>
<span class='line-number'>855</span>
<span class='line-number'>856</span>
<span class='line-number'>857</span>
<span class='line-number'>858</span>
<span class='line-number'>859</span>
<span class='line-number'>860</span>
<span class='line-number'>861</span>
<span class='line-number'>862</span>
<span class='line-number'>863</span>
<span class='line-number'>864</span>
<span class='line-number'>865</span>
<span class='line-number'>866</span>
<span class='line-number'>867</span>
<span class='line-number'>868</span>
<span class='line-number'>869</span>
<span class='line-number'>870</span>
<span class='line-number'>871</span>
<span class='line-number'>872</span>
<span class='line-number'>873</span>
<span class='line-number'>874</span>
<span class='line-number'>875</span>
<span class='line-number'>876</span>
<span class='line-number'>877</span>
<span class='line-number'>878</span>
<span class='line-number'>879</span>
<span class='line-number'>880</span>
<span class='line-number'>881</span>
<span class='line-number'>882</span>
<span class='line-number'>883</span>
<span class='line-number'>884</span>
<span class='line-number'>885</span>
<span class='line-number'>886</span>
<span class='line-number'>887</span>
<span class='line-number'>888</span>
<span class='line-number'>889</span>
<span class='line-number'>890</span>
<span class='line-number'>891</span>
<span class='line-number'>892</span>
<span class='line-number'>893</span>
<span class='line-number'>894</span>
<span class='line-number'>895</span>
<span class='line-number'>896</span>
<span class='line-number'>897</span>
<span class='line-number'>898</span>
<span class='line-number'>899</span>
<span class='line-number'>900</span>
<span class='line-number'>901</span>
<span class='line-number'>902</span>
<span class='line-number'>903</span>
<span class='line-number'>904</span>
<span class='line-number'>905</span>
<span class='line-number'>906</span>
<span class='line-number'>907</span>
<span class='line-number'>908</span>
<span class='line-number'>909</span>
<span class='line-number'>910</span>
<span class='line-number'>911</span>
<span class='line-number'>912</span>
<span class='line-number'>913</span>
<span class='line-number'>914</span>
<span class='line-number'>915</span>
<span class='line-number'>916</span>
<span class='line-number'>917</span>
<span class='line-number'>918</span>
<span class='line-number'>919</span>
<span class='line-number'>920</span>
<span class='line-number'>921</span>
<span class='line-number'>922</span>
<span class='line-number'>923</span>
<span class='line-number'>924</span>
<span class='line-number'>925</span>
<span class='line-number'>926</span>
<span class='line-number'>927</span>
<span class='line-number'>928</span>
<span class='line-number'>929</span>
<span class='line-number'>930</span>
<span class='line-number'>931</span>
<span class='line-number'>932</span>
<span class='line-number'>933</span>
<span class='line-number'>934</span>
<span class='line-number'>935</span>
<span class='line-number'>936</span>
<span class='line-number'>937</span>
<span class='line-number'>938</span>
<span class='line-number'>939</span>
<span class='line-number'>940</span>
<span class='line-number'>941</span>
<span class='line-number'>942</span>
<span class='line-number'>943</span>
<span class='line-number'>944</span>
<span class='line-number'>945</span>
<span class='line-number'>946</span>
<span class='line-number'>947</span>
<span class='line-number'>948</span>
<span class='line-number'>949</span>
<span class='line-number'>950</span>
<span class='line-number'>951</span>
<span class='line-number'>952</span>
<span class='line-number'>953</span>
<span class='line-number'>954</span>
<span class='line-number'>955</span>
<span class='line-number'>956</span>
<span class='line-number'>957</span>
<span class='line-number'>958</span>
<span class='line-number'>959</span>
<span class='line-number'>960</span>
<span class='line-number'>961</span>
<span class='line-number'>962</span>
<span class='line-number'>963</span>
<span class='line-number'>964</span>
<span class='line-number'>965</span>
<span class='line-number'>966</span>
<span class='line-number'>967</span>
<span class='line-number'>968</span>
<span class='line-number'>969</span>
<span class='line-number'>970</span>
<span class='line-number'>971</span>
<span class='line-number'>972</span>
<span class='line-number'>973</span>
<span class='line-number'>974</span>
<span class='line-number'>975</span>
<span class='line-number'>976</span>
<span class='line-number'>977</span>
<span class='line-number'>978</span>
<span class='line-number'>979</span>
<span class='line-number'>980</span>
<span class='line-number'>981</span>
<span class='line-number'>982</span>
<span class='line-number'>983</span>
<span class='line-number'>984</span>
<span class='line-number'>985</span>
<span class='line-number'>986</span>
<span class='line-number'>987</span>
<span class='line-number'>988</span>
<span class='line-number'>989</span>
<span class='line-number'>990</span>
<span class='line-number'>991</span>
<span class='line-number'>992</span>
<span class='line-number'>993</span>
<span class='line-number'>994</span>
<span class='line-number'>995</span>
<span class='line-number'>996</span>
<span class='line-number'>997</span>
<span class='line-number'>998</span>
<span class='line-number'>999</span>
<span class='line-number'>1000</span>
<span class='line-number'>1001</span>
<span class='line-number'>1002</span>
<span class='line-number'>1003</span>
<span class='line-number'>1004</span>
<span class='line-number'>1005</span>
<span class='line-number'>1006</span>
<span class='line-number'>1007</span>
<span class='line-number'>1008</span>
<span class='line-number'>1009</span>
<span class='line-number'>1010</span>
<span class='line-number'>1011</span>
<span class='line-number'>1012</span>
<span class='line-number'>1013</span>
<span class='line-number'>1014</span>
<span class='line-number'>1015</span>
<span class='line-number'>1016</span>
<span class='line-number'>1017</span>
<span class='line-number'>1018</span>
<span class='line-number'>1019</span>
<span class='line-number'>1020</span>
<span class='line-number'>1021</span>
<span class='line-number'>1022</span>
<span class='line-number'>1023</span>
<span class='line-number'>1024</span>
<span class='line-number'>1025</span>
<span class='line-number'>1026</span>
<span class='line-number'>1027</span>
<span class='line-number'>1028</span>
<span class='line-number'>1029</span>
<span class='line-number'>1030</span>
<span class='line-number'>1031</span>
<span class='line-number'>1032</span>
<span class='line-number'>1033</span>
<span class='line-number'>1034</span>
<span class='line-number'>1035</span>
<span class='line-number'>1036</span>
<span class='line-number'>1037</span>
<span class='line-number'>1038</span>
<span class='line-number'>1039</span>
<span class='line-number'>1040</span>
<span class='line-number'>1041</span>
<span class='line-number'>1042</span>
<span class='line-number'>1043</span>
<span class='line-number'>1044</span>
<span class='line-number'>1045</span>
<span class='line-number'>1046</span>
<span class='line-number'>1047</span>
<span class='line-number'>1048</span>
<span class='line-number'>1049</span>
<span class='line-number'>1050</span>
<span class='line-number'>1051</span>
<span class='line-number'>1052</span>
<span class='line-number'>1053</span>
<span class='line-number'>1054</span>
<span class='line-number'>1055</span>
<span class='line-number'>1056</span>
<span class='line-number'>1057</span>
<span class='line-number'>1058</span>
<span class='line-number'>1059</span>
<span class='line-number'>1060</span>
<span class='line-number'>1061</span>
<span class='line-number'>1062</span>
<span class='line-number'>1063</span>
<span class='line-number'>1064</span>
<span class='line-number'>1065</span>
<span class='line-number'>1066</span>
<span class='line-number'>1067</span>
<span class='line-number'>1068</span>
<span class='line-number'>1069</span>
<span class='line-number'>1070</span>
<span class='line-number'>1071</span>
<span class='line-number'>1072</span>
<span class='line-number'>1073</span>
<span class='line-number'>1074</span>
<span class='line-number'>1075</span>
<span class='line-number'>1076</span>
<span class='line-number'>1077</span>
<span class='line-number'>1078</span>
<span class='line-number'>1079</span>
<span class='line-number'>1080</span>
<span class='line-number'>1081</span>
<span class='line-number'>1082</span>
<span class='line-number'>1083</span>
<span class='line-number'>1084</span>
<span class='line-number'>1085</span>
<span class='line-number'>1086</span>
<span class='line-number'>1087</span>
<span class='line-number'>1088</span>
<span class='line-number'>1089</span>
<span class='line-number'>1090</span>
<span class='line-number'>1091</span>
<span class='line-number'>1092</span>
<span class='line-number'>1093</span>
<span class='line-number'>1094</span>
<span class='line-number'>1095</span>
<span class='line-number'>1096</span>
<span class='line-number'>1097</span>
<span class='line-number'>1098</span>
<span class='line-number'>1099</span>
<span class='line-number'>1100</span>
<span class='line-number'>1101</span>
<span class='line-number'>1102</span>
<span class='line-number'>1103</span>
<span class='line-number'>1104</span>
<span class='line-number'>1105</span>
<span class='line-number'>1106</span>
<span class='line-number'>1107</span>
<span class='line-number'>1108</span>
<span class='line-number'>1109</span>
<span class='line-number'>1110</span>
<span class='line-number'>1111</span>
<span class='line-number'>1112</span>
<span class='line-number'>1113</span>
<span class='line-number'>1114</span>
<span class='line-number'>1115</span>
<span class='line-number'>1116</span>
<span class='line-number'>1117</span>
<span class='line-number'>1118</span>
<span class='line-number'>1119</span>
<span class='line-number'>1120</span>
<span class='line-number'>1121</span>
<span class='line-number'>1122</span>
<span class='line-number'>1123</span>
<span class='line-number'>1124</span>
<span class='line-number'>1125</span>
<span class='line-number'>1126</span>
<span class='line-number'>1127</span>
<span class='line-number'>1128</span>
<span class='line-number'>1129</span>
<span class='line-number'>1130</span>
<span class='line-number'>1131</span>
<span class='line-number'>1132</span>
<span class='line-number'>1133</span>
<span class='line-number'>1134</span>
<span class='line-number'>1135</span>
<span class='line-number'>1136</span>
<span class='line-number'>1137</span>
<span class='line-number'>1138</span>
<span class='line-number'>1139</span>
<span class='line-number'>1140</span>
<span class='line-number'>1141</span>
<span class='line-number'>1142</span>
<span class='line-number'>1143</span>
<span class='line-number'>1144</span>
<span class='line-number'>1145</span>
<span class='line-number'>1146</span>
<span class='line-number'>1147</span>
<span class='line-number'>1148</span>
<span class='line-number'>1149</span>
<span class='line-number'>1150</span>
<span class='line-number'>1151</span>
<span class='line-number'>1152</span>
<span class='line-number'>1153</span>
<span class='line-number'>1154</span>
<span class='line-number'>1155</span>
<span class='line-number'>1156</span>
<span class='line-number'>1157</span>
<span class='line-number'>1158</span>
<span class='line-number'>1159</span>
<span class='line-number'>1160</span>
<span class='line-number'>1161</span>
<span class='line-number'>1162</span>
<span class='line-number'>1163</span>
<span class='line-number'>1164</span>
<span class='line-number'>1165</span>
<span class='line-number'>1166</span>
<span class='line-number'>1167</span>
<span class='line-number'>1168</span>
<span class='line-number'>1169</span>
<span class='line-number'>1170</span>
<span class='line-number'>1171</span>
<span class='line-number'>1172</span>
<span class='line-number'>1173</span>
<span class='line-number'>1174</span>
<span class='line-number'>1175</span>
<span class='line-number'>1176</span>
<span class='line-number'>1177</span>
<span class='line-number'>1178</span>
<span class='line-number'>1179</span>
<span class='line-number'>1180</span>
<span class='line-number'>1181</span>
<span class='line-number'>1182</span>
<span class='line-number'>1183</span>
<span class='line-number'>1184</span>
<span class='line-number'>1185</span>
<span class='line-number'>1186</span>
<span class='line-number'>1187</span>
<span class='line-number'>1188</span>
<span class='line-number'>1189</span>
<span class='line-number'>1190</span>
<span class='line-number'>1191</span>
<span class='line-number'>1192</span>
<span class='line-number'>1193</span>
<span class='line-number'>1194</span>
<span class='line-number'>1195</span>
<span class='line-number'>1196</span>
<span class='line-number'>1197</span>
<span class='line-number'>1198</span>
<span class='line-number'>1199</span>
<span class='line-number'>1200</span>
<span class='line-number'>1201</span>
<span class='line-number'>1202</span>
<span class='line-number'>1203</span>
<span class='line-number'>1204</span>
<span class='line-number'>1205</span>
<span class='line-number'>1206</span>
<span class='line-number'>1207</span>
<span class='line-number'>1208</span>
<span class='line-number'>1209</span>
<span class='line-number'>1210</span>
<span class='line-number'>1211</span>
<span class='line-number'>1212</span>
<span class='line-number'>1213</span>
<span class='line-number'>1214</span>
<span class='line-number'>1215</span>
<span class='line-number'>1216</span>
<span class='line-number'>1217</span>
<span class='line-number'>1218</span>
<span class='line-number'>1219</span>
<span class='line-number'>1220</span>
<span class='line-number'>1221</span>
<span class='line-number'>1222</span>
<span class='line-number'>1223</span>
<span class='line-number'>1224</span>
<span class='line-number'>1225</span>
<span class='line-number'>1226</span>
<span class='line-number'>1227</span>
<span class='line-number'>1228</span>
<span class='line-number'>1229</span>
<span class='line-number'>1230</span>
<span class='line-number'>1231</span>
<span class='line-number'>1232</span>
<span class='line-number'>1233</span>
<span class='line-number'>1234</span>
<span class='line-number'>1235</span>
<span class='line-number'>1236</span>
<span class='line-number'>1237</span>
<span class='line-number'>1238</span>
<span class='line-number'>1239</span>
<span class='line-number'>1240</span>
<span class='line-number'>1241</span>
<span class='line-number'>1242</span>
<span class='line-number'>1243</span>
<span class='line-number'>1244</span>
<span class='line-number'>1245</span>
<span class='line-number'>1246</span>
<span class='line-number'>1247</span>
<span class='line-number'>1248</span>
<span class='line-number'>1249</span>
<span class='line-number'>1250</span>
<span class='line-number'>1251</span>
<span class='line-number'>1252</span>
<span class='line-number'>1253</span>
<span class='line-number'>1254</span>
<span class='line-number'>1255</span>
<span class='line-number'>1256</span>
<span class='line-number'>1257</span>
<span class='line-number'>1258</span>
<span class='line-number'>1259</span>
<span class='line-number'>1260</span>
<span class='line-number'>1261</span>
<span class='line-number'>1262</span>
<span class='line-number'>1263</span>
<span class='line-number'>1264</span>
<span class='line-number'>1265</span>
<span class='line-number'>1266</span>
<span class='line-number'>1267</span>
<span class='line-number'>1268</span>
<span class='line-number'>1269</span>
<span class='line-number'>1270</span>
<span class='line-number'>1271</span>
<span class='line-number'>1272</span>
<span class='line-number'>1273</span>
<span class='line-number'>1274</span>
<span class='line-number'>1275</span>
<span class='line-number'>1276</span>
<span class='line-number'>1277</span>
<span class='line-number'>1278</span>
<span class='line-number'>1279</span>
<span class='line-number'>1280</span>
<span class='line-number'>1281</span>
<span class='line-number'>1282</span>
<span class='line-number'>1283</span>
<span class='line-number'>1284</span>
<span class='line-number'>1285</span>
<span class='line-number'>1286</span>
<span class='line-number'>1287</span>
<span class='line-number'>1288</span>
<span class='line-number'>1289</span>
<span class='line-number'>1290</span>
<span class='line-number'>1291</span>
<span class='line-number'>1292</span>
<span class='line-number'>1293</span>
<span class='line-number'>1294</span>
<span class='line-number'>1295</span>
<span class='line-number'>1296</span>
<span class='line-number'>1297</span>
<span class='line-number'>1298</span>
<span class='line-number'>1299</span>
<span class='line-number'>1300</span>
<span class='line-number'>1301</span>
<span class='line-number'>1302</span>
<span class='line-number'>1303</span>
<span class='line-number'>1304</span>
<span class='line-number'>1305</span>
<span class='line-number'>1306</span>
<span class='line-number'>1307</span>
<span class='line-number'>1308</span>
<span class='line-number'>1309</span>
<span class='line-number'>1310</span>
<span class='line-number'>1311</span>
<span class='line-number'>1312</span>
<span class='line-number'>1313</span>
<span class='line-number'>1314</span>
<span class='line-number'>1315</span>
<span class='line-number'>1316</span>
<span class='line-number'>1317</span>
<span class='line-number'>1318</span>
<span class='line-number'>1319</span>
<span class='line-number'>1320</span>
<span class='line-number'>1321</span>
<span class='line-number'>1322</span>
<span class='line-number'>1323</span>
<span class='line-number'>1324</span>
<span class='line-number'>1325</span>
<span class='line-number'>1326</span>
<span class='line-number'>1327</span>
<span class='line-number'>1328</span>
<span class='line-number'>1329</span>
<span class='line-number'>1330</span>
<span class='line-number'>1331</span>
<span class='line-number'>1332</span>
<span class='line-number'>1333</span>
<span class='line-number'>1334</span>
<span class='line-number'>1335</span>
<span class='line-number'>1336</span>
<span class='line-number'>1337</span>
<span class='line-number'>1338</span>
<span class='line-number'>1339</span>
<span class='line-number'>1340</span>
<span class='line-number'>1341</span>
<span class='line-number'>1342</span>
<span class='line-number'>1343</span>
<span class='line-number'>1344</span>
<span class='line-number'>1345</span>
<span class='line-number'>1346</span>
<span class='line-number'>1347</span>
<span class='line-number'>1348</span>
<span class='line-number'>1349</span>
<span class='line-number'>1350</span>
<span class='line-number'>1351</span>
<span class='line-number'>1352</span>
<span class='line-number'>1353</span>
<span class='line-number'>1354</span>
<span class='line-number'>1355</span>
<span class='line-number'>1356</span>
<span class='line-number'>1357</span>
<span class='line-number'>1358</span>
<span class='line-number'>1359</span>
<span class='line-number'>1360</span>
<span class='line-number'>1361</span>
<span class='line-number'>1362</span>
<span class='line-number'>1363</span>
<span class='line-number'>1364</span>
<span class='line-number'>1365</span>
<span class='line-number'>1366</span>
<span class='line-number'>1367</span>
<span class='line-number'>1368</span>
<span class='line-number'>1369</span>
<span class='line-number'>1370</span>
<span class='line-number'>1371</span>
<span class='line-number'>1372</span>
<span class='line-number'>1373</span>
<span class='line-number'>1374</span>
<span class='line-number'>1375</span>
<span class='line-number'>1376</span>
<span class='line-number'>1377</span>
<span class='line-number'>1378</span>
<span class='line-number'>1379</span>
<span class='line-number'>1380</span>
<span class='line-number'>1381</span>
<span class='line-number'>1382</span>
<span class='line-number'>1383</span>
<span class='line-number'>1384</span>
<span class='line-number'>1385</span>
<span class='line-number'>1386</span>
<span class='line-number'>1387</span>
<span class='line-number'>1388</span>
<span class='line-number'>1389</span>
<span class='line-number'>1390</span>
<span class='line-number'>1391</span>
<span class='line-number'>1392</span>
<span class='line-number'>1393</span>
<span class='line-number'>1394</span>
<span class='line-number'>1395</span>
<span class='line-number'>1396</span>
<span class='line-number'>1397</span>
<span class='line-number'>1398</span>
<span class='line-number'>1399</span>
<span class='line-number'>1400</span>
<span class='line-number'>1401</span>
<span class='line-number'>1402</span>
<span class='line-number'>1403</span>
<span class='line-number'>1404</span>
<span class='line-number'>1405</span>
<span class='line-number'>1406</span>
<span class='line-number'>1407</span>
<span class='line-number'>1408</span>
<span class='line-number'>1409</span>
<span class='line-number'>1410</span>
<span class='line-number'>1411</span>
<span class='line-number'>1412</span>
<span class='line-number'>1413</span>
<span class='line-number'>1414</span>
<span class='line-number'>1415</span>
<span class='line-number'>1416</span>
<span class='line-number'>1417</span>
<span class='line-number'>1418</span>
<span class='line-number'>1419</span>
<span class='line-number'>1420</span>
<span class='line-number'>1421</span>
<span class='line-number'>1422</span>
<span class='line-number'>1423</span>
<span class='line-number'>1424</span>
<span class='line-number'>1425</span>
<span class='line-number'>1426</span>
<span class='line-number'>1427</span>
<span class='line-number'>1428</span>
<span class='line-number'>1429</span>
<span class='line-number'>1430</span>
<span class='line-number'>1431</span>
<span class='line-number'>1432</span>
<span class='line-number'>1433</span>
<span class='line-number'>1434</span>
<span class='line-number'>1435</span>
<span class='line-number'>1436</span>
<span class='line-number'>1437</span>
<span class='line-number'>1438</span>
<span class='line-number'>1439</span>
<span class='line-number'>1440</span>
<span class='line-number'>1441</span>
<span class='line-number'>1442</span>
<span class='line-number'>1443</span>
<span class='line-number'>1444</span>
<span class='line-number'>1445</span>
<span class='line-number'>1446</span>
<span class='line-number'>1447</span>
<span class='line-number'>1448</span>
<span class='line-number'>1449</span>
<span class='line-number'>1450</span>
<span class='line-number'>1451</span>
<span class='line-number'>1452</span>
<span class='line-number'>1453</span>
<span class='line-number'>1454</span>
<span class='line-number'>1455</span>
<span class='line-number'>1456</span>
<span class='line-number'>1457</span>
<span class='line-number'>1458</span>
<span class='line-number'>1459</span>
<span class='line-number'>1460</span>
<span class='line-number'>1461</span>
<span class='line-number'>1462</span>
<span class='line-number'>1463</span>
<span class='line-number'>1464</span>
<span class='line-number'>1465</span>
<span class='line-number'>1466</span>
<span class='line-number'>1467</span>
<span class='line-number'>1468</span>
<span class='line-number'>1469</span>
<span class='line-number'>1470</span>
<span class='line-number'>1471</span>
<span class='line-number'>1472</span>
<span class='line-number'>1473</span>
<span class='line-number'>1474</span>
<span class='line-number'>1475</span>
<span class='line-number'>1476</span>
<span class='line-number'>1477</span>
<span class='line-number'>1478</span>
<span class='line-number'>1479</span>
<span class='line-number'>1480</span>
<span class='line-number'>1481</span>
<span class='line-number'>1482</span>
<span class='line-number'>1483</span>
<span class='line-number'>1484</span>
<span class='line-number'>1485</span>
<span class='line-number'>1486</span>
<span class='line-number'>1487</span>
<span class='line-number'>1488</span>
<span class='line-number'>1489</span>
<span class='line-number'>1490</span>
<span class='line-number'>1491</span>
<span class='line-number'>1492</span>
<span class='line-number'>1493</span>
<span class='line-number'>1494</span>
<span class='line-number'>1495</span>
<span class='line-number'>1496</span>
<span class='line-number'>1497</span>
<span class='line-number'>1498</span>
<span class='line-number'>1499</span>
<span class='line-number'>1500</span>
<span class='line-number'>1501</span>
<span class='line-number'>1502</span>
<span class='line-number'>1503</span>
<span class='line-number'>1504</span>
<span class='line-number'>1505</span>
<span class='line-number'>1506</span>
<span class='line-number'>1507</span>
<span class='line-number'>1508</span>
<span class='line-number'>1509</span>
<span class='line-number'>1510</span>
<span class='line-number'>1511</span>
<span class='line-number'>1512</span>
<span class='line-number'>1513</span>
<span class='line-number'>1514</span>
<span class='line-number'>1515</span>
<span class='line-number'>1516</span>
<span class='line-number'>1517</span>
<span class='line-number'>1518</span>
<span class='line-number'>1519</span>
<span class='line-number'>1520</span>
<span class='line-number'>1521</span>
<span class='line-number'>1522</span>
<span class='line-number'>1523</span>
<span class='line-number'>1524</span>
<span class='line-number'>1525</span>
<span class='line-number'>1526</span>
<span class='line-number'>1527</span>
<span class='line-number'>1528</span>
<span class='line-number'>1529</span>
<span class='line-number'>1530</span>
<span class='line-number'>1531</span>
<span class='line-number'>1532</span>
<span class='line-number'>1533</span>
<span class='line-number'>1534</span>
<span class='line-number'>1535</span>
<span class='line-number'>1536</span>
<span class='line-number'>1537</span>
<span class='line-number'>1538</span>
<span class='line-number'>1539</span>
<span class='line-number'>1540</span>
<span class='line-number'>1541</span>
<span class='line-number'>1542</span>
<span class='line-number'>1543</span>
<span class='line-number'>1544</span>
<span class='line-number'>1545</span>
<span class='line-number'>1546</span>
<span class='line-number'>1547</span>
<span class='line-number'>1548</span>
<span class='line-number'>1549</span>
<span class='line-number'>1550</span>
<span class='line-number'>1551</span>
<span class='line-number'>1552</span>
<span class='line-number'>1553</span>
<span class='line-number'>1554</span>
<span class='line-number'>1555</span>
<span class='line-number'>1556</span>
<span class='line-number'>1557</span>
<span class='line-number'>1558</span>
<span class='line-number'>1559</span>
<span class='line-number'>1560</span>
<span class='line-number'>1561</span>
<span class='line-number'>1562</span>
<span class='line-number'>1563</span>
<span class='line-number'>1564</span>
<span class='line-number'>1565</span>
<span class='line-number'>1566</span>
<span class='line-number'>1567</span>
<span class='line-number'>1568</span>
<span class='line-number'>1569</span>
<span class='line-number'>1570</span>
<span class='line-number'>1571</span>
<span class='line-number'>1572</span>
<span class='line-number'>1573</span>
<span class='line-number'>1574</span>
<span class='line-number'>1575</span>
<span class='line-number'>1576</span>
<span class='line-number'>1577</span>
<span class='line-number'>1578</span>
<span class='line-number'>1579</span>
<span class='line-number'>1580</span>
<span class='line-number'>1581</span>
<span class='line-number'>1582</span>
<span class='line-number'>1583</span>
<span class='line-number'>1584</span>
<span class='line-number'>1585</span>
<span class='line-number'>1586</span>
<span class='line-number'>1587</span>
<span class='line-number'>1588</span>
<span class='line-number'>1589</span>
<span class='line-number'>1590</span>
<span class='line-number'>1591</span>
<span class='line-number'>1592</span>
<span class='line-number'>1593</span>
<span class='line-number'>1594</span>
<span class='line-number'>1595</span>
<span class='line-number'>1596</span>
<span class='line-number'>1597</span>
<span class='line-number'>1598</span>
<span class='line-number'>1599</span>
<span class='line-number'>1600</span>
<span class='line-number'>1601</span>
<span class='line-number'>1602</span>
<span class='line-number'>1603</span>
<span class='line-number'>1604</span>
<span class='line-number'>1605</span>
<span class='line-number'>1606</span>
<span class='line-number'>1607</span>
<span class='line-number'>1608</span>
<span class='line-number'>1609</span>
<span class='line-number'>1610</span>
<span class='line-number'>1611</span>
<span class='line-number'>1612</span>
<span class='line-number'>1613</span>
<span class='line-number'>1614</span>
<span class='line-number'>1615</span>
<span class='line-number'>1616</span>
<span class='line-number'>1617</span>
<span class='line-number'>1618</span>
<span class='line-number'>1619</span>
<span class='line-number'>1620</span>
<span class='line-number'>1621</span>
<span class='line-number'>1622</span>
<span class='line-number'>1623</span>
<span class='line-number'>1624</span>
<span class='line-number'>1625</span>
<span class='line-number'>1626</span>
<span class='line-number'>1627</span>
<span class='line-number'>1628</span>
<span class='line-number'>1629</span>
<span class='line-number'>1630</span>
<span class='line-number'>1631</span>
<span class='line-number'>1632</span>
<span class='line-number'>1633</span>
<span class='line-number'>1634</span>
<span class='line-number'>1635</span>
<span class='line-number'>1636</span>
<span class='line-number'>1637</span>
<span class='line-number'>1638</span>
<span class='line-number'>1639</span>
<span class='line-number'>1640</span>
<span class='line-number'>1641</span>
<span class='line-number'>1642</span>
<span class='line-number'>1643</span>
<span class='line-number'>1644</span>
<span class='line-number'>1645</span>
<span class='line-number'>1646</span>
<span class='line-number'>1647</span>
<span class='line-number'>1648</span>
<span class='line-number'>1649</span>
<span class='line-number'>1650</span>
<span class='line-number'>1651</span>
<span class='line-number'>1652</span>
<span class='line-number'>1653</span>
<span class='line-number'>1654</span>
<span class='line-number'>1655</span>
<span class='line-number'>1656</span>
<span class='line-number'>1657</span>
<span class='line-number'>1658</span>
<span class='line-number'>1659</span>
<span class='line-number'>1660</span>
<span class='line-number'>1661</span>
<span class='line-number'>1662</span>
<span class='line-number'>1663</span>
<span class='line-number'>1664</span>
<span class='line-number'>1665</span>
<span class='line-number'>1666</span>
<span class='line-number'>1667</span>
<span class='line-number'>1668</span>
<span class='line-number'>1669</span>
<span class='line-number'>1670</span>
<span class='line-number'>1671</span>
<span class='line-number'>1672</span>
<span class='line-number'>1673</span>
<span class='line-number'>1674</span>
<span class='line-number'>1675</span>
<span class='line-number'>1676</span>
<span class='line-number'>1677</span>
<span class='line-number'>1678</span>
<span class='line-number'>1679</span>
<span class='line-number'>1680</span>
<span class='line-number'>1681</span>
<span class='line-number'>1682</span>
<span class='line-number'>1683</span>
<span class='line-number'>1684</span>
<span class='line-number'>1685</span>
<span class='line-number'>1686</span>
<span class='line-number'>1687</span>
<span class='line-number'>1688</span>
<span class='line-number'>1689</span>
<span class='line-number'>1690</span>
<span class='line-number'>1691</span>
<span class='line-number'>1692</span>
<span class='line-number'>1693</span>
<span class='line-number'>1694</span>
<span class='line-number'>1695</span>
<span class='line-number'>1696</span>
<span class='line-number'>1697</span>
<span class='line-number'>1698</span>
<span class='line-number'>1699</span>
<span class='line-number'>1700</span>
<span class='line-number'>1701</span>
<span class='line-number'>1702</span>
<span class='line-number'>1703</span>
<span class='line-number'>1704</span>
<span class='line-number'>1705</span>
<span class='line-number'>1706</span>
<span class='line-number'>1707</span>
<span class='line-number'>1708</span>
<span class='line-number'>1709</span>
<span class='line-number'>1710</span>
<span class='line-number'>1711</span>
<span class='line-number'>1712</span>
<span class='line-number'>1713</span>
<span class='line-number'>1714</span>
<span class='line-number'>1715</span>
<span class='line-number'>1716</span>
<span class='line-number'>1717</span>
<span class='line-number'>1718</span>
<span class='line-number'>1719</span>
<span class='line-number'>1720</span>
<span class='line-number'>1721</span>
<span class='line-number'>1722</span>
<span class='line-number'>1723</span>
<span class='line-number'>1724</span>
<span class='line-number'>1725</span>
<span class='line-number'>1726</span>
<span class='line-number'>1727</span>
<span class='line-number'>1728</span>
<span class='line-number'>1729</span>
<span class='line-number'>1730</span>
<span class='line-number'>1731</span>
<span class='line-number'>1732</span>
<span class='line-number'>1733</span>
<span class='line-number'>1734</span>
<span class='line-number'>1735</span>
<span class='line-number'>1736</span>
<span class='line-number'>1737</span>
<span class='line-number'>1738</span>
<span class='line-number'>1739</span>
<span class='line-number'>1740</span>
<span class='line-number'>1741</span>
<span class='line-number'>1742</span>
<span class='line-number'>1743</span>
<span class='line-number'>1744</span>
<span class='line-number'>1745</span>
<span class='line-number'>1746</span>
<span class='line-number'>1747</span>
<span class='line-number'>1748</span>
<span class='line-number'>1749</span>
<span class='line-number'>1750</span>
<span class='line-number'>1751</span>
<span class='line-number'>1752</span>
<span class='line-number'>1753</span>
<span class='line-number'>1754</span>
<span class='line-number'>1755</span>
<span class='line-number'>1756</span>
<span class='line-number'>1757</span>
<span class='line-number'>1758</span>
<span class='line-number'>1759</span>
<span class='line-number'>1760</span>
<span class='line-number'>1761</span>
<span class='line-number'>1762</span>
<span class='line-number'>1763</span>
<span class='line-number'>1764</span>
<span class='line-number'>1765</span>
<span class='line-number'>1766</span>
<span class='line-number'>1767</span>
<span class='line-number'>1768</span>
<span class='line-number'>1769</span>
<span class='line-number'>1770</span>
<span class='line-number'>1771</span>
<span class='line-number'>1772</span>
<span class='line-number'>1773</span>
<span class='line-number'>1774</span>
<span class='line-number'>1775</span>
<span class='line-number'>1776</span>
<span class='line-number'>1777</span>
<span class='line-number'>1778</span>
<span class='line-number'>1779</span>
<span class='line-number'>1780</span>
<span class='line-number'>1781</span>
<span class='line-number'>1782</span>
<span class='line-number'>1783</span>
<span class='line-number'>1784</span>
<span class='line-number'>1785</span>
<span class='line-number'>1786</span>
<span class='line-number'>1787</span>
<span class='line-number'>1788</span>
<span class='line-number'>1789</span>
<span class='line-number'>1790</span>
<span class='line-number'>1791</span>
<span class='line-number'>1792</span>
<span class='line-number'>1793</span>
<span class='line-number'>1794</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>netdev = alloc_etherdev(sizeof(struct ixgbe_adapter));&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;adapter = netdev_priv(netdev);
</span><span class='line'>
</span><span class='line'>static inline void *netdev_priv(const struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>return (char *)dev + ALIGN(sizeof(struct net_device), NETDEV_ALIGN);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;所以ixgbe_adapter在net_device结构按32位对其后面，偏移0x6c0（视内核而定）
</span><span class='line'>
</span><span class='line'>-----------
</span><span class='line'>
</span><span class='line'>http://blog.csdn.net/sfrysh/article/details/5736752
</span><span class='line'>
</span><span class='line'>首先来看如何分配内存给一个网络设备。
</span><span class='line'>
</span><span class='line'>内核通过alloc_netdev来分配内存给一个指定的网络设备: 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#define alloc_netdev(sizeof_priv, name, setup) /   
</span><span class='line'>alloc_netdev_mq(sizeof_priv, name, setup, 1)   
</span><span class='line'>
</span><span class='line'>struct net_device *alloc_netdev_mq(int sizeof_priv, const char *name,   
</span><span class='line'>    void (*setup)(struct net_device *), unsigned int queue_count)  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>其中alloc_netdev_mq中的第一个元素是每个网络设备的私有数据(主要是包含一些硬件参数，比如中断之类的)的大小，也就是net_device结构中的priv的大小。第二个参数是设备名，我们传递进来一般都是一个待format的字符串，比如"eth%d",到时多个相同类型网卡设备就会依次为eth0,1(内核会通过dev_alloc_name来进行设置)... 第三个参数setup是一个初始化net_device结构的回调函数。
</span><span class='line'>
</span><span class='line'>可是一般我们不需要直接调用alloc_netdev的，内核提供了一些包装好的函数：
</span><span class='line'>
</span><span class='line'>这里我们只看alloc_etherdev： 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1)   
</span><span class='line'>struct net_device *alloc_etherdev_mq(int sizeof_priv, unsigned int queue_count)   
</span><span class='line'>{   
</span><span class='line'>return alloc_netdev_mq(sizeof_priv, "eth%d", ether_setup, queue_count);   
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>这里实际是根据网卡的类型进行包装，也就类似于oo中的基类，ether_setup初始化一些所有相同类型的网络设备的一些相同配置的域： 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void ether_setup(struct net_device *dev)   
</span><span class='line'>{   
</span><span class='line'>dev-&gt;header_ops      = &amp;eth_header_ops;   
</span><span class='line'>
</span><span class='line'>dev-&gt;change_mtu      = eth_change_mtu;   
</span><span class='line'>dev-&gt;set_mac_address     = eth_mac_addr;   
</span><span class='line'>dev-&gt;validate_addr   = eth_validate_addr;   
</span><span class='line'>
</span><span class='line'>dev-&gt;type        = ARPHRD_ETHER;   
</span><span class='line'>dev-&gt;hard_header_len     = ETH_HLEN;   
</span><span class='line'>dev-&gt;mtu     = ETH_DATA_LEN;   
</span><span class='line'>dev-&gt;addr_len        = ETH_ALEN;   
</span><span class='line'>dev-&gt;tx_queue_len    = 1000; /* Ethernet wants good queues */  
</span><span class='line'>dev-&gt;flags       = IFF_BROADCAST|IFF_MULTICAST;   
</span><span class='line'>
</span><span class='line'>memset(dev-&gt;broadcast, 0xFF, ETH_ALEN);   
</span><span class='line'>
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>接下来我们来看注册网络设备的一些细节。 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int register_netdev(struct net_device *dev)   
</span><span class='line'>{   
</span><span class='line'>int err;   
</span><span class='line'>
</span><span class='line'>rtnl_lock();   
</span><span class='line'>
</span><span class='line'>/*  
</span><span class='line'> * If the name is a format string the caller wants us to do a  
</span><span class='line'> * name allocation.  
</span><span class='line'> */  
</span><span class='line'>if (strchr(dev-&gt;name, '%')) {   
</span><span class='line'>///这里通过dev_alloc_name函数来对设备名进行设置。   
</span><span class='line'>    err = dev_alloc_name(dev, dev-&gt;name);   
</span><span class='line'>    if (err &lt; 0)   
</span><span class='line'>        goto out;   
</span><span class='line'>}   
</span><span class='line'>///注册当前的网络设备到全局的网络设备链表中.下面会详细看这个函数.   
</span><span class='line'>err = register_netdevice(dev);   
</span><span class='line'>out:   
</span><span class='line'>rtnl_unlock();   
</span><span class='line'>return err;   
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>整个网络设备就是一个链表，他需要很方便的遍历所有设备，以及很快的定位某个指定的设备。为此net_device包含了下面3个链表(有关内核中数据结构的介绍，可以去自己google下)： 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;///可以根据index来定位设备   
</span><span class='line'>struct hlist_node   index_hlist;   
</span><span class='line'>///可以根据name来定位设备   
</span><span class='line'>struct hlist_node   name_hlist;   
</span><span class='line'>///通过dev_list，将此设备插入到全局的dev_base_head中，我们下面会介绍这个。   
</span><span class='line'>struct list_head    dev_list;  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>当设备注册成功后，还需要通知内核的其他组件，这里通过netdev_chain类型的notifier chain来通知其他组件。事件是NETDEV_REGISTER..其他设备通过register_netdevice_notifier来注册自己感兴趣的事件到此notifier chain上。
</span><span class='line'>
</span><span class='line'>网络设备(比如打开或关闭一个设备)，与用户空间的通信通过rtmsg_ifinfo函数，也就是RTMGRP_LINK的netlink。
</span><span class='line'>
</span><span class='line'>每个设备还包含两个状态，一个是state字段，表示排队策略状态(用位图表示)，一个是注册状态。
</span><span class='line'>
</span><span class='line'>包的排队策略也就是qos了。。 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int register_netdevice(struct net_device *dev)   
</span><span class='line'>{   
</span><span class='line'>struct hlist_head *head;   
</span><span class='line'>struct hlist_node *p;   
</span><span class='line'>int ret;   
</span><span class='line'>struct net *net;   
</span><span class='line'>
</span><span class='line'>BUG_ON(dev_boot_phase);   
</span><span class='line'>ASSERT_RTNL();   
</span><span class='line'>
</span><span class='line'>might_sleep();   
</span><span class='line'>
</span><span class='line'>/* When net_device's are persistent, this will be fatal. */  
</span><span class='line'>BUG_ON(dev-&gt;reg_state != NETREG_UNINITIALIZED);   
</span><span class='line'>BUG_ON(!dev_net(dev));   
</span><span class='line'>net = dev_net(dev);   
</span><span class='line'>
</span><span class='line'>///初始化相关的锁   
</span><span class='line'>spin_lock_init(&amp;dev-&gt;addr_list_lock);   
</span><span class='line'>netdev_set_addr_lockdep_class(dev);   
</span><span class='line'>netdev_init_queue_locks(dev);   
</span><span class='line'>
</span><span class='line'>dev-&gt;iflink = -1;   
</span><span class='line'>
</span><span class='line'>/* Init, if this function is available */  
</span><span class='line'>if (dev-&gt;init) {   
</span><span class='line'>    ret = dev-&gt;init(dev);   
</span><span class='line'>    if (ret) {   
</span><span class='line'>        if (ret &gt; 0)   
</span><span class='line'>            ret = -EIO;   
</span><span class='line'>        goto out;   
</span><span class='line'>    }   
</span><span class='line'>}   
</span><span class='line'>
</span><span class='line'>if (!dev_valid_name(dev-&gt;name)) {   
</span><span class='line'>    ret = -EINVAL;   
</span><span class='line'>    goto err_uninit;   
</span><span class='line'>}   
</span><span class='line'>///给设备分配一个唯一的identifier.   
</span><span class='line'>dev-&gt;ifindex = dev_new_index(net);   
</span><span class='line'>if (dev-&gt;iflink == -1)   
</span><span class='line'>    dev-&gt;iflink = dev-&gt;ifindex;   
</span><span class='line'>
</span><span class='line'>///在全局的链表中检测是否有重复的名字   
</span><span class='line'>head = dev_name_hash(net, dev-&gt;name);   
</span><span class='line'>hlist_for_each(p, head) {   
</span><span class='line'>    struct net_device *d   
</span><span class='line'>        = hlist_entry(p, struct net_device, name_hlist);   
</span><span class='line'>    if (!strncmp(d-&gt;name, dev-&gt;name, IFNAMSIZ)) {   
</span><span class='line'>        ret = -EEXIST;   
</span><span class='line'>        goto err_uninit;   
</span><span class='line'>    }   
</span><span class='line'>}   
</span><span class='line'>///下面是检测一些特性的组合是否合法。   
</span><span class='line'>/* Fix illegal checksum combinations */  
</span><span class='line'>if ((dev-&gt;features &amp; NETIF_F_HW_CSUM) &amp;&amp;   
</span><span class='line'>    (dev-&gt;features &amp; (NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM))) {   
</span><span class='line'>    printk(KERN_NOTICE "%s: mixed HW and IP checksum settings./n",   
</span><span class='line'>           dev-&gt;name);   
</span><span class='line'>    dev-&gt;features &amp;= ~(NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM);   
</span><span class='line'>}   
</span><span class='line'>
</span><span class='line'>if ((dev-&gt;features &amp; NETIF_F_NO_CSUM) &amp;&amp;   
</span><span class='line'>    (dev-&gt;features &amp; (NETIF_F_HW_CSUM|NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM))) {   
</span><span class='line'>    printk(KERN_NOTICE "%s: mixed no checksumming and other settings./n",   
</span><span class='line'>           dev-&gt;name);   
</span><span class='line'>    dev-&gt;features &amp;= ~(NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM|NETIF_F_HW_CSUM);   
</span><span class='line'>}   
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>/* Fix illegal SG+CSUM combinations. */  
</span><span class='line'>if ((dev-&gt;features &amp; NETIF_F_SG) &amp;&amp;   
</span><span class='line'>    !(dev-&gt;features &amp; NETIF_F_ALL_CSUM)) {   
</span><span class='line'>    printk(KERN_NOTICE "%s: Dropping NETIF_F_SG since no checksum feature./n",   
</span><span class='line'>           dev-&gt;name);   
</span><span class='line'>    dev-&gt;features &amp;= ~NETIF_F_SG;   
</span><span class='line'>}   
</span><span class='line'>
</span><span class='line'>/* TSO requires that SG is present as well. */  
</span><span class='line'>if ((dev-&gt;features &amp; NETIF_F_TSO) &amp;&amp;   
</span><span class='line'>    !(dev-&gt;features &amp; NETIF_F_SG)) {   
</span><span class='line'>    printk(KERN_NOTICE "%s: Dropping NETIF_F_TSO since no SG feature./n",   
</span><span class='line'>           dev-&gt;name);   
</span><span class='line'>    dev-&gt;features &amp;= ~NETIF_F_TSO;   
</span><span class='line'>}   
</span><span class='line'>if (dev-&gt;features &amp; NETIF_F_UFO) {   
</span><span class='line'>    if (!(dev-&gt;features &amp; NETIF_F_HW_CSUM)) {   
</span><span class='line'>        printk(KERN_ERR "%s: Dropping NETIF_F_UFO since no "  
</span><span class='line'>                "NETIF_F_HW_CSUM feature./n",   
</span><span class='line'>                        dev-&gt;name);   
</span><span class='line'>        dev-&gt;features &amp;= ~NETIF_F_UFO;   
</span><span class='line'>    }   
</span><span class='line'>    if (!(dev-&gt;features &amp; NETIF_F_SG)) {   
</span><span class='line'>        printk(KERN_ERR "%s: Dropping NETIF_F_UFO since no "  
</span><span class='line'>                "NETIF_F_SG feature./n",   
</span><span class='line'>                dev-&gt;name);   
</span><span class='line'>        dev-&gt;features &amp;= ~NETIF_F_UFO;   
</span><span class='line'>    }   
</span><span class='line'>}   
</span><span class='line'>
</span><span class='line'>/* Enable software GSO if SG is supported. */  
</span><span class='line'>if (dev-&gt;features &amp; NETIF_F_SG)   
</span><span class='line'>    dev-&gt;features |= NETIF_F_GSO;   
</span><span class='line'>
</span><span class='line'>///初始化设备驱动的kobject并创建相关的sysfs   
</span><span class='line'>netdev_initialize_kobject(dev);   
</span><span class='line'>ret = netdev_register_kobject(dev);   
</span><span class='line'>if (ret)   
</span><span class='line'>    goto err_uninit;   
</span><span class='line'>///设置注册状态。   
</span><span class='line'>dev-&gt;reg_state = NETREG_REGISTERED;   
</span><span class='line'>
</span><span class='line'>/*  
</span><span class='line'> *  Default initial state at registry is that the  
</span><span class='line'> *  device is present.  
</span><span class='line'> */  
</span><span class='line'>
</span><span class='line'>///设置排队策略状态。   
</span><span class='line'>set_bit(__LINK_STATE_PRESENT, &amp;dev-&gt;state);   
</span><span class='line'>///初始化排队规则   
</span><span class='line'>dev_init_scheduler(dev);   
</span><span class='line'>dev_hold(dev);   
</span><span class='line'>///将相应的链表插入到全局的链表中。紧接着会介绍这个函数   
</span><span class='line'>list_netdevice(dev);   
</span><span class='line'>
</span><span class='line'>/* Notify protocols, that a new device appeared. */  
</span><span class='line'>///调用netdev_chain通知内核其他子系统。   
</span><span class='line'>ret = call_netdevice_notifiers(NETDEV_REGISTER, dev);   
</span><span class='line'>ret = notifier_to_errno(ret);   
</span><span class='line'>if (ret) {   
</span><span class='line'>    rollback_registered(dev);   
</span><span class='line'>    dev-&gt;reg_state = NETREG_UNREGISTERED;   
</span><span class='line'>}   
</span><span class='line'>
</span><span class='line'>out:   
</span><span class='line'>return ret;   
</span><span class='line'>
</span><span class='line'>err_uninit:   
</span><span class='line'>if (dev-&gt;uninit)   
</span><span class='line'>    dev-&gt;uninit(dev);   
</span><span class='line'>goto out;   
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>这里要注意有一个全局的struct net init_net;变量，这个变量保存了全局的name,index  hlist以及全局的网络设备链表。
</span><span class='line'>
</span><span class='line'>net结构我们这里所需要的也就三个链表： 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;///设备链表   
</span><span class='line'>struct list_head    dev_base_head;   
</span><span class='line'>///名字为索引的hlist   
</span><span class='line'>struct hlist_head   *dev_name_head;   
</span><span class='line'>///index为索引的hlist   
</span><span class='line'>struct hlist_head   *dev_index_head;  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int list_netdevice(struct net_device *dev)   
</span><span class='line'>{   
</span><span class='line'>struct net *net = dev_net(dev);   
</span><span class='line'>
</span><span class='line'>ASSERT_RTNL();   
</span><span class='line'>
</span><span class='line'>write_lock_bh(&amp;dev_base_lock);   
</span><span class='line'>///插入全局的list   
</span><span class='line'>list_add_tail(&amp;dev-&gt;dev_list, &amp;net-&gt;dev_base_head);   
</span><span class='line'>插入全局的name_list以及index_hlist   
</span><span class='line'>hlist_add_head(&amp;dev-&gt;name_hlist, dev_name_hash(net, dev-&gt;name));   
</span><span class='line'>hlist_add_head(&amp;dev-&gt;index_hlist, dev_index_hash(net, dev-&gt;ifindex));   
</span><span class='line'>write_unlock_bh(&amp;dev_base_lock);   
</span><span class='line'>return 0;   
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>最终执行完之后，注册函数将会执行rtnl_unlock函数，而此函数则会执行netdev_run_todo方法。也就是完成最终的注册。(要注意，当取消注册这个设备时也会调用这个函数来完成最终的取消注册)
</span><span class='line'>
</span><span class='line'>这里有一个全局的net_todo_list的链表： 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static LIST_HEAD(net_todo_list);  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>而在取消注册的函数中会调用这个函数： 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void net_set_todo(struct net_device *dev)   
</span><span class='line'>{   
</span><span class='line'>list_add_tail(&amp;dev-&gt;todo_list, &amp;net_todo_list);   
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>也就是把当前将要取消注册的函数加入到todo_list链表中。 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void netdev_run_todo(void)   
</span><span class='line'>{   
</span><span class='line'>struct list_head list;   
</span><span class='line'>
</span><span class='line'>/* Snapshot list, allow later requests */  
</span><span class='line'>///replace掉net_todo_list用list代替。   
</span><span class='line'>list_replace_init(&amp;net_todo_list, &amp;list);   
</span><span class='line'>
</span><span class='line'>__rtnl_unlock();   
</span><span class='line'>///当注册设备时没有调用net_set_todo函数来设置net_todo_list，因此list为空，所以就会直接跳过。   
</span><span class='line'>while (!list_empty(&amp;list)) {   
</span><span class='line'>///通过todo_list得到当前的device对象。   
</span><span class='line'>    struct net_device *dev   
</span><span class='line'>        = list_entry(list.next, struct net_device, todo_list);   
</span><span class='line'>///删除此todo_list;   
</span><span class='line'>    list_del(&amp;dev-&gt;todo_list);   
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    if (unlikely(dev-&gt;reg_state != NETREG_UNREGISTERING)) {   
</span><span class='line'>        printk(KERN_ERR "network todo '%s' but state %d/n",   
</span><span class='line'>               dev-&gt;name, dev-&gt;reg_state);   
</span><span class='line'>        dump_stack();   
</span><span class='line'>        continue;   
</span><span class='line'>    }   
</span><span class='line'>///设置注册状态为NETREG_UNREGISTERED.   
</span><span class='line'>    dev-&gt;reg_state = NETREG_UNREGISTERED;   
</span><span class='line'>///在每个cpu上调用刷新函数。   
</span><span class='line'>    on_each_cpu(flush_backlog, dev, 1);   
</span><span class='line'>
</span><span class='line'>///等待引用此设备的所有系统释放资源，也就是引用计数清0.   
</span><span class='line'>    netdev_wait_allrefs(dev);   
</span><span class='line'>
</span><span class='line'>    /* paranoia */  
</span><span class='line'>    BUG_ON(atomic_read(&amp;dev-&gt;refcnt));   
</span><span class='line'>    WARN_ON(dev-&gt;ip_ptr);   
</span><span class='line'>    WARN_ON(dev-&gt;ip6_ptr);   
</span><span class='line'>    WARN_ON(dev-&gt;dn_ptr);   
</span><span class='line'>
</span><span class='line'>    if (dev-&gt;destructor)   
</span><span class='line'>        dev-&gt;destructor(dev);   
</span><span class='line'>
</span><span class='line'>    /* Free network device */  
</span><span class='line'>    kobject_put(&amp;dev-&gt;dev.kobj);   
</span><span class='line'>}   
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>下面来看netdev_wait_allrefs函数，我们先看它的调用流程:
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void netdev_wait_allrefs(struct net_device *dev)   
</span><span class='line'>{   
</span><span class='line'>unsigned long rebroadcast_time, warning_time;   
</span><span class='line'>
</span><span class='line'>rebroadcast_time = warning_time = jiffies;   
</span><span class='line'>while (atomic_read(&amp;dev-&gt;refcnt) != 0) {   
</span><span class='line'>    if (time_after(jiffies, rebroadcast_time + 1 * HZ)) {   
</span><span class='line'>        rtnl_lock();   
</span><span class='line'>
</span><span class='line'>///给netdev_chain发送NETDEV_UNREGISTER事件，通知各个子模块释放资源   
</span><span class='line'>        /* Rebroadcast unregister notification */  
</span><span class='line'>        call_netdevice_notifiers(NETDEV_UNREGISTER, dev);   
</span><span class='line'>
</span><span class='line'>        if (test_bit(__LINK_STATE_LINKWATCH_PENDING,   
</span><span class='line'>                 &amp;dev-&gt;state)) {   
</span><span class='line'>            /* We must not have linkwatch events  
</span><span class='line'>             * pending on unregister. If this  
</span><span class='line'>             * happens, we simply run the queue  
</span><span class='line'>             * unscheduled, resulting in a noop  
</span><span class='line'>             * for this device.  
</span><span class='line'>             */  
</span><span class='line'>            linkwatch_run_queue();   
</span><span class='line'>        }   
</span><span class='line'>
</span><span class='line'>        __rtnl_unlock();   
</span><span class='line'>
</span><span class='line'>        rebroadcast_time = jiffies;   
</span><span class='line'>    }   
</span><span class='line'>
</span><span class='line'>    msleep(250);   
</span><span class='line'>
</span><span class='line'>    if (time_after(jiffies, warning_time + 10 * HZ)) {   
</span><span class='line'>        printk(KERN_EMERG "unregister_netdevice: "  
</span><span class='line'>               "waiting for %s to become free. Usage "  
</span><span class='line'>               "count = %d/n",   
</span><span class='line'>               dev-&gt;name, atomic_read(&amp;dev-&gt;refcnt));   
</span><span class='line'>        warning_time = jiffies;   
</span><span class='line'>    }   
</span><span class='line'>}   
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[TCP的TSO/GSO处理（二）]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/03/27/kernel-net-tso3/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-03-27T17:45:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/03/27/kernel-net-tso3&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://book.51cto.com/art/201206/345021.htm"&gt;http://book.51cto.com/art/201206/345021.htm&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;有些网络设备硬件可以完成一些传统上由CPU完成的任务，最常见的例子就是计算三层和四层校验和。有些网络设备甚至可以维护四层协议的状态机，由硬件完成分段或分片，因此传输层通过网络层提交给网络设备时可能是个GSO段，参见1.3.1节。本节论述SKB的成员都是用来支持GSO的。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>unsigned short gso_size
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>生成GSO段时的MSS，因为GSO段的长度是与发送该段的套接口中合适MSS的整数倍。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>unsigned short gso_segs
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>GSO段的长度是gso_size的倍数，即用gso_size来分割大段时产生的段数。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>unsigned short gso_type
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>该SKB中的数据支持的GSO类型，见表3-5。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;表3-5  gso_type的取值&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;gso_type            描述&lt;br/&gt;
</span><span class='line'>SKB_GSO_TCPV4   IPv4的TCP段卸载&lt;br/&gt;
</span><span class='line'>SKB_GSO_UDP     IPv4的UDP分片卸载&lt;br/&gt;
</span><span class='line'>SKB_GSO_DODGY   表明数据报是从一个不可信赖的来源发出的&lt;br/&gt;
</span><span class='line'>SKB_GSO_TCP_ECN IPv4的TCP段卸载，当设置TCP首部的CWR时，使用此gos_type。CWR参见29.4节&lt;br/&gt;
</span><span class='line'>SKB_GSO_TCPV6   IPv6的TCP段卸载&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://blog.csdn.net/majieyue/article/details/11881325"&gt;http://blog.csdn.net/majieyue/article/details/11881325&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;GSO用来扩展之前的TSO，目前已经并入upstream内核。TSO只能支持tcp协议，而GSO可以支持tcpv4, tcpv6, udp等协议。在GSO之前，skb_shinfo(skb)有两个成员ufo_size, tso_size，分别表示udp fragmentation offloading支持的分片长度，以及tcp segmentation offloading支持的分段长度，现在都用skb_shinfo(skb)-&gt;gso_size代替。skb_shinfo(skb)-&gt;ufo_segs, skb_shinfo(skb)-&gt;tso_segs也被替换成了skb_shinfo(skb)-&gt;gso_segs，表示分片的个数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;skb_shinfo(skb)-&gt;gso_type包括SKB_GSO_TCPv4, SKB_GSO_UDPv4，同时NETIF_F_XXX的标志也增加了相应的bit，标识设备是否支持TSO, GSO, e.g.
</span><span class='line'>&lt;code&gt;
</span><span class='line'>NETIF_F_TSO = SKB_GSO_TCPV4 &lt;&lt; NETIF_F_GSO_SHIFT
</span><span class='line'>NETIF_F_UFO = SKB_GSO_UDPV4 &lt;&lt; NETIF_F_GSO_SHIFT
</span><span class='line'>#define NETIF_F_GSO_SHIFT 16
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>dev_hard_start_xmit在调用设备驱动的发送函数之前，会通过netif_needs_gso判断是否需要软件做GSO，如果需要，那么会调用到dev_gso_segment&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    /**
</span><span class='line'> *  dev_gso_segment - Perform emulated hardware segmentation on skb.
</span><span class='line'> *  @skb: buffer to segment
</span><span class='line'> *
</span><span class='line'> *  This function segments the given skb and stores the list of segments
</span><span class='line'> *  in skb-&gt;next.
</span><span class='line'> */
</span><span class='line'>static int dev_gso_segment(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    struct net_device *dev = skb-&gt;dev;
</span><span class='line'>    struct sk_buff *segs;
</span><span class='line'>    int features = dev-&gt;features &amp; ~(illegal_highdma(dev, skb) ?
</span><span class='line'>                     NETIF_F_SG : 0);
</span><span class='line'>
</span><span class='line'>    segs = skb_gso_segment(skb, features);
</span><span class='line'>
</span><span class='line'>    /* Verifying header integrity only. */
</span><span class='line'>    if (!segs)
</span><span class='line'>        return 0;
</span><span class='line'>
</span><span class='line'>    if (IS_ERR(segs))
</span><span class='line'>        return PTR_ERR(segs);
</span><span class='line'>
</span><span class='line'>    skb-&gt;next = segs;
</span><span class='line'>    DEV_GSO_CB(skb)-&gt;destructor = skb-&gt;destructor;
</span><span class='line'>    skb-&gt;destructor = dev_gso_skb_destructor;
</span><span class='line'>
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;分析skb_gso_segment之前，看下析构过程，此时skb经过分片之后已经是一个skb list，通过skb-&gt;next串在一起，此时把初始的skb-&gt;destructor函数存到skb-&gt;cb中，然后把skb-&gt;destructor变更为dev_gso_skb_destructor。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;dev_gso_skb_destructor会把skb-&gt;next一个个通过kfree_skb释放掉，最后调用DEV_GSO_CB(skb)-&gt;destructor，即skb初始的析构函数做最后的清理。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;skb_gso_segment是通过软件方式模拟网卡分段的函数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    struct sk_buff *skb_gso_segment(struct sk_buff *skb, int features)
</span><span class='line'>{
</span><span class='line'>    struct sk_buff *segs = ERR_PTR(-EPROTONOSUPPORT);
</span><span class='line'>    struct packet_type *ptype;
</span><span class='line'>    __be16 type = skb-&gt;protocol;
</span><span class='line'>    int err;
</span><span class='line'>
</span><span class='line'>    skb_reset_mac_header(skb);
</span><span class='line'>    skb-&gt;mac_len = skb-&gt;network_header - skb-&gt;mac_header;
</span><span class='line'>    __skb_pull(skb, skb-&gt;mac_len);
</span><span class='line'>
</span><span class='line'>    if (unlikely(skb-&gt;ip_summed != CHECKSUM_PARTIAL)) {
</span><span class='line'>        struct net_device *dev = skb-&gt;dev;
</span><span class='line'>        struct ethtool_drvinfo info = {};
</span><span class='line'>
</span><span class='line'>        if (dev &amp;&amp; dev-&gt;ethtool_ops &amp;&amp; dev-&gt;ethtool_ops-&gt;get_drvinfo)
</span><span class='line'>            dev-&gt;ethtool_ops-&gt;get_drvinfo(dev, &amp;info);
</span><span class='line'>
</span><span class='line'>        WARN(1, "%s: caps=(0x%lx, 0x%lx) len=%d data_len=%d "
</span><span class='line'>            "ip_summed=%d",
</span><span class='line'>             info.driver, dev ? dev-&gt;features : 0L,
</span><span class='line'>             skb-&gt;sk ? skb-&gt;sk-&gt;sk_route_caps : 0L,
</span><span class='line'>             skb-&gt;len, skb-&gt;data_len, skb-&gt;ip_summed);
</span><span class='line'>
</span><span class='line'>        if (skb_header_cloned(skb) &amp;&amp;
</span><span class='line'>            (err = pskb_expand_head(skb, 0, 0, GFP_ATOMIC)))
</span><span class='line'>            return ERR_PTR(err);
</span><span class='line'>
</span><span class='line'>如果skb header是clone，分离出来
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>如果skb-&gt;ip_summed 不是 CHECKSUM_PARTIAL，那么报个warning，因为GSO类型的skb其ip_summed一般都是CHECKSUM_PARTIAL
</span><span class='line'>
</span><span class='line'>    rcu_read_lock();
</span><span class='line'>    list_for_each_entry_rcu(ptype,
</span><span class='line'>            &amp;ptype_base[ntohs(type) &amp; PTYPE_HASH_MASK], list) {
</span><span class='line'>        if (ptype-&gt;type == type &amp;&amp; !ptype-&gt;dev &amp;&amp; ptype-&gt;gso_segment) {
</span><span class='line'>            if (unlikely(skb-&gt;ip_summed != CHECKSUM_PARTIAL)) {
</span><span class='line'>                err = ptype-&gt;gso_send_check(skb);
</span><span class='line'>                segs = ERR_PTR(err);
</span><span class='line'>                if (err || skb_gso_ok(skb, features))
</span><span class='line'>                    break;
</span><span class='line'>                __skb_push(skb, (skb-&gt;data -
</span><span class='line'>                         skb_network_header(skb)));
</span><span class='line'>            }
</span><span class='line'>            segs = ptype-&gt;gso_segment(skb, features);
</span><span class='line'>            break;
</span><span class='line'>
</span><span class='line'>把skb-&gt;data指向network header，然后调用inet_gso_segment，四层的gso_segment会在inet_gso_segment中被调用
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    rcu_read_unlock();
</span><span class='line'>
</span><span class='line'>    __skb_push(skb, skb-&gt;data - skb_mac_header(skb));
</span><span class='line'>
</span><span class='line'>把skb-&gt;data再次指向mac header
</span><span class='line'>
</span><span class='line'>    return segs;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>static struct sk_buff *inet_gso_segment(struct sk_buff *skb, int features)
</span><span class='line'>{
</span><span class='line'>    struct sk_buff *segs = ERR_PTR(-EINVAL);
</span><span class='line'>    struct iphdr *iph;
</span><span class='line'>    const struct net_protocol *ops;
</span><span class='line'>    int proto;
</span><span class='line'>    int ihl;
</span><span class='line'>    int id;
</span><span class='line'>    unsigned int offset = 0;
</span><span class='line'>
</span><span class='line'>    if (!(features &amp; NETIF_F_V4_CSUM))
</span><span class='line'>        features &amp;= ~NETIF_F_SG;
</span><span class='line'>如果设备不支持NETIF_F_V4_CSUM，那么就当设备不支持SG
</span><span class='line'>
</span><span class='line'>    if (unlikely(skb_shinfo(skb)-&gt;gso_type &amp;
</span><span class='line'>             ~(SKB_GSO_TCPV4 |
</span><span class='line'>               SKB_GSO_UDP |
</span><span class='line'>               SKB_GSO_DODGY |
</span><span class='line'>               SKB_GSO_TCP_ECN |
</span><span class='line'>               0)))
</span><span class='line'>        goto out;
</span><span class='line'>gso_type不合法，直接返错
</span><span class='line'>
</span><span class='line'>    if (unlikely(!pskb_may_pull(skb, sizeof(*iph))))
</span><span class='line'>        goto out;
</span><span class='line'>20字节ip头部无法获得，返错
</span><span class='line'>
</span><span class='line'>    iph = ip_hdr(skb);
</span><span class='line'>    ihl = iph-&gt;ihl * 4;
</span><span class='line'>    if (ihl &lt; sizeof(*iph))
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    if (unlikely(!pskb_may_pull(skb, ihl)))
</span><span class='line'>        goto out;
</span><span class='line'>实际ip头部无法获得，返错
</span><span class='line'>
</span><span class='line'>    __skb_pull(skb, ihl);
</span><span class='line'>    skb_reset_transport_header(skb);
</span><span class='line'>    iph = ip_hdr(skb);
</span><span class='line'>
</span><span class='line'>OK，现在拿到ip头部了
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    id = ntohs(iph-&gt;id);
</span><span class='line'>
</span><span class='line'>ip包的id
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    proto = iph-&gt;protocol &amp; (MAX_INET_PROTOS - 1);
</span><span class='line'>    segs = ERR_PTR(-EPROTONOSUPPORT);
</span><span class='line'>
</span><span class='line'>    rcu_read_lock();
</span><span class='line'>    ops = rcu_dereference(inet_protos[proto]);
</span><span class='line'>    if (likely(ops &amp;&amp; ops-&gt;gso_segment))
</span><span class='line'>        segs = ops-&gt;gso_segment(skb, features);
</span><span class='line'>
</span><span class='line'>如果是tcp，那么调用tcp_tso_segment，如果是udp，那么调用udp4_ufo_fragment
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    rcu_read_unlock();
</span><span class='line'>
</span><span class='line'>    if (!segs || IS_ERR(segs))
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    skb = segs;
</span><span class='line'>    do {
</span><span class='line'>        iph = ip_hdr(skb);
</span><span class='line'>        if (proto == IPPROTO_UDP) {
</span><span class='line'>            iph-&gt;id = htons(id);
</span><span class='line'>            iph-&gt;frag_off = htons(offset &gt;&gt; 3);
</span><span class='line'>            if (skb-&gt;next != NULL)
</span><span class='line'>                iph-&gt;frag_off |= htons(IP_MF);
</span><span class='line'>            offset += (skb-&gt;len - skb-&gt;mac_len - iph-&gt;ihl * 4);
</span><span class='line'>        } else
</span><span class='line'>            iph-&gt;id = htons(id++);
</span><span class='line'>        iph-&gt;tot_len = htons(skb-&gt;len - skb-&gt;mac_len);
</span><span class='line'>        iph-&gt;check = 0;
</span><span class='line'>        iph-&gt;check = ip_fast_csum(skb_network_header(skb), iph-&gt;ihl);
</span><span class='line'>    } while ((skb = skb-&gt;next));
</span><span class='line'>
</span><span class='line'>对每一个skb segment，填充ip包头，计算ip checksum。如果是tcp segmentation，那么ip头的id递增。如果是udp fragmentation，那么ip头的id不变，每次计算增加的offset，等于是在做ip分片
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>    return segs;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;下面来看TCP协议的分段函数tcp_tso_segment&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    struct sk_buff *tcp_tso_segment(struct sk_buff *skb, int features)
</span><span class='line'>{
</span><span class='line'>    struct sk_buff *segs = ERR_PTR(-EINVAL);
</span><span class='line'>    struct tcphdr *th;
</span><span class='line'>    unsigned thlen;
</span><span class='line'>    unsigned int seq;
</span><span class='line'>    __be32 delta;
</span><span class='line'>    unsigned int oldlen;
</span><span class='line'>    unsigned int mss;
</span><span class='line'>
</span><span class='line'>    if (!pskb_may_pull(skb, sizeof(*th)))
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    th = tcp_hdr(skb);
</span><span class='line'>    thlen = th-&gt;doff * 4;
</span><span class='line'>    if (thlen &lt; sizeof(*th))
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    if (!pskb_may_pull(skb, thlen))
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    oldlen = (u16)~skb-&gt;len;
</span><span class='line'>    __skb_pull(skb, thlen);
</span><span class='line'>把tcp header移到skb header里，把skb-&gt;len存到oldlen中，此时skb-&gt;len就只有tcp payload的长度
</span><span class='line'>
</span><span class='line'>    mss = skb_shinfo(skb)-&gt;gso_size;
</span><span class='line'>    if (unlikely(skb-&gt;len &lt;= mss))
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {
</span><span class='line'>        /* Packet is from an untrusted source, reset gso_segs. */
</span><span class='line'>        int type = skb_shinfo(skb)-&gt;gso_type;
</span><span class='line'>
</span><span class='line'>        if (unlikely(type &amp;
</span><span class='line'>                 ~(SKB_GSO_TCPV4 |
</span><span class='line'>                   SKB_GSO_DODGY |
</span><span class='line'>                   SKB_GSO_TCP_ECN |
</span><span class='line'>                   SKB_GSO_TCPV6 |
</span><span class='line'>                   0) ||
</span><span class='line'>                 !(type &amp; (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))))
</span><span class='line'>            goto out;
</span><span class='line'>
</span><span class='line'>        skb_shinfo(skb)-&gt;gso_segs = DIV_ROUND_UP(skb-&gt;len, mss);
</span><span class='line'>重新计算skb_shinfo(skb)-&gt;gso_segs的个数，基于skb-&gt;len和mss值
</span><span class='line'>
</span><span class='line'>        segs = NULL;
</span><span class='line'>        goto out;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    segs = skb_segment(skb, features);
</span><span class='line'>    if (IS_ERR(segs))
</span><span class='line'>        goto out;
</span><span class='line'>skb_segment是真正的分段实现，后面再分析
</span><span class='line'>
</span><span class='line'>    delta = htonl(oldlen + (thlen + mss));
</span><span class='line'>
</span><span class='line'>    skb = segs;
</span><span class='line'>    th = tcp_hdr(skb);
</span><span class='line'>    seq = ntohl(th-&gt;seq);
</span><span class='line'>
</span><span class='line'>    do {
</span><span class='line'>        th-&gt;fin = th-&gt;psh = 0;
</span><span class='line'>
</span><span class='line'>        th-&gt;check = ~csum_fold((__force __wsum)((__force u32)th-&gt;check +
</span><span class='line'>                       (__force u32)delta));
</span><span class='line'>        if (skb-&gt;ip_summed != CHECKSUM_PARTIAL)
</span><span class='line'>            th-&gt;check =
</span><span class='line'>                 csum_fold(csum_partial(skb_transport_header(skb),
</span><span class='line'>                            thlen, skb-&gt;csum));
</span><span class='line'>对每个分段都要计算tcp checksum
</span><span class='line'>
</span><span class='line'>        seq += mss;
</span><span class='line'>        skb = skb-&gt;next;
</span><span class='line'>        th = tcp_hdr(skb);
</span><span class='line'>
</span><span class='line'>        th-&gt;seq = htonl(seq);
</span><span class='line'>
</span><span class='line'>对每个分段重新计算sequence值
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        th-&gt;cwr = 0;
</span><span class='line'>    } while (skb-&gt;next);
</span><span class='line'>
</span><span class='line'>    delta = htonl(oldlen + (skb-&gt;tail - skb-&gt;transport_header) +
</span><span class='line'>              skb-&gt;data_len);
</span><span class='line'>    th-&gt;check = ~csum_fold((__force __wsum)((__force u32)th-&gt;check +
</span><span class='line'>                (__force u32)delta));
</span><span class='line'>    if (skb-&gt;ip_summed != CHECKSUM_PARTIAL)
</span><span class='line'>        th-&gt;check = csum_fold(csum_partial(skb_transport_header(skb),
</span><span class='line'>                           thlen, skb-&gt;csum));
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>    return segs;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;UDP协议的分片函数是udp4_ufo_fragment&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    struct sk_buff *udp4_ufo_fragment(struct sk_buff *skb, int features)
</span><span class='line'>{
</span><span class='line'>    struct sk_buff *segs = ERR_PTR(-EINVAL);
</span><span class='line'>    unsigned int mss;
</span><span class='line'>    int offset;
</span><span class='line'>    __wsum csum;
</span><span class='line'>
</span><span class='line'>    mss = skb_shinfo(skb)-&gt;gso_size;
</span><span class='line'>    if (unlikely(skb-&gt;len &lt;= mss))
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {
</span><span class='line'>        /* Packet is from an untrusted source, reset gso_segs. */
</span><span class='line'>        int type = skb_shinfo(skb)-&gt;gso_type;
</span><span class='line'>
</span><span class='line'>        if (unlikely(type &amp; ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||
</span><span class='line'>                 !(type &amp; (SKB_GSO_UDP))))
</span><span class='line'>            goto out;
</span><span class='line'>
</span><span class='line'>        skb_shinfo(skb)-&gt;gso_segs = DIV_ROUND_UP(skb-&gt;len, mss);
</span><span class='line'>
</span><span class='line'>        segs = NULL;
</span><span class='line'>        goto out;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Do software UFO. Complete and fill in the UDP checksum as HW cannot
</span><span class='line'>     * do checksum of UDP packets sent as multiple IP fragments.
</span><span class='line'>     */
</span><span class='line'>    offset = skb-&gt;csum_start - skb_headroom(skb);
</span><span class='line'>    csum = skb_checksum(skb, offset, skb-&gt;len - offset, 0);
</span><span class='line'>    offset += skb-&gt;csum_offset;
</span><span class='line'>    *(__sum16 *)(skb-&gt;data + offset) = csum_fold(csum);
</span><span class='line'>    skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>
</span><span class='line'>计算udp的checksum
</span><span class='line'>
</span><span class='line'>    /* Fragment the skb. IP headers of the fragments are updated in
</span><span class='line'>     * inet_gso_segment()
</span><span class='line'>     */
</span><span class='line'>    segs = skb_segment(skb, features);
</span><span class='line'>out:
</span><span class='line'>    return segs;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;udp的分段其实和ip的分片没什么区别，只是多一个计算checksum的步骤&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最后来分析下skb_segment&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    struct sk_buff *skb_segment(struct sk_buff *skb, int features)
</span><span class='line'>{
</span><span class='line'>    struct sk_buff *segs = NULL;
</span><span class='line'>    struct sk_buff *tail = NULL;
</span><span class='line'>    struct sk_buff *fskb = skb_shinfo(skb)-&gt;frag_list;
</span><span class='line'>    unsigned int mss = skb_shinfo(skb)-&gt;gso_size;
</span><span class='line'>    unsigned int doffset = skb-&gt;data - skb_mac_header(skb);
</span><span class='line'>    unsigned int offset = doffset;
</span><span class='line'>    unsigned int headroom;
</span><span class='line'>    unsigned int len;
</span><span class='line'>    int sg = features &amp; NETIF_F_SG;
</span><span class='line'>    int nfrags = skb_shinfo(skb)-&gt;nr_frags;
</span><span class='line'>    int err = -ENOMEM;
</span><span class='line'>    int i = 0;
</span><span class='line'>    int pos;
</span><span class='line'>
</span><span class='line'>    __skb_push(skb, doffset);
</span><span class='line'>    headroom = skb_headroom(skb);
</span><span class='line'>    pos = skb_headlen(skb);
</span><span class='line'>
</span><span class='line'>skb-&gt;data指向mac header，计算headroom，skb_headlen长度
</span><span class='line'>
</span><span class='line'>    do {
</span><span class='line'>        struct sk_buff *nskb;
</span><span class='line'>        skb_frag_t *frag;
</span><span class='line'>        int hsize;
</span><span class='line'>        int size;
</span><span class='line'>
</span><span class='line'>        len = skb-&gt;len - offset;
</span><span class='line'>        if (len &gt; mss)
</span><span class='line'>            len = mss;
</span><span class='line'>len为skb-&gt;len减去直到offset的部分。开始时，offset只是mac header + ip header + tcp header的长度，len即tcp payload的长度。随着segment增加, offset每次都增加mss长度。因此len的定义是每个segment的payload长度（最后一个segment的payload可能小于一个mss长度）
</span><span class='line'>
</span><span class='line'>        hsize = skb_headlen(skb) - offset;
</span><span class='line'>
</span><span class='line'>hsize为skb header减去offset后的大小，如果hsize小于0，那么说明payload在skb的frags, frag_list中。随着offset一直增长，必定会有hsize一直&lt;0的情况开始出现，除非skb是一个完全linearize化的skb
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        if (hsize &lt; 0)
</span><span class='line'>            hsize = 0;
</span><span class='line'>
</span><span class='line'>这种情况说明skb_headlen没有tcp payload的部分，需要pull数据过来
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        if (hsize &gt; len || !sg)
</span><span class='line'>            hsize = len;
</span><span class='line'>
</span><span class='line'>如果不支持sg同时hsize大于len，那么hsize就为len，此时说明segment的payload还在skb header中
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        if (!hsize &amp;&amp; i &gt;= nfrags) {
</span><span class='line'>            BUG_ON(fskb-&gt;len != len);
</span><span class='line'>
</span><span class='line'>            pos += len;
</span><span class='line'>            nskb = skb_clone(fskb, GFP_ATOMIC);
</span><span class='line'>            fskb = fskb-&gt;next;
</span><span class='line'>
</span><span class='line'>            if (unlikely(!nskb))
</span><span class='line'>                goto err;
</span><span class='line'>
</span><span class='line'>            hsize = skb_end_pointer(nskb) - nskb-&gt;head;
</span><span class='line'>            if (skb_cow_head(nskb, doffset + headroom)) {
</span><span class='line'>                kfree_skb(nskb);
</span><span class='line'>                goto err;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            nskb-&gt;truesize += skb_end_pointer(nskb) - nskb-&gt;head -
</span><span class='line'>                      hsize;
</span><span class='line'>            skb_release_head_state(nskb);
</span><span class='line'>            __skb_push(nskb, doffset);
</span><span class='line'>        } else {
</span><span class='line'>
</span><span class='line'>            nskb = alloc_skb(hsize + doffset + headroom,
</span><span class='line'>                     GFP_ATOMIC);
</span><span class='line'>
</span><span class='line'>            if (unlikely(!nskb))
</span><span class='line'>                goto err;
</span><span class='line'>
</span><span class='line'>            skb_reserve(nskb, headroom);
</span><span class='line'>            __skb_put(nskb, doffset);
</span><span class='line'>
</span><span class='line'>alloc新的skb，skb-&gt;data到skb-&gt;head之间保留headroom，skb-&gt;tail到skb-&gt;data之间保留mac header + ip header + tcp header + hsize的长度
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        if (segs)
</span><span class='line'>            tail-&gt;next = nskb;
</span><span class='line'>        else
</span><span class='line'>            segs = nskb;
</span><span class='line'>        tail = nskb;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        __copy_skb_header(nskb, skb);
</span><span class='line'>        nskb-&gt;mac_len = skb-&gt;mac_len;
</span><span class='line'>把老skb的skb_buff内容拷贝到新skb中
</span><span class='line'>
</span><span class='line'>        /* nskb and skb might have different headroom */
</span><span class='line'>        if (nskb-&gt;ip_summed == CHECKSUM_PARTIAL)
</span><span class='line'>            nskb-&gt;csum_start += skb_headroom(nskb) - headroom;
</span><span class='line'>修正下checksum计算的位置
</span><span class='line'>
</span><span class='line'>        skb_reset_mac_header(nskb);
</span><span class='line'>        skb_set_network_header(nskb, skb-&gt;mac_len);
</span><span class='line'>        nskb-&gt;transport_header = (nskb-&gt;network_header +
</span><span class='line'>                      skb_network_header_len(skb));
</span><span class='line'>        skb_copy_from_linear_data(skb, nskb-&gt;data, doffset);
</span><span class='line'>
</span><span class='line'>把skb-&gt;data开始doffset长度的内容拷贝到nskb-&gt;data中，即把mac header , ip header, tcp header都复制过去
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        if (fskb != skb_shinfo(skb)-&gt;frag_list)
</span><span class='line'>            continue;
</span><span class='line'>
</span><span class='line'>        if (!sg) {
</span><span class='line'>            nskb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>            nskb-&gt;csum = skb_copy_and_csum_bits(skb, offset,
</span><span class='line'>                                skb_put(nskb, len),
</span><span class='line'>                                len, 0);
</span><span class='line'>            continue;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        frag = skb_shinfo(nskb)-&gt;frags;
</span><span class='line'>
</span><span class='line'>        skb_copy_from_linear_data_offset(skb, offset,
</span><span class='line'>                         skb_put(nskb, hsize), hsize);
</span><span class='line'>
</span><span class='line'>如果hsize不为0，那么拷贝hsize的内容到nskb header中
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        while (pos &lt; offset + len &amp;&amp; i &lt; nfrags) {
</span><span class='line'>
</span><span class='line'>offset + len长度超过了pos，即超过了nskb header，这时需要用到frag
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>            *frag = skb_shinfo(skb)-&gt;frags[i];
</span><span class='line'>            get_page(frag-&gt;page);
</span><span class='line'>            size = frag-&gt;size;
</span><span class='line'>
</span><span class='line'>            if (pos &lt; offset) {
</span><span class='line'>                frag-&gt;page_offset += offset - pos;
</span><span class='line'>                frag-&gt;size -= offset - pos;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>            skb_shinfo(nskb)-&gt;nr_frags++;
</span><span class='line'>
</span><span class='line'>            if (pos + size &lt;= offset + len) {
</span><span class='line'>                i++;
</span><span class='line'>                pos += size;
</span><span class='line'>            } else {
</span><span class='line'>                frag-&gt;size -= pos + size - (offset + len);
</span><span class='line'>                goto skip_fraglist;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            frag++;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>如果skb header空间不够，那么通过frag，把一个mss的内容拷贝到nskb的frag中
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        if (pos &lt; offset + len) {
</span><span class='line'>            struct sk_buff *fskb2 = fskb;
</span><span class='line'>
</span><span class='line'>            BUG_ON(pos + fskb-&gt;len != offset + len);
</span><span class='line'>
</span><span class='line'>            pos += fskb-&gt;len;
</span><span class='line'>            fskb = fskb-&gt;next;
</span><span class='line'>
</span><span class='line'>            if (fskb2-&gt;next) {
</span><span class='line'>                fskb2 = skb_clone(fskb2, GFP_ATOMIC);
</span><span class='line'>                if (!fskb2)
</span><span class='line'>                    goto err;
</span><span class='line'>            } else
</span><span class='line'>                skb_get(fskb2);
</span><span class='line'>
</span><span class='line'>            SKB_FRAG_ASSERT(nskb);
</span><span class='line'>            skb_shinfo(nskb)-&gt;frag_list = fskb2;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>如果frag都用完还是无法满足mss的大小，那么就要用到frag_list，这段代码跳过去了，因为基本永远不会走到这里
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>skip_fraglist:
</span><span class='line'>        nskb-&gt;data_len = len - hsize;
</span><span class='line'>        nskb-&gt;len += nskb-&gt;data_len;
</span><span class='line'>        nskb-&gt;truesize += nskb-&gt;data_len;
</span><span class='line'>    } while ((offset += len) &lt; skb-&gt;len);
</span><span class='line'>
</span><span class='line'>完成一个nskb之后，继续下一个seg，一直到offset &gt;= skb-&gt;len
</span><span class='line'>
</span><span class='line'>    return segs;
</span><span class='line'>
</span><span class='line'>err:
</span><span class='line'>    while ((skb = segs)) {
</span><span class='line'>        segs = skb-&gt;next;
</span><span class='line'>        kfree_skb(skb);
</span><span class='line'>    }
</span><span class='line'>    return ERR_PTR(err);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[FRTO—虚假超时剖析]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/03/23/kernel-net-frto/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-03-23T14:37:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/03/23/kernel-net-frto&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://blog.csdn.net/zhangskd/article/details/7446441"&gt;http://blog.csdn.net/zhangskd/article/details/7446441&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;F-RTO：Forward RTO-Recovery，for a TCP sender to recover after a retransmission timeout.
</span><span class='line'>F-RTO的主要目的：The main motivation of the algorithm is to recover efficiently from a spurious
</span><span class='line'>RTO.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;F-RTO的基本思想&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;The guideline behind F-RTO is, that an RTO either indicates a loss, or it is caused by an
</span><span class='line'>excessive delay in packet delivery while there still are outstanding segments in flight. If the
</span><span class='line'>RTO was due to delay, i.e. the RTO was spurious, acknowledgements for non-retransmitted
</span><span class='line'>segments sent before the RTO should arrive at the sender after the RTO occurred. If no such
</span><span class='line'>segments arrive, the RTO is concluded to be non-spurious and the conventional RTO
</span><span class='line'>recovery with go-back-N retransmissions should take place at the TCP sender.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;To implement the principle described above, an F-RTO sender acts as follows: if the first ACK
</span><span class='line'>arriving after a RTO-triggered retransmission advances the window, transmit two new segments
</span><span class='line'>instead of continuing retransmissions. If also the second incoming acknowledgement advances
</span><span class='line'>the window, RTO is likely to be spurious, because the second ACK is triggered by an originally
</span><span class='line'>transmitted segment that has not been retransmitted after the RTO. If either one of the two
</span><span class='line'>acknowledgements after RTO is a duplicate ACK, the sender continues retransmissions similarly
</span><span class='line'>to the conventional RTO recovery algorithm.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;When the retransmission timer expires, the F-RTO algorithm takes the following steps at the TCP
</span><span class='line'>sender. In the algorithm description below we use SND.UNA to indicate the first unacknowledged
</span><span class='line'>segment.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1.When the retransmission timer expires, retransmit the segment that triggered the timeout. As
</span><span class='line'>required by the TCP congestion control specifications, the ssthresh is adjusted to half of the
</span><span class='line'>number of currently outstanding segments. However, the congestion window is not yet set to one
</span><span class='line'>segment, but the sender waits for the next two acknowledgements before deciding on what to do
</span><span class='line'>with the congestion window.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2.When the first acknowledgement after RTO arrives at the sender, the sender chooses the
</span><span class='line'>following actions depending on whether the ACK advances the window or whether it is a duplicate
</span><span class='line'>ACK.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（a）If the acknowledgement advances SND.UNA, transmit up to two new (previously unsent)
</span><span class='line'>segments. This is the main point in which the F-RTO algorithm differs from the conventional way
</span><span class='line'>of recovering from RTO. After transmitting the two new segments, the congestion window size
</span><span class='line'>is set to have the same value as ssthresh. In effect this reduces the transmission rate of the
</span><span class='line'>sender to half of the transmission rate before the RTO. At this point the TCP sender has transmitted
</span><span class='line'>a total of three segments after the RTO, similarly to the conventional recovery algorithm. If
</span><span class='line'>transmitting two new segments is not possible due to advertised window limitation, or because
</span><span class='line'>there is no more data to send, the sender may transmit only one segment. If now new data can
</span><span class='line'>be transmitted, the TCP sender follows the conventional RTO recovery algorithm and starts
</span><span class='line'>retransmitting the unacknowledged data using slow start.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（b）If the acknowledgement is duplicate ACK, set the congestion window to one segment and
</span><span class='line'>proceed with the conventional RTO recovery. Two new segments are not transmitted in this case,
</span><span class='line'>because the conventional RTO recovery algorithm would not transmit anything at this point either.
</span><span class='line'>Instead, the F-RTO sender continues with slow start and performs similarly to the conventional
</span><span class='line'>TCP sender in retransmitting the unacknowledged segments. Step 3 of the F-RTO algorithm is
</span><span class='line'>not entered in this case. A common reason for executing this branch is the loss of a segment,
</span><span class='line'>in which case the segments injected by the sender before the RTO may still trigger duplicate
</span><span class='line'>ACKs that arrive at the sender after the RTO.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;3.When the second acknowledgement after the RTO arrives, either continue transmitting new
</span><span class='line'>data, or start retransmitting with the slow start algorithm, depending on whether new data was
</span><span class='line'>acknowledged.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（a）If the acknowledgement advances SND.UNA, continue transmitting new data following
</span><span class='line'>the congestion avoidance algorithm. Because the TCP sender has retransmitted only one
</span><span class='line'>segment after the RTO, this acknowledgement indicates that an originally transmitted
</span><span class='line'>segment has arrived at the receiver. This is regarded as a strong indication of a suprious
</span><span class='line'>RTO. However, since the TCP sender cannot surely know at this point whether the segment
</span><span class='line'>that triggered the RTO was actually lost, adjusting the congestion control parameters after
</span><span class='line'>the RTO is the conservative action. From this point on, the TCP sender continues as in the
</span><span class='line'>normal congestion avoidance.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;If this algorithm branch is taken, the TCP sender ignores the send_high variable that indicates
</span><span class='line'>the highest sequence number transmitted so far. The send_high variable was proposed as a
</span><span class='line'>bugfix for avoiding unnecessary multiple fast retransmits when RTO expires during fast recovery
</span><span class='line'>with NewReon TCP. As the sender has not retransmitted other segments but the one that
</span><span class='line'>triggered RTO, the problem addressed by the bugfix cannot occur. Therefore, if there are
</span><span class='line'>duplicate ACKs arriving at the sender after the RTO, they are likely to indicate a packet loss,
</span><span class='line'>hence fast retransmit should bu used to allow efficient recovery. Alternatively, if there are not
</span><span class='line'>enough duplicate ACKs arriving at the sender after a packet loss, the retransmission timer
</span><span class='line'>expires another time and the sender enters step 1 of this algorithm to detect whether the
</span><span class='line'>new RTO is spurious.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（b）If the acknowledgement is duplicate ACK, set the congestion window to three segments,
</span><span class='line'>continue with the slow start algorithm retransmitting unacknowledged segments. The duplicate
</span><span class='line'>ACK indicates that at least one segment other than the segment that triggered RTO is lost in the
</span><span class='line'>last window of data. There is no sufficient evidence that any of the segments was delayed.
</span><span class='line'>Therefore the sender proceeds with retransmissions similarly to the conventional RTO recovery
</span><span class='line'>algorithm, with the send_high variable stored when the retransmission timer expired to avoid
</span><span class='line'>unnecessary fast retransmits.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;引起RTO的主要因素：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（1）Sudden delays&lt;br/&gt;
</span><span class='line'>The primary motivation of the F-RTO algorithm is to improve the TCP performance when sudden
</span><span class='line'>delays cause spurious retransmission timeouts.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（2）Packet losses&lt;br/&gt;
</span><span class='line'>These timeouts occur mainly when retransmissions are lost, since lost original packets are
</span><span class='line'>usually recovered by fast retransmit.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（3）Bursty losses&lt;br/&gt;
</span><span class='line'>Losses of several successive packets can result in a retransmission timeout.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;造成虚假RTO的原因还有：&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Wireless links may also suffer from link outages that cause persistent data loss for a period
</span><span class='line'>of time.&lt;br/&gt;
</span><span class='line'>Oher potential reasons for sudden delays that have been reported to trigger spurious RTOs
</span><span class='line'>include a delay due to tedious actions required to complete a hand-off or re-routing of packets
</span><span class='line'>to the new serving access point after the hand-off, arrival of competing traffic on a shared link
</span><span class='line'>with low bandwidth, and a sudden bandwidth degradation due to reduced resources on a
</span><span class='line'>wireless channel.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;造成真实RTO的原因：&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;A RTO-triggered retransmission is needed when a retransmission is lost, or when nearly a whole
</span><span class='line'>window of data is lost, thus making it impossible for the receiver to generate enough duplicate
</span><span class='line'>ACKs for triggering TCP fast retransmit.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;虚假RTO的后果&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;If no segments were lost but the retransmission timer expires spuriously, the segments retransmitted
</span><span class='line'>in the slow-start are sent unnecessarily. Particularly, this phenomenon is very possible with the
</span><span class='line'>various wireless access network technologies that are prone to sudden delay spikes.
</span><span class='line'>The retransmission timer expires because of the delay, spuriously triggering the RTO recovery and
</span><span class='line'>unnecessarily retransmission of all unacknowledged segments. This happens because after the
</span><span class='line'>delay the ACKs for the original segments arrive at the sender one at the time but too late, because
</span><span class='line'>the TCP sender has already entered the RTO recovery. Therefore, each of the ACKs trigger the
</span><span class='line'>retransmission of segments for which the original ACKs will arrive after a while. This continues
</span><span class='line'>until the whole window of segments is eventually unnecessarily retransmitted. Furthermore,
</span><span class='line'>because a full window of retransmitted segments arrive unnecessarily at the receiver, it generates
</span><span class='line'>duplicate ACKs for these out-of-order segments. Later on, the duplicate ACKs unnecessarily
</span><span class='line'>trigger fast retransmit at the sender.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;TCP uses the fast retransmit mechanism to trigger retransmissions after receiving three successive
</span><span class='line'>duplicate acknowledgements (ACKs). If for a certain time period TCP sender does not receive ACKs
</span><span class='line'>that acknowledge new data, the TCP retransmission timer expires as a backoff mechanism.
</span><span class='line'>When the retransmission time expires, the TCP sender retransmits the first unacknowledged
</span><span class='line'>segment assuming it was lost in the network. Because a retransmission timeout (RTO) can be
</span><span class='line'>an indication of severe congestion in the network, the TCP sender resets its congestion window
</span><span class='line'>to one segment and starts increasing it according to the slow start algorithm.
</span><span class='line'>However, if the RTO occurs spuriously and there still are segments outstanding in the network,
</span><span class='line'>a false slow start is harmful for the potentially congested network as it injects extra segments
</span><span class='line'>to the network at increasing rate.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;虚假的RTO不仅会降低吞吐量，而且由于丢包后会使用慢启动算法，快速的向网络中注入数据包，
</span><span class='line'>而此时网络中还有原来发送的数据包，这样可能会造成真正的网络拥塞！&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;How about Reliable link-layer protocol ?
</span><span class='line'>Since wireless networks are often subject to high packet loss rate due to corruption or hand-offs,
</span><span class='line'>reliable link-layer protocols are widely employed with wireless links. The link-layer receiver often
</span><span class='line'>aims to deliver the packets to the upper protocol layers in order, which implies that the later
</span><span class='line'>arriving packets are blocked until the head of the queue arrives successfully. Due to the strict
</span><span class='line'>link-layer ordering, the communication end point observe a pause in packet delivery that can
</span><span class='line'>cause a spurious TCP RTO instead of getting out-of-order packets that could result in a false
</span><span class='line'>fast retransmit instead. Either way, interaction between TCP retransmission mechanisms
</span><span class='line'>and link-layer recovery can cause poor performance.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;DSACK不能解决此问题
</span><span class='line'>If the unnecessary retransmissions occurred due to spurious RTO caused by a sudden delay,
</span><span class='line'>the acknowledgements with the DSACK information arrive at the sender only after the
</span><span class='line'>acknowledgements of the original segments. Therefore, the unnecessary retransmissions
</span><span class='line'>following the spurious RTO cannot be avoided by using DSACK. Instead, the suggested
</span><span class='line'>recovery algorithm using DSACK can only revert the congestion control parameters to the
</span><span class='line'>state preceding the spurious retransmissions.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;F-RTO实现&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;F-RTO is implemented (mainly) in four functions:&lt;br/&gt;
</span><span class='line'>（1）tcp_use_frto() is used to determine if TCP can use F-RTO.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（2）tcp_enter_frto() prepares TCP state on RTO if F-RTO is used, it is called when&lt;br/&gt;
</span><span class='line'>      tcp_use_frto() showed green light.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（3）tcp_process_frto() handles incoming ACKs during F-RTO algorithm.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（4）tcp_enter_frto_loss() is called if there is not enough evidence to prove that the RTO is&lt;br/&gt;
</span><span class='line'>      indeed spurious. It transfers the control from F-RTO to the conventional RTO recovery.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;判断是否可以使用F-RTO&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt; 调用时机：当TCP段传送超时后，会引起段的重传，在重传定时器的处理过程中会判断是否可以使用F-RTO算法。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    void tcp_retransmit_timer (struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    ....  
</span><span class='line'>
</span><span class='line'>    if (tcp_use_frto(sk)) {  
</span><span class='line'>        tcp_enter_frto(sk);  
</span><span class='line'>    } else {  
</span><span class='line'>        tcp_enter_loss(sk);  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    ....  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;能够使用F-RTO的条件：&lt;br/&gt;
</span><span class='line'>（1）tcp_frto非零，此为TCP参数&lt;br/&gt;
</span><span class='line'>（2）MTU probe没使用，因为它和F-RTO有冲突&lt;br/&gt;
</span><span class='line'>（3）a. 如果启用了sackfrto，则可以使用&lt;br/&gt;
</span><span class='line'>b. 如果没启用sackfrto，不能重传过除head以外的数据&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    /* F-RTO can only be used if TCP has never retransmitted anything other than 
</span><span class='line'> * head (SACK enhanced variant from Appendix B of RFC4138 is more robust here) 
</span><span class='line'> */  
</span><span class='line'>int tcp_use_frto(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    const struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    const struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>    struct sk_buff *skb;  
</span><span class='line'>
</span><span class='line'>    if (! sysctl_tcp_frto)  
</span><span class='line'>        return 0;  
</span><span class='line'>
</span><span class='line'>    /* MTU probe and F-RTO won't really play nicely along currently */  
</span><span class='line'>    if (icsk-&gt;icsk_mtup.probe_size)  
</span><span class='line'>        return 0;  
</span><span class='line'>
</span><span class='line'>    if (tcp_is_sackfrto(tp))  
</span><span class='line'>        return 1;  
</span><span class='line'>
</span><span class='line'>    /* Avoid expensive walking of rexmit queue if possible */  
</span><span class='line'>    if (tp-&gt;retrans_out &gt; 1)  
</span><span class='line'>        return 0; /* 不能重过传除了head以外的数据*/  
</span><span class='line'>
</span><span class='line'>    skb = tcp_write_queue_head(sk);  
</span><span class='line'>    if (tcp_skb_is_last(sk, skb))  
</span><span class='line'>        return 1;  
</span><span class='line'>    skb = tcp_write_queue_next(sk, skb); /* Skips head */  
</span><span class='line'>    tcp_for_write_queue_from(skb, sk) {  
</span><span class='line'>        if (skb == tcp_send_head(sk))  
</span><span class='line'>            break;  
</span><span class='line'>
</span><span class='line'>        if (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_RETRANS)  
</span><span class='line'>            return 0; /* 不允许处head以外的数据包被重传过 */  
</span><span class='line'>
</span><span class='line'>        /* Short-circut when first non-SACKed skb has been checked */  
</span><span class='line'>        if (! (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_SACKED_ACKED))  
</span><span class='line'>        break;  
</span><span class='line'>    }  
</span><span class='line'>    return 1;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>static int tcp_is_sackfrto(const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>    return (sysctl_tcp_frto == 0x2) &amp;&amp; ! tcp_is_reno(tp);  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;进入F-RTO状态&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;启用F-RTO后，虽然传送超时，但还没进入Loss状态，相反，先进入Disorder状态。减小慢启动阈值，而snd_cwnd暂时保持不变。此时对应head数据包还没重传前。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    /* RTO occurred, but do not yet enter Loss state. Instead, defer RTO recovery 
</span><span class='line'> * a bit and use heuristics in tcp_process_frto() to detect if the RTO was  
</span><span class='line'> * spurious. 
</span><span class='line'> */  
</span><span class='line'>
</span><span class='line'>void tcp_enter_frto (struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    const struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    struct sk_buff *skb;  
</span><span class='line'>
</span><span class='line'>    /* Do like tcp_enter_loss() would*/  
</span><span class='line'>    if ((! tp-&gt;frto_counter &amp;&amp; icsk-&gt;icsk_ca_state &lt;= TCP_CA_Disorder) ||  
</span><span class='line'>        tp-&gt;snd_una == tp-&gt;high_seq ||   
</span><span class='line'>        ((icsk-&gt;icsk_ca_state == TCP_CA_Loss || tp-&gt;frto_counter) &amp;&amp;  
</span><span class='line'>        ! icsk-&gt;icsk_retransmits)) {  
</span><span class='line'>
</span><span class='line'>        tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk); /* 保存旧阈值*/  
</span><span class='line'>
</span><span class='line'>        if (tp-&gt;frto_counter) {   
</span><span class='line'>            u32 stored_cwnd;  
</span><span class='line'>            stored_cwnd = tp-&gt;snd_cwnd;  
</span><span class='line'>            tp-&gt;snd_cwnd = 2;  
</span><span class='line'>            tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);  
</span><span class='line'>            tp-&gt;snd_cwnd = stored_cwnd;  
</span><span class='line'>        } else {  
</span><span class='line'>            tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk); /* 减小阈值*/  
</span><span class='line'>        }  
</span><span class='line'>
</span><span class='line'>        tcp_ca_event(sk, CA_EVENT_FRTO); /* 触发FRTO事件 */  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    tp-&gt;undo_marker = tp-&gt;snd_una;  
</span><span class='line'>    tp-&gt;undo_retrans = 0;  
</span><span class='line'>
</span><span class='line'>    skb = tcp_write_queue_head(sk);  
</span><span class='line'>    if (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_RETRANS)  
</span><span class='line'>        tp-&gt;undo_marker = 0;  
</span><span class='line'>
</span><span class='line'>    /* 清除head与重传相关的标志*/  
</span><span class='line'>    if (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_SACKED_RETRANS) {  
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_RETRANS;  
</span><span class='line'>        tp-&gt;retrans_out -= tcp_skb_pcount(skb);  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    tcp_verfify_left_out(tp);  
</span><span class='line'>
</span><span class='line'>    /* Too bad if TCP was application limited */  
</span><span class='line'>    tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tcp_packets_in_flight(tp) + 1);  
</span><span class='line'>
</span><span class='line'>    /* Earlier loss recovery underway */  
</span><span class='line'>    if (tcp_is_sackfrto(tp) &amp;&amp; (tp-&gt;frto_counter ||   
</span><span class='line'>        ((1 &lt;&lt; icsk-&gt;icsk_ca_state) &amp; (TCPF_CA_Recovery | TCPF_CA_Loss))) &amp;&amp;  
</span><span class='line'>        after(tp-&gt;high_seq, tp-&gt;snd_una)) {  
</span><span class='line'>
</span><span class='line'>        tp-&gt;frto_highmark = tp-&gt;high_seq;  
</span><span class='line'>
</span><span class='line'>    } else {  
</span><span class='line'>        tp-&gt;frto_highmark = tp-&gt;snd_nxt;  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    tcp_set_ca_state (sk, TCP_CA_Disorder); /* 设置拥塞状态*/  
</span><span class='line'>    tp-&gt;high_seq = tp-&gt;snd_nxt;  
</span><span class='line'>    tp-&gt;frto_counter = 1; /* 表示刚进入F-RTO状态！*/  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;F-RTO算法处理&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;F-RTO算法的处理过程主要发生在重传完超时数据包后。发送方在接收到ACK后，在处理ACK时会检查是否处于F-RTO处理阶段。如果是则会调用tcp_process_frto()进行F-RTO阶段的处理。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static int tcp_ack (struct sock *sk, const struct sk_buff *skb, int flag)  
</span><span class='line'>{  
</span><span class='line'>    ....  
</span><span class='line'>
</span><span class='line'>    if (tp-&gt;frto_counter )  
</span><span class='line'>        frto_cwnd = tcp_process_frto(sk, flag);  
</span><span class='line'>
</span><span class='line'>    ....  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;2.6.20的F-RTO&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;tcp_process_frto()用于判断RTO是否为虚假的，主要依据为RTO后的两个ACK。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static void tcp_process_frto (struct sock *sk, u32 prior_snd_una)  
</span><span class='line'>{  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    tcp_sync_left_out(tp);  
</span><span class='line'>
</span><span class='line'>    /* RTO was caused by loss, start retransmitting in 
</span><span class='line'>     * go-back-N slow start. 
</span><span class='line'>     * 包括两种情况： 
</span><span class='line'>      * （1）此ACK为dupack 
</span><span class='line'>     * （2）此ACK确认完整个窗口 
</span><span class='line'>      * 以上两种情况都表示有数据包丢失了，需要采用传统的方法。 
</span><span class='line'>      */  
</span><span class='line'>    if (tp-&gt;snd_una == prior_snd_una ||   
</span><span class='line'>        ! before(tp-&gt;snd_una, tp-&gt;frto_highmark)) {  
</span><span class='line'>
</span><span class='line'>        tcp_enter_frto_loss(sk);  
</span><span class='line'>        return;  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    /* First ACK after RTO advances the window: allow two new  
</span><span class='line'>     * segments out. 
</span><span class='line'>     * frto_counter = 1表示收到第一个有效的ACK，则重新设置 
</span><span class='line'>     * 拥塞窗口，确保可以在F-RTO处理阶段在输出两个数据包， 
</span><span class='line'>     * 因为此时还没进入Loss状态，所以可以发送新数据包。 
</span><span class='line'>     */  
</span><span class='line'>    if (tp-&gt;frto_counter == 1) {  
</span><span class='line'>
</span><span class='line'>        tp-&gt;snd_cwnd = tcp_packets_in_flight(tp) + 2;  
</span><span class='line'>
</span><span class='line'>    } else {  
</span><span class='line'>
</span><span class='line'>        /* Also the second ACK after RTO advances the window. 
</span><span class='line'>         * The RTO was likely spurious. Reduce cwnd and continue 
</span><span class='line'>         * in congestion avoidance. 
</span><span class='line'>         * 第二个ACK有效，则调整拥塞窗口，直接进入拥塞避免阶段， 
</span><span class='line'>          * 而不用重传数据包。 
</span><span class='line'>          * / 
</span><span class='line'>        tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh); 
</span><span class='line'>        tcp_moderate_cwnd(tp); 
</span><span class='line'>    } 
</span><span class='line'>
</span><span class='line'>    /* F-RTO affects on two new ACKs following RTO. 
</span><span class='line'>     * At latest on third ACK the TCP behavior is back to normal. 
</span><span class='line'>     * 如果能连续收到两个确认了新数据的ACK，则说明RTO是虚假的，因此 
</span><span class='line'>      * 退出F-RTO。 
</span><span class='line'>      */  
</span><span class='line'>    tp-&gt;frto_counter = (tp-&gt;frto_counter + 1) % 3;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如果确定RTO为虚假的，则调用tcp_enter_frto_loss()，进入RTO恢复阶段，开始慢启动。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    /* Enter Loss state after F-RTO was applied. Dupack arrived after RTO, which 
</span><span class='line'> * indicates that we should follow the traditional RTO recovery, i.e. mark  
</span><span class='line'> * erverything lost and do go-back-N retransmission. 
</span><span class='line'> */  
</span><span class='line'>static void tcp_enter_frto_loss (struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    struct sk_buff *skb;  
</span><span class='line'>    int cnt = 0;  
</span><span class='line'>
</span><span class='line'>    /* 进入Loss状态后，清零SACK、lost、retrans_out等数据*/  
</span><span class='line'>    tp-&gt;sacked_out = 0;  
</span><span class='line'>    tp-&gt;lost_out = 0;  
</span><span class='line'>    tp-&gt;fackets_out = 0;  
</span><span class='line'>
</span><span class='line'>    /* 遍历重传队列，重新标志LOST。对于那些在RTO发生后传输 
</span><span class='line'>     * 的数据不用标志为LOST。 
</span><span class='line'>     */  
</span><span class='line'>    sk_stream_for_retrans_queue(skb, sk) {  
</span><span class='line'>        cnt += tcp_skb_pcount(skb);  
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_LOST;  
</span><span class='line'>
</span><span class='line'>        /* 对于那些没被SACK的数据包，需要把它标志为LOST。*/  
</span><span class='line'>        if (! (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_SACKED_ACKED)) {  
</span><span class='line'>            /* Do not mark those segments lost that were forward 
</span><span class='line'>             * transmitted after RTO. 
</span><span class='line'>             */  
</span><span class='line'>             if (! after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;frto_highmark))  
</span><span class='line'>             {  
</span><span class='line'>                TCP_SKB_CB(skb)-&gt;sacked |= TCP_LOST;  
</span><span class='line'>                tp-&gt;lost_out += tcp_skb_pcount(skb);  
</span><span class='line'>             }  
</span><span class='line'>
</span><span class='line'>        } else { /* 对于那些已被sacked的数据包，则不用标志LOST。*/  
</span><span class='line'>            tp-&gt;sacked_out += tcp_skb_pcount(skb);  
</span><span class='line'>            tp-&gt;fackets_out = cnt;  
</span><span class='line'>        }  
</span><span class='line'>    }  
</span><span class='line'>    tcp_syn_left_out(tp);  
</span><span class='line'>
</span><span class='line'>    tp-&gt;snd_cwnd = tp-&gt;frto_counter + tcp_packets_in_flight(tp) + 1;  
</span><span class='line'>    tp-&gt;snd_cwnd_cnt = 0;  
</span><span class='line'>    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;  
</span><span class='line'>    tp-&gt;undo_marker = 0; /* 不需要undo标志*/  
</span><span class='line'>    tp-&gt;frto_counter = 0; /* 表示F-RTO结束了*/  
</span><span class='line'>
</span><span class='line'>    /* 更新乱序队列的最大值*/  
</span><span class='line'>    tp-&gt;reordering = min_t(unsigned int, tp-&gt;reordering, sysctl_tcp_reordering);  
</span><span class='line'>    tcp_set_ca_state(sk, TCP_CA_Loss); /* 进入loss状态*/  
</span><span class='line'>    tp-&gt;high_seq = tp-&gt;frto_highmark; /*RTO时的最大序列号*/  
</span><span class='line'>    TCP_ECN_queue_cwr(tp); /* 设置显示拥塞标志*/  
</span><span class='line'>    clear_all_retrans_hints(tp);  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;3.2.12的F-RTO&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;F-RTO spurious RTO detection algorithm (RFC4138)&lt;br/&gt;
</span><span class='line'>F-RTO affects during two new ACKs following RTO (well, almost, see inline
</span><span class='line'>comments). State (ACK number) is kept in frto_counter. When ACK advances
</span><span class='line'>window (but not to or beyond highest sequence sent before RTO) :&lt;br/&gt;
</span><span class='line'>On First ACK, send two new segments out.&lt;br/&gt;
</span><span class='line'>On second ACK, RTO was likely spurious. Do spurious response (response&lt;br/&gt;
</span><span class='line'>algorithm is not part of the F-RTO detection algorithm given in RFC4138 but&lt;br/&gt;
</span><span class='line'>can be selected separately).&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Otherwise (basically on duplicate ACK), RTO was (likely) caused by a loss and
</span><span class='line'>TCP falls back to conventional RTO recovery. F-RTO allows overriding of Nagle,
</span><span class='line'>this is done using frto_counter states 2 and 3, when a new data segment of any
</span><span class='line'>size sent during F-RTO, state 2 is upgraded to 3.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Rationale: if the RTO was suprious, new ACKs should arrive from the original
</span><span class='line'>window even after we transmit two new data segments.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;SACK version:&lt;br/&gt;
</span><span class='line'>on first step, wait until first cumulative ACK arrives, then move to the second
</span><span class='line'>step. In second step, the next ACK decides.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static int tcp_process_frto(struct sock *sk, int flag)  
</span><span class='line'>{  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    tcp_verify_left_out(tp);  
</span><span class='line'>
</span><span class='line'>    /* Duplicate the behavior from Loss state (fastretrans_alert) */  
</span><span class='line'>    if (flag &amp; FLAG_DATA_ACKED)  
</span><span class='line'>        inet_csk(sk)-&gt;icsk_retransmits = 0; /*重传次数归零*/  
</span><span class='line'>
</span><span class='line'>    if ((flag &amp; FLAG_NONHEAD_RETRANS_ACKED) ||  
</span><span class='line'>        ((tp-&gt;frto_counter &gt;= 2) &amp;&amp; (flag &amp; FLAG_RETRANS_DATA_ACKED)))  
</span><span class='line'>        tp-&gt;undo_marker = 0;  
</span><span class='line'>
</span><span class='line'>    /* 一个ACK确认完RTO时整个窗口，表示出现了丢包*/  
</span><span class='line'>    if (! before(tp-&gt;snd_una, tp-&gt;frto_highmark)) {  
</span><span class='line'>        tcp_enter_frto_loss(sk, (tp-&gt;frto_counter == 1 ? 2 : 3), flag) ;  
</span><span class='line'>        return 1;  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    /* Reno的处理方式 */  
</span><span class='line'>    if (! tcp_is_sackfrto(tp)) {   
</span><span class='line'>        /* RFC4138 shortcoming in step2; should also have case c): 
</span><span class='line'>         * ACK isn't duplicate nor advances window, e.g., opposite dir 
</span><span class='line'>         * data, winupdate 
</span><span class='line'>         */  
</span><span class='line'>        if (! (flag &amp; FLAG_ANY_PROGRESS) &amp;&amp; (flag &amp; FLAG_NOT_DUP))  
</span><span class='line'>            return 1; /*不采取任何措施，忽略*/  
</span><span class='line'>
</span><span class='line'>        if (! (flag &amp; FLAG_DATA_ACKED)) { /* 没有确认新的数据*/  
</span><span class='line'>            tcp_enter_frto_loss(sk, (tp-&gt;frto_counter == 1 ? 0 : 3), flag);  
</span><span class='line'>            return 1;  
</span><span class='line'>        }  
</span><span class='line'>
</span><span class='line'>    } else { /* SACK的处理方式 */  
</span><span class='line'>        /* Prevent sender of new data. 表示第一个ACK没有确认新数据， 
</span><span class='line'>         * 这个时候不允许发送新的数据，直接返回。 
</span><span class='line'>         */  
</span><span class='line'>        if (! (flag &amp; FLAG_DATA_ACKED) &amp; (tp-&gt;frto_conter == 1) {  
</span><span class='line'>            tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tcp_packets_in_flight(tp));  
</span><span class='line'>            return 1;  
</span><span class='line'>        }  
</span><span class='line'>
</span><span class='line'>        /* 当第二个ACK也没有确认新的数据时，判定RTO真实，退出F-RTO。*/  
</span><span class='line'>        if ( (tp-&gt;frto_counter &gt;= 2) &amp;&amp;   
</span><span class='line'>            (! (flag &amp; FLAG_FORWARD_PROGRESS) ||  
</span><span class='line'>            ((flag &amp; FLAG_DATA_SACKED) &amp;&amp; ! (flag &amp; FLAG_ONLY_ORIG_SACKED))) {  
</span><span class='line'>            /* RFC4138 shortcoming (see comment above) */  
</span><span class='line'>
</span><span class='line'>            if (! (flag &amp; FLAG_FORWARD_PROGRESS) &amp;&amp;   
</span><span class='line'>                (flag &amp; FLAG_NOT_DUP);  
</span><span class='line'>                return 1;  
</span><span class='line'>
</span><span class='line'>            tcp_enter_frto_loss(sk, 3, flag);  
</span><span class='line'>            return 1;  
</span><span class='line'>        }  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    if (tp-&gt;frto_counter == 1) {  
</span><span class='line'>        /* tcp_may_send_now needs to see updated state */  
</span><span class='line'>        tp-&gt;snd_cwnd = tcp_packets_in_flight(tp) + 2;  
</span><span class='line'>        tp-&gt;frto_counter = 2;  
</span><span class='line'>
</span><span class='line'>        if (! tcp_may_send_now(sk))  
</span><span class='line'>            tcp_enter_frto_loss(sk, 2, flag);  
</span><span class='line'>        return 1;  
</span><span class='line'>
</span><span class='line'>    } else {  
</span><span class='line'>        switch (sysctl_tcp_frto_response) {  
</span><span class='line'>        case 2: /* 比较激进的，恢复到RTO前的窗口和阈值*/  
</span><span class='line'>            tcp_undo_spur_to_response(sk, flag);  
</span><span class='line'>            break;  
</span><span class='line'>
</span><span class='line'>        case 1: /* 非常保守，阈值减小B，可窗口一再减小，为B/2 */  
</span><span class='line'>            tcp_conservative_spur_to_response(sk);  
</span><span class='line'>            break;  
</span><span class='line'>
</span><span class='line'>        default:  
</span><span class='line'>            /* 保守*/  
</span><span class='line'>            tcp_ratehalving_spur_to_response(sk);  
</span><span class='line'>            break;  
</span><span class='line'>        }  
</span><span class='line'>
</span><span class='line'>        tp-&gt;frto_counter = 0; /*F-RTO算法结束标志*/  
</span><span class='line'>        tp-&gt;undo_marker = 0; /*清零undo标志*/  
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSPURIOUSRTOS);  
</span><span class='line'>    }  
</span><span class='line'>    return 0;   
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>#define FLAG_DATA_ACKED 0x04 /* This ACK acknowledged new data. */  
</span><span class='line'>#define FLAG_NONHEAD_RETRANS_ACKED 0x1000 /* Non-head rexmit data was ACKed. */  
</span><span class='line'>#define FLAG_RETRANS_DATA_ACKED 0x08 /* some of which was retransmitted.*/  
</span><span class='line'>
</span><span class='line'>#define FLAG_ACKED (FLAG_DATA_ACKED | FLAG_SYN_ACKED)  
</span><span class='line'>#define FLAG_FORWARD_PROGRESS (FLAG_ACKED | FLAG_DATA_SACKED)  
</span><span class='line'>#define FLAG_ANY_PROGRESS (FLAG_RORWARD_PROGRESS | FLAG_SND_UNA_ADVANCED)  
</span><span class='line'>
</span><span class='line'>#define FLAG_NOT_DUP (FLAG_DATA | FLAG_WIN_UPDATE | FLAG_ACKED)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;tcp_frto_response选项&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;tcp_frto_response表示TCP在检测到虚假的RTO后，采用什么函数来进行阈值和拥塞窗口的调整，它有三种取值：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;（1）值为2&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;表示使用tcp_undo_spur_to_response()，这是一种比较激进的处理方法，它把阈值和拥塞窗口都恢复到RTO前的值。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;（2）值为1&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;表示使用tcp_conservative_spur_to_response()，这是一种很保守的处理方法。&lt;br/&gt;
</span><span class='line'>假设减小因子为B，RTO前的窗口为C，那么一般情况下（因为阈值调整算法不同）&lt;br/&gt;
</span><span class='line'>此后ssthresh=（1 - B）C，cwnd = （1 -B ）（1- B）C&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;（3）值为0或其它（默认为0）&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;表示使用默认的tcp_ratehalving_spur_to_response()，也是一种保守的处理方法。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static void tcp_undo_spur_to_response (struct sock *sk, int flag)  
</span><span class='line'>{  
</span><span class='line'>    /* 如果有显示拥塞标志，则进入CWR状态，最终阈值不变，窗口减半*/  
</span><span class='line'>    if (flag &amp; FLAG_ECE)  
</span><span class='line'>        tcp_ratehalving_spur_to_response(sk);  
</span><span class='line'>    else  
</span><span class='line'>    /* 撤销阈值调整，撤销窗口调整，恢复RTO前的状态*/  
</span><span class='line'>        tcp_undo_cwr(sk, true);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* A conservative spurious RTO response algorithm: reduce cwnd 
</span><span class='line'> * using rate halving and continue in congestion_avoidance. 
</span><span class='line'> */  
</span><span class='line'>static void tcp_ratehalving_spur_to_response(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    tcp_enter_cwr(sk, 0);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* A very conservative spurious RTO response algorithm: reduce cwnd 
</span><span class='line'> * and continue in congestion avoidance. 
</span><span class='line'> */  
</span><span class='line'>static void tcp_conservative_spur_to_response(struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>    tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh);  
</span><span class='line'>    tp-&gt;snd_cwnd_cnt = 0;  
</span><span class='line'>    tp-&gt;bytes_acked = 0;  
</span><span class='line'>    /* 竟然又设置了显示拥塞标志，那窗口就还要减小到阈值的（1-B）！ 
</span><span class='line'>     * 果然是非常保守。 
</span><span class='line'>     */  
</span><span class='line'>    TCP_ECN_queue_cwr(tp);   
</span><span class='line'>    tcp_moderate_cwnd(tp);  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如果判断RTO是真实的，就调用tcp_enter_frto_loss()来处理。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    /* Enter Loss state after F-RTO was applied. Dupack arrived after RTO, 
</span><span class='line'> * which indicates that we should follow the tradditional RTO recovery, 
</span><span class='line'> * i.e. mark everything lost and do go-back-N retransmission. 
</span><span class='line'> */  
</span><span class='line'>static void tcp_enter_frto_loss(struct sock *sk, int allowed_segments, int flag)  
</span><span class='line'>{  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    struct sk_buff *skb;  
</span><span class='line'>
</span><span class='line'>    tp-&gt;lost_out = 0;  
</span><span class='line'>    tp-&gt;retrans_out = 0;  
</span><span class='line'>
</span><span class='line'>    if (tcp_is_reno(tp))  
</span><span class='line'>        tcp_reset_reno_sack(tp);  
</span><span class='line'>
</span><span class='line'>    tcp_for_write_queue(skb, sk) {  
</span><span class='line'>        if (skb == tcp_send_head(sk))  
</span><span class='line'>            break;  
</span><span class='line'>
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_LOST;  
</span><span class='line'>        /*  
</span><span class='line'>         * Count the retransmission made on RTO correctly (only when waiting for 
</span><span class='line'>         * the first ACK and did not get it. 
</span><span class='line'>         */  
</span><span class='line'>        if ((tp-&gt;frto_counter == 1) &amp;&amp; !(flag &amp; FLAG_DATA_ACKED)) {  
</span><span class='line'>            /* For some reason this R-bit might get cleared ? */  
</span><span class='line'>            if (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_SACKED_RETRANS)  
</span><span class='line'>                tp-&gt;retrans_out += tcp_skb_pcount(skb);  
</span><span class='line'>
</span><span class='line'>            /* enter this if branch just for the first segment */  
</span><span class='line'>            flag |= FLAG_DATA_ACKED;  
</span><span class='line'>        } else {  
</span><span class='line'>
</span><span class='line'>            if (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_RETRANS)  
</span><span class='line'>                tp-&gt;undo_marker = 0;  
</span><span class='line'>            TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_RETRANS;  
</span><span class='line'>        }  
</span><span class='line'>
</span><span class='line'>        /* Marking forward transmissions that were made after RTO lost can 
</span><span class='line'>        * cause unnecessary retransmissions in some scenarios, 
</span><span class='line'>        * SACK blocks will mitigate that in some but not in all cases. 
</span><span class='line'>        * We used to not mark them but it was casuing break-ups with 
</span><span class='line'>        * receivers that do only in-order receival. 
</span><span class='line'>        *  
</span><span class='line'>        * TODO: we could detect presence of such receiver and select different 
</span><span class='line'>        * behavior per flow. 
</span><span class='line'>        */  
</span><span class='line'>       if (! (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_SACKED_ACKED)) {  
</span><span class='line'>          TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST;  
</span><span class='line'>           tp-&gt;lost_out += tcp_skb_pcount(skb);  
</span><span class='line'>           tp-&gt;retransmit_high = TCP_SKB_CB(skb)-&gt;end_seq;  
</span><span class='line'>       }  
</span><span class='line'>    }  
</span><span class='line'>    tcp_verify_left_out(tp);  
</span><span class='line'>
</span><span class='line'>    /* allowed_segments应该不大于3*/  
</span><span class='line'>    tp-&gt;snd_cwnd = tcp_packets_in_flight(tp) + allowed_segments;  
</span><span class='line'>    tp-&gt;snd_cwnd_cnt = 0;  
</span><span class='line'>    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;  
</span><span class='line'>    tp-&gt;frto_counter = 0; /* F-RTO结束了*/  
</span><span class='line'>    tp-&gt;bytes_acked = 0;  
</span><span class='line'>
</span><span class='line'>    /* 更新乱序队列的最大长度*/  
</span><span class='line'>    tp-&gt;reordering = min_t(unsigned int, tp-&gt;reordering,  
</span><span class='line'>                                               sysctl_tcp_reordering);  
</span><span class='line'>
</span><span class='line'>    tcp_set_ca_state(sk, TCP_CA_Loss); /*设置成Loss状态*/  
</span><span class='line'>    tp-&gt;high_seq = tp-&gt;snd_nxt;  
</span><span class='line'>    TCP_ECN_queue_cwr(tp); /*设置显式拥塞标志*/  
</span><span class='line'>    tcp_clear_all_retrans_hints(tp);  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;总结&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;现在内核（3.2.12）是默认使用F-RTO算法的。&lt;br/&gt;
</span><span class='line'>其中tcp_frto默认为2，tcp_frto_response默认为0。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[TCP拥塞状态机的实现tcp_fastretrans_alert]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/03/23/kernel-net-ca/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-03-23T14:03:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/03/23/kernel-net-ca&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://blog.csdn.net/zhangskd/article/details/8260873"&gt;TCP拥塞状态机的实现（上）&lt;/a&gt;&lt;br/&gt;
</span><span class='line'>&lt;a href="http://blog.csdn.net/zhangskd/article/details/8283687"&gt;TCP拥塞状态机的实现（中）&lt;/a&gt;&lt;br/&gt;
</span><span class='line'>&lt;a href="http://blog.csdn.net/zhangskd/article/details/8283689"&gt;TCP拥塞状态机的实现（下）&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;TCP拥塞状态机的实现（上）&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内容：本文主要分析TCP拥塞状态机的实现中，主体函数tcp_fastretrans_alert()的实现。接下来的文章会对其中重要的部分进行更具体的分析。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内核版本：2.6.37&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;原理&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;先来看一下涉及到的知识。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;拥塞状态：&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（1）Open：Normal state, no dubious events, fast path.&lt;br/&gt;
</span><span class='line'>（2）Disorder：In all respects it is Open, but requres a bit more attention.&lt;br/&gt;
</span><span class='line'>      It is entered when we see some SACKs or dupacks. It is split of Open mainly to move some processing from fast path to slow one.&lt;br/&gt;
</span><span class='line'>（3）CWR：cwnd was reduced due to some Congestion Notification event.&lt;br/&gt;
</span><span class='line'>      It can be ECN, ICMP source quench, local device congestion.&lt;br/&gt;
</span><span class='line'>（4）Recovery：cwnd was reduced, we are fast-retransmitting.&lt;br/&gt;
</span><span class='line'>（5）Loss：cwnd was reduced due to RTO timeout or SACK reneging.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;tcp_fastretrans_alert() is entered：&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（1）each incoming ACK, if state is not Open&lt;br/&gt;
</span><span class='line'>（2）when arrived ACK is unusual, namely:&lt;br/&gt;
</span><span class='line'>      SACK&lt;br/&gt;
</span><span class='line'>      Duplicate ACK&lt;br/&gt;
</span><span class='line'>      ECN ECE&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;Counting packets in flight is pretty simple.&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（1）in_flight = packets_out - left_out + retrans_out&lt;br/&gt;
</span><span class='line'>packets_out is SND.NXT - SND.UNA counted in packets. &lt;br/&gt;
</span><span class='line'>retrans_out is number of retransmitted segments.&lt;br/&gt;
</span><span class='line'>left_out is number of segments left network, but not ACKed yet.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（2）left_out = sacked_out + lost_out&lt;br/&gt;
</span><span class='line'>sacked_out：Packets, which arrived to receiver out of order and hence not ACKed. With SACK this number is simply amount of SACKed data. Even without SACKs it is easy to give pretty reliable estimate of this number, counting duplicate ACKs.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（3）lost_out：Packets lost by network. TCP has no explicit loss notification feedback from network(for now). It means that this number can be only guessed. Actually, it is the heuristics to predict lossage that distinguishes different algorithms.&lt;br/&gt;
</span><span class='line'>F.e. after RTO, when all the queue is considered as lost, lost_out = packets_out and in_flight = retrans_out.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;Essentially, we have now two algorithms counting lost packets.&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1）FACK：It is the simplest heuristics. As soon as we decided that something is lost, we decide that all not SACKed packets until the most forward SACK are lost. I.e.&lt;br/&gt;
</span><span class='line'>lost_out = fackets_out - sacked_out and left_out = fackets_out&lt;br/&gt;
</span><span class='line'>It is absolutely correct estimate, if network does not reorder packets. And it loses any connection to reality when reordering takes place. We use FACK by defaut until reordering is suspected on the path to this destination.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2）NewReno：when Recovery is entered, we assume that one segment is lost (classic Reno). While we are in Recovery and a partial ACK arrives, we assume that one more packet is lost (NewReno).&lt;br/&gt;
</span><span class='line'>This heuristics are the same in NewReno and SACK. &lt;br/&gt;
</span><span class='line'>Imagine, that&rsquo;s all! Forget about all this shamanism about CWND inflation deflation etc. CWND is real congestion window, never inflated, changes only according to classic VJ rules.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Really tricky (and requiring careful tuning) part of algorithm is hidden in functions tcp_time_to_recover() and tcp_xmit_retransmit_queue().&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;tcp_time_to_recover()&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;It determines the moment when we should reduce cwnd and, hence, slow down forward transmission. In fact, it determines the moment when we decide that hole is caused by loss, rather than by a reorder.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;tcp_xmit_retransmit_queue()&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;It decides what we should retransmit to fill holes, caused by lost packets.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;undo heuristics&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;And the most logically complicated part of algorithm is undo heuristics. We detect false retransmits due to both too early fast retransmit (reordering) and underestimated RTO, analyzing timestamps and D-SACKs. When we detect that some segments were retransmitted by mistake and CWND reduction was wrong, we undo window reduction and abort recovery phase. This logic is hidden inside several functions named tcp_try_undo_&lt;something&gt;.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;主体函数&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;TCP拥塞状态机主要是在tcp_fastretrans_alert()中实现的，tcp_fastretrans_alert()在tcp_ack()中被调用。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;此函数分成几个阶段：&lt;br/&gt;
</span><span class='line'>A. FLAG_ECE，收到包含ECE标志的ACK。&lt;br/&gt;
</span><span class='line'>B. reneging SACKs，ACK指向已经被SACK的数据段。如果是此原因，进入超时处理，然后返回。&lt;br/&gt;
</span><span class='line'>C. state is not Open，发现丢包，需要标志出丢失的包，这样就知道该重传哪些包了。&lt;br/&gt;
</span><span class='line'>D. 检查是否有错误( left_out &gt; packets_out)。&lt;br/&gt;
</span><span class='line'>E. 各个状态是怎样退出的，当snd_una &gt;= high_seq时候。&lt;br/&gt;
</span><span class='line'>F. 各个状态的处理和进入。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;下文会围绕这几个阶段进行具体分析。</span></code></pre></td></tr></table></div></figure>
    /<em> Process an event, which can update packets-in-flight not trivially.
     * Main goal of this function is to calculate new estimate for left_out,
     * taking into account both packets sitting in receiver&rsquo;s buffer and
     * packets lost by network.
     *
     * Besides that it does CWND reduction, when packet loss is detected
     * and changes state of machine.
     *
     * It does not decide what to send, it is made in function
     * tcp_xmit_retransmit_queue().
     </em>/</p>

<pre><code>/* 此函数被调用的条件：
 * (1) each incoming ACK, if state is not Open
 * (2) when arrived ACK is unusual, namely:
 *       SACK
 *       Duplicate ACK
 *       ECN ECE
 */

static void tcp_fastretrans_alert(struct sock *sk, int pkts_acked, int flag)
{
    struct inet_connection_sock *icsk = inet_csk(sk);
    struct tcp_sock *tp = tcp_sk(sk);

    /* 判断是不是重复的ACK*/
    int is_dupack = ! (flag &amp; (FLAG_SND_UNA_ADVANCED | FLAG_NOT_DUP));

    /* tcp_fackets_out()返回hole的大小，如果大于reordering，则认为发生丢包.*/
    int do_lost = is_dupack || ((flag &amp; FLAG_DATA_SACKED) &amp;&amp; 
                                (tcp_fackets_out(tp) &gt; tp-&gt;reordering ));

    int fast_rexmit = 0, mib_idx;

    /* 如果packet_out为0，那么不可能有sacked_out */
    if (WARN_ON(!tp-&gt;packets_out &amp;&amp; tp-&gt;sacked_out))
        tp-&gt;sacked_out = 0;

    /* fack的计数至少需要依赖一个SACK的段.*/
    if (WARN_ON(!tp-&gt;sacked_out &amp;&amp; tp-&gt;fackets_out))
        tp-&gt;fackets_out = 0;

    /* Now state machine starts.
     * A. ECE, hence prohibit cwnd undoing, the reduction is required. 
     * 禁止拥塞窗口撤销，并开始减小拥塞窗口。
     */
    if (flag &amp; FLAG_ECE)
        tp-&gt;prior_ssthresh = 0;

    /* B. In all the states check for reneging SACKs. 
     * 检查是否为虚假的SACK，即ACK是否确认已经被SACK的数据.
     */
    if (tcp_check_sack_reneging(sk, flag))
        return;

    /* C. Process data loss notification, provided it is valid. 
     * 为什么需要这么多个条件？不太理解。
     * 此时不在Open态，发现丢包，需要标志出丢失的包。
      */
    if (tcp_is_fack(tp) &amp;&amp; (flag &amp; FLAG_DATA_LOSS) &amp;&amp;
        before(tp-&gt;snd_una, tp-&gt;high_seq) &amp;&amp;
        icsk-&gt;icsk_ca_state != TCP_CA_Open &amp;&amp;
        tp-&gt;fackets_out &gt; tp-&gt;reordering) {
        tcp_mark_head_lost(sk, tp-&gt;fackets_out - tp-&gt;reordering, 0);
        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPLOSS);
        }

    /* D. Check consistency of the current state. 
     * 确定left_out &lt; packets_out
     */
    tcp_verify_left_out(tp); 

    /* E. Check state exit conditions. State can be terminated 
     * when high_seq is ACKed. */
    if (icsk-&gt;icsk_ca_state == TCP_CA_Open) {
        /* 在Open状态，不可能有重传且尚未确认的段*/
        WARN_ON(tp-&gt;retrans_out != 0);
        /* 清除上次重传阶段第一个重传段的发送时间*/
        tp-&gt;retrans_stamp = 0;

    } else if (!before(tp-&gt;snd_una, tp-&gt;high_seq) {/* high_seq被确认了*/
        switch(icsk-&gt;icsk_ca_state) {
            case TCP_CA_Loss:
                icsk-&gt;icsk_retransmits = 0; /*超时重传次数归0*/ 

                /*不管undo成功与否，都会返回Open态，除非没有使用SACK*/
                if (tcp_try_undo_recovery(sk)) 
                    return;
                break;

            case TCP_CA_CWR:
                /* CWR is to be held someting *above* high_seq is ACKed
                 * for CWR bit to reach receiver.
                 * 需要snd_una &gt; high_seq才能撤销
                   */
                if (tp-&gt;snd_una != tp-&gt;high_seq) {
                    tcp_complete_cwr(sk);
                    tcp_set_ca_state(sk, TCP_CA_Open);
                }
                break;

            case TCP_CA_Disorder:
                tcp_try_undo_dsack(sk);
                 /* For SACK case do not Open to allow to undo
                  * catching for all duplicate ACKs.?*/
                if (!tp-&gt;undo_marker || tcp_is_reno(tp) || 
                    tp-&gt;snd_una != tp-&gt;high_seq) {
                    tp-&gt;undo_marker = 0;
                    tcp_set_ca_state(sk, TCP_CA_Open);
                }

            case TCP_CA_Recovery:
                if (tcp_is_reno(tp))
                    tcp_reset_reno_sack(tp)); /* sacked_out清零*/

                if (tcp_try_undo_recovery(sk))
                    return;

                tcp_complete_cwr(sk);
                break;
        }
    }

    /* F. Process state. */
    switch(icsk-&gt;icsk_ca_state) {
        case TCP_CA_Recovery:
            if (!(flag &amp; FLAG_SND_UNA_ADVANCED)) {
                if (tcp_is_reno(tp) &amp;&amp; is_dupack)
                    tcp_add_reno_sack(sk); /* 增加sacked_out ，检查是否出现reorder*/
            } else 
                do_lost = tcp_try_undo_partial(sk, pkts_acked);
            break;

        case TCP_CA_Loss:
            /* 收到partical ack，超时重传的次数归零*/
            if (flag &amp; FLAG_DATA_ACKED)
                icsk-&gt;icsk_retransmits = 0;

            if (tcp_is_reno(tp) &amp;&amp; flag &amp; FLAG_SND_UNA_ADVANCED)
                tcp_reset_reno_sack(tp); /* sacked_out清零*/

            if (!tcp_try_undo_loss(sk)) { /* 尝试撤销拥塞调整，进入Open态*/
                /* 如果不能撤销，则继续重传标志为丢失的包*/
                tcp_moderate_cwnd(tp);
                tcp_xmit_retransmit_queue(sk); /* 待看*/
               return;
            }

            if (icsk-&gt;icsk_ca_state != TCP_CA_Open)
                return;

        /* Loss is undone; fall through to process in Open state.*/
        default:
            if (tcp_is_reno(tp)) {
                if (flag &amp; FLAG_SND_UNA_ADVANCED)
                   tcp_reset_reno_sack(tp);

                if (is_dupack)
                   tcp_add_reno_sack(sk);
            }

            if (icsk-&gt;icsk_ca_state == TCP_CA_Disorder)
                tcp_try_undo_dsack(sk); /*D-SACK确认了所有重传的段*/

            /* 判断是否应该进入Recovery状态*/
            if (! tcp_time_to_recover(sk)) {
               /*此过程中，会判断是否进入Open、Disorder、CWR状态*/
                tcp_try_to_open(sk, flag); 
                return;
            }

            /* MTU probe failure: don't reduce cwnd */
            /* 关于MTU探测部分此处略过！*/
            ......

            /* Otherwise enter Recovery state */
            if (tcp_is_reno(tp))
                mib_idx = LINUX_MIB_TCPRENORECOVERY;
            else
                mib_idx = LINUX_MIB_TCPSACKRECOVERY;

             NET_INC_STATS_BH(sock_net(sk), mib_idx);

            /* 进入Recovery状态前，保存那些用于恢复的数据*/
            tp-&gt;high_seq = tp-&gt;snd_nxt; /* 用于判断退出时机*/
            tp-&gt;prior_ssthresh = 0;
            tp-&gt;undo_marker = tp-&gt;snd_una;
            tp-&gt;undo_retrans=tp-&gt;retrans_out;

           if (icsk-&gt;icsk_ca_state &lt; TCP_CA_CWR) {
               if (! (flag &amp; FLAG_ECE))
                   tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk); /*保存旧阈值*/
               tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);/*更新阈值*/
               TCP_ECN_queue_cwr(tp);
           }

           tp-&gt;bytes_acked = 0;
           tp-&gt;snd_cwnd_cnt = 0;

           tcp_set_ca_state(sk, TCP_CA_Recovery); /* 进入Recovery状态*/
           fast_rexmit = 1; /* 快速重传标志 */
    }

    if (do_lost || (tcp_is_fack(tp) &amp;&amp; tcp_head_timeout(sk)))
        /* 更新记分牌，标志丢失和超时的数据包，增加lost_out */
        tcp_update_scoreboard(sk, fast_rexmit); 

    /* 减小snd_cwnd */
    tcp_cwnd_down(sk, flag);
    tcp_xmit_retransmit_queue(sk);
}
</code></pre>

<pre><code>
#### flag标志
</code></pre>

<pre><code>#define FLAG_DATA 0x01  /* Incoming frame contained data. */  
#define FLAG_WIN_UPDATE 0x02  /* Incoming ACK was a window update. */  
#define FLAG_SND_UNA_ADVANCED 0x400  /* snd_una was changed (!= FLAG_DATA_ACKED) */  
#define FLAG_DATA_SACKED 0x20  /* New SACK. */  
#define FLAG_ECE 0x40  /* ECE in this ACK */  
#define FLAG_SACK_RENEGING 0x2000  /* snd_una advanced to a sacked seq */  
#define FLAG_DATA_LOST  /* SACK detected data lossage. */  

#define FLAG_DATA_ACKED 0x04  /* This ACK acknowledged new data. */  
#define FLAG_SYN_ACKED 0x10    /* This ACK acknowledged SYN. */  
#define FLAG_ACKED (FLAG_DATA_ACKED | FLAG_SYN_ACKED)  

#define FLAG_NOT_DUP (FLAG_DATA | FLAG_WIN_UPDATE | FLAG_ACKED)  /* 定义非重复ACK*/  

#define FLAG_FORWARD_PROGRESS (FLAG_ACKED | FLAG_DATA_SACKED)  
#define FLAG_ANY_PROGRESS (FLAG_FORWARD_PROGRESS | FLAG_SND_UNA_ADVANCED)  
#define FLAG_DSACKING_ACK 0x800  /* SACK blocks contained D-SACK info */  

struct tcp_sock {  
    ...  
    u32 retrans_out; /*重传还未得到确认的TCP段数目*/  
    u32 retrans_stamp; /* 记录上次重传阶段，第一个段的发送时间，用于判断是否可以进行拥塞调整撤销*/  

    struct sk_buff *highest_sack; /* highest skb with SACK received,  
                                   *(validity guaranteed only if sacked_out &gt; 0)  
                                   */  
   ...  
}  

struct inet_connection_sock {  
    ...  
    __u8 icks_retransmits; /* 记录超时重传的次数*/  
    ...  
}
</code></pre>

<pre><code>
#### SACK/ RENO/ FACK是否启用
</code></pre>

<pre><code>/* These function determine how the currrent flow behaves in respect of SACK 
 * handling. SACK is negotiated with the peer, and therefore it can very between 
 * different flows. 
 * 
 * tcp_is_sack - SACK enabled 
 * tcp_is_reno - No SACK 
 * tcp_is_fack - FACK enabled, implies SACK enabled 
 */  

static inline int tcp_is_sack (const struct tcp_sock *tp)  
{  
        return tp-&gt;rx_opt.sack_ok; /* SACK seen on SYN packet */  
}  

static inline int tcp_is_reno (const struct tcp_sock *tp)  
{  
        return ! tcp_is_sack(tp);  
}  

static inline int tcp_is_fack (const struct tcp_sock *tp)  
{  
        return tp-&gt;rx_opt.sack_ok &amp; 2;  
}  

static inline void tcp_enable_fack(struct tcp_sock *tp)  
{  
        tp-&gt;rx_opt.sack_ok |= 2;  
}  

static inline int tcp_fackets_out(const struct tcp_sock *tp)  
{  
        return tcp_is_reno(tp) ? tp-&gt;sacked_out +1 : tp-&gt;fackets_out;  
}
</code></pre>

<pre><code>
（1）如果启用了FACK，那么fackets_out = left_out  
           fackets_out = sacked_out + loss_out  
           所以：loss_out = fackets_out - sacked_out  
          这是一种比较激进的丢包估算，即FACK。

（2）如果没启用FACK，那么就假设只丢了一个数据包，所以left_out = sacked_out + 1  
         这是一种较为保守的做法，当出现大量丢包时，这种做法会出现问题。 

--------------

### TCP拥塞状态机的实现（中）

内容：本文主要分析TCP拥塞状态机的实现中，虚假SACK的处理、标志丢失数据包的详细过程。  
内核版本：2.6.37

#### 虚假SACK
state B

如果接收的ACK指向已记录的SACK，这说明记录的SACK并没有反应接收方的真实的状态，也就是说接收方现在已经处于严重拥塞的状态或者在处理上有bug，所以接下来就按照超时重传的方式去处理。因为按照正常的逻辑流程，接收的ACK不应该指向已记录的SACK，而应该指向SACK后面未接收的地方。通常情况下，此时接收方已经删除了保存到失序队列中的段。
</code></pre>

<pre><code>/* If ACK arrived pointing to a remembered SACK, it means that our remembered 
 * SACKs do not reflect real state of receiver i.e. receiver host is heavily congested 
 * or buggy. 
 * 
 * Do processing similar to RTO timeout. 
 */  

static int tcp_check_sack_reneging (struct sock *sk, int flag)  
{  
    if (flag &amp; FLAG_SACK_RENEGING) {  
        struct inet_connection_sock *icsk = inet_csk(sk);  
        /* 记录mib信息，供SNMP使用*/  
        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSACKRENEGING);  

        /* 进入loss状态，1表示清除SACKED标志*/  
        tcp_enter_loss(sk, 1);  /* 此函数在前面blog中分析过：）*/  

        icsk-&gt;icsk_retransmits++; /* 未恢复的RTO加一*/  

        /* 重传发送队列中的第一个数据包*/  
        tcp_retransmit_skb(sk, tcp_write_queue_head(sk));   

        /* 更新超时重传定时器*/  
        inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,   
                                     icsk-&gt;icsk_rto, TCP_RTO_MAX);  
        return 1;  
    }  
    return 0;  
}  

/** 用于返回发送队列中的第一个数据包，或者NULL 
 * skb_peek - peek at the head of an &amp;sk_buff_head 
 * @list_ : list to peek at  
 * 
 * Peek an &amp;sk_buff. Unlike most other operations you must 
 * be careful with this one. A peek leaves the buffer on the 
 * list and someone else may run off with it. You must hold 
 * the appropriate locks or have a private queue to do this. 
 * 
 * Returns %NULL for an empty list or a pointer to the head element. 
 * The reference count is not incremented and the reference is therefore 
 * volatile. Use with caution. 
 */  

static inline struct sk_buff *skb_peek (const struct sk_buff_head *list_)  
{  
    struct sk_buff *list = ((const struct sk_buff *) list_)-&gt;next;  
    if (list == (struct sk_buff *) list_)  
        list = NULL;  
    return list;  
}  

static inline struct sk_buff *tcp_write_queue_head(const struct sock *sk)  
{  
    return skb_peek(&amp;sk-&gt;sk_write_queue);  
}
</code></pre>

<pre><code>
tcp_retransmit_skb()用来重传一个数据包。它最终调用tcp_transmit_skb()来发送一个数据包。这个函数在接下来的blog中会分析。

#### 重设重传定时器
state B
</code></pre>

<pre><code>/** inet_connection_sock - INET connection oriented sock 
 * 
 * @icsk_timeout: Timeout 
 * @icsk_retransmit_timer: Resend (no ack) 
 * @icsk_rto: Retransmission timeout 
 * @icsk_ca_ops: Pluggable congestion control hook 
 * @icsk_ca_state: Congestion control state 
 * @icsk_ca_retransmits: Number of unrecovered [RTO] timeouts 
 * @icsk_pending: scheduled timer event 
 * @icsk_ack: Delayed ACK control data 
 */  

struct inet_connection_sock {  
    ...  
    unsigned long icsk_timeout; /* 数据包超时时间*/  
    struct timer_list icsk_retransmit_timer; /* 重传定时器*/  
    struct timer_list icsk_delack_timer; /* delay ack定时器*/  
    __u32 icsk_rto; /*超时时间*/  
    const struct tcp_congestion ops *icsk_ca_ops; /*拥塞控制算法*/  
    __u8 icsk_ca_state; /*所处拥塞状态*/  
    __u8 icsk_retransmits; /*还没恢复的timeout个数*/  
    __u8 icsk_pending; /* 等待的定时器事件*/  
    ...  
    struct {  
       ...  
        __u8 pending; /* ACK is pending */  
        unsigned long timeout; /* Currently scheduled timeout */  
        ...  
    } icsk_ack; /* Delayed ACK的控制模块*/  
    ...  
    u32 icsk_ca_priv[16]; /*放置拥塞控制算法的参数*/  
    ...  
#define ICSK_CA_PRIV_SIZE (16*sizeof(u32))  
}  

#define ICSK_TIME_RETRANS 1 /* Retransmit timer */  
#define ICSK_TIME_DACK 2 /* Delayed ack timer */  
#define ICSK_TIME_PROBE0 3 /* Zero window probe timer */  

/* 
 * Reset the retransmissiion timer 
 */  
static inline void inet_csk_reset_xmit_timer(struct sock *sk, const int what,  
                                            unsigned long when,  
                                            const unsigned long max_when)  
{  
    struct inet_connection_sock *icsk = inet_csk(sk);  

    if (when &gt; max_when) {  
#ifdef INET_CSK_DEBUG  
        pr_debug("reset_xmit_timer: sk=%p %d when=0x%lx, caller=%p\n",  
                    sk, what, when, current_text_addr());  
#endif  
        when = max_when;  
    }  
    if (what == ICSK_TIME_RETRANS || what == ICSK_TIME_PROBE0) {  
        icsk-&gt;icsk_pending = what;  
        icsk-&gt;icsk_timeout = jiffies + when; /*数据包超时时刻*/  
        sk_reset_timer(sk, &amp;icsk-&gt;icsk_retransmit_timer, icsk-&gt;icsk_timeout);  
    } else if (what == ICSK_TIME_DACK) {  
        icsk-&gt;icsk_ack.pending |= ICSK_ACK_TIMER;  
        icsk-&gt;icsk_ack.timeout = jiffies + when; /*Delay ACK定时器超时时刻*/  
        sk_reset_timer(sk, &amp;icsk-&gt;icsk_delack_timer, icsk-&gt;icsk_ack.timeout);  
    }  
#ifdef INET_CSK_DEBUG  
    else {  
        pr_debug("%s", inet_csk_timer_bug_msg);  
    }    
#endif       
}
</code></pre>

<pre><code>
#### 添加LOST标志
state C

Q: 我们发现有数据包丢失了，怎么知道要重传哪些数据包呢？  
A: tcp_mark_head_lost()通过给丢失的数据包标志TCPCB_LOST，就可以表明哪些数据包需要重传。  
如果通过SACK发现有段丢失，则需要从重传队首或上次标志丢失段的位置开始，为记分牌为0的段添加LOST标志，直到所有被标志LOST的段数达到packets或者被标志序号超过high_seq为止。
</code></pre>

<pre><code>/* Mark head of queue up as lost. With RFC3517 SACK, the packets is against sakced cnt, 
 * otherwise it's against fakced cnt. 
 * packets = fackets_out - reordering，表示sacked_out和lost_out的总和。 
 * 所以，被标志为LOST的段数不能超过packets。 
 * high_seq : 可以标志为LOST的段序号的最大值。 
 * mark_head: 为1表示只需要标志发送队列的第一个段。 
 */  

static void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    struct sk_buff *skb;  
    int cnt, oldcnt;  
    int err;  
    unsigned int mss;  

    /* 被标志为丢失的段不能超过发送出去的数据段数*/  
    WARN_ON(packets &gt; tp-&gt;packets_out);  

    /* 如果已经有标识为丢失的段了*/  
    if (tp-&gt;lost_skb_hint) {  
        skb = tp-&gt;lost_skb_hint; /* 下一个要标志的段 */  
        cnt = tp-&gt;lost_cnt_hint; /* 已经标志了多少段 */  

        /* Head already handled? 如果发送队列第一个数据包已经标志了，则返回 */  
        if (mark_head &amp;&amp; skb != tcp_write_queue_head(sk))  
            return;  

    } else {  
        skb = tcp_write_queue_head(sk);  
        cnt = 0;  
    }  

    tcp_for_write_queue_from(skb, sk) {  
        if (skb == tcp_send_head(sk))  
            break; /* 如果遍历到snd_nxt，则停止*/  

        /* 更新丢失队列信息*/  
        tp-&gt;lost_skb_hint = skb;  
        tp-&gt;lost_cnt_hint = cnt ;  

        /* 标志为LOST的段序号不能超过high_seq */  
        if (after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;high_seq))  
            break;  

        oldcnt = cnt;  

        if (tcp_is_fack(tp) || tcp_is_reno(tp) ||   
            (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_SACKED_ACKED))  
            cnt += tcp_skb_pcount(skb); /* 此段已经被sacked */  

        /* 主要用于判断退出时机 */  
        if (cnt &gt; packets) {  
            if ((tcp_is_sack(tp) &amp;&amp; !tcp_is_fack(tp) ||   
                (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_SACKED_ACKED) ||  
                (oldcnt &gt;= pakcets))  

                break;  

             mss = skb_shinfo(skb)-&gt;gso_size;  
             err = tcp_fragment(sk, skb, (packets - oldcnt) * mss, mss);  
             if (err &lt; 0)  
                 break;  
             cnt = packets;  
        }  

        /* 标志动作：标志一个段为LOST*/  
        tcp_skb_mark_lost(tp, skb);  
        if (mark_head)  
            break;  
    }  
    tcp_verify_left_out(tp);  
}
</code></pre>

<pre><code>
涉及变量
</code></pre>

<pre><code>struct tcp_sock {  
    /* 在重传队列中，缓存下次要标志的段，为了加速对重传队列的标志操作 */  
    struct sk_buff *lost_skb_hint; /* 下一次要标志的段 */  
    int lost_cnt_hint; /* 已经标志了多少个段 */  

    struct sk_buff *retransmit_skb_hint; /* 表示将要重传的起始包*/  
    u32 retransmit_high; /*重传队列的最大序列号*/  
    struct sk_buff *scoreboard_skb_hint; /* 记录超时的数据包，序号最大*/  
}
</code></pre>

<pre><code>
TCP分片函数tcp_fragment
</code></pre>

<pre><code>/* Function to create two new TCP segments. shrinks the given segment 
 * to the specified size and appends a new segment with the rest of the 
 * packet to the list. This won't be called frequently, I hope. 
 * Remember, these are still headerless SKBs at this point. 
 */  

int tcp_fragment (struct sock *sk, struct sk_buff *skb, u32 len,  
                                unsigned int mss_now) {}  
</code></pre>

<pre><code>
给一个段添加一个LOST标志
</code></pre>

<pre><code>static void tcp_skb_mark_lost(struct tcp_sock *tp, struct sk_buff *skb)  
{  
    if (! (TCP_SKB_CB(skb)-&gt;sacked &amp; (TCPCB_LOST | TCPCB_SACKED_ACKED))) {  
        tcp_verify_retransmit_hint(tp, skb); /* 更新重传队列*/  
        tp-&gt;lost_out += tcp_skb_pcount(skb); /*增加LOST的段数*/  
        TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST; /* 添加LOST标志*/  
    }  
}  

/* This must be called before lost_out is incremented */  
static void tcp_verify_retransmit_hint(struct tcp_sock *tp, struct sk_buff *skb)  
{  
    if ((tp-&gt;retransmit_skb_hint == NULL) ||  
         before(TCP_SKB_CB(skb)-&gt;seq,  
                       TCP_SKB_CB(tp-&gt;retransmit_skb_hint)-&gt;seq))  
    tp-&gt;retransmit_skb_hint = skb;   

    if (! tp-&gt;lost_out ||  
        after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;retransmit_high))  
        tp-&gt;retransmit_high = TCP_SKB_CB(skb)-&gt;end_seq;  
}
</code></pre>

<pre><code>
--------------

### TCP拥塞状态机的实现（下）

内容：本文主要分析TCP拥塞状态机的实现中，各个拥塞状态的进入、处理和退出的详细过程。  
内核版本：2.6.37

#### 各状态的退出
state E

各状态的退出时机：tp-&gt;snd_una &gt;= tp-&gt;high_seq

#####（1） Open
因为Open态是正常态，所以无所谓退出，保持原样。

#####（2）Loss
icsk-&gt;icsk_retransmits = 0; /*超时重传次数归0*/  
tcp_try_undo_recovery(sk);  

检查是否需要undo，不管undo成功与否，都返回Open态。

##### （3）CWR
If seq number greater than high_seq is acked, it indicates that the CWR indication has reached the peer TCP, call tcp_complete_cwr() to bring down the cwnd to ssthresh value.

tcp_complete_cwr(sk)中：  
tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh);

#####（4）Disorder
启用sack，则tcp_try_undo_dsack(sk)，交给它处理。否则，tp-&gt;undo_marker = 0;

#####（5）Recovery
tcp_try_undo_recovery(sk);  
在tcp_complete_cwr(sk)中：  
tp-&gt;snd_cwnd = tp-&gt;snd_ssthresh;
</code></pre>

<pre><code>/*cwr状态或Recovery状态结束时调用，减小cwnd*/   

static inline void tcp_complete_cwr(struct sock *sk)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh);  
    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;  
    tcp_ca_event(sk, CA_EVENT_COMPLETE_CWR);  
}
</code></pre>

<pre><code>
#### Recovery状态处理
state F

##### （1）收到dupack
如果收到的ACK并没有使snd_una前进、是重复的ACK，并且没有使用SACK，则：  
    sacked_out++，增加sacked数据包的个数。  
    检查是否有reordering，如果有reordering则：  
        纠正sacked_out  
        禁用FACK(画外音：这实际上是多此一举，没有使用SACK，哪来的FACK？)  
        更新tp-&gt;reordering  
</code></pre>

<pre><code>/* Emulate SACKs for SACKless connection: account for a new dupack.*/  
static void tcp_add_reno_sack(struct sock *sk)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    tp-&gt;sacked_out++; /* 增加sacked数据包个数*/  
    tcp_check_reno_reordering(sk, 0); /*检查是否有reordering*/  
    tcp_verify_left_out(tp);  
}  

/* If we receive more dupacks than we expected counting segments in  
 * assumption of absent reordering, interpret this as reordering. 
 * The only another reason could be bug in receiver TCP. 
 * tcp_limit_reno_sack()是判断是否有reordering的函数。 
 */  
static void tcp_check_reno_reordering(struct sock *sk, const int addend)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    if (tcp_limit_reno_sack(tp)) /* 检查sack是否过多*/  
        /* 如果是reordering则更新reordering信息*/  
        tcp_update_reordering(sk, tp-&gt;packets_out + addend, 0);  
}  

/* Limit sacked_out so that sum with lost_out isn't ever larger than packets_out. 
 * Returns zero if sacked_out adjustment wasn't necessary. 
 * 检查sacked_out是否过多，过多则限制，且返回1说明出现reordering了。 
 * Q: 怎么判断是否有reordering呢？ 
 * A: 我们知道dupack可能由lost引起，也有可能由reorder引起，那么如果 
 *    sacked_out + lost_out &gt; packets_out，则说明sacked_out偏大了，因为它错误的把由reorder 
 *    引起的dupack当客户端的sack了。 
 */  
static int tcp_limit_reno_sacked(struct tcp_sock *tp)  
{  
    u32 holes;  
    holes = max(tp-&gt;lost_out, 1U);  
    holes = min(holes, tp-&gt;packets_out);  
    if ((tp-&gt;sacked_out + holes) &gt; tp-&gt;packets_out) {  
        tp-&gt;sacked_out = tp-&gt;packets_out - holes;  
        return 1;  
    }  
    return 0;  
}
</code></pre>

<pre><code>
更新reordering信息
</code></pre>

<pre><code>static void tcp_update_reordering(struct sock *sk, const int metric,  
                                       const int ts)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  

    if (metric &gt; tp-&gt;reordering) {  
        int mib_idx;  
        /* 更新reordering的值，取其小者*/  
        tp-&gt;reordering = min(TCP_MAX_REORDERING, metric);  

        if (ts)  
            mib_idx = LINUX_MIB_TCPTSREORDER;  
        else if (tcp_is_reno(tp))  
            mib_idx = LINUX_MIB_TCPRENOREORDER;  
        else if (tcp_is_fack(tp))  
            mib_idx = LINUX_MIB_TCPFACKREORDER;  
        else   
            mib_idx = LINUX_MIB_TCPSACKREORDER;  

        NET_INC_STATS_BH(sock_net(sk), mib_idx);  
#if FASTRETRANS_DEBUG &gt; 1  
        printk(KERN_DEBUG "Disorder%d %d %u f%u s%u rr%d\n",  
                   tp-&gt;rx_opt.sack_ok, inet_csk(sk)-&gt;icsk_ca_state,  
                   tp-&gt;reordering, tp-&gt;fackets_out, tp-&gt;sacked_out,  
                   tp-&gt;undo_marker ? tp-&gt;undo_retrans : 0);  
#endif  
        tcp_disable_fack(tp); /* 出现了reorder，再用fack就太激进了*/  
    }  
}  
/* Packet counting of FACK is based on in-order assumptions, therefore 
 * TCP disables it when reordering is detected. 
 */  

static void tcp_disable_fack(struct tcp_sock *tp)  
{  
    /* RFC3517 uses different metric in lost marker =&gt; reset on change */  
    if (tcp_is_fack(tp))  
        tp-&gt;lost_skb_hint = NULL;  
    tp-&gt;rx_opt.sack_ok &amp;= ~2; /* 取消FACK选项*/  
}
</code></pre>

<pre><code>
##### （2）收到partical ack
do_lost = tcp_try_undo_partical(sk, pkts_acked);  
一般情况下do_lost都会为真，除非需要undo。  
具体可以看前面blog《TCP拥塞窗口调整撤销剖析》。


##### （3）跳出F state，标志丢失的数据段
执行完(1)或(2)后，就跳出F state。  
如果有丢失的数据包，或者发送队列的第一个数据包超时，则调用tcp_update_scoreboard()来更新记分牌，给丢失的段加TCPCB_LOST标志，增加lost_out。

检查发送队列的第一个数据包是否超时。
</code></pre>

<pre><code>/* 检验发送队列的第一个数据包是否超时*/  
static inline int tcp_head_timeout(const struct sock *sk)  
{  
    const struct tcp_sock *tp = tcp_sk(sk);  
    return tp-&gt;packets_out &amp;&amp;   
                tcp_skb_timeout(sk, tcp_write_queue_head(sk));  
}  

/* 检验发送队列的某个数据包是否超时*/  
static inline int tcp_skb_timeout(const struct sock *sk,  
                 const struct sk_buff *skb)  
{  
    return tcp_time_stamp - TCP_SKB_CB(skb)-&gt;when &gt; inet_csk(sk)-&gt;icsk_rto;  
}
</code></pre>

<pre><code>
为确定丢失的段更新记分牌，记分牌指的是tcp_skb_cb结构中的sacked，保存该数据包的状态信息。  
(1) 没有使用SACK，每次收到dupack或partical ack时，只能标志一个包为丢失。  

(2) 使用FACK，每次收到dupack或partical ack时，分两种情况：  
      如果lost = fackets_out - reordering &lt;= 0，这时虽然不能排除是由乱序引起的，但是fack的思想较为激进，所以也标志一个包为丢失。  
      如果lost &gt;0，就可以肯定有丢包，一次性可以标志lost个包为丢失。  

(3) 使用SACK，但是没有使用FACK。  
      如果sacked_upto = sacked_out - reordering，这是不能排除是由乱序引起的，除非快速重传标志fast_rexmit为真，才标志一个包为丢失。  
      如果sacked_upto &gt; 0，就可以肯定有丢包，一次性可以标志sacked_upto个包为丢失。  

内核默认使用的是(2)。
</code></pre>

<pre><code>/* Account newly detected lost packet(s) */  

 static void tcp_update_scoreboard (struct sock *sk, int fast_rexmit)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    if (tcp_is_reno(tp)) {  
        /* 只标志第一个数据包为丢失，reno一次性只标志一个包*/  
        tcp_mark_head_lost(sk, 1, 1);  

    } else if (tcp_is_fack(tp)) {  
        /* 还是考虑到乱序的，对于可能是由乱序引起的部分，一次标志一个包*/  
        int lost = tp-&gt;fackets_out - tp-&gt;reordering;  
        if (lost &lt;= 0)  
            lost = 1;  

        /* 因为使用了FACK，可以标志多个数据包丢失*/  
        tcp_mark_head_lost(sk, lost, 0);  

    } else {  
        int sacked_upto = tp-&gt;sacked_out - tp-&gt;reordering;  
        if (sacked_upto &gt;= 0)  
            tcp_mark_head_lost(sk, sacked_upto, 0);  

        else if (fast_rexmit)  
            tcp_mark_head_lost(sk, 1, 1);  
    }  

    /* 检查发送队列中的数据包是否超时，如果超时则标志为丢失*/  
    tcp_timeout_skbs(sk);  
}
</code></pre>

<pre><code>
检查发送队列中哪些数据包超时，并标志为丢失
</code></pre>

<pre><code>static void tcp_timeout_skbs(struct sock *sk)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    struct sk_buff *skb;  

    if (! tcp_is_fack(tp) || !tcp_head_timeout(sk))  
        return;  

    skb = tp-&gt;scoreboard_skb_hint;  

    if (tp-&gt;scoreboard_skb_hint == NULL)  
        skb = tcp_write_queue_head(sk));  

    tcp_for_write_queue_from(skb, sk) {  
        if (skb == tcp_send_head(sk)) /*遇到snd_nxt则停止*/  
            break;  

        if (!tcp_skb_timeout(sk, skb)) /* 数据包不超时则停止*/  
            break;  

        tcp_skb_mark_lost(tp, skb); /* 标志为LOST，并增加lost_out */  
    }  

    tp-&gt;scoreboard_skb_hint = skb;  
    tcp_verify_left_out(tp);  
}
</code></pre>

<pre><code>
##### （4）减小snd_cwnd
拥塞窗口每隔一个确认段减小一个段，即每收到2个确认将拥塞窗口减1，直到拥塞窗口等于慢启动阈值为止。
</code></pre>

<pre><code>/* Decrease cwnd each second ack. */  
static void tcp_cwnd_down (struct sock *sk, int flag)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    int decr = tp-&gt;snd_cwnd_cnt + 1;  

    if ((flag &amp; (FLAG_ANY_PROGRESS | FLAG_DSACKING_ACK )) ||  
        (tcp_is_reno(tp) &amp;&amp; ! (flag &amp; FLAG_NOT_DUP))) {  
        tp-&gt;snd_cwnd_cnt = decr &amp; 1; /* 0=&gt;1,1=&gt;0 */  

        decr &gt;&gt;= 1; /*与上个snd_cwnd_cnt相同，0或1*/  

        /* 减小cwnd */  
        if (decr &amp;&amp; tp-&gt;snd_cwnd &gt; tcp_cwnd_min(sk))  
            tp-&gt;snd_cwnd -= decr;  

        /* 注：不太理解这句的用意。*/  
        tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tcp_packets_in_flight(tp) +1);  
        tp-&gt;snd_cwnd_stamp = tcp_time_stamp;  
    }  
}  

/* Lower bound on congestion window is slow start threshold 
 * unless congestion avoidance choice decides to override it. 
 */  
static inline u32 tcp_cwnd_min(const struct sock *tp)  
{  
    const struct tcp_congestion_ops *ca_ops = inet_csk(sk)-&gt;icsk_ca_ops;  
    return ca_ops-&gt;min_cwnd ? ca_ops-&gt;min_cwnd(sk) : tcp_sk(sk)-&gt;snd_ssthresh;  
}
</code></pre>

<pre><code>
##### （5）重传标志为丢失的段
</code></pre>

<pre><code>/* This gets called after a retransmit timeout, and the initially retransmitted data is  
 * acknowledged. It tries to continue resending the rest of the retransmit queue, until  
 * either we've sent it all or the congestion window limit is reached. If doing SACK,  
 * the first ACK which comes back for a timeout based retransmit packet might feed us  
 * FACK information again. If so, we use it to avoid unnecessarily retransmissions. 
 */  

void tcp_xmit_retransmit_queue (struct sock *sk) {}
</code></pre>

<pre><code>
这个函数决定着发送哪些包，比较复杂，会在之后的blog单独分析。

##### （6）什么时候进入Recovery状态
tcp_time_to_recover()是一个重要函数，决定什么时候进入Recovery状态。
</code></pre>

<pre><code>/* This function decides, when we should leave Disordered state and enter Recovery 
 * phase, reducing congestion window. 
 * 决定什么时候离开Disorder状态，进入Recovery状态。 
 */  

static int tcp_time_to_recover(struct sock *sk)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    __u32 packets_out;  

    /* Do not perform any recovery during F-RTO algorithm 
     * 这说明Recovery状态不能打断Loss状态。 
     */  
    if (tp-&gt;frto_counter)  
        return 0;  

    /* Trick#1: The loss is proven.  
     * 如果传输过程中存在丢失段，则可以进入Recovery状态。 
     */  
    if (tp-&gt;lost_out)  
        return 1;  

    /* Not-A-Trick#2 : Classic rule... 
     * 如果收到重复的ACK大于乱序的阈值，表示有数据包丢失了， 
     * 可以进入到Recovery状态。 
     */  
    if (tcp_dupack_heuristics(tp) &gt; tp-&gt;reordering)  
        return 1;  

    /* Trick#3 : when we use RFC2988 timer restart, fast 
     * retransmit can be triggered by timeout of queue head. 
     * 如果发送队列的第一个数据包超时，则进入Recovery状态。 
     */  
      if (tcp_is_fack(tp) &amp;&amp; tcp_head_timeout(sk))  
         return 1;  

    /* Trick#4 : It is still not OK... But will it be useful to delay recovery more? 
     * 如果此时由于应用程序或接收窗口的限制而不能发包，且接收到很多的重复ACK。那么不能再等下去了， 
     * 推测发生了丢包，且马上进入Recovery状态。 
     */  
    if (packets_out &lt;= tp-&gt;reordering &amp;&amp;  
        tp-&gt;sacked_out &gt;= max_t(__u32, packets_out/2, sysctl_tcp_reordering)  
        &amp;&amp; ! tcp_may_send_now(sk)  ) {  
        /* We have nothing to send. This connection is limited 
         * either by receiver window or by application. 
         */  
        return 1;  
    }  

    /* If a thin stream is detected, retransmit after first received 
     * dupack. Employ only if SACK is supported in order to avoid  
     * possible corner-case series of spurious retransmissions 
     * Use only if there are no unsent data. 
     */  
    if ((tp-&gt;thin_dupack || sysctl_tcp_thin_dupack) &amp;&amp;  
         tcp_stream_is_thin(tp) &amp;&amp; tcp_dupack_heuristics(tp) &gt; 1 &amp;&amp;  
         tcp_is_sack(tp) &amp;&amp; ! tcp_send_head(sk))  
         return 1;  

    return 0; /*表示为假*/  
}
</code></pre>

<pre><code></code></pre>

<pre><code>/* Heurestics to calculate number of duplicate ACKs. There's no  
 * dupACKs counter when SACK is enabled (without SACK, sacked_out 
 * is used for that purpose). 
 * Instead, with FACK TCP uses fackets_out that includes both SACKed 
 * segments up to the highest received SACK block so far and holes in 
 * between them. 
 * 
 * With reordering, holes may still be in filght, so RFC3517 recovery uses 
 * pure sacked_out (total number of SACKed segment) even though it 
 * violates the RFC that uses duplicate ACKs, often these are equal but 
 * when e.g. out-of-window ACKs or packet duplication occurs, they differ. 
 * Since neither occurs due to loss, TCP shuld really ignore them. 
 */  
static inline int tcp_dupack_heuristics(const struct tcp_sock *tp)  
{  
    return tcp_is_fack(tp) ? tp-&gt;fackets_out : tp-&gt;sacked_out + 1;  
}  


/* Determines whether this is a thin stream (which may suffer from increased 
 * latency). Used to trigger latency-reducing mechanisms. 
 */  
static inline unsigned int tcp_stream_is_thin(struct tcp_sock *tp)  
{  
    return tp-&gt;packets_out &lt; 4 &amp;&amp; ! tcp_in_initial_slowstart(tp);  
}  

#define TCP_INFINITE_SSTHRESH 0x7fffffff  

static inline bool tcp_in_initial_slowstart(const struct tcp_sock *tp)  
{  
    return tp-&gt;snd_ssthresh &gt;= TCP_INFINITE_SSTHRESH;  
}
</code></pre>

<pre><code>
This function examines various parameters (like number of packet lost) for TCP connection to decide whether it is the right time to move to Recovery state. It's time to recover when TCP heuristics suggest a strong possibility of packet loss in the network, the following checks are made.

总的来说，一旦确定有丢包，或者很可能丢包，就可以进入Recovery状态恢复丢包了。

可以进入Recovery状态的条件包括：  
(1) some packets are lost (lost_out is non zero)。发现有丢包。  

(2) SACK is an acknowledgement for out of order packets. If number of packets Sacked is greater than the  
      reordering metrics of the network, then loss is assumed to have happened.  
      被fack数据或收到的重复ACK，大于乱序的阈值，表明很可能发生丢包。  

(3) If the first packet waiting to be acked (head of the write Queue) has waited for time equivalent to retransmission  
      timeout, the packet is assumed to have been lost. 发送队列的第一个数据段超时，表明它可能丢失了。  

(4) If the following three conditions are true, TCP sender is in a state where no more data can be transmitted  
      and number of packets acked is big enough to assume that rest of the packets are lost in the network:  
      A: If packets in flight is less than the reordering metrics.  
      B: More than half of the packets in flight have been sacked by the receiver or number of packets sacked is more  
           than the Fast Retransmit thresh. (Fast Retransmit thresh is the number of dupacks that sender awaits before  
           fast retransmission)  
      C: The sender can not send any more packets because either it is bound by the sliding window or the application  
           has not delivered any more data to it in anticipation of ACK for already provided data.  
      我们收到很多的重复ACK，那么很可能有数据段丢失了。如果此时由于接收窗口或应用程序的限制而不能发送数据，那么我们不打算再等下去，直接进入Recovery状态。  

(5) 当检测到当前流量很小时（packets_out &lt; 4），如果还满足以下条件：  
      A: tp-&gt;thin_dupack == 1 /* Fast retransmit on first dupack */  
           或者sysctl_tcp_thin_dupack为1，表明允许在收到第一个重复的包时就重传。  
      B: 启用SACK，且FACK或SACK的数据量大于1。  
      C: 没有未发送的数据，tcp_send_head(sk) == NULL。  
      这是一种特殊的情况，只有当流量非常小的时候才采用。  

（7）刚进入Recovery时的设置  
保存那些用于undo的数据：  
tp-&gt;prior_ssthresh = tp-&gt;snd_ssthresh; /* 保存旧阈值*/  
tp-&gt;undo_marker = tp-&gt;snd_una; /* tracking retrans started here.*/  
tp-&gt;undo_retrans = tp-&gt;retrans_out; /* Retransmitted packets out */  

保存退出点：  
tp-&gt;high_seq = tp-&gt;snd_nxt;

重置变量：  
tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);  
tp-&gt;bytes_acked = 0;  
tp-&gt;snd_cwnd_cnt = 0;  

进入Recovery状态：  
tcp_set_ca_state(sk, TCP_CA_Recovery);

#### Loss状态处理
state F

##### （1）收到partical ack
icsk-&gt;icsk_retransmits = 0; /* 超时重传的次数归零*/  
如果使用的是reno，没有使用sack，则归零tp-&gt;sacked_out。

##### （2）尝试undo
调用tcp_try_undo_loss()，当使用时间戳检测到一个不必要的重传时：  
    移除记分牌中所有段的Loss标志，从而发送新的数据而不再重传。  
    调用tcp_undo_cwr()来撤销拥塞窗口和阈值的调整。

否则：  
    tcp_moderate_cwnd()调整拥塞窗口，防止爆发式重传。  
    tcp_xmit_retransmit_queue()继续重传丢失的数据段。

#### 其它状态处理
state F

如果tcp_time_to_recover(sk)返回值为假，也就是说不能进入Recovery状态，则进行CWR、Disorder或Open状态的处理。
</code></pre>

<pre><code>static void tcp_try_to_open (struct sock *sk, int flag)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    tcp_verify_left_out(tp);  

    if (!tp-&gt;frto_conter &amp;&amp; !tcp_any_retrans_done(sk))  
        tp-&gt;retrans_stamp = 0; /* 归零，因为不需要undo了*/  

    /* 判断是否需要进入CWR状态*/  
    if (flag &amp; FLAG_ECE)  
        tcp_enter_cwr(sk, 1);  

    if (inet_csk(sk)-&gt;icsk_ca_state != TCP_CA_CWR) { /*没进入CWR*/  
        tcp_try_keep_open(sk); /* 尝试保持Open状态*/  
        tcp_moderate_cwnd(tp);  

    } else { /* 说明进入CWR状态*/  
        tcp_cwnd_down(sk, flag);/* 每2个ACK减小cwnd*/  
    }  
}  

static void tcp_try_keep_open(struct sock *sk)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    int state = TCP_CA_Open;  

    /* 是否需要进入Disorder状态*/  
    if (tcp_left_out(tp) || tcp_any_retrans_done(sk) || tp-&gt;undo_marker)  
        state = TCP_CA_Disorder;  

    if (inet_csk(sk)-&gt;icsk_ca_state != state) {  
        tcp_set_ca_state(sk, state);  
        tp-&gt;high_seq = tp-&gt;snd_nxt;  
    }  
}
</code></pre>

<pre><code>
##### （1）CWR状态
Q: 什么时候进入CWR状态？  
A: 如果检测到ACK包含ECE标志，表示接收方通知发送法进行显示拥塞控制。  
</code></pre>

<pre><code> @tcp_try_to_open():
 if (flag &amp; FLAG_ECE)
     tcp_enter_cwr(sk, 1);
</code></pre>

<p>```
tcp_enter_cwr()函数分析可见前面blog《TCP拥塞状态变迁》。<br/>
它主要做了：<br/>
    1. 重新设置慢启动阈值。<br/>
    2. 清除undo需要的标志，不允许undo。<br/>
    3. 记录此时的最高序号(high_seq = snd_nxt)，用于判断退出时机。<br/>
    4. 添加CWR标志，用于通知接收方它已经做出反应。<br/>
    5. 设置此时的状态为TCP_CA_CWR。</p>

<p>Q: 在CWR期间采取什么措施？<br/>
A: 拥塞窗口每隔一个确认段减小一个段，即每收到2个确认将拥塞窗口减1，直到拥塞窗口等于慢启动阈值为止。<br/>
     调用tcp_cwnd_down()。</p>

<h5>（2）Disorder状态</h5>

<p>Q: 什么时候进入Disorder状态？<br/>
A: 如果检测到有被sacked的数据包，或者有重传的数据包，则进入Disorder状态。<br/>
    当然，之前已经确认不能进入Loss或Recovery状态了。<br/>
    判断条件： sacked_out、lost_out、retrans_out、undo_marker不为0。</p>

<p>Q: 在Disorder期间采取什么措施？<br/>
A: 1. 设置CA状态为TCP_CA_Disorder。<br/>
   2. 记录此时的最高序号(high_seq = snd_nxt)，用于判断退出时机。<br/>
   3. 微调拥塞窗口，防止爆发式传输。</p>

<p>In Disorder state TCP is still unsure of genuiness of loss, after receiving acks with sack there may be a clearing ack which acks many packets non dubiously in one go. Such a clearing ack may cause a packet burst in the network, to avoid this cwnd size is reduced to allow no more than max_burst (usually 3) number of packets.</p>

<h5>（3）Open状态</h5>

<p>因为Open状态是正常的状态，是状态处理的最终目的，所以不需要进行额外处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP接收缓存大小的动态调整]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/03/23/kernel-net-rmem/"/>
    <updated>2015-03-23T13:53:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/03/23/kernel-net-rmem</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/8200048">http://blog.csdn.net/zhangskd/article/details/8200048</a></p>

<h4>引言</h4>

<p>TCP中有拥塞控制，也有流控制，它们各自有什么作用呢？</p>

<p>拥塞控制(Congestion Control) — A mechanism to prevent a TCP sender from overwhelming the network.<br/>
流控制(Flow Control) — A mechanism to prevent a TCP sender from overwhelming a TCP receiver.</p>

<p>下面是一段关于流控制原理的简要描述。<br/>
“The basic flow control algorithm works as follows: The receiver communicates to the sender the maximum amount of data it can accept using the rwnd protocol field. This is called the receive window. The TCP sender then sends no more than this amount of data across the network. The TCP sender then stops and waits for acknowledgements back from the receiver. When acknowledgement of the previously sent data is returned to the sender, the sender then resumes sending new data. It&rsquo;s essentially the old maxim hurry up and wait. ”</p>

<p>由于发送速度可能大于接收速度、接收端的应用程序未能及时从接收缓冲区读取数据、接收缓冲区不够大不能缓存所有接收到的报文等原因，TCP接收端的接收缓冲区很快就会被塞满，从而导致不能接收后续的数据，发送端此后发送数据是无效的，因此需要流控制。TCP流控制主要用于匹配发送端和接收端的速度，即根据接收端当前的接收能力来调整发送端的发送速度。</p>

<p>TCP流控制中一个很重要的地方就是，TCP接收缓存大小是如何动态调整的，即TCP确认窗口上限是如何动态调整的？</p>

<p>本文主要分析TCP接收缓存大小动态调整的原理和实现。</p>

<h4>原理</h4>

<p>早期的TCP实现中，TCP接收缓存的大小是固定的。随着网络的发展，固定的TCP接收缓存值就不适应了，成为TCP性能的瓶颈之一。这时候就需要手动去调整，因为不同的网络需要不同大小的TCP接收缓存，手动调整不仅费时费力，还会引起一些问题。TCP接收缓存设置小了，就不能充分利用网络。而TCP缓存设置大了，又浪费了内存。</p>

<p>如果把TCP接收缓存设置为无穷大，那就更糟糕了，因为某些应用可能会耗尽内存，使其它应用的连接陷入饥饿。所以TCP接收缓存的大小需要动态调整，才能达到最佳的效果。</p>

<p>动态调整TCP接收缓存大小，就是使TCP接收缓存按需分配，同时要确保TCP接收缓存大小不会成为传输的限制。</p>

<p>linux采用Dynamic Right-Sizing方法来动态调整TCP的接收缓存大小，其基本思想就是：通过估算发送方的拥塞窗口的大小，来动态设置TCP接收缓存的大小。</p>

<p>It has been demomstrated that this method can successfully grow the receiver&rsquo;s advertised window at a pace sufficient to avoid constraining the sender&rsquo;s throughput. As a result, systems can avoid the network performance problems that result from either the under-utilization or over-utilization of buffer space.</p>

<h4>实现</h4>

<p>下文代码基于3.2.12内核，主要源文件为：net/ipv4/tcp_input.c。
```
    struct tcp_sock {<br/>
        &hellip;<br/>
        u32 rcv_nxt; /<em> What we want to receive next，希望接收的下一个序列号 </em>/<br/>
        u32 rcv_wnd; /<em> Current receiver window，当前接收窗口的大小</em>/<br/>
        u32 copied_seq; /<em> Head of yet unread data，应用程序下次从这里复制数据 </em>/<br/>
        u16 advmss; /<em> Advertised MSS，接收端通告的MSS </em>/<br/>
        u32 window_clamp; /<em> Maximal window to advertise，通告窗口的上限</em>/</p>

<pre><code>    /* Receiver side RTT estimation */  
    struct {  
        u32 rtt;  
        u32 seq;  
        u32 time;  
    } rcv_rtt_est; /* 用于接收端的RTT测量*/  

    /* Receiver queue space */  
    struct {  
        int space;  
        u32 seq;  
        u32 time;  
    } rcvq_space; /* 用于调整接收缓冲区和接收窗口*/  

    /* Options received (usually on last packet, some only on SYN packets). */  
    struct tcp_options_received rx_opt; /* TCP选项*/  
    ...  
};  

struct sock {  
    ...  
    int sk_rcvbuf; /* TCP接收缓冲区的大小*/  
    int sk_sndbuf; /* TCP发送缓冲区大小*/  
    unsigned int ...  
        sk_userlocks : 4, /*TCP接收缓冲区的锁标志*/  
    ...  
};
</code></pre>

<pre><code>
#### RTT测量
在发送端有两种RTT的测量方法(具体可见前面blog)，但是因为TCP流控制是在接收端进行的，所以接收端也需要有测量RTT的方法。

#####（1）没有时间戳时的测量方法
</code></pre>

<pre><code>static inline void tcp_rcv_rtt_measure(struct tcp_sock *tp)  
{  
    /* 第一次接收到数据时，需要对相关变量初始化*/  
    if (tp-&gt;rcv_rtt_est.time == 0)  
        goto new_measure;  

    /* 收到指定的序列号后，才能获取一个RTT测量样本*/  
    if (before(tp-&gt;rcv_nxt, tp-&gt;rcv_rtt_est.seq))  
        return;  

    /* RTT的样本：jiffies - tp-&gt;rcv_rtt_est.time */  
    tcp_rcv_rtt_update(tp, jiffies - tp-&gt;rcv_rtt_est.time, 1);  

new_measure:  
    tp-&gt;rcv_rtt_est.seq = tp-&gt;rcv_nxt + tp-&gt;rcv_wnd; /* 收到此序列号的ack时，一个RTT样本的计时结束*/  
    tp-&gt;rcv_rtt_est.time = tcp_time_stamp; /* 一个RTT样本开始计时*/  
}
</code></pre>

<pre><code>
此函数在接收到带有负载的数据段时被调用。

此函数的原理：我们知道发送端不可能在一个RTT期间发送大于一个通告窗口的数据量。那么接收端可以把接收一个确认窗口的数据量(rcv_wnd)所用的时间作为RTT。接收端收到一个数据段，然后发送确认(确认号为rcv_nxt，通告窗口为rcv_wnd)，开始计时，RTT就是收到序号为rcv_nxt + rcv_wnd的数据段所用的时间。很显然，这种假设并不准确，测量所得的RTT会偏大一些。所以这种方法只有当没有采用时间戳选项时才使用，而内核默认是采用时间戳选项的(tcp_timestamps为1)。

下面是一段对此方法的评价：  
If the sender is being throttled by the network, this estimate will be valid. However, if the sending application did not have any data to send, the measured time could be much larger than the actual round-trip time. Thus this measurement acts only as an upper-bound on the round-trip time.

#####（2）采用时间戳选项时的测量方法
</code></pre>

<pre><code>static inline void tcp_rcv_rtt_measure_ts(struct sock *sk, const struct sk_buff *skb)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    /* 启用了Timestamps选项，并且流量稳定*/  
    if (tp-&gt;rx_opt.rcv_tsecr &amp;&amp; (TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq &gt;=  
        inet_csk(sk)-&gt;icsk_ack.rcv_mss))  
        /* RTT = 当前时间 - 回显时间*/  
        tcp_rcv_rtt_update(tp, tcp_time_stamp - tp-&gt;rx_opt.rcv_tsecr, 0);  
}
</code></pre>

<pre><code>
虽然此种方法是默认方法，但是在流量小的时候，通过时间戳采样得到的RTT的值会偏大，此时就会采用没有时间戳时的RTT测量方法。

#####（3）采样处理
不管是没有使用时间戳选项的RTT采样，还是使用时间戳选项的RTT采样，都是获得一个RTT样本。之后还需要对获得的RTT样本进行处理，以得到最终的RTT。
</code></pre>

<pre><code>/* win_dep表示是否对RTT采样进行微调，1为不进行微调，0为进行微调。*/  
static void tcp_rcv_rtt_update(struct tcp_sock *tp, u32 sample, int win_dep)  
{  
    u32 new_sample = tp-&gt;rcv_rtt_est.rtt;  
    long m = sample;  

    if (m == 0)  
        m = 1; /* 时延最小为1ms*/  

    if (new_sample != 0) { /* 不是第一次获得样本*/  
        /* If we sample in larger samples in the non-timestamp case, we could grossly 
         * overestimate the RTT especially with chatty applications or bulk transfer apps 
         * which are stalled on filesystem I/O. 
         * 
         * Also, since we are only going for a minimum in the non-timestamp case, we do 
         * not smooth things out else with timestamps disabled convergence takes too long. 
         */  
        /* 对RTT采样进行微调，新的RTT样本只占最终RTT的1/8 */  
        if (! win_dep) {   
            m -= (new_sample &gt;&gt; 3);  
            new_sample += m;  

        } else if (m &lt; new_sample)  
            /* 不对RTT采样进行微调，直接取最小值，原因可见上面那段注释*/  
            new_sample = m &lt;&lt; 3;   

    } else {   
        /* No previous measure. 第一次获得样本*/  
        new_sample = m &lt;&lt; 3;  
    }  

    if (tp-&gt;rcv_rtt_est.rtt != new_sample)  
        tp-&gt;rcv_rtt_est.rtt = new_sample; /* 更新RTT*/  
}
</code></pre>

<pre><code>
对于没有使用时间戳选项的RTT测量方法，不进行微调。因为用此种方法获得的RTT采样值已经偏高而且收敛很慢。直接选择最小RTT样本作为最终的RTT测量值。  
对于使用时间戳选项的RTT测量方法，进行微调，新样本占最终RTT的1/8，即rtt = 7/8 old + 1/8 new。

#### 调整接收缓存
当数据从TCP接收缓存复制到用户空间之后，会调用tcp_rcv_space_adjust()来调整TCP接收缓存和接收窗口上限的大小。
</code></pre>

<pre><code>/*  
 * This function should be called every time data is copied to user space. 
 * It calculates the appropriate TCP receive buffer space. 
 */  
void tcp_rcv_space_adjust(struct sock *sk)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    int time;  
    int space;  

    /* 第一次调整*/  
    if (tp-&gt;rcvq_space.time == 0)  
        goto new_measure;  

    time = tcp_time_stamp - tp-&gt;rcvq_space.time; /*计算上次调整到现在的时间*/  

    /* 调整至少每隔一个RTT才进行一次，RTT的作用在这里！*/  
    if (time &lt; (tp-&gt;rcv_rtt_est.rtt &gt;&gt; 3) || tp-&gt;rcv_rtt_est.rtt == 0)  
        return;  

    /* 一个RTT内接收方应用程序接收并复制到用户空间的数据量的2倍*/  
    space = 2 * (tp-&gt;copied_seq - tp-&gt;rcvq_space.seq);  
    space = max(tp-&gt;rcvq_space.space, space);  

    /* 如果这次的space比上次的大*/  
    if (tp-&gt;rcvq_space.space != space) {  
        int rcvmem;  
        tp-&gt;rcvq_space.space = space; /*更新rcvq_space.space*/  

        /* 启用自动调节接收缓冲区大小，并且接收缓冲区没有上锁*/  
        if (sysctl_tcp_moderate_rcvbuf &amp;&amp; ! (sk-&gt;sk_userlocks &amp; SOCK_RCVBUF_LOCK)) {  
            int new_clamp = space;  
            /* Receive space grows, normalize in order to take into account packet headers and 
             * sk_buff structure overhead. 
             */  
             space /= tp-&gt;advmss; /* 接收缓冲区可以缓存数据包的个数*/  

             if (!space)  
                space = 1;  

            /* 一个数据包耗费的总内存包括： 
               * 应用层数据：tp-&gt;advmss， 
               * 协议头：MAX_TCP_HEADER， 
               * sk_buff结构， 
               * skb_shared_info结构。 
               */  
             rcvmem = SKB_TRUESIZE(tp-&gt;advmss + MAX_TCP_HEADER);  

             /* 对rcvmem进行微调*/  
             while(tcp_win_from_space(rcvmem) &lt; tp-&gt;advmss)  
                 rcvmem += 128;  

             space *= rcvmem;  
             space = min(space, sysctl_tcp_rmem[2]); /*不能超过允许的最大接收缓冲区大小*/  

             if (space &gt; sk-&gt;sk_rcvbuf) {  
                 sk-&gt;sk_rcvbuf = space; /* 调整接收缓冲区的大小*/  
                 /* Make the window clamp follow along. */  
                 tp-&gt;window_clamp = new_clamp; /*调整接收窗口的上限*/  
             }  
        }  
    }  

new_measure:  
     /*此序号之前的数据已复制到用户空间，下次复制将从这里开始*/  
    tp-&gt;rcvq_space.seq = tp-&gt;copied_seq;  
    tp-&gt;rcvq_space.time = tcp_time_stamp; /*记录这次调整的时间*/  
}  


/* return minimum truesize of the skb containing X bytes of data */  
#define SKB_TRUESIZE(X) ((X) +              \  
                            SKB_DATA_ALIGN(sizeof(struct sk_buff)) +        \  
                            SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))  


static inline int tcp_win_from_space(int space)  
{  
    return sysctl_tcp_adv_win_scale &lt;= 0 ?  
              (space &gt;&gt; (-sysctl_tcp_adv_win_scale)) :  
               space - (space &gt;&gt; sysctl_tcp_adv_win_scale);  
}
</code></pre>

<p>```</p>

<p>tp->rcvq_space.space表示当前接收缓存的大小（只包括应用层数据，单位为字节）。<br/>
sk->sk_rcvbuf表示当前接收缓存的大小（包括应用层数据、TCP协议头、sk_buff和skb_shared_info结构，tcp_adv_win_scale微调，单位为字节）。</p>

<h4>系统参数</h4>

<h5>(1) tcp_moderate_rcvbuf</h5>

<p>是否自动调节TCP接收缓冲区的大小，默认值为1。</p>

<h5>(2) tcp_adv_win_scale</h5>

<p>在tcp_moderate_rcvbuf启用的情况下，用来对计算接收缓冲区和接收窗口的参数进行微调，默认值为2。<br/>
This means that the application buffer is &frac14;th of the total buffer space specified in the tcp_rmem variable.</p>

<h5>(3) tcp_rmem</h5>

<p>包括三个参数：min default max。<br/>
tcp_rmem[1] — default ：接收缓冲区长度的初始值，用来初始化sock的sk_rcvbuf，默认为87380字节。<br/>
tcp_rmem[2] — max：接收缓冲区长度的最大值，用来调整sock的sk_rcvbuf，默认为4194304，一般是2000多个数据包。</p>

<h5>小结</h5>

<p>接收端的接收窗口上限和接收缓冲区大小，是接收方应用程序在上个RTT内接收并复制到用户空间的数据量的2倍，并且接收窗口上限和接收缓冲区大小是递增的。</p>

<h6>（1）为什么是2倍呢？</h6>

<p>In order to keep pace with the growth of the sender&rsquo;s congestion window during slow-start, the receiver should use the same doubling factor. Thus the receiver should advertise a window that is twice the size of the last measured window size.</p>

<p>这样就能保证接收窗口上限的增长速度不小于拥塞窗口的增长速度，避免接收窗口成为传输瓶颈。</p>

<h6>（2）收到乱序包时有什么影响？</h6>

<p>Packets that are received out of order may have lowered the goodput during this measurement, but will increase the goodput of the following measurement which, if larger, will supercede this measurement.</p>

<p>乱序包会使本次的吞吐量测量值偏小，使下次的吞吐量测量值偏大。</p>

<h4>Reference</h4>

<p>[1] Mike Fisk, Wu-chun Feng, &ldquo;Dynamic Right-Sizing in TCP&rdquo;.</p>
]]></content>
  </entry>
  
</feed>
