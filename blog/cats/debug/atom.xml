<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-10-31T23:58:56+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ack loop]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/09/30/debug-loop_ack/"/>
    <updated>2015-09-30T15:32:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/09/30/debug-loop_ack</id>
    <content type="html"><![CDATA[<h4>patch</h4>

<pre><code>    commit 4fb17a6091674f469e8ac85dc770fbf9a9ba7cc8
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:41 2015 -0500

        tcp: mitigate ACK loops for connections as tcp_timewait_sock

        Ensure that in state FIN_WAIT2 or TIME_WAIT, where the connection is
        represented by a tcp_timewait_sock, we rate limit dupacks in response
        to incoming packets (a) with TCP timestamps that fail PAWS checks, or
        (b) with sequence numbers that are out of the acceptable window.

        We do not send a dupack in response to out-of-window packets if it has
        been less than sysctl_tcp_invalid_ratelimit (default 500ms) since we
        last sent a dupack in response to an out-of-window packet.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/include/linux/tcp.h b/include/linux/tcp.h
    index 66d85a8..1a7adb4 100644
    --- a/include/linux/tcp.h
    +++ b/include/linux/tcp.h
    @@ -342,6 +342,10 @@ struct tcp_timewait_sock {
        u32           tw_rcv_wnd;
        u32           tw_ts_offset;
        u32           tw_ts_recent;
    +
    +   /* The time we sent the last out-of-window ACK: */
    +   u32           tw_last_oow_ack_time;
    +
        long              tw_ts_recent_stamp;
     #ifdef CONFIG_TCP_MD5SIG
        struct tcp_md5sig_key     *tw_md5_key;
    diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
    index 98a8405..dd11ac7 100644
    --- a/net/ipv4/tcp_minisocks.c
    +++ b/net/ipv4/tcp_minisocks.c
    @@ -58,6 +58,25 @@ static bool tcp_in_window(u32 seq, u32 end_seq, u32 s_win, u32 e_win)
        return seq == e_win &amp;&amp; seq == end_seq;
     }

    +static enum tcp_tw_status
    +tcp_timewait_check_oow_rate_limit(struct inet_timewait_sock *tw,
    +                 const struct sk_buff *skb, int mib_idx)
    +{
    +   struct tcp_timewait_sock *tcptw = tcp_twsk((struct sock *)tw);
    +
    +   if (!tcp_oow_rate_limited(twsk_net(tw), skb, mib_idx,
    +                 &amp;tcptw-&gt;tw_last_oow_ack_time)) {
    +       /* Send ACK. Note, we do not put the bucket,
    +        * it will be released by caller.
    +        */
    +       return TCP_TW_ACK;
    +   }
    +
    +   /* We are rate-limiting, so just release the tw sock and drop skb. */
    +   inet_twsk_put(tw);
    +   return TCP_TW_SUCCESS;
    +}
    +
     /*
      * * Main purpose of TIME-WAIT state is to close connection gracefully,
      *   when one of ends sits in LAST-ACK or CLOSING retransmitting FIN
    @@ -116,7 +135,8 @@ tcp_timewait_state_process(struct inet_timewait_sock *tw, struct sk_buff *skb,
                !tcp_in_window(TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq,
                       tcptw-&gt;tw_rcv_nxt,
                       tcptw-&gt;tw_rcv_nxt + tcptw-&gt;tw_rcv_wnd))
    -           return TCP_TW_ACK;
    +           return tcp_timewait_check_oow_rate_limit(
    +               tw, skb, LINUX_MIB_TCPACKSKIPPEDFINWAIT2);

            if (th-&gt;rst)
                goto kill;
    @@ -250,10 +270,8 @@ kill:
                inet_twsk_schedule(tw, &amp;tcp_death_row, TCP_TIMEWAIT_LEN,
                           TCP_TIMEWAIT_LEN);

    -       /* Send ACK. Note, we do not put the bucket,
    -        * it will be released by caller.
    -        */
    -       return TCP_TW_ACK;
    +       return tcp_timewait_check_oow_rate_limit(
    +           tw, skb, LINUX_MIB_TCPACKSKIPPEDTIMEWAIT);
        }
        inet_twsk_put(tw);
        return TCP_TW_SUCCESS;
    @@ -289,6 +307,7 @@ void tcp_time_wait(struct sock *sk, int state, int timeo)
            tcptw-&gt;tw_ts_recent = tp-&gt;rx_opt.ts_recent;
            tcptw-&gt;tw_ts_recent_stamp = tp-&gt;rx_opt.ts_recent_stamp;
            tcptw-&gt;tw_ts_offset = tp-&gt;tsoffset;
    +       tcptw-&gt;tw_last_oow_ack_time = 0;

     #if IS_ENABLED(CONFIG_IPV6)
            if (tw-&gt;tw_family == PF_INET6) {

    commit f2b2c582e82429270d5818fbabe653f4359d7024
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:40 2015 -0500

        tcp: mitigate ACK loops for connections as tcp_sock

        Ensure that in state ESTABLISHED, where the connection is represented
        by a tcp_sock, we rate limit dupacks in response to incoming packets
        (a) with TCP timestamps that fail PAWS checks, or (b) with sequence
        numbers or ACK numbers that are out of the acceptable window.

        We do not send a dupack in response to out-of-window packets if it has
        been less than sysctl_tcp_invalid_ratelimit (default 500ms) since we
        last sent a dupack in response to an out-of-window packet.

        There is already a similar (although global) rate-limiting mechanism
        for "challenge ACKs". When deciding whether to send a challence ACK,
        we first consult the new per-connection rate limit, and then the
        global rate limit.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/include/linux/tcp.h b/include/linux/tcp.h
    index bcc828d..66d85a8 100644
    --- a/include/linux/tcp.h
    +++ b/include/linux/tcp.h
    @@ -153,6 +153,7 @@ struct tcp_sock {
        u32 snd_sml;    /* Last byte of the most recently transmitted small packet */
        u32 rcv_tstamp; /* timestamp of last received ACK (for keepalives) */
        u32 lsndtime;   /* timestamp of last sent data packet (for restart window) */
    +   u32 last_oow_ack_time;  /* timestamp of last out-of-window ACK */

        u32 tsoffset;   /* timestamp offset */

    diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
    index 9401aa43..8fdd27b 100644
    --- a/net/ipv4/tcp_input.c
    +++ b/net/ipv4/tcp_input.c
    @@ -3322,13 +3322,22 @@ static int tcp_ack_update_window(struct sock *sk, const struct sk_buff *skb, u32
     }

     /* RFC 5961 7 [ACK Throttling] */
    -static void tcp_send_challenge_ack(struct sock *sk)
    +static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)
     {
        /* unprotected vars, we dont care of overwrites */
        static u32 challenge_timestamp;
        static unsigned int challenge_count;
    -   u32 now = jiffies / HZ;
    +   struct tcp_sock *tp = tcp_sk(sk);
    +   u32 now;
    +
    +   /* First check our per-socket dupack rate limit. */
    +   if (tcp_oow_rate_limited(sock_net(sk), skb,
    +                LINUX_MIB_TCPACKSKIPPEDCHALLENGE,
    +                &amp;tp-&gt;last_oow_ack_time))
    +       return;

    +   /* Then check the check host-wide RFC 5961 rate limit. */
    +   now = jiffies / HZ;
        if (now != challenge_timestamp) {
            challenge_timestamp = now;
            challenge_count = 0;
    @@ -3424,7 +3433,7 @@ static int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)
        if (before(ack, prior_snd_una)) {
            /* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */
            if (before(ack, prior_snd_una - tp-&gt;max_window)) {
    -           tcp_send_challenge_ack(sk);
    +           tcp_send_challenge_ack(sk, skb);
                return -1;
            }
            goto old_ack;
    @@ -4993,7 +5002,10 @@ static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
            tcp_paws_discard(sk, skb)) {
            if (!th-&gt;rst) {
                NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);
    -           tcp_send_dupack(sk, skb);
    +           if (!tcp_oow_rate_limited(sock_net(sk), skb,
    +                         LINUX_MIB_TCPACKSKIPPEDPAWS,
    +                         &amp;tp-&gt;last_oow_ack_time))
    +               tcp_send_dupack(sk, skb);
                goto discard;
            }
            /* Reset is accepted even if it did not pass PAWS. */
    @@ -5010,7 +5022,10 @@ static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
            if (!th-&gt;rst) {
                if (th-&gt;syn)
                    goto syn_challenge;
    -           tcp_send_dupack(sk, skb);
    +           if (!tcp_oow_rate_limited(sock_net(sk), skb,
    +                         LINUX_MIB_TCPACKSKIPPEDSEQ,
    +                         &amp;tp-&gt;last_oow_ack_time))
    +               tcp_send_dupack(sk, skb);
            }
            goto discard;
        }
    @@ -5026,7 +5041,7 @@ static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
            if (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt)
                tcp_reset(sk);
            else
    -           tcp_send_challenge_ack(sk);
    +           tcp_send_challenge_ack(sk, skb);
            goto discard;
        }

    @@ -5040,7 +5055,7 @@ syn_challenge:
            if (syn_inerr)
                TCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);
            NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSYNCHALLENGE);
    -       tcp_send_challenge_ack(sk);
    +       tcp_send_challenge_ack(sk, skb);
            goto discard;
        }

    diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
    index 131aa49..98a8405 100644
    --- a/net/ipv4/tcp_minisocks.c
    +++ b/net/ipv4/tcp_minisocks.c
    @@ -467,6 +467,7 @@ struct sock *tcp_create_openreq_child(struct sock *sk, struct request_sock *req,
            tcp_enable_early_retrans(newtp);
            newtp-&gt;tlp_high_seq = 0;
            newtp-&gt;lsndtime = treq-&gt;snt_synack;
    +       newtp-&gt;last_oow_ack_time = 0;
            newtp-&gt;total_retrans = req-&gt;num_retrans;

            /* So many TCP implementations out there (incorrectly) count the

    commit a9b2c06dbef48ed31cff1764c5ce824829106f4f
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:39 2015 -0500

        tcp: mitigate ACK loops for connections as tcp_request_sock

        In the SYN_RECV state, where the TCP connection is represented by
        tcp_request_sock, we now rate-limit SYNACKs in response to a client's
        retransmitted SYNs: we do not send a SYNACK in response to client SYN
        if it has been less than sysctl_tcp_invalid_ratelimit (default 500ms)
        since we last sent a SYNACK in response to a client's retransmitted
        SYN.

        This allows the vast majority of legitimate client connections to
        proceed unimpeded, even for the most aggressive platforms, iOS and
        MacOS, which actually retransmit SYNs 1-second intervals for several
        times in a row. They use SYN RTO timeouts following the progression:
        1,1,1,1,1,2,4,8,16,32.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/include/linux/tcp.h b/include/linux/tcp.h
    index 67309ec..bcc828d 100644
    --- a/include/linux/tcp.h
    +++ b/include/linux/tcp.h
    @@ -115,6 +115,7 @@ struct tcp_request_sock {
        u32             rcv_isn;
        u32             snt_isn;
        u32             snt_synack; /* synack sent time */
    +   u32             last_oow_ack_time; /* last SYNACK */
        u32             rcv_nxt; /* the ack # by SYNACK. For
                              * FastOpen it's the seq#
                              * after data-in-SYN.
    diff --git a/include/net/tcp.h b/include/net/tcp.h
    index b81f45c..da4196fb 100644
    --- a/include/net/tcp.h
    +++ b/include/net/tcp.h
    @@ -1145,6 +1145,7 @@ static inline void tcp_openreq_init(struct request_sock *req,
        tcp_rsk(req)-&gt;rcv_isn = TCP_SKB_CB(skb)-&gt;seq;
        tcp_rsk(req)-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
        tcp_rsk(req)-&gt;snt_synack = tcp_time_stamp;
    +   tcp_rsk(req)-&gt;last_oow_ack_time = 0;
        req-&gt;mss = rx_opt-&gt;mss_clamp;
        req-&gt;ts_recent = rx_opt-&gt;saw_tstamp ? rx_opt-&gt;rcv_tsval : 0;
        ireq-&gt;tstamp_ok = rx_opt-&gt;tstamp_ok;
    diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
    index bc9216d..131aa49 100644
    --- a/net/ipv4/tcp_minisocks.c
    +++ b/net/ipv4/tcp_minisocks.c
    @@ -605,7 +605,11 @@ struct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,
             * Reset timer after retransmitting SYNACK, similar to
             * the idea of fast retransmit in recovery.
             */
    -       if (!inet_rtx_syn_ack(sk, req))
    +       if (!tcp_oow_rate_limited(sock_net(sk), skb,
    +                     LINUX_MIB_TCPACKSKIPPEDSYNRECV,
    +                     &amp;tcp_rsk(req)-&gt;last_oow_ack_time) &amp;&amp;
    +
    +           !inet_rtx_syn_ack(sk, req))
                req-&gt;expires = min(TCP_TIMEOUT_INIT &lt;&lt; req-&gt;num_timeout,
                           TCP_RTO_MAX) + jiffies;
            return NULL;

    commit 032ee4236954eb214651cb9bfc1b38ffa8fd7a01
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:38 2015 -0500

        tcp: helpers to mitigate ACK loops by rate-limiting out-of-window dupacks

        Helpers for mitigating ACK loops by rate-limiting dupacks sent in
        response to incoming out-of-window packets.

        This patch includes:

        - rate-limiting logic
        - sysctl to control how often we allow dupacks to out-of-window packets
        - SNMP counter for cases where we rate-limited our dupack sending

        The rate-limiting logic in this patch decides to not send dupacks in
        response to out-of-window segments if (a) they are SYNs or pure ACKs
        and (b) the remote endpoint is sending them faster than the configured
        rate limit.

        We rate-limit our responses rather than blocking them entirely or
        resetting the connection, because legitimate connections can rely on
        dupacks in response to some out-of-window segments. For example, zero
        window probes are typically sent with a sequence number that is below
        the current window, and ZWPs thus expect to thus elicit a dupack in
        response.

        We allow dupacks in response to TCP segments with data, because these
        may be spurious retransmissions for which the remote endpoint wants to
        receive DSACKs. This is safe because segments with data can't
        realistically be part of ACK loops, which by their nature consist of
        each side sending pure/data-less ACKs to each other.

        The dupack interval is controlled by a new sysctl knob,
        tcp_invalid_ratelimit, given in milliseconds, in case an administrator
        needs to dial this upward in the face of a high-rate DoS attack. The
        name and units are chosen to be analogous to the existing analogous
        knob for ICMP, icmp_ratelimit.

        The default value for tcp_invalid_ratelimit is 500ms, which allows at
        most one such dupack per 500ms. This is chosen to be 2x faster than
        the 1-second minimum RTO interval allowed by RFC 6298 (section 2, rule
        2.4). We allow the extra 2x factor because network delay variations
        can cause packets sent at 1 second intervals to be compressed and
        arrive much closer.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/Documentation/networking/ip-sysctl.txt b/Documentation/networking/ip-sysctl.txt
    index a5e4c81..1b8c964 100644
    --- a/Documentation/networking/ip-sysctl.txt
    +++ b/Documentation/networking/ip-sysctl.txt
    @@ -290,6 +290,28 @@ tcp_frto - INTEGER

        By default it's enabled with a non-zero value. 0 disables F-RTO.

    +tcp_invalid_ratelimit - INTEGER
    +   Limit the maximal rate for sending duplicate acknowledgments
    +   in response to incoming TCP packets that are for an existing
    +   connection but that are invalid due to any of these reasons:
    +
    +     (a) out-of-window sequence number,
    +     (b) out-of-window acknowledgment number, or
    +     (c) PAWS (Protection Against Wrapped Sequence numbers) check failure
    +
    +   This can help mitigate simple "ack loop" DoS attacks, wherein
    +   a buggy or malicious middlebox or man-in-the-middle can
    +   rewrite TCP header fields in manner that causes each endpoint
    +   to think that the other is sending invalid TCP segments, thus
    +   causing each side to send an unterminating stream of duplicate
    +   acknowledgments for invalid segments.
    +
    +   Using 0 disables rate-limiting of dupacks in response to
    +   invalid segments; otherwise this value specifies the minimal
    +   space between sending such dupacks, in milliseconds.
    +
    +   Default: 500 (milliseconds).
    +
     tcp_keepalive_time - INTEGER
        How often TCP sends out keepalive messages when keepalive is enabled.
        Default: 2hours.
    diff --git a/include/net/tcp.h b/include/net/tcp.h
    index 28e9bd3..b81f45c 100644
    --- a/include/net/tcp.h
    +++ b/include/net/tcp.h
    @@ -274,6 +274,7 @@ extern int sysctl_tcp_challenge_ack_limit;
     extern unsigned int sysctl_tcp_notsent_lowat;
     extern int sysctl_tcp_min_tso_segs;
     extern int sysctl_tcp_autocorking;
    +extern int sysctl_tcp_invalid_ratelimit;

     extern atomic_long_t tcp_memory_allocated;
     extern struct percpu_counter tcp_sockets_allocated;
    @@ -1236,6 +1237,37 @@ static inline bool tcp_paws_reject(const struct tcp_options_received *rx_opt,
        return true;
     }

    +/* Return true if we're currently rate-limiting out-of-window ACKs and
    + * thus shouldn't send a dupack right now. We rate-limit dupacks in
    + * response to out-of-window SYNs or ACKs to mitigate ACK loops or DoS
    + * attacks that send repeated SYNs or ACKs for the same connection. To
    + * do this, we do not send a duplicate SYNACK or ACK if the remote
    + * endpoint is sending out-of-window SYNs or pure ACKs at a high rate.
    + */
    +static inline bool tcp_oow_rate_limited(struct net *net,
    +                   const struct sk_buff *skb,
    +                   int mib_idx, u32 *last_oow_ack_time)
    +{
    +   /* Data packets without SYNs are not likely part of an ACK loop. */
    +   if ((TCP_SKB_CB(skb)-&gt;seq != TCP_SKB_CB(skb)-&gt;end_seq) &amp;&amp;
    +       !tcp_hdr(skb)-&gt;syn)
    +       goto not_rate_limited;
    +
    +   if (*last_oow_ack_time) {
    +       s32 elapsed = (s32)(tcp_time_stamp - *last_oow_ack_time);
    +
    +       if (0 &lt;= elapsed &amp;&amp; elapsed &lt; sysctl_tcp_invalid_ratelimit) {
    +           NET_INC_STATS_BH(net, mib_idx);
    +           return true;    /* rate-limited: don't send yet! */
    +       }
    +   }
    +
    +   *last_oow_ack_time = tcp_time_stamp;
    +
    +not_rate_limited:
    +   return false;   /* not rate-limited: go ahead, send dupack now! */
    +}
    +
     static inline void tcp_mib_init(struct net *net)
     {
        /* See RFC 2012 */
    diff --git a/include/uapi/linux/snmp.h b/include/uapi/linux/snmp.h
    index b222241..6a6fb74 100644
    --- a/include/uapi/linux/snmp.h
    +++ b/include/uapi/linux/snmp.h
    @@ -270,6 +270,12 @@ enum
        LINUX_MIB_TCPHYSTARTTRAINCWND,      /* TCPHystartTrainCwnd */
        LINUX_MIB_TCPHYSTARTDELAYDETECT,    /* TCPHystartDelayDetect */
        LINUX_MIB_TCPHYSTARTDELAYCWND,      /* TCPHystartDelayCwnd */
    +   LINUX_MIB_TCPACKSKIPPEDSYNRECV,     /* TCPACKSkippedSynRecv */
    +   LINUX_MIB_TCPACKSKIPPEDPAWS,        /* TCPACKSkippedPAWS */
    +   LINUX_MIB_TCPACKSKIPPEDSEQ,     /* TCPACKSkippedSeq */
    +   LINUX_MIB_TCPACKSKIPPEDFINWAIT2,    /* TCPACKSkippedFinWait2 */
    +   LINUX_MIB_TCPACKSKIPPEDTIMEWAIT,    /* TCPACKSkippedTimeWait */
    +   LINUX_MIB_TCPACKSKIPPEDCHALLENGE,   /* TCPACKSkippedChallenge */
        __LINUX_MIB_MAX
     };

    diff --git a/net/ipv4/proc.c b/net/ipv4/proc.c
    index 8f9cd20..d8953ef 100644
    --- a/net/ipv4/proc.c
    +++ b/net/ipv4/proc.c
    @@ -292,6 +292,12 @@ static const struct snmp_mib snmp4_net_list[] = {
        SNMP_MIB_ITEM("TCPHystartTrainCwnd", LINUX_MIB_TCPHYSTARTTRAINCWND),
        SNMP_MIB_ITEM("TCPHystartDelayDetect", LINUX_MIB_TCPHYSTARTDELAYDETECT),
        SNMP_MIB_ITEM("TCPHystartDelayCwnd", LINUX_MIB_TCPHYSTARTDELAYCWND),
    +   SNMP_MIB_ITEM("TCPACKSkippedSynRecv", LINUX_MIB_TCPACKSKIPPEDSYNRECV),
    +   SNMP_MIB_ITEM("TCPACKSkippedPAWS", LINUX_MIB_TCPACKSKIPPEDPAWS),
    +   SNMP_MIB_ITEM("TCPACKSkippedSeq", LINUX_MIB_TCPACKSKIPPEDSEQ),
    +   SNMP_MIB_ITEM("TCPACKSkippedFinWait2", LINUX_MIB_TCPACKSKIPPEDFINWAIT2),
    +   SNMP_MIB_ITEM("TCPACKSkippedTimeWait", LINUX_MIB_TCPACKSKIPPEDTIMEWAIT),
    +   SNMP_MIB_ITEM("TCPACKSkippedChallenge", LINUX_MIB_TCPACKSKIPPEDCHALLENGE),
        SNMP_MIB_SENTINEL
     };

    diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
    index e0ee384..82601a6 100644
    --- a/net/ipv4/sysctl_net_ipv4.c
    +++ b/net/ipv4/sysctl_net_ipv4.c
    @@ -729,6 +729,13 @@ static struct ctl_table ipv4_table[] = {
            .extra2     = &amp;one,
        },
        {
    +       .procname   = "tcp_invalid_ratelimit",
    +       .data       = &amp;sysctl_tcp_invalid_ratelimit,
    +       .maxlen     = sizeof(int),
    +       .mode       = 0644,
    +       .proc_handler   = proc_dointvec_ms_jiffies,
    +   },
    +   {
            .procname   = "icmp_msgs_per_sec",
            .data       = &amp;sysctl_icmp_msgs_per_sec,
            .maxlen     = sizeof(int),
    diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
    index d3dfff7..9401aa43 100644
    --- a/net/ipv4/tcp_input.c
    +++ b/net/ipv4/tcp_input.c
    @@ -100,6 +100,7 @@ int sysctl_tcp_thin_dupack __read_mostly;

     int sysctl_tcp_moderate_rcvbuf __read_mostly = 1;
     int sysctl_tcp_early_retrans __read_mostly = 3;
    +int sysctl_tcp_invalid_ratelimit __read_mostly = HZ/2;

     #define FLAG_DATA      0x01 /* Incoming frame contained data.      */
     #define FLAG_WIN_UPDATE        0x02 /* Incoming ACK was a window update.   */
</code></pre>

<hr />

<h4>sample</h4>

<pre><code>    #define KMSG_COMPONENT "synflood"
    #define pr_fmt(fmt) KMSG_COMPONENT ": " fmt

    #include &lt;linux/module.h&gt;
    #include &lt;linux/kernel.h&gt;
    #include &lt;linux/ip.h&gt;
    #include &lt;linux/tcp.h&gt;
    #include &lt;linux/icmp.h&gt;
    #include &lt;linux/netfilter.h&gt;
    #include &lt;linux/netfilter_ipv4.h&gt;
    #include &lt;linux/netdevice.h&gt;

    #include &lt;net/ip.h&gt;
    #include &lt;net/tcp.h&gt;
    #include &lt;net/udp.h&gt;
    #include &lt;net/icmp.h&gt;

    __be16 cport = 80;
    char *selfip = NULL;

    module_param(cport, short, S_IRUGO);
    module_param(selfip, charp, S_IRUGO);

    void skbcsum(struct sk_buff *skb)
    {
        struct tcphdr *tcph;
        struct iphdr *iph;
        int iphl;
        int tcphl;
        int tcplen;

        iph = (struct iphdr *)skb-&gt;data;
        iphl = iph-&gt;ihl &lt;&lt; 2;
        tcph = (struct tcphdr *)(skb-&gt;data + iphl);
        tcphl = tcph-&gt;doff &lt;&lt; 2;

        iph-&gt;check = 0;
        iph-&gt;check = ip_fast_csum((unsigned char *)iph, iph-&gt;ihl);

        tcph-&gt;check    = 0;
        tcplen        = skb-&gt;len - (iph-&gt;ihl &lt;&lt; 2);
        if (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {
            tcph-&gt;check = ~csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr,
                    tcplen, IPPROTO_TCP, 0);
            skb-&gt;csum_start    = skb_transport_header(skb) - skb-&gt;head;
            skb-&gt;csum_offset = offsetof(struct tcphdr, check);
        }
        else {
            skb-&gt;csum = 0;
            skb-&gt;csum = skb_checksum(skb, iph-&gt;ihl &lt;&lt; 2, tcplen, 0);
            tcph-&gt;check = csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr,
                    tcplen, IPPROTO_TCP, skb-&gt;csum);

        }
    }

    int pktcome = 0;
    int fincome = 0;
    static int check(__be32 ip, __be16 port, int syn, int fin)
    {
        if ((selfip == NULL || ip == in_aton(selfip)) &amp;&amp; ntohs(port) == cport) {
            if (syn) {
                pktcome = 0;
                fincome = 0;
            }
            pktcome ++;
            if (pktcome &gt; 30 || fincome == 3)
                return 1;
            fincome |= fin;
        }
        return 0;
    }

    static unsigned int local_in(unsigned int hooknum, 
        struct sk_buff *skb, const struct net_device *in, 
        const struct net_device *out, int (*okfn) (struct sk_buff *))
    {
        struct iphdr *iph;
        struct tcphdr *th;

        if (unlikely(skb-&gt;pkt_type != PACKET_HOST))
            goto exit;
        if (unlikely(skb-&gt;protocol != __constant_htons(ETH_P_IP)))
            goto exit;
        iph = (struct iphdr *)skb_network_header(skb);
        if (iph-&gt;protocol != IPPROTO_TCP)
            goto exit;
        if (unlikely(!pskb_may_pull(skb, iph-&gt;ihl * 4 + sizeof(struct tcphdr))))
            goto drop_out;
        skb_set_transport_header(skb, iph-&gt;ihl * 4);
        th = tcp_hdr(skb);
        if (check(iph-&gt;daddr, th-&gt;dest, th-&gt;syn, th-&gt;fin)) {
            skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
            th-&gt;seq = htonl(ntohl(th-&gt;seq) + 10000000);
        }
    exit:
        return NF_ACCEPT;
    drop_out:
        return NF_DROP;
    }

    static unsigned int local_out(unsigned int hooknum, 
        struct sk_buff *skb, const struct net_device *in, 
        const struct net_device *out, int (*okfn) (struct sk_buff *))
    {
        struct iphdr *iph;
        struct tcphdr *th;

        iph = (struct iphdr *)skb_network_header(skb);
        if (iph-&gt;protocol != IPPROTO_TCP)
            goto exit;
        if (unlikely(!pskb_may_pull(skb, iph-&gt;ihl * 4 + sizeof(struct tcphdr))))
            goto drop_out;
        skb_set_transport_header(skb, iph-&gt;ihl * 4);
        th = tcp_hdr(skb);
        if (check(iph-&gt;saddr, th-&gt;source, 0, (th-&gt;fin) &lt;&lt; 1)) {
            th-&gt;seq = htonl(ntohl(th-&gt;seq) + 10000000);
            skbcsum(skb);
        }
    exit:
        return NF_ACCEPT;
    drop_out:
        return NF_DROP;
    }

    static struct nf_hook_ops syndef_ops[] __read_mostly = {
        {
            .hook = local_in,
            .owner = THIS_MODULE,
            .pf = PF_INET,
            .hooknum = NF_INET_LOCAL_IN,
            .priority = 100,
        },
        {
            .hook = local_out,
            .owner = THIS_MODULE,
            .pf = PF_INET,
            .hooknum = NF_INET_LOCAL_OUT,
            .priority = 100,
        },

    };

    int __init loopack_init(void)
    {
        int ret;

        ret = nf_register_hooks(syndef_ops, ARRAY_SIZE(syndef_ops));
        if (ret &lt; 0) {
            pr_err("can't register hooks.\n");
            goto hooks_err;
        }

        pr_err("init success.\n");

    hooks_err:
        return ret;
    }

    void __exit loopack_exit(void)
    {
        nf_unregister_hooks(syndef_ops, ARRAY_SIZE(syndef_ops));

        pr_err("unload success.\n");
    }

    module_init(loopack_init);
    module_exit(loopack_exit);
    MODULE_AUTHOR("kk");
    MODULE_VERSION("1.0.0");
    MODULE_LICENSE("GPL");
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine Check Exception]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/09/02/debug-mce/"/>
    <updated>2015-09-02T16:53:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/09/02/debug-mce</id>
    <content type="html"><![CDATA[<p>dmesg显示
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;sbridge: HANDLING MCE MEMORY ERROR
</span><span class='line'>CPU 0: Machine Check Exception: 0 Bank 5: 8c00004000010093
</span><span class='line'>TSC 0 ADDR 67081b300 MISC 2140040486 PROCESSOR 0:206d7 TIME 1441181676 SOCKET 0 APIC 0
</span><span class='line'>EDAC MC0: CE row 2, channel 0, label "CPU_SrcID#0_Channel#3_DIMM#0": 1 Unknown error(s): memory read on FATAL area : cpu=0 Err=0001:0093 (ch=3), addr= 0x67081b300 =&gt; socket=0, Channel=3(mask=8), rank=0
</span><span class='line'>
</span><span class='line'>...
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>保存4行log为mlog
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# mcelog --ascii &lt; /tmp/mlog
</span><span class='line'>WARNING: with --dmi mcelog --ascii must run on the same machine with the
</span><span class='line'> same BIOS/memory configuration as where the machine check occurred.
</span><span class='line'>sbridge: HANDLING MCE MEMORY ERROR
</span><span class='line'>CPU 0: Machine Check Exception: 0 Bank 5: 8c00004000010093
</span><span class='line'>HARDWARE ERROR. This is *NOT* a software problem!
</span><span class='line'>Please contact your hardware vendor
</span><span class='line'>Wed Sep  2 16:14:36 2015
</span><span class='line'>CPU 0 BANK 5 MISC 2140040486 ADDR 67081b300
</span><span class='line'>STATUS 8c00004000010093 MCGSTATUS 0
</span><span class='line'>CPUID Vendor Intel Family 6 Model 45
</span><span class='line'>WARNING: SMBIOS data is often unreliable. Take with a grain of salt!
</span><span class='line'>&lt;24&gt; DIMM 1333 Mhz Res13 Width 72 Data Width 64 Size 16 GB
</span><span class='line'>Device Locator: Node0_Channel2_Dimm0
</span><span class='line'>Bank Locator: Node0_Bank0
</span><span class='line'>Manufacturer: Hynix Semiconducto
</span><span class='line'>Serial Number: 40743B5A
</span><span class='line'>Asset Tag: Dimm2_AssetTag
</span><span class='line'>Part Number: HMT42GR7BFR4A-PB
</span><span class='line'>TSC 0 ADDR 67081b300 MISC 2140040486 PROCESSOR 0:206d7 TIME 1441181676 SOCKET 0 APIC 0
</span><span class='line'>EDAC MC0: CE row 2, channel 0, label "CPU_SrcID#0_Channel#3_DIMM#0": 1 Unknown error(s): memory read on FATAL area : cpu=0 Err=0001:0093 (ch=3), addr = 0x67081b300 =&gt; socket=0, Channel=3(mask=8), rank=0
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>根据  
</span><span class='line'>Part Number: HMT42GR7BFR4A-PB  
</span><span class='line'>Serial Number: 40743B5A  
</span><span class='line'>
</span><span class='line'>在lshw中找相应硬件
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;...
</span><span class='line'>
</span><span class='line'> *-memory:0
</span><span class='line'>      description: System Memory
</span><span class='line'>      physical id: 2d
</span><span class='line'>      slot: System board or motherboard
</span><span class='line'>    *-bank:0
</span><span class='line'>         description: DIMM 1333 MHz (0.8 ns)
</span><span class='line'>         product: HMT42GR7BFR4A-PB
</span><span class='line'>         vendor: Hynix Semiconducto
</span><span class='line'>         physical id: 0
</span><span class='line'>         serial: 905D21AE
</span><span class='line'>         slot: Node0_Channel1_Dimm0
</span><span class='line'>         size: 16GiB
</span><span class='line'>         width: 64 bits
</span><span class='line'>         clock: 1333MHz (0.8ns)
</span><span class='line'>    *-bank:1
</span><span class='line'>         description: DIMM Synchronous [empty]
</span><span class='line'>         product: A1_Dimm1_PartNumber
</span><span class='line'>         vendor: Dimm1_Manufacturer
</span><span class='line'>         physical id: 1
</span><span class='line'>         serial: Dimm1_SerNum
</span><span class='line'>         slot: Node0_Channel1_Dimm1
</span><span class='line'>         width: 64 bits
</span><span class='line'>    *-bank:2
</span><span class='line'>         description: DIMM 1333 MHz (0.8 ns)
</span><span class='line'>         product: HMT42GR7BFR4A-PB
</span><span class='line'>         vendor: Hynix Semiconducto
</span><span class='line'>         physical id: 2
</span><span class='line'>         serial: 40743B5A
</span><span class='line'>         slot: Node0_Channel2_Dimm0
</span><span class='line'>         size: 16GiB
</span><span class='line'>         width: 64 bits
</span><span class='line'>         clock: 1333MHz (0.8ns)
</span><span class='line'>
</span><span class='line'>    ...
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[ixgbe两个合并包功能]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/08/21/debug-ixgbe/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-08-21T15:29:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/08/21/debug-ixgbe&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://downloadmirror.intel.com/22919/eng/README.txt"&gt;http://downloadmirror.intel.com/22919/eng/README.txt&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://www.360doc.com/content/12/1101/17/9008018_245137867.shtml"&gt;http://www.360doc.com/content/12/1101/17/9008018_245137867.shtml&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;      LRO
</span><span class='line'>  ---
</span><span class='line'>  Large Receive Offload (LRO) is a technique for increasing inbound throughput
</span><span class='line'>  of high-bandwidth network connections by reducing CPU overhead. It works by
</span><span class='line'>  aggregating multiple incoming packets from a single stream into a larger 
</span><span class='line'>  buffer before they are passed higher up the networking stack, thus reducing
</span><span class='line'>  the number of packets that have to be processed. LRO combines multiple 
</span><span class='line'>  Ethernet frames into a single receive in the stack, thereby potentially 
</span><span class='line'>  decreasing CPU utilization for receives. 
</span><span class='line'>
</span><span class='line'>  IXGBE_NO_LRO is a compile time flag. The user can enable it at compile
</span><span class='line'>  time to remove support for LRO from the driver. The flag is used by adding 
</span><span class='line'>  CFLAGS_EXTRA="-DIXGBE_NO_LRO" to the make file when it's being compiled. 
</span><span class='line'>
</span><span class='line'>     make CFLAGS_EXTRA="-DIXGBE_NO_LRO" install
</span><span class='line'>
</span><span class='line'>  You can verify that the driver is using LRO by looking at these counters in 
</span><span class='line'>  ethtool:
</span><span class='line'>
</span><span class='line'>  lro_flushed - the total number of receives using LRO.
</span><span class='line'>  lro_aggregated - counts the total number of Ethernet packets that were combined.
</span><span class='line'>
</span><span class='line'>  NOTE: IPv6 and UDP are not supported by LRO.
</span><span class='line'>
</span><span class='line'>  HW RSC
</span><span class='line'>  ------
</span><span class='line'>  82599 and X540-based adapters support HW based receive side coalescing (RSC) 
</span><span class='line'>  which can merge multiple frames from the same IPv4 TCP/IP flow into a single
</span><span class='line'>  structure that can span one or more descriptors. It works similarly to SW
</span><span class='line'>  Large receive offload technique. By default HW RSC is enabled and SW LRO 
</span><span class='line'>  cannot be used for 82599 or X540-based adapters unless HW RSC is disabled.
</span><span class='line'>
</span><span class='line'>  IXGBE_NO_HW_RSC is a compile time flag. The user can enable it at compile 
</span><span class='line'>  time to remove support for HW RSC from the driver. The flag is used by adding 
</span><span class='line'>  CFLAGS_EXTRA="-DIXGBE_NO_HW_RSC" to the make file when it's being compiled.
</span><span class='line'>
</span><span class='line'>     make CFLAGS_EXTRA="-DIXGBE_NO_HW_RSC" install
</span><span class='line'>
</span><span class='line'>  You can verify that the driver is using HW RSC by looking at the counter in 
</span><span class='line'>  ethtool:
</span><span class='line'>
</span><span class='line'>     hw_rsc_count - counts the total number of Ethernet packets that were being
</span><span class='line'>     combined.
</span><span class='line'>
</span><span class='line'>    ...
</span><span class='line'>
</span><span class='line'>max_vfs
</span><span class='line'>-------
</span><span class='line'>Valid Range:   1-63
</span><span class='line'>Default Value: 0
</span><span class='line'>
</span><span class='line'>  If the value is greater than 0 it will also force the VMDq parameter to be 1
</span><span class='line'>  or more.
</span><span class='line'>
</span><span class='line'>  This parameter adds support for SR-IOV.  It causes the driver to spawn up to 
</span><span class='line'>  max_vfs worth of virtual function.  
</span><span class='line'>
</span><span class='line'>  NOTE: When either SR-IOV mode or VMDq mode is enabled, hardware VLAN 
</span><span class='line'>  filtering and VLAN tag stripping/insertion will remain enabled.
</span><span class='line'>  Please remove the old VLAN filter before the new VLAN filter is added.
</span><span class='line'>  For example, 
</span><span class='line'>
</span><span class='line'>    ip link set eth0 vf 0 vlan 100     // set vlan 100 for VF 0
</span><span class='line'>    ip link set eth0 vf 0 vlan 0       // Delete vlan 100 
</span><span class='line'>    ip link set eth0 vf 0 vlan 200     // set a new vlan 200 for VF 0
</span><span class='line'>
</span><span class='line'>The parameters for the driver are referenced by position.  So, if you have a 
</span><span class='line'>dual port 82599 or X540-based adapter and you want N virtual functions per 
</span><span class='line'>port, you must specify a number for each port with each parameter separated by
</span><span class='line'>a comma.
</span><span class='line'>
</span><span class='line'>For example:
</span><span class='line'>  modprobe ixgbe max_vfs=63,63
</span><span class='line'>
</span><span class='line'>NOTE: If both 82598 and 82599 or X540-based adapters are installed on the same 
</span><span class='line'>machine, you must be careful in loading the driver with the parameters. 
</span><span class='line'>Depending on system configuration, number of slots, etc. it's impossible to 
</span><span class='line'>predict in all cases where the positions would be on the command line and the 
</span><span class='line'>user will have to specify zero in those positions occupied by an 82598 port.
</span><span class='line'>
</span><span class='line'>With kernel 3.6, the driver supports the simultaneous usage of max_vfs and DCB 
</span><span class='line'>features, subject to the constraints described below. Prior to kernel 3.6, the 
</span><span class='line'>driver did not support the simultaneous operation of max_vfs &gt; 0 and the DCB 
</span><span class='line'>features (multiple traffic classes utilizing Priority Flow Control and Extended 
</span><span class='line'>Transmission Selection).
</span><span class='line'>
</span><span class='line'>When DCB is enabled, network traffic is transmitted and received through multiple 
</span><span class='line'>traffic classes (packet buffers in the NIC). The traffic is associated with a 
</span><span class='line'>specific class based on priority, which has a value of 0 through 7 used in the 
</span><span class='line'>VLAN tag. When SR-IOV is not enabled, each traffic class is associated with a set 
</span><span class='line'>of RX/TX descriptor queue pairs. The number of queue pairs for a given traffic 
</span><span class='line'>class depends on the hardware configuration. When SR-IOV is enabled, the descriptor 
</span><span class='line'>queue pairs are grouped into pools. The Physical Function (PF) and each Virtual 
</span><span class='line'>Function (VF) is allocated a pool of RX/TX descriptor queue pairs. When multiple 
</span><span class='line'>traffic classes are configured (for example, DCB is enabled), each pool contains a 
</span><span class='line'>queue pair from each traffic class. When a single traffic class is configured in 
</span><span class='line'>the hardware, the pools contain multiple queue pairs from the single traffic class.
</span><span class='line'>
</span><span class='line'>The number of VFs that can be allocated depends on the number of traffic classes 
</span><span class='line'>that can be enabled. The configurable number of traffic classes for each enabled 
</span><span class='line'>VF is as follows:
</span><span class='line'>
</span><span class='line'>  0 - 15 VFs = Up to 8 traffic classes, depending on device support
</span><span class='line'>
</span><span class='line'>  16 - 31 VFs = Up to 4 traffic classes
</span><span class='line'>
</span><span class='line'>  32 - 63 = 1 traffic class 
</span><span class='line'>
</span><span class='line'>When VFs are configured, the PF is allocated one pool as well. The PF supports 
</span><span class='line'>the DCB features with the constraint that each traffic class will only use a 
</span><span class='line'>single queue pair. When zero VFs are configured, the PF can support multiple 
</span><span class='line'>queue pairs per traffic class.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如果编译时disable了LRO，但没有disable RSC，可以用 ethtool -C eth2 rx-usecs 0 临时解决，或用 max_vfs=1 ？？？&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="https://bugzilla.redhat.com/show_bug.cgi?id=680998"&gt;https://bugzilla.redhat.com/show_bug.cgi?id=680998&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>Chris Wright has this board in hands, here the comment from him:
</span><span class='line'>&gt; OK, disabling hw RSC with 'ethtool -C eth2 rx-usecs 0' (thanks
</span><span class='line'>&gt; Herbert!) is bringing this back for me (something like ~1800 Mb/s).
</span><span class='line'>&gt; This is roughly what booting with max_vfs=1 should have done, so I'm not
</span><span class='line'>&gt; sure why that didn't work.
</span><span class='line'>
</span><span class='line'>Note that disabling coalescing with ethtool results in better, 
</span><span class='line'>though still poor performance as would be expected since we're disabling coalescing. 
</span><span class='line'>The "max_vfs=1" parameter disables RSC as a side-effect and 
</span><span class='line'>doesn't have the performance hit that disabling interrupt coalescing on the NIC does. 
</span><span class='line'>In internal testing, "max_vfs=1" results in ~2.5x better performance than using ethtool.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[系统级性能分析工具 --- Perf]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/07/27/debug-perf/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-07-27T17:09:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/07/27/debug-perf&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://blog.csdn.net/zhangskd/article/details/37902159"&gt;http://blog.csdn.net/zhangskd/article/details/37902159&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;从2.6.31内核开始，linux内核自带了一个性能分析工具perf，能够进行函数级与指令级的热点查找。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;perf&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Performance analysis tools for Linux.&lt;br/&gt;
</span><span class='line'>Performance counters for Linux are a new kernel-based subsystem that provide a framework for all things performance analysis. It covers hardware level (CPU/PMU, Performance Monitoring Unit) features and software features (software counters, tracepoints) as well.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;perf是内置于Linux内核源码树中的性能剖析(profiling)工具。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;常用于性能瓶颈的查找与热点代码的定位。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CPU周期(cpu-cycles)是默认的性能事件，所谓的CPU周期是指CPU所能识别的最小时间单元，通常为亿分之几秒，是CPU执行最简单的指令时所需要的时间，例如读取寄存器中的内容，也叫做clock tick。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;perf是一个包含22种子工具的工具集，以下是最常用的5种：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>perf list
</span><span class='line'>perf stat
</span><span class='line'>perf top
</span><span class='line'>perf record
</span><span class='line'>perf report
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;perf list&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;perf list用来查看perf所支持的性能事件，有软件的也有硬件的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;List all symbolic event types.
</span><span class='line'>&lt;code&gt;
</span><span class='line'>perf list [hw | sw | cache | tracepoint | event_glob]
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(1) 性能事件的分布&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;hw：Hardware event，9个&lt;br/&gt;
</span><span class='line'>sw：Software event，9个&lt;br/&gt;
</span><span class='line'>cache：Hardware cache event，26个&lt;br/&gt;
</span><span class='line'>tracepoint：Tracepoint event，775个&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;sw实际上是内核的计数器，与硬件无关。&lt;br/&gt;
</span><span class='line'>hw和cache是CPU架构相关的，依赖于具体硬件。&lt;br/&gt;
</span><span class='line'>tracepoint是基于内核的ftrace，主线2.6.3x以上的内核版本才支持。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(2) 指定性能事件(以它的属性)&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    -e &lt;event&gt; : u // userspace
</span><span class='line'>-e &lt;event&gt; : k // kernel
</span><span class='line'>-e &lt;event&gt; : h // hypervisor
</span><span class='line'>-e &lt;event&gt; : G // guest counting (in KVM guests)
</span><span class='line'>-e &lt;event&gt; : H // host counting (not in KVM guests)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(3) 使用例子&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;显示内核和模块中，消耗最多CPU周期的函数：
</span><span class='line'>&lt;code&gt;
</span><span class='line'># perf top -e cycles:k
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>显示分配高速缓存最多的函数：
</span><span class='line'>&lt;code&gt;
</span><span class='line'># perf top -e kmem:kmem_cache_alloc
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;perf top&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;对于一个指定的性能事件(默认是CPU周期)，显示消耗最多的函数或指令。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;System profiling tool.&lt;br/&gt;
</span><span class='line'>Generates and displays a performance counter profile in real time.&lt;br/&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>perf top [-e &lt;EVENT&gt; | --event=EVENT] [&lt;options&gt;]
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;perf top主要用于实时分析各个函数在某个性能事件上的热度，能够快速的定位热点函数，包括应用程序函数、模块函数与内核函数，甚至能够定位到热点指令。默认的性能事件为cpu cycles。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(1) 输出格式&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    # perf top
</span><span class='line'>
</span><span class='line'>Samples: 1M of event 'cycles', Event count (approx.): 73891391490
</span><span class='line'>     5.44%  perf              [.] 0x0000000000023256
</span><span class='line'>     4.86%  [kernel]          [k] _spin_lock
</span><span class='line'>     2.43%  [kernel]          [k] _spin_lock_bh
</span><span class='line'>     2.29%  [kernel]          [k] _spin_lock_irqsave
</span><span class='line'>     1.77%  [kernel]          [k] __d_lookup
</span><span class='line'>     1.55%  libc-2.12.so      [.] __strcmp_sse42
</span><span class='line'>     1.43%  nginx             [.] ngx_vslprintf
</span><span class='line'>     1.37%  [kernel]          [k] tcp_poll
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;第一列：符号引发的性能事件的比例，默认指占用的cpu周期比例。&lt;br/&gt;
</span><span class='line'>第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。&lt;br/&gt;
</span><span class='line'>第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库)。[k]表述此符号属于内核或模块。&lt;br/&gt;
</span><span class='line'>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(2) 常用交互命令&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;h：显示帮助&lt;br/&gt;
</span><span class='line'>UP/DOWN/PGUP/PGDN/SPACE：上下和翻页。&lt;br/&gt;
</span><span class='line'>a：annotate current symbol，注解当前符号。能够给出汇编语言的注解，给出各条指令的采样率。&lt;br/&gt;
</span><span class='line'>d：过滤掉所有不属于此DSO的符号。非常方便查看同一类别的符号。&lt;br/&gt;
</span><span class='line'>P：将当前信息保存到perf.hist.N中。&lt;br/&gt;
</span><span class='line'>s：输入函数，查看函数内部热点。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(3) 常用命令行参数&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    -e &lt;event&gt;：指明要分析的性能事件。
</span><span class='line'>-p &lt;pid&gt;：Profile events on existing Process ID (comma sperated list). 仅分析目标进程及其创建的线程。
</span><span class='line'>-k &lt;path&gt;：Path to vmlinux. Required for annotation functionality. 带符号表的内核映像所在的路径。
</span><span class='line'>-K：不显示属于内核或模块的符号。
</span><span class='line'>-U：不显示属于用户态程序的符号。
</span><span class='line'>-d &lt;n&gt;：界面的刷新周期，默认为2s，因为perf top默认每2s从mmap的内存区域读取一次性能数据。
</span><span class='line'>-G：得到函数的调用关系图。
</span><span class='line'>perf top -G [fractal]，路径概率为相对值，加起来为100%，调用顺序为从下往上。
</span><span class='line'>perf top -G graph，路径概率为绝对值，加起来为该函数的热度。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(4) 使用例子&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    # perf top // 默认配置
</span><span class='line'># perf top -G // 得到调用关系图
</span><span class='line'># perf top -e cycles // 指定性能事件
</span><span class='line'># perf top -p 23015,32476 // 查看这两个进程的cpu cycles使用情况
</span><span class='line'># perf top -s comm,pid,symbol // 显示调用symbol的进程名和进程号
</span><span class='line'># perf top --comms nginx,top // 仅显示属于指定进程的符号
</span><span class='line'># perf top --symbols kfree // 仅显示指定的符号
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;perf stat&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;用于分析指定程序的性能概况。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Run a command and gather performance counter statistics.
</span><span class='line'>&lt;code&gt;
</span><span class='line'>perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] &lt;command&gt;
</span><span class='line'>perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] - &lt;command&gt; [&lt;options&gt;]
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(1) 输出格式&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    # perf stat ls
</span><span class='line'>
</span><span class='line'>Performance counter stats for 'ls':
</span><span class='line'>
</span><span class='line'>         0.653782 task-clock                #    0.691 CPUs utilized
</span><span class='line'>                0 context-switches          #    0.000 K/sec
</span><span class='line'>                0 CPU-migrations            #    0.000 K/sec
</span><span class='line'>              247 page-faults               #    0.378 M/sec
</span><span class='line'>        1,625,426 cycles                    #    2.486 GHz
</span><span class='line'>        1,050,293 stalled-cycles-frontend   #   64.62% frontend cycles idle
</span><span class='line'>          838,781 stalled-cycles-backend    #   51.60% backend  cycles idle
</span><span class='line'>        1,055,735 instructions              #    0.65  insns per cycle
</span><span class='line'>                                            #    0.99  stalled cycles per insn
</span><span class='line'>          210,587 branches                  #  322.106 M/sec
</span><span class='line'>           10,809 branch-misses             #    5.13% of all branches
</span><span class='line'>
</span><span class='line'>      0.000945883 seconds time elapsed
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;输出包括ls的执行时间，以及10个性能事件的统计。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;task-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized = task-clock / time elapsed，CPU的占用率。&lt;br/&gt;
</span><span class='line'>context-switches：上下文的切换次数。&lt;br/&gt;
</span><span class='line'>CPU-migrations：处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。&lt;br/&gt;
</span><span class='line'>page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。&lt;br/&gt;
</span><span class='line'>cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles / task-clock算出。&lt;br/&gt;
</span><span class='line'>stalled-cycles-frontend：略过。&lt;br/&gt;
</span><span class='line'>stalled-cycles-backend：略过。&lt;br/&gt;
</span><span class='line'>instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。&lt;br/&gt;
</span><span class='line'>branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(2) 常用参数&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    -p：stat events on existing process id (comma separated list). 仅分析目标进程及其创建的线程。
</span><span class='line'>-a：system-wide collection from all CPUs. 从所有CPU上收集性能数据。
</span><span class='line'>-r：repeat command and print average + stddev (max: 100). 重复执行命令求平均。
</span><span class='line'>-C：Count only on the list of CPUs provided (comma separated list), 从指定CPU上收集性能数据。
</span><span class='line'>-v：be more verbose (show counter open errors, etc), 显示更多性能数据。
</span><span class='line'>-n：null run - don't start any counters，只显示任务的执行时间 。
</span><span class='line'>-x SEP：指定输出列的分隔符。
</span><span class='line'>-o file：指定输出文件，--append指定追加模式。
</span><span class='line'>--pre &lt;cmd&gt;：执行目标程序前先执行的程序。
</span><span class='line'>--post &lt;cmd&gt;：执行目标程序后再执行的程序。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(3) 使用例子&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;执行10次程序，给出标准偏差与期望的比值：
</span><span class='line'>&lt;code&gt;
</span><span class='line'># perf stat -r 10 ls &gt; /dev/null
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;显示更详细的信息：
</span><span class='line'>&lt;code&gt;
</span><span class='line'># perf stat -v ls &gt; /dev/null
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;只显示任务执行时间，不显示性能计数器：
</span><span class='line'>&lt;code&gt;
</span><span class='line'># perf stat -n ls &gt; /dev/null
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;单独给出每个CPU上的信息：
</span><span class='line'>&lt;code&gt;
</span><span class='line'># perf stat -a -A ls &gt; /dev/null
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ls命令执行了多少次系统调用：
</span><span class='line'>&lt;code&gt;
</span><span class='line'># perf stat -e syscalls:sys_enter ls
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;perf record&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;收集采样信息，并将其记录在数据文件中。随后可以通过其它工具(perf-report)对数据文件进行分析，结果类似于perf-top的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Run a command and record its profile into perf.data.&lt;br/&gt;
</span><span class='line'>This command runs a command and gathers a performance counter profile from it, into perf.data,without displaying anything. This file can then be inspected later on, using perf report.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(1) 常用参数&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    -e：Select the PMU event.
</span><span class='line'>-a：System-wide collection from all CPUs.
</span><span class='line'>-p：Record events on existing process ID (comma separated list).
</span><span class='line'>-A：Append to the output file to do incremental profiling.
</span><span class='line'>-f：Overwrite existing data file.
</span><span class='line'>-o：Output file name.
</span><span class='line'>-g：Do call-graph (stack chain/backtrace) recording.
</span><span class='line'>-C：Collect samples only on the list of CPUs provided.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(2) 使用例子&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;记录nginx进程的性能数据：
</span><span class='line'>&lt;code&gt;
</span><span class='line'># perf record -p `pgrep -d ',' nginx`
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;记录执行ls时的性能数据：
</span><span class='line'>&lt;code&gt;
</span><span class='line'># perf record ls -g
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;记录执行ls时的系统调用，可以知道哪些系统调用最频繁：
</span><span class='line'>&lt;code&gt;
</span><span class='line'># perf record -e syscalls:sys_enter ls
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;perf report&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;读取perf record创建的数据文件，并给出热点分析结果。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Read perf.data (created by perf record) and display the profile.&lt;br/&gt;
</span><span class='line'>This command displays the performance counter profile information recorded via perf record.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(1) 常用参数&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    -i：Input file name. (default: perf.data)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(2) 使用例子&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    # perf report -i perf.data.2
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;More&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;除了以上5个常用工具外，还有一些适用于较特殊场景的工具， 比如内核锁、slab分配器、调度器，也支持自定义探测点。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;perf lock&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内核锁的性能分析。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Analyze lock events.
</span><span class='line'>&lt;code&gt;
</span><span class='line'>perf lock {record | report | script | info}
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;需要编译选项的支持：CONFIG_LOCKDEP、CONFIG_LOCK_STAT。&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CONFIG_LOCKDEP defines acquired and release events.&lt;br/&gt;
</span><span class='line'>CONFIG_LOCK_STAT defines contended and acquired lock events.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(1) 常用选项&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    -i &lt;file&gt;：输入文件
</span><span class='line'>-k &lt;value&gt;：sorting key，默认为acquired，还可以按contended、wait_total、wait_max和wait_min来排序。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(2) 使用例子&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    # perf lock record ls // 记录
</span><span class='line'># perf lock report // 报告
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;(3) 输出格式&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;                   Name   acquired  contended total wait (ns)   max wait (ns)   min wait (ns)
</span><span class='line'>
</span><span class='line'>&amp;mm-&gt;page_table_...        382          0               0               0               0
</span><span class='line'>&amp;mm-&gt;page_table_...         72          0               0               0               0
</span><span class='line'>          &amp;fs-&gt;lock         64          0               0               0               0
</span><span class='line'>        dcache_lock         62          0               0               0               0
</span><span class='line'>      vfsmount_lock         43          0               0               0               0
</span><span class='line'>&amp;newf-&gt;file_lock...         41          0               0               0               0
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Name：内核锁的名字。&lt;br/&gt;
</span><span class='line'>aquired：该锁被直接获得的次数，因为没有其它内核路径占用该锁，此时不用等待。&lt;br/&gt;
</span><span class='line'>contended：该锁等待后获得的次数，此时被其它内核路径占用，需要等待。&lt;br/&gt;
</span><span class='line'>total wait：为了获得该锁，总共的等待时间。&lt;br/&gt;
</span><span class='line'>max wait：为了获得该锁，最大的等待时间。&lt;br/&gt;
</span><span class='line'>min wait：为了获得该锁，最小的等待时间。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最后还有一个Summary：</span></code></pre></td></tr></table></div></figure>
    === output for debug===</p>

<pre><code>bad: 10, total: 246  
bad rate: 4.065041 %  
histogram of events caused bad sequence  
    acquire: 0  
   acquired: 0  
  contended: 0  
    release: 10  
</code></pre>

<pre><code>
---------------

##### perf kmem

slab分配器的性能分析。

Tool to trace/measure kernel memory(slab) properties.
</code></pre>

<pre><code>perf kmem {record | stat} [&lt;options&gt;]
</code></pre>

<pre><code>
##### (1) 常用选项
</code></pre>

<pre><code>--i &lt;file&gt;：输入文件
--caller：show per-callsite statistics，显示内核中调用kmalloc和kfree的地方。
--alloc：show per-allocation statistics，显示分配的内存地址。
-l &lt;num&gt;：print n lines only，只显示num行。
-s &lt;key[,key2...]&gt;：sort the output (default: frag,hit,bytes)
</code></pre>

<pre><code>
##### (2) 使用例子
</code></pre>

<pre><code># perf kmem record ls // 记录
# perf kmem stat --caller --alloc -l 20 // 报告
</code></pre>

<pre><code>
##### (3) 输出格式
</code></pre>

<pre><code>------------------------------------------------------------------------------------------------------
 Callsite                           | Total_alloc/Per | Total_req/Per   | Hit      | Ping-pong | Frag
------------------------------------------------------------------------------------------------------
 perf_event_mmap+ec                 |    311296/8192  |    155952/4104  |       38 |        0 | 49.902%
 proc_reg_open+41                   |        64/64    |        40/40    |        1 |        0 | 37.500%
 __kmalloc_node+4d                  |      1024/1024  |       664/664   |        1 |        0 | 35.156%
 ext3_readdir+5bd                   |        64/64    |        48/48    |        1 |        0 | 25.000%
 load_elf_binary+8ec                |       512/512   |       392/392   |        1 |        0 | 23.438%
</code></pre>

<pre><code>
Callsite：内核代码中调用kmalloc和kfree的地方。  
Total_alloc/Per：总共分配的内存大小，平均每次分配的内存大小。  
Total_req/Per：总共请求的内存大小，平均每次请求的内存大小。  
Hit：调用的次数。  
Ping-pong：kmalloc和kfree不被同一个CPU执行时的次数，这会导致cache效率降低。  
Frag：碎片所占的百分比，碎片 = 分配的内存 - 请求的内存，这部分是浪费的。  
有使用--alloc选项，还会看到Alloc Ptr，即所分配内存的地址。  

最后还有一个Summary：
</code></pre>

<pre><code>SUMMARY
=======
Total bytes requested: 290544
Total bytes allocated: 447016
Total bytes wasted on internal fragmentation: 156472
Internal fragmentation: 35.003669%
Cross CPU allocations: 2/509
</code></pre>

<pre><code>
---------------

#### probe sched

调度模块分析。

trace/measure scheduler properties (latencies)
</code></pre>

<pre><code>perf sched {record | latency | map | replay | script}
</code></pre>

<pre><code>
##### (1) 使用例子 
</code></pre>

<pre><code># perf sched record sleep 10 // perf sched record &lt;command&gt;
# perf report latency --sort max
</code></pre>

<pre><code>
##### (2) 输出格式
</code></pre>

<pre><code>---------------------------------------------------------------------------------------------------------------
 Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at     |
---------------------------------------------------------------------------------------------------------------
 events/10:61          |      0.655 ms |       10 | avg:    0.045 ms | max:    0.161 ms | max at: 9804.958730 s
 sleep:11156           |      2.263 ms |        4 | avg:    0.052 ms | max:    0.118 ms | max at: 9804.865552 s
 edac-poller:1125      |      0.598 ms |       10 | avg:    0.042 ms | max:    0.113 ms | max at: 9804.958698 s
 events/2:53           |      0.676 ms |       10 | avg:    0.037 ms | max:    0.102 ms | max at: 9814.751605 s
 perf:11155            |      2.109 ms |        1 | avg:    0.068 ms | max:    0.068 ms | max at: 9814.867918 s
</code></pre>

<pre><code>TASK：进程名和pid。  
Runtime：实际的运行时间。  
Switches：进程切换的次数。  
Average delay：平均的调度延迟。  
Maximum delay：最大的调度延迟。  
Maximum delay at：最大调度延迟发生的时刻。  


---------------

#### perf probe

可以自定义探测点。

Define new dynamic tracepoints.

##### 使用例子

(1) Display which lines in schedule() can be probed
</code></pre>

<pre><code># perf probe --line schedule
</code></pre>

<pre><code>前面有行号的可以探测，没有行号的就不行了。

(2) Add a probe on schedule() function 12th line.
</code></pre>

<pre><code># perf probe -a schedule:12
</code></pre>

<p>```
在schedule函数的12处增加一个探测点。</p>

<hr />

<h4>Reference</h4>

<p>[1]. Linux的系统级性能剖析工具系列，by 承刚</p>

<p>[2]. <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/">http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/</a></p>

<p>[3]. <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/">http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/</a></p>

<p>[4]. <a href="https://perf.wiki.kernel.org/index.php/Tutorial">https://perf.wiki.kernel.org/index.php/Tutorial</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gdb break/watch/catch]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/21/debug-gdb-break/"/>
    <updated>2015-07-21T15:49:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/21/debug-gdb-break</id>
    <content type="html"><![CDATA[<p><a href="http://sourceware.org/gdb/current/onlinedocs/gdb">http://sourceware.org/gdb/current/onlinedocs/gdb</a></p>

<p><a href="http://blog.csdn.net/yangzhongxuan/article/details/6897968">gdb break 断点设置（一）</a><br/>
<a href="http://blog.csdn.net/yangzhongxuan/article/details/6899186">gdb watch 断点设置（二）</a><br/>
<a href="http://blog.csdn.net/yangzhongxuan/article/details/6901440">gdb catch 断点设置（三）</a><br/>
<a href="http://blog.csdn.net/yangzhongxuan/article/details/6901477">gdb 断点删除（四）</a></p>

<hr />

<h3>二、断点设置</h3>

<h4>gdb断点分类：</h4>

<p>以设置断点的命令分类：</p>

<p>breakpoint 可以根据行号、函数、条件生成断点。
watchpoint 监测变量或者表达式的值发生变化时产生断点。
catchpoint 监测信号的产生。例如c++的throw，或者加载库的时候。</p>

<p>gdb中的变量从1开始标号，不同的断点采用变量标号同一管理，可以 用enable、disable等命令管理，同时支持断点范围的操作，比如有些命令接受断点范围作为参数。</p>

<h4>1、break及break变种详解：</h4>

<p>相关命令有break，tbreak，rbreak,hbreak，thbreak，后两种是基于硬件的，先不介绍。</p>

<h5>break 与 tbeak</h5>

<p>break，tbreak可以根据行号、函数、条件生成断点。tbreak设置方法与break相同，只不过tbreak只在断点停一次，过后会自动将断点删除，break需要手动控制断点的删除和使能。</p>

<p>break 可带如下参数：<br/>
  linenum            本地行号，即list命令可见的行号<br/>
  filename:linenum   制定个文件的行号<br/>
  function           函数，可以是自定义函数也可是库函数，如open<br/>
  filename:function  制定文件中的函数<br/>
  condtion           条件<br/>
  *address           地址，可是函数，变量的地址，此地址可以通过info add命令得到。</p>

<p>例如：
<code>
    break 10    
    break test.c:10
    break main
    break test.c:main
    break system
    break open
</code></p>

<p>如果想在指定的地址设置断点，比如在main函数的地址出设断点。可用info add main 获得main的地址如0x80484624，然后用break *0x80484624.</p>

<h6>条件断点</h6>

<p>就是在如上述指定断点的同时指定进入断点的条件。</p>

<p>例如：（假如有int 类型变量 index）
<code>
    break 10 if index == 3
    tbreak 12 if index == 5
</code></p>

<h5>rbreak</h5>

<p>rbreak 可以跟一个规则表达式。rbreak + 表达式的用法与grep + 表达式相似。即在所有与表达式匹配的函数入口都设置断点。</p>

<p>rbreak list<em>* 即在所有以 list</em> 为开头字符的函数地方都设置断点。</p>

<p>rbreak ^list_ 功能与上同。</p>

<h5>查看断点信息</h5>

<pre><code>    info break [break num ]
    info break 可列出所有断点信息，info break 后也可设置要查看的break num如：
    info break 1 列出断点号是1的断点信息

    Num        Type                    Disp Enb  Address      What
     1       breakpoint                keep y    &lt;MULTIPLE&gt;
     stop only if i==1
     breakpoint already hit 1 time
     1.1                                    y    0x080486a2 in void foo&lt;int&gt;() at t.cc:8
     1.2                                    y    0x080486ca in void foo&lt;double&gt;() at t.cc:8
</code></pre>

<hr />

<h4>2、watch</h4>

<pre><code>    watch [-l|-location] expr [thread threadnum] [mask maskvalue]
</code></pre>

<p>-l 与 mask没有仔细研究，thread threadnum 是在多线程的程序中限定只有被线程号是threadnum的线程修改值后进入断点。</p>

<p>经常用到的如下命令：
watch <expr><br/>
为表达式（变量）expr设置一个观察点。变量量表达式值有变化时，马上停住程序。</p>

<p>表达式可以是一个变量, 例如：watch value_a</p>

<p>表达式可以是一个地址, 例如：watch <em>(int </em>)0x12345678 可以检测4个字节的内存是否变化。</p>

<p>表达式可以是一个复杂的语句表达式, 例如：watch a*b + c/d</p>

<p>watch 在有些操作系统支持硬件观测点，硬件观测点的运行速度比软件观测点的快。如果系统支持硬件观测的话，当设置观测点是会打印如下信息：<code>Hardware watchpoint num: expr</code></p>

<p>如果不想用硬件观测点的话可如下设置：<code>set can-use-hw-watchpoints</code></p>

<p>watch两个变种 rwatch，awatch，这两个命令只支持硬件观测点如果系统不支持硬件观测点会答应出不支持这两个命令的信息:，</p>

<p>rwatch <expr><br/>
当表达式（变量）expr被读时，停住程序。</p>

<p>awatch <expr><br/>
当表达式（变量）的值被读或被写时，停住程序。</p>

<p>info watchpoints<br/>
列出当前所设置了的所有观察点。</p>

<p>watch 所设置的断点也可以用控制断点的命令来控制。如 disable、enable、delete等。</p>

<p>可以为停止点设定运行命令
<code>
    commands [bnum]
    ... command-list ...
    end
</code></p>

<p>为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令。</p>

<p>例如：
<code>
    break foo if x&gt;0
    commands
    printf "x is %d/n",x
    continue
    end
</code></p>

<p>断点设置在函数foo中，断点条件是x>0，如果程序被断住后，也就是，一旦x的值在foo函数中大于0，GDB会自动打印出x的值，并继续运行程序。</p>

<p>注意：watch 设置也是断点，如果调试的时候设置的断点（任何种类的断点）过多的时候，watch断点会被忽略，有时候没有任何提示，这是我在测试的时候发现的，只有把多余的断点删除后才可用。</p>

<hr />

<p>在调试的时候通常用catchpoints来捕获事件，如c++的异常等。捕获点的设置通过catch与tcatch两个命令。</p>

<p>tcatch所设置的断点停止一次后自动删除，设置断点的方法与catch相同。</p>

<p>用法：catch event</p>

<p>这些event事件如下：
```
    throw
        The throwing of a C++ exception.
    catch
        The catching of a C++ exception.
    exception</p>

<pre><code>exception unhandled
    An exception that was raised but is not handled by the program.
assert
    Ada 语言 assert断言失败时，断点被踩到。
exec
    调用exec时断点被踩到。
syscall
syscall [name | number] ...
    通过系统函数的名称和系统号，来设置捕获点，当所设定的系统调用时，断点被踩到。
    因为经常在linux用c语言，所以主要用到的event是最后四个，其他的没有仔细研究。
</code></pre>

<pre><code>
例如：
</code></pre>

<pre><code>catch syscall open
catch syscall 5
</code></pre>

<pre><code>这两个捕获断点一样。

--------------

断点的删除与断点的设置同样的重要。删除断点的命令有两个: delete, clear

##### delete
用法：  
delete [breakpoints num] [range...]

delete可删除单个断点，也可删除一个断点的集合，这个集合用连续的断点号来描述。

例如：
</code></pre>

<pre><code>delete 5
delete 1-10
</code></pre>

<pre><code>
##### clear
用法:  
clear  
删除所在行的多有断点。

clear location  
clear 删除所选定的环境中所有的断点  
clear location location描述具体的断点。  

例如：
</code></pre>

<pre><code>clear list_insert         //删除函数的所有断点
clear list.c:list_delet   //删除文件：函数的所有断点
clear 12                  //删除行号的所有断点
clear list.c:12           //删除文件：行号的所有断点
</code></pre>

<p>```</p>

<p>clear 删除断点是基于行的，不是把所有的断点都删除。</p>
]]></content>
  </entry>
  
</feed>
