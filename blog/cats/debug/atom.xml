<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-07-23T17:56:52+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[gdb break/watch/catch]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/21/debug-gdb-break/"/>
    <updated>2015-07-21T15:49:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/21/debug-gdb-break</id>
    <content type="html"><![CDATA[<p><a href="http://sourceware.org/gdb/current/onlinedocs/gdb">http://sourceware.org/gdb/current/onlinedocs/gdb</a></p>

<p><a href="http://blog.csdn.net/yangzhongxuan/article/details/6897968">gdb break 断点设置（一）</a><br/>
<a href="http://blog.csdn.net/yangzhongxuan/article/details/6899186">gdb watch 断点设置（二）</a><br/>
<a href="http://blog.csdn.net/yangzhongxuan/article/details/6901440">gdb catch 断点设置（三）</a><br/>
<a href="http://blog.csdn.net/yangzhongxuan/article/details/6901477">gdb 断点删除（四）</a></p>

<hr />

<h3>二、断点设置</h3>

<h4>gdb断点分类：</h4>

<p>以设置断点的命令分类：</p>

<p>breakpoint 可以根据行号、函数、条件生成断点。
watchpoint 监测变量或者表达式的值发生变化时产生断点。
catchpoint 监测信号的产生。例如c++的throw，或者加载库的时候。</p>

<p>gdb中的变量从1开始标号，不同的断点采用变量标号同一管理，可以 用enable、disable等命令管理，同时支持断点范围的操作，比如有些命令接受断点范围作为参数。</p>

<h4>1、break及break变种详解：</h4>

<p>相关命令有break，tbreak，rbreak,hbreak，thbreak，后两种是基于硬件的，先不介绍。</p>

<h5>break 与 tbeak</h5>

<p>break，tbreak可以根据行号、函数、条件生成断点。tbreak设置方法与break相同，只不过tbreak只在断点停一次，过后会自动将断点删除，break需要手动控制断点的删除和使能。</p>

<p>break 可带如下参数：<br/>
  linenum            本地行号，即list命令可见的行号<br/>
  filename:linenum   制定个文件的行号<br/>
  function           函数，可以是自定义函数也可是库函数，如open<br/>
  filename:function  制定文件中的函数<br/>
  condtion           条件<br/>
  *address           地址，可是函数，变量的地址，此地址可以通过info add命令得到。</p>

<p>例如：
<code>
    break 10    
    break test.c:10
    break main
    break test.c:main
    break system
    break open
</code></p>

<p>如果想在指定的地址设置断点，比如在main函数的地址出设断点。可用info add main 获得main的地址如0x80484624，然后用break *0x80484624.</p>

<h6>条件断点</h6>

<p>就是在如上述指定断点的同时指定进入断点的条件。</p>

<p>例如：（假如有int 类型变量 index）
<code>
    break 10 if index == 3
    tbreak 12 if index == 5
</code></p>

<h5>rbreak</h5>

<p>rbreak 可以跟一个规则表达式。rbreak + 表达式的用法与grep + 表达式相似。即在所有与表达式匹配的函数入口都设置断点。</p>

<p>rbreak list<em>* 即在所有以 list</em> 为开头字符的函数地方都设置断点。</p>

<p>rbreak ^list_ 功能与上同。</p>

<h5>查看断点信息</h5>

<pre><code>    info break [break num ]
    info break 可列出所有断点信息，info break 后也可设置要查看的break num如：
    info break 1 列出断点号是1的断点信息

    Num        Type                    Disp Enb  Address      What
     1       breakpoint                keep y    &lt;MULTIPLE&gt;
         stop only if i==1
         breakpoint already hit 1 time
     1.1                                    y    0x080486a2 in void foo&lt;int&gt;() at t.cc:8
     1.2                                    y    0x080486ca in void foo&lt;double&gt;() at t.cc:8
</code></pre>

<hr />

<h4>2、watch</h4>

<pre><code>    watch [-l|-location] expr [thread threadnum] [mask maskvalue]
</code></pre>

<p>-l 与 mask没有仔细研究，thread threadnum 是在多线程的程序中限定只有被线程号是threadnum的线程修改值后进入断点。</p>

<p>经常用到的如下命令：
watch <expr><br/>
为表达式（变量）expr设置一个观察点。变量量表达式值有变化时，马上停住程序。</p>

<p>表达式可以是一个变量, 例如：watch value_a</p>

<p>表达式可以是一个地址, 例如：watch <em>(int </em>)0x12345678 可以检测4个字节的内存是否变化。</p>

<p>表达式可以是一个复杂的语句表达式, 例如：watch a*b + c/d</p>

<p>watch 在有些操作系统支持硬件观测点，硬件观测点的运行速度比软件观测点的快。如果系统支持硬件观测的话，当设置观测点是会打印如下信息：<code>Hardware watchpoint num: expr</code></p>

<p>如果不想用硬件观测点的话可如下设置：<code>set can-use-hw-watchpoints</code></p>

<p>watch两个变种 rwatch，awatch，这两个命令只支持硬件观测点如果系统不支持硬件观测点会答应出不支持这两个命令的信息:，</p>

<p>rwatch <expr><br/>
当表达式（变量）expr被读时，停住程序。</p>

<p>awatch <expr><br/>
当表达式（变量）的值被读或被写时，停住程序。</p>

<p>info watchpoints<br/>
列出当前所设置了的所有观察点。</p>

<p>watch 所设置的断点也可以用控制断点的命令来控制。如 disable、enable、delete等。</p>

<p>可以为停止点设定运行命令
<code>
    commands [bnum]
    ... command-list ...
    end
</code></p>

<p>为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令。</p>

<p>例如：
<code>
    break foo if x&gt;0
    commands
    printf "x is %d/n",x
    continue
    end
</code></p>

<p>断点设置在函数foo中，断点条件是x>0，如果程序被断住后，也就是，一旦x的值在foo函数中大于0，GDB会自动打印出x的值，并继续运行程序。</p>

<p>注意：watch 设置也是断点，如果调试的时候设置的断点（任何种类的断点）过多的时候，watch断点会被忽略，有时候没有任何提示，这是我在测试的时候发现的，只有把多余的断点删除后才可用。</p>

<hr />

<p>在调试的时候通常用catchpoints来捕获事件，如c++的异常等。捕获点的设置通过catch与tcatch两个命令。</p>

<p>tcatch所设置的断点停止一次后自动删除，设置断点的方法与catch相同。</p>

<p>用法：catch event</p>

<p>这些event事件如下：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>throw
</span><span class='line'>    The throwing of a C++ exception.
</span><span class='line'>catch
</span><span class='line'>    The catching of a C++ exception.
</span><span class='line'>exception&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;exception unhandled
</span><span class='line'>An exception that was raised but is not handled by the program.
</span><span class='line'>assert
</span><span class='line'>Ada 语言 assert断言失败时，断点被踩到。
</span><span class='line'>exec
</span><span class='line'>调用exec时断点被踩到。
</span><span class='line'>syscall
</span><span class='line'>syscall [name | number] ...
</span><span class='line'>通过系统函数的名称和系统号，来设置捕获点，当所设定的系统调用时，断点被踩到。
</span><span class='line'>因为经常在linux用c语言，所以主要用到的event是最后四个，其他的没有仔细研究。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>例如：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;catch syscall open
</span><span class='line'>catch syscall 5
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;这两个捕获断点一样。
</span><span class='line'>
</span><span class='line'>--------------
</span><span class='line'>
</span><span class='line'>断点的删除与断点的设置同样的重要。删除断点的命令有两个: delete, clear
</span><span class='line'>
</span><span class='line'>##### delete
</span><span class='line'>用法：  
</span><span class='line'>delete [breakpoints num] [range...]
</span><span class='line'>
</span><span class='line'>delete可删除单个断点，也可删除一个断点的集合，这个集合用连续的断点号来描述。
</span><span class='line'>
</span><span class='line'>例如：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;delete 5
</span><span class='line'>delete 1-10
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### clear
</span><span class='line'>用法:  
</span><span class='line'>clear  
</span><span class='line'>删除所在行的多有断点。
</span><span class='line'>
</span><span class='line'>clear location  
</span><span class='line'>clear 删除所选定的环境中所有的断点  
</span><span class='line'>clear location location描述具体的断点。  
</span><span class='line'>
</span><span class='line'>例如：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;clear list_insert         //删除函数的所有断点
</span><span class='line'>clear list.c:list_delet   //删除文件：函数的所有断点
</span><span class='line'>clear 12                  //删除行号的所有断点
</span><span class='line'>clear list.c:12           //删除文件：行号的所有断点
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;clear 删除断点是基于行的，不是把所有的断点都删除。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[gdb 修改寄存器/变量]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/07/21/debug-gdb-info-set/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-07-21T15:34:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/07/21/debug-gdb-info-set&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;pre&gt;&lt;code&gt;    # 查看所有寄存器
</span><span class='line'>(gdb) info register  # 可以简写成 i r
</span><span class='line'>
</span><span class='line'># 查看单个寄存器
</span><span class='line'>(gdb) i r rax
</span><span class='line'>
</span><span class='line'># 修改寄存器
</span><span class='line'>(gdb) set $rax=3
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'># 查看变量
</span><span class='line'>(gdb) i local
</span><span class='line'>
</span><span class='line'># 修改变量
</span><span class='line'>(gdb) set var b=4
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[crash kmem]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/07/02/debug-crash-kmem/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-07-02T10:29:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/07/02/debug-crash-kmem&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;h4&gt;一、kmem -s 查看slab&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    crash&gt; kmem -s
</span><span class='line'>CACHE            NAME                 OBJSIZE  ALLOCATED     TOTAL  SLABS  SSIZE
</span><span class='line'>...
</span><span class='line'>ffff8808132d1ac0 request_sock_TCP         128          2        30      1     4k
</span><span class='line'>ffff8808135e1400 sock_inode_cache         704        298       470     94     4k
</span><span class='line'>...
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;二、kmem -S 查看slab中详细内容&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    crash&gt; kmem -S request_sock_TCP
</span><span class='line'>CACHE            NAME                 OBJSIZE  ALLOCATED     TOTAL  SLABS  SSIZE
</span><span class='line'>ffff8808132d1ac0 request_sock_TCP         128          2        30      1     4k
</span><span class='line'>SLAB              MEMORY            TOTAL  ALLOCATED  FREE
</span><span class='line'>ffff88078b9c6000  ffff88078b9c60c0     30          2    28
</span><span class='line'>FREE / [ALLOCATED]
</span><span class='line'>   ffff88078b9c60c0
</span><span class='line'>   ffff88078b9c6140
</span><span class='line'>   ffff88078b9c61c0
</span><span class='line'>   ffff88078b9c6240
</span><span class='line'>   ffff88078b9c62c0
</span><span class='line'>   ffff88078b9c6340
</span><span class='line'>   ffff88078b9c63c0
</span><span class='line'>   ffff88078b9c6440
</span><span class='line'>   ffff88078b9c64c0
</span><span class='line'>   ffff88078b9c6540
</span><span class='line'>   ffff88078b9c65c0
</span><span class='line'>   ffff88078b9c6640
</span><span class='line'>   ffff88078b9c66c0
</span><span class='line'>  [ffff88078b9c6740]
</span><span class='line'>  [ffff88078b9c67c0]
</span><span class='line'>   ffff88078b9c6840
</span><span class='line'>   ffff88078b9c68c0
</span><span class='line'>   ffff88078b9c6940
</span><span class='line'>   ffff88078b9c69c0
</span><span class='line'>...
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;request_sock_TCP 是 struct request_sock 类型，所以对于已分配的地址可以直接查看&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    crash&gt; struct request_sock 0xffff88078b9c6740
</span><span class='line'>struct request_sock {
</span><span class='line'>  dl_next = 0x0, 
</span><span class='line'>  mss = 1460, 
</span><span class='line'>  retrans = 0 '\000', 
</span><span class='line'>  cookie_ts = 0 '\000', 
</span><span class='line'>  window_clamp = 8388480, 
</span><span class='line'>  rcv_wnd = 14600, 
</span><span class='line'>  ts_recent = 0, 
</span><span class='line'>  expires = 4302901768, 
</span><span class='line'>  rsk_ops = 0xffffffff81c0e840 &lt;tcp_request_sock_ops&gt;, 
</span><span class='line'>  sk = 0xffff880771dad800, 
</span><span class='line'>  secid = 3039208612, 
</span><span class='line'>  peer_secid = 3672081930
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://blog.csdn.net/u011279649/article/details/17529315"&gt;http://blog.csdn.net/u011279649/article/details/17529315&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[SystemTap---嵌入C代码]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/06/01/debug-systemtap-with-c/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-06-01T15:36:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/06/01/debug-systemtap-with-c&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;ul&gt;
</span><span class='line'>&lt;li&gt;访问参数的值是以STAP_ARG_+参数名的形式，这种方式是最新版本的SystemTap中的方式。1.7及更早的版本是通过THIS-&gt;+参数名的方式, 返回值&lt;code&gt;THIS-&gt;__returnval&lt;/code&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://www.4byte.cn/learning/53860.html"&gt;http://www.4byte.cn/learning/53860.html&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  SystemTap支持guru模式，通过-g选项来以这种模式执行SystemTap脚本。在guru模式下，嵌入的C代码在“%{&ldquo;和“%}"标记之间，这些代码会原封不动地放到生成的模块中。嵌入的C代码不仅可以作为函数体，还可以出现在SystemTap描述中（例如函数等），示例如下：</span></code></pre></td></tr></table></div></figure>
    %{
        #include &lt;linux/in.h>
        #include &lt;linux/ip.h>
    %} /<em> &lt;&ndash; top level </em>/</p>

<pre><code>function read_iphdr:long(skb:long)
%{
    struct iphdr *iph = ip_hdr((struct sk_buff *)STAP_ARG_skb);
    STAP_RETVALUE = (long)iph;
%}

/* Determines whether an IP packet is TCP, based on the iphdr: */
function is_tcp_packet:long(iphdr)
{
    protocol = @cast(iphdr, "iphdr")-&gt;protocol
    return (protocol == %{ IPPROTO_TCP %}) /* &lt;-- expression */
}

probe begin {
    printf("SystemTap start!\n");
}

probe kernel.function("ip_local_deliver") {
    iph = read_iphdr(pointer_arg(1));
    printf("tcp packet ? %s\n", is_tcp_packet(iph) ? "yes" : "no");
}
</code></pre>

<pre><code>
在这里read_iphdr函数就是使用嵌入的C代码作为函数体，is_tcp_packet中是作为systemtap辅助函数中的一部分。

在使用嵌入C代码作为函数体的函数中，访问参数的值是以STAP_ARG_+参数名的形式，这种方式是最新版本的SystemTap中的方式。1.7及更早的版本是通过THIS-&gt;+参数名的方式。CentOS6.4中的SystemTap版本是1.8，所以你如果在SystemTap脚本中仍然使用老的访问方式会报错。同样，最新的设置返回值的方式是STAP_RETVALUE，1.7及更早的版本是THIS-&gt;__retvalue。

由于在guru模式下，SystemTap对嵌入的C代码没有做任何的处理，所以如果在C代码中出现异常的访问或者其他错误，就会导致内核crash。不过SystemTap提供了kread宏来安全地访问指针，如下所示：
</code></pre>

<pre><code>struct net_device *dev;
char *name;
dev = kread(&amp;(skb-&gt;dev));
name = kread(&amp;(dev-&gt;name));
</code></pre>

<p>```</p>

<p>还有一点要特别注意，所有的SystemTap函数和probe都是在关闭中断下执行，所以在所有嵌入的C代码中都不能睡眠！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SystemTap Beginner]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/06/01/debug-systemtap-beginner/"/>
    <updated>2015-06-01T15:03:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/06/01/debug-systemtap-beginner</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/kafeiflynn/article/details/6429976">http://blog.csdn.net/kafeiflynn/article/details/6429976</a></p>

<h3>SystemTap</h3>

<p>应用：</p>

<p>  对管理员，SystemTap可用于监控系统性能，找出系统瓶颈，而对于开发者，可以查看他们的程序运行时在linux系统内核内部的运行情况。主要用于查看内核空间事件信息，对用户空间事件的探测，目前正加紧改进。</p>

<h4>安装</h4>

<p>1、SystemTap的安装及使用需要针对正在使用的内核安装相应的kernel-devel、kernel-debuginfo和kernel-debuginfo-common包，以插入探针。<br/>
2、安装SystemTap和SystemTap-runtime包<br/>
3、使用如下命令测试一下：</p>

<pre><code>    stap -v -e 'probe vfs.read {printf("read performed/n"); exit()}'
</code></pre>

<p>为目标机产生SystemTap instrumentation:</p>

<p>这样就可以在一台机器上为多种内核产生SystemTap instrumentation，而且目标机上只安装SystemTap-runtime即可。</p>

<p>操作如下：<br/>
1.在目标机上安装systemtap-runtime RPM包；<br/>
2.使用uname –r查看目标机内核；<br/>
3.在host system上安装SystemTap；<br/>
4.在host system上安装目标机内核及相关RPMs<br/>
5.在host name上运行命令：<br/>
<code>
    stap -r kernel_version script -m module_name
</code></p>

<p>6.把新产生的模块拷贝到目标机，并运行如下命令：
<code>
    staprun module_name.ko
</code></p>

<p>注意：host system和目标机架构及操作系统版本必须一致。</p>

<h4>运行SystemTap脚本</h4>

<p>运行stap和staprun需要被授以权限，一般用户需要运行SystemTap，则需要被加入到以下用户组的一个：<br/>
1、stapdev：用stap编译SystemTap脚本成内核模块，并加载进内核；<br/>
2、stapusr：仅能运行staprun加载/lib/modules/kernel_version/systemtap/目录下模块。</p>

<h5>SystemTap Flight Recorder模式</h5>

<p>该模式允许长时间运行SystemTap脚本，但仅focus on 最近的输出，有2个变种：in-memory和file模式，两种情况下SystemTap都作为后台进程运行。</p>

<h5>In-memory模式：</h5>

<pre><code>    stap -F iotime.stp
</code></pre>

<p>一旦脚本启动后，你可以看到以下输出信息以辅助命令重新连到运行中的脚本：
<code>
    Disconnecting from systemtap module.
    To reconnect, type "staprun -A stap_5dd0073edcb1f13f7565d8c343063e68_19556"
</code>
当感兴趣的事件发生时，可以重新连接到运行中的脚本，并在内存Buffer中输出最近的数据并持续输出：
<code>
    staprun -A stap_5dd0073edcb1f13f7565d8c343063e68_19556
</code>
内存Buffer默认1MB，可以使用-S选项，例如-S2指定为2MB
<code>
    File Flight Recorder
    stap -F -o /tmp/pfaults.log -S 1,2  pfaults.stp
</code>
命令结果输出到/tmp/pfaults.log.[0-9]，每个文件1MB，并且仅保存最近的两个文件，-S指定了第一个参数：每个输出文件大小1MB，第二个参数：仅保留最近的两个文件，systemtap在pfaults.log后面加.[0-9]后缀。</p>

<p>该命令的输出是systemtap脚本进程ID，使用如下命令可以终止systemtap脚本</p>

<pre><code>    kill -s SIGTERM 7590
</code></pre>

<p>运行
```
    ls –sh /tmp/pfaults.log.*</p>

<pre><code>1020K /tmp/pfaults.log.5    44K /tmp/pfaults.log.6
</code></pre>

<pre><code>
#### SystemTap如何工作

SystemTap的基本工作原理就是：event/handler，运行systemtap脚本产生的加载模块时刻监控事件的发生，一旦发生，内核就调用相关的handler处理。

一运行一个SystemTap脚本就会产生一个SystemTap session：  
1.SystemTap检查脚本以及所使用的相关tapset库；  
2.SystemTap将脚本转换成C语言文件，并运行C语言编译器编译之创建一个内核模块；  
3.SystemTap加载该模块，从而使用所有探针(events和handlers)；  
4.事件发生时，执行相关handlers  
5.一旦SystemTap session停止，则探针被禁止，该内核模块被卸载。  

探针：event及其handler，一个SystemTap脚本可以包含多个探针。

SystemTap脚本以.stp为扩展名，其基本格式如下所示：
</code></pre>

<pre><code>probe event {statements}
</code></pre>

<pre><code>
允许一个探针内多个event，以,隔开，任一个event发生时，都会执行statements，各个语句之间不需要特殊的结束符号标记。而且可以在一个statements block中包含其他的statements block。

函数编写：
</code></pre>

<pre><code>function function_name(arguments) {statements}

probe event {function_name(arguments)}
</code></pre>

<pre><code>
#### SystemTap Event

可大致划分为synchronous和asynchronous。

##### 同步事件：

执行到定位到内核代码中的特定位置时触发event

1.syscall.system_call  
系统调用入口和exit处：syscall.system_call和syscall.system_call.return，比如对于close系统调用：syscall.close和syscall.close.return

2.vfs.file_operation  
vfs.file_operation和vfs.file_operation.return

3.kernel.function("function")  
如：kernel.function(“sys_open”)和kernel.function(“sys_open”).return

可使用*来代表wildcards：
</code></pre>

<pre><code>probe kernel.function("*@net/socket.c") { }
probe kernel.function("*@net/socket.c").return { }
</code></pre>

<pre><code>
代表了net/socket.c中所有函数的入口和exit口。

4.kernel.trace("tracepoint")  
2.6.30及newer为内核中的特定事件定义了instrumentation，入kernel.trace(“kfree_skb”)代表内核中每次网络buffer被释放掉时的event。

5.module("module").function("function")
</code></pre>

<pre><code>probe module("ext3").function("*") { }
probe module("ext3").function("*").return { }
</code></pre>

<pre><code>
系统内核模块多存放在/lib/modules/kernel_version

#### Asynchronous Events

不绑定到内核的特定指令或位置处。包括：  
1、begin：SystemTap session开始时触发，当SystemTap脚本开始运行时触发；  
2、end ：SystemTap session终止时触发；  
3、timer事件：  
</code></pre>

<pre><code>probe timer.s(4)
{
    printf("hello world/n")
}
</code></pre>

<pre><code>
• timer.ms(milliseconds)  
• timer.us(microseconds)  
• timer.ns(nanoseconds)  
• timer.hz(hertz)  
• timer.jiffies(jiffies)

可查看man stapprobes来查看其它支持的events

#### SystemTap Handler/Body

支持的函数：  
1、  printf ("format string/n", arguments)，%s：字符串，%d数字，以 , 隔开；  
2、  tid()：当前线程ID；  
3、  uid()：当前用户ID；  
4、  cpu()：当前CPU号；  
5、  gettimeofday_s()：自从Epoch开始的秒数；  
6、  ctime()将从Unix Epoch开始的秒数转换成date；  
7、  pp()：描述当前被处理的探针点的字符串；  
8、  thread_indent()：  
</code></pre>

<pre><code>probe kernel.function("*@net/socket.c")
{
    printf ("%s -&gt; %s/n", thread_indent(1), probefunc())
}

probe kernel.function("*@net/socket.c").return
{
    printf ("%s &lt;- %s/n", thread_indent(-1), probefunc())
}

0 ftp(7223): -&gt; sys_socketcall
1159 ftp(7223):  -&gt; sys_socket
2173 ftp(7223):   -&gt; __sock_create
2286 ftp(7223):    -&gt; sock_alloc_inode
2737 ftp(7223):    &lt;- sock_alloc_inode
3349 ftp(7223):    -&gt; sock_alloc
3389 ftp(7223):    &lt;- sock_alloc
3417 ftp(7223):   &lt;- __sock_create
4117 ftp(7223):   -&gt; sock_create
4160 ftp(7223):   &lt;- sock_create
4301 ftp(7223):   -&gt; sock_map_fd
4644 ftp(7223):    -&gt; sock_map_file
4699 ftp(7223):    &lt;- sock_map_file
4715 ftp(7223):   &lt;- sock_map_fd
4732 ftp(7223):  &lt;- sys_socket
4775 ftp(7223): &lt;- sys_socketcall
</code></pre>

<pre><code>
  函数thread_indent()只有1个参数：代表对线程的”indentation counter”的增减数，即系统调用显示的步数，返回字符串(自从第一次调用thread_indent()以来的描述：进程名(进程ID))

9、name  
标记系统调用的名字，仅用于syscall.system_call中。

10、target()  
与stap script -x process ID or stap script -c command联合使用，如果想在脚本中获得进程ID或命令可以如此做
</code></pre>

<pre><code>probe syscall.* {
    if (pid() == target())
        printf("%s/n", name)
}
</code></pre>

<pre><code>
#### SystemTap Handler构造

##### 变量
1、不必事先声明，直接使用即可，由SystemTap自动判断其属于string还是integer，整数则默认为0，默认在probe中声明的是local变量  
2、在各个probe之间共享的变量使用global声明  
</code></pre>

<pre><code>global count_jiffies, count_ms
probe timer.jiffies(100) { count_jiffies ++ }
probe timer.ms(100) { count_ms ++ }
probe timer.ms(12345)
{
    hz=(1000*count_jiffies) / count_ms
    printf ("jiffies:ms ratio %d:%d =&gt; CONFIG_HZ=%d/n",
        count_jiffies, count_ms, hz)
    exit()
}
</code></pre>

<pre><code>
##### Target变量

Probe event可以映射到代码的实际位置，如kernel.function(“function”)、kernel.statement(“statement”)，这允许使用target变量来记录代码中指定位置处可视变量的值。

运行如下命令：可以显示指定vfs_read处可视target变量
</code></pre>

<pre><code>stap -L 'kernel.function("vfs_read")'
</code></pre>

<pre><code>
显示
</code></pre>

<pre><code>kernel.function("vfs_read@fs/read_write.c:277") $file:struct file* $buf:char* $count:size_t

$pos:loff_t*
</code></pre>

<pre><code>
每个target变量以$开头：变量类型。如果是结构体类型，则SystemTap可以使用-&gt;来查看其成员。对基本类型，integer或string，SystemTap有函数可以直接读取address处的值，如：
</code></pre>

<pre><code># 好像有时对于小于8位的函数，会取出8为长度的值
kernel_char(address)
Obtain the character at address from kernel memory.

kernel_short(address)
Obtain the short at address from kernel memory.

kernel_int(address)
Obtain the int at address from kernel memory.

kernel_long(address)
Obtain the long at address from kernel memory

kernel_string(address)
Obtain the string at address from kernel memory.

kernel_string_n(address, n)
Obtain the string at address from the kernel memory and limits the string to n bytes.
</code></pre>

<pre><code>
##### 打印target变量
</code></pre>

<pre><code>$$vars：类似sprintf("parm1=%x ... parmN=%x var1=%x ... varN=%x", parm1, ..., parmN, var1, ..., varN)，目的是打印probe点处的每个变量；

$$locals：$$vars子集，仅打印local变量；

$$parms：$$vars子集，仅包含函数参数；

$$return：仅在return probes存在，类似sprintf("return=%x", $return)，如果没有返回值，则是空串
</code></pre>

<pre><code>
例子如下：
</code></pre>

<pre><code>stap -e 'probe kernel.function("vfs_read") {printf("%s/n", $$parms); exit(); }'
</code></pre>

<pre><code>
函数vfs_read有4个参数：file、buf、count和pos，输出如下：
</code></pre>

<pre><code>file=0xffff8800b40d4c80 buf=0x7fff634403e0 count=0x2004 pos=0xffff8800af96df48
</code></pre>

<pre><code>如果你想知道数据结构里面的成员信息，可以在”$$params”后面加一个”$”，如下所示：
</code></pre>

<pre><code>stap -e 'probe kernel.function("vfs_read") {printf("%s/n", $$parms$); exit(); }'
</code></pre>

<pre><code>输出如下：
</code></pre>

<pre><code>file={.f_u={...}, .f_path={...}, .f_op=0xffffffffa06e1d80, .f_lock={...}, .f_count={...}, .f_flags=34818, buf="" count=8196 pos=-131938753921208
</code></pre>

<pre><code>
仅一个”$”表示，不展开数据结构域成员，如想展开，则需使用”$$”
</code></pre>

<pre><code>stap -e 'probe kernel.function("vfs_read") {printf("%s/n", parms); exit(); }'
</code></pre>

<pre><code>
输出受限于最大字符串大小：
</code></pre>

<pre><code>file={.f_u={.fu_list={.next=0xffff8801336ca0e8, .prev=0xffff88012ded0840}, .fu_rcuhead={.next=0xffff8801336ca0e8
</code></pre>

<pre><code>
##### 强制类型转换

大多数情况下，SystemTap都可以从debuginfo中获得变量类型，但对于代码中void指针则debuginfo中类型信息不可用，同样probe handler里面的类型信息在function里面也不可用，怎么办呢？

SystemTap函数参数使用long来代替typed pointer，SystemTap的@cast操作可以指出对象正确类型：
</code></pre>

<pre><code>function task_state:long (task:long)
{
    return @cast(task, "task_struct", "kernel&lt;linux/sched.h&gt;")-&gt;state
}
</code></pre>

<pre><code>
第一个参数是指向对象的指针， 第二个参数是将该对象(参数1)要强制类型转换成的类型，第三个参数指出类型定义的出处，是可选的。

##### 检查Target变量可用性

随着代码运行，变量可能失效，因此需要用@defined来判断该变量是否可用：
</code></pre>

<pre><code>probe vm.pagefault = kernel.function("__handle_mm_fault@mm/memory.c") ?,

kernel.function("handle_mm_fault@mm/memory.c") ?
{
    name = "pagefault"
    write_access = (@defined($flags) ? $flags &amp; FAULT_FLAG_WRITE : $write_access)
    address = $address
}
</code></pre>

<pre><code>
##### 条件语句
</code></pre>

<pre><code>if (condition)
    statement1
else
    statement2
</code></pre>

<pre><code></code></pre>

<pre><code>global countread, countnonread
probe kernel.function("vfs_read"),kernel.function("vfs_write")
{
    if (probefunc()=="vfs_read")
        countread ++
    else
        countnonread ++
}

probe timer.s(5) { exit() }

probe end
{
    printf("VFS reads total %d/n VFS writes total %d/n", countread, countnonread)
}
</code></pre>

<pre><code>
##### 循环语句
</code></pre>

<pre><code>while (condition)
    statement

for (initialization; conditional; increment) statement
</code></pre>

<pre><code>
##### 比较：
</code></pre>

<pre><code>==、&gt;=、&lt;=、!=
</code></pre>

<pre><code>
##### 命令行参数：
使用$标志着希望输入的是integer类型命令行参数，@：string
</code></pre>

<pre><code>probe kernel.function(@1) { }
probe kernel.function(@1).return { }
</code></pre>

<pre><code>
#### 关联数组

关联数组一般在multiple probes里面处理，所以必须声明为global，不管是在一个还是多个probes里面用，要读取数组成员值，可以：
</code></pre>

<pre><code>array_name[index_expression]
</code></pre>

<pre><code>如下所示：
</code></pre>

<pre><code>foo["tom"] = 23
foo["dick"] = 24
foo["harry"] = 25
</code></pre>

<pre><code>
一个索引可以包含最多9个索引表达式，用 , 隔开：
</code></pre>

<pre><code>device[pid(),execname(),uid(),ppid(),"W"] = devname
</code></pre>

<pre><code>
##### SystemTap的数组操作

###### 赋值：
</code></pre>

<pre><code>array_name[index_expression] = value
</code></pre>

<pre><code>例子：索引和值可以使用handler function：
</code></pre>

<pre><code>foo[tid()] = gettimeofday_s()
</code></pre>

<pre><code>
每次触发这个语句，多次后就会构成一个关联数组，如果tid()返回值在foo索引中已有一个，则用新值代替旧值。

###### 读取数组值：
</code></pre>

<pre><code>delta = gettimeofday_s() - foo[tid()]
</code></pre>

<pre><code>
如果无法找到指定”索引”对应的值，则数组读返回0(int)或null/empty值(string)

###### 增加关联数组值
</code></pre>

<pre><code>array_name[index_expression] ++
</code></pre>

<pre><code>
处理数组的多个成员：
</code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname()] ++
}

probe timer.s(3)
{
    foreach (count in reads)
    printf("%s : %d /n", count, reads[count])
}
</code></pre>

<pre><code>
这个foreach无序打印所有reads数组值，如果想升序/降序，则需要使用升序(+)、降序(-)，也可以限制处理的数组数目：
</code></pre>

<pre><code>probe timer.s(3)
{
    foreach (count in reads- limit 10)
    printf("%s : %d /n", count, reads[count])
}
</code></pre>

<pre><code>
##### Clearing/Deleting数组和数组成员
</code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname()] ++
}

probe timer.s(3)
{
    foreach (count in reads)
    printf("%s : %d /n", count, reads[count])

    delete reads
}
</code></pre>

<pre><code>
使用delete操作来删除数组成员或整个数组。
</code></pre>

<pre><code>global reads, totalreads
probe vfs.read
{
    reads[execname()] ++
    totalreads[execname()] ++
}

probe timer.s(3)
{
    printf("=======/n")
    foreach (count in reads-)
        printf("%s : %d /n", count, reads[count])
    delete reads
}

probe end
{
    printf("TOTALS/n")
    foreach (total in totalreads-)
    printf("%s : %d /n", total, totalreads[total])
}
</code></pre>

<pre><code>
在if语句中使用数组：
</code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname()] ++
}

probe timer.s(3)
{
    printf("=======/n")
    foreach (count in reads-)
    if (reads[count] &gt;= 1024)
        printf("%s : %dkB /n", count, reads[count]/1024)
    else
        printf("%s : %dB /n", count, reads[count])
}
</code></pre>

<pre><code>
##### 检查成员

可以检查是否一个指定健是数组键值：
</code></pre>

<pre><code>if([index_expression] in array_name) statement
</code></pre>

<pre><code></code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname()] ++
}

probe timer.s(3)
{
    printf("=======/n")
    foreach (count in reads+)
        printf("%s : %d /n", count, reads[count])
    if(["stapio"] in reads) {
        printf("stapio read detected, exiting/n")
        exit()
    }
}
</code></pre>

<pre><code>
##### 计算统计集合

统计集合用于收集数值的统计信息，用于计算新值
</code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname()] &lt;&lt;&lt; count
}
</code></pre>

<pre><code>
操作符&lt;&lt;&lt;用于将count返回的值存放在read数组中execname()相关的值中，即一个键值关联多个相关值。

为计算统计信息，使用@extractor(variable/array index expression)，extractor可以是如下integer extractor：
</code></pre>

<pre><code>count：@count(writes[execname()])返回存放在writes数组中某单一键值对应的值数目；
sum：@sum(writes[execname()])返回在writes数组中某单一键值对应的值的和
min：最小值
max：最大值
avg：variable/array作为索引的统计集合中数据的平均值
</code></pre>

<pre><code></code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname(),pid()] &lt;&lt;&lt; 1
}

probe timer.s(3)
{
    foreach([var1,var2] in reads)
    printf("%s (%d) : %d /n", var1, var2, @count(reads[var1,var2]))
}
</code></pre>

<p>```</p>

<h4>Tapsets</h4>

<p>Tapsets是脚本库，里面预写好了probes和functions可以被SystemTap脚本调用，tapsets也使用.stp作为后缀，默认位于：/usr/share/systemtap/tapset，但无法直接运行。</p>
]]></content>
  </entry>
  
</feed>
