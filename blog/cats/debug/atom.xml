<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-07-27T18:24:50+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[系统级性能分析工具 --- Perf]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/27/debug-perf/"/>
    <updated>2015-07-27T17:09:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/27/debug-perf</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/37902159">http://blog.csdn.net/zhangskd/article/details/37902159</a></p>

<p>从2.6.31内核开始，linux内核自带了一个性能分析工具perf，能够进行函数级与指令级的热点查找。</p>

<h4>perf</h4>

<p>Performance analysis tools for Linux.<br/>
Performance counters for Linux are a new kernel-based subsystem that provide a framework for all things performance analysis. It covers hardware level (CPU/PMU, Performance Monitoring Unit) features and software features (software counters, tracepoints) as well.</p>

<p>perf是内置于Linux内核源码树中的性能剖析(profiling)工具。</p>

<p>它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。</p>

<p>常用于性能瓶颈的查找与热点代码的定位。</p>

<p>CPU周期(cpu-cycles)是默认的性能事件，所谓的CPU周期是指CPU所能识别的最小时间单元，通常为亿分之几秒，是CPU执行最简单的指令时所需要的时间，例如读取寄存器中的内容，也叫做clock tick。</p>

<p>perf是一个包含22种子工具的工具集，以下是最常用的5种：
<code>
    perf list
    perf stat
    perf top
    perf record
    perf report
</code></p>

<hr />

<h4>perf list</h4>

<p>perf list用来查看perf所支持的性能事件，有软件的也有硬件的。</p>

<p>List all symbolic event types.
<code>
    perf list [hw | sw | cache | tracepoint | event_glob]
</code></p>

<h5>(1) 性能事件的分布</h5>

<p>hw：Hardware event，9个<br/>
sw：Software event，9个<br/>
cache：Hardware cache event，26个<br/>
tracepoint：Tracepoint event，775个</p>

<p>sw实际上是内核的计数器，与硬件无关。<br/>
hw和cache是CPU架构相关的，依赖于具体硬件。<br/>
tracepoint是基于内核的ftrace，主线2.6.3x以上的内核版本才支持。</p>

<h5>(2) 指定性能事件(以它的属性)</h5>

<pre><code>    -e &lt;event&gt; : u // userspace
    -e &lt;event&gt; : k // kernel
    -e &lt;event&gt; : h // hypervisor
    -e &lt;event&gt; : G // guest counting (in KVM guests)
    -e &lt;event&gt; : H // host counting (not in KVM guests)
</code></pre>

<h5>(3) 使用例子</h5>

<p>显示内核和模块中，消耗最多CPU周期的函数：
<code>
    # perf top -e cycles:k
</code>
显示分配高速缓存最多的函数：
<code>
    # perf top -e kmem:kmem_cache_alloc
</code></p>

<hr />

<h4>perf top</h4>

<p>对于一个指定的性能事件(默认是CPU周期)，显示消耗最多的函数或指令。</p>

<p>System profiling tool.<br/>
Generates and displays a performance counter profile in real time.<br/>
<code>
    perf top [-e &lt;EVENT&gt; | --event=EVENT] [&lt;options&gt;]
</code></p>

<p>perf top主要用于实时分析各个函数在某个性能事件上的热度，能够快速的定位热点函数，包括应用程序函数、模块函数与内核函数，甚至能够定位到热点指令。默认的性能事件为cpu cycles。</p>

<h5>(1) 输出格式</h5>

<pre><code>    # perf top

    Samples: 1M of event 'cycles', Event count (approx.): 73891391490
         5.44%  perf              [.] 0x0000000000023256
         4.86%  [kernel]          [k] _spin_lock
         2.43%  [kernel]          [k] _spin_lock_bh
         2.29%  [kernel]          [k] _spin_lock_irqsave
         1.77%  [kernel]          [k] __d_lookup
         1.55%  libc-2.12.so      [.] __strcmp_sse42
         1.43%  nginx             [.] ngx_vslprintf
         1.37%  [kernel]          [k] tcp_poll
</code></pre>

<p>第一列：符号引发的性能事件的比例，默认指占用的cpu周期比例。<br/>
第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。<br/>
第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库)。[k]表述此符号属于内核或模块。<br/>
第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p>

<h5>(2) 常用交互命令</h5>

<p>h：显示帮助<br/>
UP/DOWN/PGUP/PGDN/SPACE：上下和翻页。<br/>
a：annotate current symbol，注解当前符号。能够给出汇编语言的注解，给出各条指令的采样率。<br/>
d：过滤掉所有不属于此DSO的符号。非常方便查看同一类别的符号。<br/>
P：将当前信息保存到perf.hist.N中。<br/>
s：输入函数，查看函数内部热点。</p>

<h5>(3) 常用命令行参数</h5>

<pre><code>    -e &lt;event&gt;：指明要分析的性能事件。
    -p &lt;pid&gt;：Profile events on existing Process ID (comma sperated list). 仅分析目标进程及其创建的线程。
    -k &lt;path&gt;：Path to vmlinux. Required for annotation functionality. 带符号表的内核映像所在的路径。
    -K：不显示属于内核或模块的符号。
    -U：不显示属于用户态程序的符号。
    -d &lt;n&gt;：界面的刷新周期，默认为2s，因为perf top默认每2s从mmap的内存区域读取一次性能数据。
    -G：得到函数的调用关系图。
    perf top -G [fractal]，路径概率为相对值，加起来为100%，调用顺序为从下往上。
    perf top -G graph，路径概率为绝对值，加起来为该函数的热度。
</code></pre>

<h5>(4) 使用例子</h5>

<pre><code>    # perf top // 默认配置
    # perf top -G // 得到调用关系图
    # perf top -e cycles // 指定性能事件
    # perf top -p 23015,32476 // 查看这两个进程的cpu cycles使用情况
    # perf top -s comm,pid,symbol // 显示调用symbol的进程名和进程号
    # perf top --comms nginx,top // 仅显示属于指定进程的符号
    # perf top --symbols kfree // 仅显示指定的符号
</code></pre>

<hr />

<h4>perf stat</h4>

<p>用于分析指定程序的性能概况。</p>

<p>Run a command and gather performance counter statistics.
<code>
    perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] &lt;command&gt;
    perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] - &lt;command&gt; [&lt;options&gt;]
</code></p>

<h5>(1) 输出格式</h5>

<pre><code>    # perf stat ls

    Performance counter stats for 'ls':

             0.653782 task-clock                #    0.691 CPUs utilized
                    0 context-switches          #    0.000 K/sec
                    0 CPU-migrations            #    0.000 K/sec
                  247 page-faults               #    0.378 M/sec
            1,625,426 cycles                    #    2.486 GHz
            1,050,293 stalled-cycles-frontend   #   64.62% frontend cycles idle
              838,781 stalled-cycles-backend    #   51.60% backend  cycles idle
            1,055,735 instructions              #    0.65  insns per cycle
                                                #    0.99  stalled cycles per insn
              210,587 branches                  #  322.106 M/sec
               10,809 branch-misses             #    5.13% of all branches

          0.000945883 seconds time elapsed
</code></pre>

<p>输出包括ls的执行时间，以及10个性能事件的统计。</p>

<p>task-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized = task-clock / time elapsed，CPU的占用率。<br/>
context-switches：上下文的切换次数。<br/>
CPU-migrations：处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。<br/>
page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。<br/>
cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles / task-clock算出。<br/>
stalled-cycles-frontend：略过。<br/>
stalled-cycles-backend：略过。<br/>
instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。<br/>
branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p>

<h5>(2) 常用参数</h5>

<pre><code>    -p：stat events on existing process id (comma separated list). 仅分析目标进程及其创建的线程。
    -a：system-wide collection from all CPUs. 从所有CPU上收集性能数据。
    -r：repeat command and print average + stddev (max: 100). 重复执行命令求平均。
    -C：Count only on the list of CPUs provided (comma separated list), 从指定CPU上收集性能数据。
    -v：be more verbose (show counter open errors, etc), 显示更多性能数据。
    -n：null run - don't start any counters，只显示任务的执行时间 。
    -x SEP：指定输出列的分隔符。
    -o file：指定输出文件，--append指定追加模式。
    --pre &lt;cmd&gt;：执行目标程序前先执行的程序。
    --post &lt;cmd&gt;：执行目标程序后再执行的程序。
</code></pre>

<h5>(3) 使用例子</h5>

<p>执行10次程序，给出标准偏差与期望的比值：
<code>
    # perf stat -r 10 ls &gt; /dev/null
</code></p>

<p>显示更详细的信息：
<code>
    # perf stat -v ls &gt; /dev/null
</code></p>

<p>只显示任务执行时间，不显示性能计数器：
<code>
    # perf stat -n ls &gt; /dev/null
</code></p>

<p>单独给出每个CPU上的信息：
<code>
    # perf stat -a -A ls &gt; /dev/null
</code></p>

<p>ls命令执行了多少次系统调用：
<code>
    # perf stat -e syscalls:sys_enter ls
</code></p>

<hr />

<h4>perf record</h4>

<p>收集采样信息，并将其记录在数据文件中。随后可以通过其它工具(perf-report)对数据文件进行分析，结果类似于perf-top的。</p>

<p>Run a command and record its profile into perf.data.<br/>
This command runs a command and gathers a performance counter profile from it, into perf.data,without displaying anything. This file can then be inspected later on, using perf report.</p>

<h5>(1) 常用参数</h5>

<pre><code>    -e：Select the PMU event.
    -a：System-wide collection from all CPUs.
    -p：Record events on existing process ID (comma separated list).
    -A：Append to the output file to do incremental profiling.
    -f：Overwrite existing data file.
    -o：Output file name.
    -g：Do call-graph (stack chain/backtrace) recording.
    -C：Collect samples only on the list of CPUs provided.
</code></pre>

<h5>(2) 使用例子</h5>

<p>记录nginx进程的性能数据：
<code>
    # perf record -p `pgrep -d ',' nginx`
</code></p>

<p>记录执行ls时的性能数据：
<code>
    # perf record ls -g
</code></p>

<p>记录执行ls时的系统调用，可以知道哪些系统调用最频繁：
<code>
    # perf record -e syscalls:sys_enter ls
</code></p>

<hr />

<h4>perf report</h4>

<p>读取perf record创建的数据文件，并给出热点分析结果。</p>

<p>Read perf.data (created by perf record) and display the profile.<br/>
This command displays the performance counter profile information recorded via perf record.</p>

<h5>(1) 常用参数</h5>

<pre><code>    -i：Input file name. (default: perf.data)
</code></pre>

<h5>(2) 使用例子</h5>

<pre><code>    # perf report -i perf.data.2
</code></pre>

<hr />

<h3>More</h3>

<p>除了以上5个常用工具外，还有一些适用于较特殊场景的工具， 比如内核锁、slab分配器、调度器，也支持自定义探测点。</p>

<h4>perf lock</h4>

<p>内核锁的性能分析。</p>

<p>Analyze lock events.
<code>
    perf lock {record | report | script | info}
</code></p>

<ul>
<li>需要编译选项的支持：CONFIG_LOCKDEP、CONFIG_LOCK_STAT。</li>
</ul>


<p>CONFIG_LOCKDEP defines acquired and release events.<br/>
CONFIG_LOCK_STAT defines contended and acquired lock events.</p>

<h5>(1) 常用选项</h5>

<pre><code>    -i &lt;file&gt;：输入文件
    -k &lt;value&gt;：sorting key，默认为acquired，还可以按contended、wait_total、wait_max和wait_min来排序。
</code></pre>

<h5>(2) 使用例子</h5>

<pre><code>    # perf lock record ls // 记录
    # perf lock report // 报告
</code></pre>

<h5>(3) 输出格式</h5>

<pre><code>                   Name   acquired  contended total wait (ns)   max wait (ns)   min wait (ns)

    &amp;mm-&gt;page_table_...        382          0               0               0               0
    &amp;mm-&gt;page_table_...         72          0               0               0               0
              &amp;fs-&gt;lock         64          0               0               0               0
            dcache_lock         62          0               0               0               0
          vfsmount_lock         43          0               0               0               0
    &amp;newf-&gt;file_lock...         41          0               0               0               0
</code></pre>

<p>Name：内核锁的名字。<br/>
aquired：该锁被直接获得的次数，因为没有其它内核路径占用该锁，此时不用等待。<br/>
contended：该锁等待后获得的次数，此时被其它内核路径占用，需要等待。<br/>
total wait：为了获得该锁，总共的等待时间。<br/>
max wait：为了获得该锁，最大的等待时间。<br/>
min wait：为了获得该锁，最小的等待时间。</p>

<p>最后还有一个Summary：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>=== output for debug===&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;bad: 10, total: 246  
</span><span class='line'>bad rate: 4.065041 %  
</span><span class='line'>histogram of events caused bad sequence  
</span><span class='line'>acquire: 0  
</span><span class='line'>   acquired: 0  
</span><span class='line'>  contended: 0  
</span><span class='line'>release: 10  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>---------------
</span><span class='line'>
</span><span class='line'>##### perf kmem
</span><span class='line'>
</span><span class='line'>slab分配器的性能分析。
</span><span class='line'>
</span><span class='line'>Tool to trace/measure kernel memory(slab) properties.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;perf kmem {record | stat} [&lt;options&gt;]
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (1) 常用选项
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;--i &lt;file&gt;：输入文件
</span><span class='line'>--caller：show per-callsite statistics，显示内核中调用kmalloc和kfree的地方。
</span><span class='line'>--alloc：show per-allocation statistics，显示分配的内存地址。
</span><span class='line'>-l &lt;num&gt;：print n lines only，只显示num行。
</span><span class='line'>-s &lt;key[,key2...]&gt;：sort the output (default: frag,hit,bytes)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (2) 使用例子
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# perf kmem record ls // 记录
</span><span class='line'># perf kmem stat --caller --alloc -l 20 // 报告
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (3) 输出格式
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;------------------------------------------------------------------------------------------------------
</span><span class='line'> Callsite                           | Total_alloc/Per | Total_req/Per   | Hit      | Ping-pong | Frag
</span><span class='line'>------------------------------------------------------------------------------------------------------
</span><span class='line'> perf_event_mmap+ec                 |    311296/8192  |    155952/4104  |       38 |        0 | 49.902%
</span><span class='line'> proc_reg_open+41                   |        64/64    |        40/40    |        1 |        0 | 37.500%
</span><span class='line'> __kmalloc_node+4d                  |      1024/1024  |       664/664   |        1 |        0 | 35.156%
</span><span class='line'> ext3_readdir+5bd                   |        64/64    |        48/48    |        1 |        0 | 25.000%
</span><span class='line'> load_elf_binary+8ec                |       512/512   |       392/392   |        1 |        0 | 23.438%
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>Callsite：内核代码中调用kmalloc和kfree的地方。  
</span><span class='line'>Total_alloc/Per：总共分配的内存大小，平均每次分配的内存大小。  
</span><span class='line'>Total_req/Per：总共请求的内存大小，平均每次请求的内存大小。  
</span><span class='line'>Hit：调用的次数。  
</span><span class='line'>Ping-pong：kmalloc和kfree不被同一个CPU执行时的次数，这会导致cache效率降低。  
</span><span class='line'>Frag：碎片所占的百分比，碎片 = 分配的内存 - 请求的内存，这部分是浪费的。  
</span><span class='line'>有使用--alloc选项，还会看到Alloc Ptr，即所分配内存的地址。  
</span><span class='line'>
</span><span class='line'>最后还有一个Summary：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;SUMMARY
</span><span class='line'>=======
</span><span class='line'>Total bytes requested: 290544
</span><span class='line'>Total bytes allocated: 447016
</span><span class='line'>Total bytes wasted on internal fragmentation: 156472
</span><span class='line'>Internal fragmentation: 35.003669%
</span><span class='line'>Cross CPU allocations: 2/509
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>---------------
</span><span class='line'>
</span><span class='line'>#### probe sched
</span><span class='line'>
</span><span class='line'>调度模块分析。
</span><span class='line'>
</span><span class='line'>trace/measure scheduler properties (latencies)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;perf sched {record | latency | map | replay | script}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (1) 使用例子 
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# perf sched record sleep 10 // perf sched record &lt;command&gt;
</span><span class='line'># perf report latency --sort max
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (2) 输出格式
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;---------------------------------------------------------------------------------------------------------------
</span><span class='line'> Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at     |
</span><span class='line'>---------------------------------------------------------------------------------------------------------------
</span><span class='line'> events/10:61          |      0.655 ms |       10 | avg:    0.045 ms | max:    0.161 ms | max at: 9804.958730 s
</span><span class='line'> sleep:11156           |      2.263 ms |        4 | avg:    0.052 ms | max:    0.118 ms | max at: 9804.865552 s
</span><span class='line'> edac-poller:1125      |      0.598 ms |       10 | avg:    0.042 ms | max:    0.113 ms | max at: 9804.958698 s
</span><span class='line'> events/2:53           |      0.676 ms |       10 | avg:    0.037 ms | max:    0.102 ms | max at: 9814.751605 s
</span><span class='line'> perf:11155            |      2.109 ms |        1 | avg:    0.068 ms | max:    0.068 ms | max at: 9814.867918 s
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;TASK：进程名和pid。  
</span><span class='line'>Runtime：实际的运行时间。  
</span><span class='line'>Switches：进程切换的次数。  
</span><span class='line'>Average delay：平均的调度延迟。  
</span><span class='line'>Maximum delay：最大的调度延迟。  
</span><span class='line'>Maximum delay at：最大调度延迟发生的时刻。  
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>---------------
</span><span class='line'>
</span><span class='line'>#### perf probe
</span><span class='line'>
</span><span class='line'>可以自定义探测点。
</span><span class='line'>
</span><span class='line'>Define new dynamic tracepoints.
</span><span class='line'>
</span><span class='line'>##### 使用例子
</span><span class='line'>
</span><span class='line'>(1) Display which lines in schedule() can be probed
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# perf probe --line schedule
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;前面有行号的可以探测，没有行号的就不行了。
</span><span class='line'>
</span><span class='line'>(2) Add a probe on schedule() function 12th line.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# perf probe -a schedule:12
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```
</span><span class='line'>在schedule函数的12处增加一个探测点。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Reference&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;[1]. Linux的系统级性能剖析工具系列，by 承刚&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;[2]. &lt;a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/"&gt;http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;[3]. &lt;a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/"&gt;http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;[4]. &lt;a href="https://perf.wiki.kernel.org/index.php/Tutorial"&gt;https://perf.wiki.kernel.org/index.php/Tutorial&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[gdb break/watch/catch]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/07/21/debug-gdb-break/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-07-21T15:49:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/07/21/debug-gdb-break&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://sourceware.org/gdb/current/onlinedocs/gdb"&gt;http://sourceware.org/gdb/current/onlinedocs/gdb&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://blog.csdn.net/yangzhongxuan/article/details/6897968"&gt;gdb break 断点设置（一）&lt;/a&gt;&lt;br/&gt;
</span><span class='line'>&lt;a href="http://blog.csdn.net/yangzhongxuan/article/details/6899186"&gt;gdb watch 断点设置（二）&lt;/a&gt;&lt;br/&gt;
</span><span class='line'>&lt;a href="http://blog.csdn.net/yangzhongxuan/article/details/6901440"&gt;gdb catch 断点设置（三）&lt;/a&gt;&lt;br/&gt;
</span><span class='line'>&lt;a href="http://blog.csdn.net/yangzhongxuan/article/details/6901477"&gt;gdb 断点删除（四）&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;二、断点设置&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;gdb断点分类：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;以设置断点的命令分类：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;breakpoint 可以根据行号、函数、条件生成断点。
</span><span class='line'>watchpoint 监测变量或者表达式的值发生变化时产生断点。
</span><span class='line'>catchpoint 监测信号的产生。例如c++的throw，或者加载库的时候。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;gdb中的变量从1开始标号，不同的断点采用变量标号同一管理，可以 用enable、disable等命令管理，同时支持断点范围的操作，比如有些命令接受断点范围作为参数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;1、break及break变种详解：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;相关命令有break，tbreak，rbreak,hbreak，thbreak，后两种是基于硬件的，先不介绍。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;break 与 tbeak&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;break，tbreak可以根据行号、函数、条件生成断点。tbreak设置方法与break相同，只不过tbreak只在断点停一次，过后会自动将断点删除，break需要手动控制断点的删除和使能。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;break 可带如下参数：&lt;br/&gt;
</span><span class='line'>  linenum            本地行号，即list命令可见的行号&lt;br/&gt;
</span><span class='line'>  filename:linenum   制定个文件的行号&lt;br/&gt;
</span><span class='line'>  function           函数，可以是自定义函数也可是库函数，如open&lt;br/&gt;
</span><span class='line'>  filename:function  制定文件中的函数&lt;br/&gt;
</span><span class='line'>  condtion           条件&lt;br/&gt;
</span><span class='line'>  *address           地址，可是函数，变量的地址，此地址可以通过info add命令得到。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;例如：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>break 10    
</span><span class='line'>break test.c:10
</span><span class='line'>break main
</span><span class='line'>break test.c:main
</span><span class='line'>break system
</span><span class='line'>break open
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如果想在指定的地址设置断点，比如在main函数的地址出设断点。可用info add main 获得main的地址如0x80484624，然后用break *0x80484624.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h6&gt;条件断点&lt;/h6&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;就是在如上述指定断点的同时指定进入断点的条件。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;例如：（假如有int 类型变量 index）
</span><span class='line'>&lt;code&gt;
</span><span class='line'>break 10 if index == 3
</span><span class='line'>tbreak 12 if index == 5
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;rbreak&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;rbreak 可以跟一个规则表达式。rbreak + 表达式的用法与grep + 表达式相似。即在所有与表达式匹配的函数入口都设置断点。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;rbreak list&lt;em&gt;* 即在所有以 list&lt;/em&gt; 为开头字符的函数地方都设置断点。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;rbreak ^list_ 功能与上同。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;查看断点信息&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    info break [break num ]
</span><span class='line'>info break 可列出所有断点信息，info break 后也可设置要查看的break num如：
</span><span class='line'>info break 1 列出断点号是1的断点信息
</span><span class='line'>
</span><span class='line'>Num        Type                    Disp Enb  Address      What
</span><span class='line'> 1       breakpoint                keep y    &lt;MULTIPLE&gt;
</span><span class='line'>     stop only if i==1
</span><span class='line'>     breakpoint already hit 1 time
</span><span class='line'> 1.1                                    y    0x080486a2 in void foo&lt;int&gt;() at t.cc:8
</span><span class='line'> 1.2                                    y    0x080486ca in void foo&lt;double&gt;() at t.cc:8
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;2、watch&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    watch [-l|-location] expr [thread threadnum] [mask maskvalue]
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;-l 与 mask没有仔细研究，thread threadnum 是在多线程的程序中限定只有被线程号是threadnum的线程修改值后进入断点。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;经常用到的如下命令：
</span><span class='line'>watch &lt;expr&gt;&lt;br/&gt;
</span><span class='line'>为表达式（变量）expr设置一个观察点。变量量表达式值有变化时，马上停住程序。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;表达式可以是一个变量, 例如：watch value_a&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;表达式可以是一个地址, 例如：watch &lt;em&gt;(int &lt;/em&gt;)0x12345678 可以检测4个字节的内存是否变化。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;表达式可以是一个复杂的语句表达式, 例如：watch a*b + c/d&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;watch 在有些操作系统支持硬件观测点，硬件观测点的运行速度比软件观测点的快。如果系统支持硬件观测的话，当设置观测点是会打印如下信息：&lt;code&gt;Hardware watchpoint num: expr&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如果不想用硬件观测点的话可如下设置：&lt;code&gt;set can-use-hw-watchpoints&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;watch两个变种 rwatch，awatch，这两个命令只支持硬件观测点如果系统不支持硬件观测点会答应出不支持这两个命令的信息:，&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;rwatch &lt;expr&gt;&lt;br/&gt;
</span><span class='line'>当表达式（变量）expr被读时，停住程序。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;awatch &lt;expr&gt;&lt;br/&gt;
</span><span class='line'>当表达式（变量）的值被读或被写时，停住程序。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;info watchpoints&lt;br/&gt;
</span><span class='line'>列出当前所设置了的所有观察点。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;watch 所设置的断点也可以用控制断点的命令来控制。如 disable、enable、delete等。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;可以为停止点设定运行命令
</span><span class='line'>&lt;code&gt;
</span><span class='line'>commands [bnum]
</span><span class='line'>... command-list ...
</span><span class='line'>end
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;例如：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>break foo if x&gt;0
</span><span class='line'>commands
</span><span class='line'>printf "x is %d/n",x
</span><span class='line'>continue
</span><span class='line'>end
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;断点设置在函数foo中，断点条件是x&gt;0，如果程序被断住后，也就是，一旦x的值在foo函数中大于0，GDB会自动打印出x的值，并继续运行程序。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;注意：watch 设置也是断点，如果调试的时候设置的断点（任何种类的断点）过多的时候，watch断点会被忽略，有时候没有任何提示，这是我在测试的时候发现的，只有把多余的断点删除后才可用。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在调试的时候通常用catchpoints来捕获事件，如c++的异常等。捕获点的设置通过catch与tcatch两个命令。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;tcatch所设置的断点停止一次后自动删除，设置断点的方法与catch相同。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;用法：catch event&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这些event事件如下：</span></code></pre></td></tr></table></div></figure>
    throw
        The throwing of a C++ exception.
    catch
        The catching of a C++ exception.
    exception</p>

<pre><code>exception unhandled
    An exception that was raised but is not handled by the program.
assert
    Ada 语言 assert断言失败时，断点被踩到。
exec
    调用exec时断点被踩到。
syscall
syscall [name | number] ...
    通过系统函数的名称和系统号，来设置捕获点，当所设定的系统调用时，断点被踩到。
    因为经常在linux用c语言，所以主要用到的event是最后四个，其他的没有仔细研究。
</code></pre>

<pre><code>
例如：
</code></pre>

<pre><code>catch syscall open
catch syscall 5
</code></pre>

<pre><code>这两个捕获断点一样。

--------------

断点的删除与断点的设置同样的重要。删除断点的命令有两个: delete, clear

##### delete
用法：  
delete [breakpoints num] [range...]

delete可删除单个断点，也可删除一个断点的集合，这个集合用连续的断点号来描述。

例如：
</code></pre>

<pre><code>delete 5
delete 1-10
</code></pre>

<pre><code>
##### clear
用法:  
clear  
删除所在行的多有断点。

clear location  
clear 删除所选定的环境中所有的断点  
clear location location描述具体的断点。  

例如：
</code></pre>

<pre><code>clear list_insert         //删除函数的所有断点
clear list.c:list_delet   //删除文件：函数的所有断点
clear 12                  //删除行号的所有断点
clear list.c:12           //删除文件：行号的所有断点
</code></pre>

<p>```</p>

<p>clear 删除断点是基于行的，不是把所有的断点都删除。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gdb 修改寄存器/变量]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/21/debug-gdb-info-set/"/>
    <updated>2015-07-21T15:34:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/21/debug-gdb-info-set</id>
    <content type="html"><![CDATA[<pre><code>    # 查看所有寄存器
    (gdb) info register  # 可以简写成 i r

    # 查看单个寄存器
    (gdb) i r rax

    # 修改寄存器
    (gdb) set $rax=3



    # 查看变量
    (gdb) i local

    # 修改变量
    (gdb) set var b=4
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[crash kmem]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/07/02/debug-crash-kmem/"/>
    <updated>2015-07-02T10:29:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/07/02/debug-crash-kmem</id>
    <content type="html"><![CDATA[<h4>一、kmem -s 查看slab</h4>

<pre><code>    crash&gt; kmem -s
    CACHE            NAME                 OBJSIZE  ALLOCATED     TOTAL  SLABS  SSIZE
    ...
    ffff8808132d1ac0 request_sock_TCP         128          2        30      1     4k
    ffff8808135e1400 sock_inode_cache         704        298       470     94     4k
    ...
</code></pre>

<h4>二、kmem -S 查看slab中详细内容</h4>

<pre><code>    crash&gt; kmem -S request_sock_TCP
    CACHE            NAME                 OBJSIZE  ALLOCATED     TOTAL  SLABS  SSIZE
    ffff8808132d1ac0 request_sock_TCP         128          2        30      1     4k
    SLAB              MEMORY            TOTAL  ALLOCATED  FREE
    ffff88078b9c6000  ffff88078b9c60c0     30          2    28
    FREE / [ALLOCATED]
       ffff88078b9c60c0
       ffff88078b9c6140
       ffff88078b9c61c0
       ffff88078b9c6240
       ffff88078b9c62c0
       ffff88078b9c6340
       ffff88078b9c63c0
       ffff88078b9c6440
       ffff88078b9c64c0
       ffff88078b9c6540
       ffff88078b9c65c0
       ffff88078b9c6640
       ffff88078b9c66c0
      [ffff88078b9c6740]
      [ffff88078b9c67c0]
       ffff88078b9c6840
       ffff88078b9c68c0
       ffff88078b9c6940
       ffff88078b9c69c0
    ...
</code></pre>

<p>request_sock_TCP 是 struct request_sock 类型，所以对于已分配的地址可以直接查看</p>

<pre><code>    crash&gt; struct request_sock 0xffff88078b9c6740
    struct request_sock {
      dl_next = 0x0, 
      mss = 1460, 
      retrans = 0 '\000', 
      cookie_ts = 0 '\000', 
      window_clamp = 8388480, 
      rcv_wnd = 14600, 
      ts_recent = 0, 
      expires = 4302901768, 
      rsk_ops = 0xffffffff81c0e840 &lt;tcp_request_sock_ops&gt;, 
      sk = 0xffff880771dad800, 
      secid = 3039208612, 
      peer_secid = 3672081930
    }
</code></pre>

<p><a href="http://blog.csdn.net/u011279649/article/details/17529315">http://blog.csdn.net/u011279649/article/details/17529315</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SystemTap---嵌入C代码]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/06/01/debug-systemtap-with-c/"/>
    <updated>2015-06-01T15:36:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/06/01/debug-systemtap-with-c</id>
    <content type="html"><![CDATA[<ul>
<li>访问参数的值是以STAP_ARG_+参数名的形式，这种方式是最新版本的SystemTap中的方式。1.7及更早的版本是通过THIS->+参数名的方式, 返回值<code>THIS-&gt;__returnval</code></li>
</ul>


<hr />

<p><a href="http://www.4byte.cn/learning/53860.html">http://www.4byte.cn/learning/53860.html</a></p>

<p>  SystemTap支持guru模式，通过-g选项来以这种模式执行SystemTap脚本。在guru模式下，嵌入的C代码在“%{&ldquo;和“%}"标记之间，这些代码会原封不动地放到生成的模块中。嵌入的C代码不仅可以作为函数体，还可以出现在SystemTap描述中（例如函数等），示例如下：
```
    %{
        #include &lt;linux/in.h>
        #include &lt;linux/ip.h>
    %} /<em> &lt;&ndash; top level </em>/</p>

<pre><code>function read_iphdr:long(skb:long)
%{
    struct iphdr *iph = ip_hdr((struct sk_buff *)STAP_ARG_skb);
    STAP_RETVALUE = (long)iph;
%}

/* Determines whether an IP packet is TCP, based on the iphdr: */
function is_tcp_packet:long(iphdr)
{
    protocol = @cast(iphdr, "iphdr")-&gt;protocol
    return (protocol == %{ IPPROTO_TCP %}) /* &lt;-- expression */
}

probe begin {
    printf("SystemTap start!\n");
}

probe kernel.function("ip_local_deliver") {
    iph = read_iphdr(pointer_arg(1));
    printf("tcp packet ? %s\n", is_tcp_packet(iph) ? "yes" : "no");
}
</code></pre>

<pre><code>
在这里read_iphdr函数就是使用嵌入的C代码作为函数体，is_tcp_packet中是作为systemtap辅助函数中的一部分。

在使用嵌入C代码作为函数体的函数中，访问参数的值是以STAP_ARG_+参数名的形式，这种方式是最新版本的SystemTap中的方式。1.7及更早的版本是通过THIS-&gt;+参数名的方式。CentOS6.4中的SystemTap版本是1.8，所以你如果在SystemTap脚本中仍然使用老的访问方式会报错。同样，最新的设置返回值的方式是STAP_RETVALUE，1.7及更早的版本是THIS-&gt;__retvalue。

由于在guru模式下，SystemTap对嵌入的C代码没有做任何的处理，所以如果在C代码中出现异常的访问或者其他错误，就会导致内核crash。不过SystemTap提供了kread宏来安全地访问指针，如下所示：
</code></pre>

<pre><code>struct net_device *dev;
char *name;
dev = kread(&amp;(skb-&gt;dev));
name = kread(&amp;(dev-&gt;name));
</code></pre>

<p>```</p>

<p>还有一点要特别注意，所有的SystemTap函数和probe都是在关闭中断下执行，所以在所有嵌入的C代码中都不能睡眠！</p>
]]></content>
  </entry>
  
</feed>
