<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2016-03-21T14:03:53+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[kdump时间错误]]></title>
    <link href="http://abcdxyzk.github.io/blog/2016/01/12/debug-kdump-rtc/"/>
    <updated>2016-01-12T15:39:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2016/01/12/debug-kdump-rtc</id>
    <content type="html"><![CDATA[<p><a href="/blog/2016/01/06/debug-mark-rtc/">CentOS 5.x安装新内核之后时钟混乱问题</a></p>

<p>解决kdump的vmcore保存的目录的时间错误问题</p>

<pre><code>    diff --git a/mkdumprd b/mkdumprd
    index d567085..7d946f4 100755
    --- a/mkdumprd
    +++ b/mkdumprd
    @@ -2279,12 +2279,19 @@ mknod /dev/systty c 4 0
     mknod /dev/tty c 5 0
     mknod /dev/console c 5 1
     mknod /dev/ptmx c 5 2
    -mknod /dev/rtc c 10 135
     mknod /dev/urandom c 1 9
     mknod /dev/efirtc c 10 136
     export network_up=0
     EOF

    +kernelval=`echo $kernel | awk -F "[-|.]" '{print $1*65536+$2*256+$3}'`
    +#echo "kernel=$kernel kernelval=$kernelval"
    +if [ $kernelval -lt 132640 ]; then
    +   emit "mknod /dev/rtc c 10 135"
    +else
    +   emit "mknod /dev/rtc c 254 0"
    +fi
    +
     # XXX really we need to openvt too, in case someting changes the
     # color palette and then changes vts on fbcon before gettys start.
     # (yay, fbcon bugs!)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 5.x安装新内核之后时钟混乱问题]]></title>
    <link href="http://abcdxyzk.github.io/blog/2016/01/06/debug-mark-rtc/"/>
    <updated>2016-01-06T11:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2016/01/06/debug-mark-rtc</id>
    <content type="html"><![CDATA[<pre><code>    $ ll /etc/rc.sysinit
    /etc/rc.sysinit -&gt; rc.d/rc.sysinit
</code></pre>

<p>el5在调用mkinitrd命令时，会将/dev/rtc生成好，放到initrd- x.x.x.img文件中。而el6的系统在 /etc/rc.sysinit的/sbin/start_udev 之前是有这两个文件，也没找到el6的系统是在哪里加的这两句。</p>

<p>el5可选的一个做法是：修改/etc/rc.sysinit,在/sbin/start_udev这行之前加入两行：
<code>
    mv /dev/rtc /dev/rtc0
    ln -sf rtc0 /dev/rtc
</code>
在/sbin/start_udev这行之后加入一行
<code>
    [ -x /sbin/hwclock ] &amp;&amp; /sbin/hwclock $CLOCKFLAGS
</code>
这样el5系统用18、32内核都没问题了。</p>

<p>el5试着将这两句改在/sbin/mkinitrd里修改，但不知道为什么改完后在执行到 /etc/rc.sysinit 时 /dev/rtc 这个软连接不见了。</p>

<p>或者直接将/dev/rtc改成254，0
<code>``
    diff --git a/mkinitrd b/mkinitrd
    index 5ddb909..dcba61d 100755
    --- a/mkinitrd
    +++ b/mkinitrd
    @@ -1708,7 +1708,14 @@ done
     mknod $MNTIMAGE/dev/tty c 5 0
     mknod $MNTIMAGE/dev/console c 5 1
     mknod $MNTIMAGE/dev/ptmx c 5 2
    -mknod $MNTIMAGE/dev/rtc c 10 135
    +
    +kernelval=</code>echo $kernel | awk -F &ldquo;[-|.]&rdquo; &lsquo;{print $1<em>65536+$2</em>256+$3}&rsquo;`
    +#echo &ldquo;kernel=$kernel kernelval=$kernelval&rdquo;
    +if [ $kernelval -lt 132640 ]; then
    +   mknod $MNTIMAGE/dev/rtc c 10 135
    +else
    +   mknod $MNTIMAGE/dev/rtc c 254 0
    +fi</p>

<pre><code> if [ "$(uname -m)" == "ia64" ]; then
     mknod $MNTIMAGE/dev/efirtc c 10 136
@@ -1911,8 +1918,16 @@ mknod /dev/systty c 4 0
 mknod /dev/tty c 5 0
 mknod /dev/console c 5 1
 mknod /dev/ptmx c 5 2
-mknod /dev/rtc c 10 135
 EOF
+
+kernelval=`echo $kernel | awk -F "[-|.]" '{print $1*65536+$2*256+$3}'`
+#echo "kernel=$kernel kernelval=$kernelval"
+if [ $kernelval -lt 132640 ]; then
+   emit "mknod /dev/rtc c 10 135"
+else
+   emit "mknod /dev/rtc c 254 0"
+fi
+
 if [ "$(uname -m)" == "ia64" ]; then
     emit "mknod /dev/efirtc c 10 136"
 fi
</code></pre>

<pre><code>然后重建img
</code></pre>

<pre><code>/sbin/new-kernel-pkg --package kernel --mkinitrd --depmod --install 2.6.32-XXX
</code></pre>

<pre><code>
------------------

http://www.csdn123.com/html/mycsdn20140110/59/59dd8c5f069a09bf9dc1785e19eb329f.html

CentOS在安装完新内核之后，每次重启之后时钟总是会发生一些变化，使得系统时钟不准确。在多操作系统的情况下（例如windows和 linux双系统），还可能会出现时区的偏差，而且无论如何设置，在重启之后都会恢复原样。如何解决这个问题还得从操作系统的时钟原理开始。

#### 1. 操作系统中的时钟

操作系统为实现其功能，必须知道当前外部世界的时间（年月日时分秒等）。为实现这一目的，计算机设计者在主板上设置了一个硬件时钟，由主板上的一块纽扣电池（Cell）供电，这个硬件时钟无论计算机电源是否接通都会不停的数秒，来计算当前时间。

操作系统在启动的时候，会调用一段程序来读取主板上的硬件时钟，并记录在操作系统的一个（或一组）变量中。自此之后，操作系统的时钟便脱离主板的硬件时钟，开始单独运行（操作系统时钟的运行是由时钟中断来驱动的，不同于主板上的时钟）。

无论做工多么精细，主板硬件时钟和由时钟中断维护的操作系统内的时钟多多少少会有一些误差。所以，操作系统在每次关闭的时候会调用另一段程序，将操作系统 内的时钟写到主板硬件时钟里（这样设计是不是说明时钟中断比主板硬件时钟更准确一些呢？）。类似的，当用户在操作系统内修改时钟之后，也不会立即写入主板 时钟，而是在关机的时候写入硬件时钟。

#### 2. 旧汤和新药的冲突
主板上的硬件时钟在Linux操作系统中呈现为一个设备，设备名称为rtc（Real Time Clock）。

使用旧的系统（如CentOS的2.6.18内核）编译新内核时，在调用mkinitrd命令时，会将/dev/rtc生成好，放到initrd- x.x.x.img文件中;而新的内核是自己生成/dev/rtc文件的，当kernel生成/dev/rtc时，发现系统内已经有了这个设备，于是就会 创建/dev/rtc0设备。这时hwclock程序仍然会读取rtc设备，就会造成设备读写失败。运行`hwclock --debug`命令可以看到如下输出：
</code></pre>

<pre><code>[root@localhost ~]# hwclock --debug
hwclock from util-linux-2.13-pre7
hwclock: Open of /dev/rtc failed, errno=19: No such device.
No usable clock interface found.
Cannot access the Hardware Clock via any known method.
</code></pre>

<pre><code>但是有的能够直接读写I/O，这样虽然/dev/rtc是错的，但还能正常运行
</code></pre>

<pre><code>[root@localhost ~]# hwclock --debug
hwclock from util-linux-2.13-pre7
hwclock: Open of /dev/rtc failed, errno=19: No such device.
Using direct I/O instructions to ISA clock.
.....
</code></pre>

<pre><code>
其实，对应这个问题，新版的hwclock已经做出了调整。新的hwclock会主动去寻找/dev/rtc0设备，来操作主板硬件时钟。于是，解决方法就出现了。

#### 3. 新汤配新药
既然内核这剂药已经换成了新的，那我们就把外围应用程序hwclock也换成新的。

从这里可以下载比较新的（不用最新的是因为最新的源码在旧版的CentOS上编译会出现错误）程序源码：http://now-code.com/download/util-linux-ng-2.17.tar.bz2 

如果需要更多版本的程序源码，请到这里下载：ftp://ftp.kernel.org/pub/linux/utils/。

下载完成之后，编译该程序：
</code></pre>

<pre><code>tar xfv util-linux-ng-2.17.tar.bz2
cd util-linux-ng-2.17
./configure
make
</code></pre>

<pre><code>编译完成之后，将生成的hwclock文件拷贝到指定位置即可：
</code></pre>

<pre><code>cp hwclock/hwclock /sbin/
</code></pre>

<p>```</p>

<p>之后，操作系统和主板的硬件时钟就可以同步起来了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[debuginfo 编译速度]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/11/26/debug-spec/"/>
    <updated>2015-11-26T11:30:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/11/26/debug-spec</id>
    <content type="html"><![CDATA[<p>Have a look into /usr/lib/rpm/macros:
<code>
    #       Compression type and level for source/binary package payloads.
    #               "w9.gzdio"      gzip level 9 (default).
    #               "w9.bzdio"      bzip2 level 9.
    #               "w7.xzdio"      xz level 7, xz's default.
    #               "w7.lzdio"      lzma-alone level 7, lzma's default
    #
    #%_source_payload       w9.gzdio
    #%_binary_payload       w9.gzdio
</code></p>

<p>binkernel.spec中加入
<code>
    %_source_payload       w5.gzdio
    %_binary_payload       w5.gzdio
</code>
略微降低压缩率，大大提高打包速度。kernel增加600K，debuginfo增加3M，时间从14分钟降至2分钟内</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CC_STACKPROTECTOR防内核堆栈溢出补丁分析]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/11/17/debug-CC_STACKPROTECTOR/"/>
    <updated>2015-11-17T16:01:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/11/17/debug-CC_STACKPROTECTOR</id>
    <content type="html"><![CDATA[<p><a href="http://blog.aliyun.com/1126">http://blog.aliyun.com/1126</a></p>

<p>内核堆栈溢出通常有两种情况。一种是函数调用栈超出了内核栈THREAD_SIZE的大小， 这是栈底越界，另一种是栈上缓冲越界访问，这是栈顶越界。</p>

<h4>检测栈底越界</h4>

<p>以arm平台为例，内核栈THREAD_SIZE为8K,当调用栈层次过多或某调用栈上分配过大的 空间，就会导致它越界。越界后struct thread_info结构可能被破坏，轻则内核 panic，重则内核数据被覆盖仍继续运行。</p>

<h4>检测栈顶越界</h4>

<p>对于栈顶越界，gcc提供了支持。打开内核配置CONFIG_CC_STACKPROTECTOR后，会打 开编译选项-fstack-protector.</p>

<hr />

<p>  CC_STACKPROTECT补丁是Tejun Heo在09年给主线kernel提交的一个用来防止内核堆栈溢出的补丁。默认的config是将这个选项关闭的，可以在编译内核的时候， 修改.config文件为CONFIG_CC_STACKPROTECTOR=y来启用。未来飞天内核可以将这个选项开启来防止利用内核stack溢出的0day攻击。这个补丁的防溢出原理是： 在进程启动的时候， 在每个buffer的后面放置一个预先设置好的stack canary，你可以把它理解成一个哨兵， 当buffer发生缓冲区溢出的时候， 肯定会破坏stack canary的值， 当stack canary的值被破坏的时候， 内核就会直接当机。那么是怎么判断stack canary被覆盖了呢？ 其实这个事情是gcc来做的，内核在编译的时候给gcc加了个-fstack-protector参数， 我们先来研究下这个参数是做什么用的。</p>

<p>先写个简单的有溢出的程序：</p>

<pre><code>    [wzt@localhost csaw]$ cat test.c

    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    void test(void)
    {
        char buff[64];

        memset(buff, 0x41, 128);     //向64大小的buffer拷贝128字节， 肯定会发生缓冲区溢出。
    }

    int main(void)
    {
        test();

        return 0;
    }
</code></pre>

<pre><code>    [wzt@localhost csaw]$ gcc -o test test.c
    [wzt@localhost csaw]$ ./test
    段错误
</code></pre>

<p>反汇编看看：</p>

<pre><code>    [wzt@localhost csaw]$ objdump -d test &gt; hex

    08048384 &lt;test&gt;:
     8048384:       55                      push   %ebp
     8048385:       89 e5                   mov    %esp,%ebp
     8048387:       83 ec 58                sub    $0x58,%esp
     804838a:       c7 44 24 08 80 00 00    movl   $0x80,0x8(%esp)
     8048391:       00
     8048392:       c7 44 24 04 41 00 00    movl   $0x41,0x4(%esp)
     8048399:       00
     804839a:       8d 45 c0                lea    0xffffffc0(%ebp),%eax
     804839d:       89 04 24                mov    %eax,(%esp)
     80483a0:       e8 e3 fe ff ff          call   8048288 &lt;memset@plt&gt;
     80483a5:       c9                      leave
     80483a6:       c3                      ret
</code></pre>

<p>没什么特别的，我们在加上-fstack-protector参数看看：</p>

<pre><code>    [wzt@localhost csaw]$ gcc -o test test.c -fstack-protector
    [wzt@localhost csaw]$ ./test
    *** stack smashing detected ***: ./test terminated
    已放弃
</code></pre>

<p>这次程序打印了一条堆栈被溢出的信息，然后就自动退出了。</p>

<p>在反汇编看下：</p>

<pre><code>    [wzt@localhost csaw]$ objdump -d test &gt; hex1

    080483d4 &lt;test&gt;:
     80483d4:       55                      push   %ebp
     80483d5:       89 e5                   mov    %esp,%ebp
     80483d7:       83 ec 68                sub    $0x68,%esp
     80483da:       65 a1 14 00 00 00       mov    %gs:0x14,%eax
     80483e0:       89 45 fc                mov    %eax,0xfffffffc(%ebp)
     80483e3:       31 c0                   xor    %eax,%eax
     80483e5:       c7 44 24 08 80 00 00    movl   $0x80,0x8(%esp)
     80483ec:       00
     80483ed:       c7 44 24 04 41 00 00    movl   $0x41,0x4(%esp)
     80483f4:       00
     80483f5:       8d 45 bc                lea    0xffffffbc(%ebp),%eax
     80483f8:       89 04 24                mov    %eax,(%esp)
     80483fb:       e8 cc fe ff ff          call   80482cc &lt;memset@plt&gt;
     8048400:       8b 45 fc                mov    0xfffffffc(%ebp),%eax
     8048403:       65 33 05 14 00 00 00    xor    %gs:0x14,%eax
     804840a:       74 05                   je     8048411 &lt;test+0x3d&gt;
     804840c:       e8 db fe ff ff          call   80482ec &lt;__stack_chk_fail@plt&gt;
     8048411:       c9                      leave
     8048412:       c3                      ret
</code></pre>

<p>使用-fstack-protector参数后， gcc在函数的开头放置了几条汇编代码：</p>

<pre><code>     80483d7:       83 ec 68                sub    $0x68,%esp
     80483da:       65 a1 14 00 00 00       mov    %gs:0x14,%eax
     80483e0:       89 45 fc                mov    %eax,0xfffffffc(%ebp)
</code></pre>

<p>将代码段gs偏移0×14内存处的值赋值给了ebp-4， 也就是第一个变量值的后面。</p>

<p>在call完memeset后，有如下汇编代码：</p>

<pre><code>     80483fb:       e8 cc fe ff ff          call   80482cc &lt;memset@plt&gt;
     8048400:       8b 45 fc                mov    0xfffffffc(%ebp),%eax
     8048403:       65 33 05 14 00 00 00    xor    %gs:0x14,%eax
     804840a:       74 05                   je     8048411 &lt;test+0x3d&gt;
     804840c:       e8 db fe ff ff          call   80482ec &lt;__stack_chk_fail@plt&gt;
</code></pre>

<p>在memset后，gcc要检查这个操作是否发生了堆栈溢出, 将保存在ebp-4的这个值与原来的值对比一下，如果不相同， 说明堆栈发生了溢出，那么就会执行stack_chk_fail这个函数， 这个函数是glibc实现的，打印出上面看到的信息， 然后进程退出。</p>

<p>从这个例子中我们可以看出gcc使用了-fstack-protector参数后，会自动检查堆栈是否发生了溢出， 但是有一个前提就是内核要给每个进程提前设置好一个检测值放置在%gs:0×14位置处，这个值称之为stack canary。所以我们可以看到防止堆栈溢出是由内核和gcc共同来完成的。</p>

<p>gcc的任务就是放置几条汇编代码， 然后和%gs:0×14位置处的值进行对比即可。 主要任务还是内核如何来设置stack canary， 也是CC_STACKPROTECTOR补丁要实现的目的， 下面我们仔细来看下这个补丁是如何实现的。</p>

<p>既然gcc硬性规定了stack canary必须在%gs的某个偏移位置处， 那么内核也必须按着这个规定来设置。</p>

<p>对于32位和64位内核， gs寄存器有着不同的功能。</p>

<p>64位内核gcc要求stack canary是放置在gs段的40偏移处， 并且gs寄存器在每cpu变量中是共享的，每cpu变量irq_stack_union的结构如下：</p>

<pre><code>    arch/x86/include/asm/processor.h

    union irq_stack_union {
        char irq_stack[IRQ_STACK_SIZE];
        /*
         * GCC hardcodes the stack canary as %gs:40.  Since the
         * irq_stack is the object at %gs:0, we reserve the bottom
         * 48 bytes of the irq stack for the canary. 
         */
        struct {
            char gs_base[40];
            unsigned long stack_canary;
        };
    };

    DECLARE_PER_CPU_FIRST(union irq_stack_union, irq_stack_union);
</code></pre>

<p>gs_base只是一个40字节的站位空间， stack_canary就紧挨其后。并且在应用程序进出内核的时候，内核会使用swapgs指令自动更换gs寄存器的内容。</p>

<p>32位下就稍微有点复杂了。由于某些处理器在加载不同的段寄存器时很慢， 所以内核使用fs段寄存器替换了gs寄存器。 但是gcc在使用-fstack-protector的时候， 还要用到gs段寄存器， 所以内核还要管理gs寄存器，我们要把CONFIG_X86_32_LAZY_GS选项关闭， gs也只在进程切换的时候才改变。 32位用每cpu变量stack_canary保存stack canary。</p>

<pre><code>    struct stack_canary {
        char __pad[20];         /* canary at %gs:20 */
        unsigned long canary;
    };      
    DECLARE_PER_CPU_ALIGNED(struct stack_canary, stack_canary);
</code></pre>

<p>内核是处于保护模式的， 因此gs寄存器就变成了保护模式下的段选子，在GDT表中也要有相应的设置：</p>

<pre><code>    diff --git a/arch/x86/include/asm/segment.h b/arch/x86/include/asm/segment.h
    index 1dc1b51..14e0ed8 100644 (file)
    --- a/arch/x86/include/asm/segment.h
    +++ b/arch/x86/include/asm/segment.h
    @@ -61,7 +61,7 @@
      *
      *  26 - ESPFIX small SS
      *  27 - per-cpu                       [ offset to per-cpu data area ]
    - *  28 - unused
    + *  28 - stack_canary-20               [ for stack protector ]
      *  29 - unused
      *  30 - unused
      *  31 - TSS for double fault handler
    @@ -95,6 +95,13 @@
     #define __KERNEL_PERCPU 0
     #endif

    +#define GDT_ENTRY_STACK_CANARY         (GDT_ENTRY_KERNEL_BASE + 16)
    +#ifdef CONFIG_CC_STACKPROTECTOR
    +#define __KERNEL_STACK_CANARY          (GDT_ENTRY_STACK_CANARY * 8)
    +#else
    +#define __KERNEL_STACK_CANARY          0
    +#endif
    +
     #define GDT_ENTRY_DOUBLEFAULT_TSS      31
</code></pre>

<p>GDT表中的第28个表项用来定为stack canary所在的段。</p>

<pre><code>    #define GDT_STACK_CANARY_INIT                                           \
            [GDT_ENTRY_STACK_CANARY] = GDT_ENTRY_INIT(0x4090, 0, 0x18),
</code></pre>

<p>GDT_STACK_CANARY_INIT在刚进入保护模式的时候被调用， 这个段描述符项被设置为基地址为0， 段大小设为24，因为只在基地址为0， 偏移为0×14处放置一个4bytes的stack canary， 所以24字节正好。不理解的同学可以看看intel保护模式的手册， 对着段描述符结构一个个看就行了。</p>

<p>在进入保护模式后， start_kernel()会调用boot_init_stack_canary()来初始话一个stack canary。</p>

<pre><code>    /*      
     * Initialize the stackprotector canary value.
     *
     * NOTE: this must only be called from functions that never return,
     * and it must always be inlined.
     */
    static __always_inline void boot_init_stack_canary(void)
    {
        u64 canary;
        u64 tsc;

    #ifdef CONFIG_X86_64
        BUILD_BUG_ON(offsetof(union irq_stack_union, stack_canary) != 40);
    #endif
        /*
         * We both use the random pool and the current TSC as a source
         * of randomness. The TSC only matters for very early init,
         * there it already has some randomness on most systems. Later
         * on during the bootup the random pool has true entropy too.
         */
        get_random_bytes(&amp;canary, sizeof(canary));
        tsc = __native_read_tsc();
        canary += tsc + (tsc &lt;&lt; 32UL);

        current-&gt;stack_canary = canary;
    #ifdef CONFIG_X86_64
        percpu_write(irq_stack_union.stack_canary, canary);
    #else
        percpu_write(stack_canary.canary, canary);
    #endif
    }
</code></pre>

<p>随机出了一个值赋值给每cpu变量， 32位是stack_canary, 64位是irq_stack_union。</p>

<p>内核在进一步初始化cpu的时候，会调用setup_stack_canary_segment()来设置每个cpu的GDT的stack canary描述符项：</p>

<p>start_kernel()->setup_per_cpu_areas()->setup_stack_canary_segment：</p>

<pre><code>    static inline void setup_stack_canary_segment(int cpu)
    {
    #ifdef CONFIG_X86_32
        unsigned long canary = (unsigned long)&amp;per_cpu(stack_canary, cpu);
        struct desc_struct *gdt_table = get_cpu_gdt_table(cpu);
        struct desc_struct desc;

        desc = gdt_table[GDT_ENTRY_STACK_CANARY];
        set_desc_base(&amp;desc, canary);
        write_gdt_entry(gdt_table, GDT_ENTRY_STACK_CANARY, &amp;desc, DESCTYPE_S);
    #endif
    }
</code></pre>

<p>在内核刚进入保护模式的时候, stack canary描述符的基地址被初始化为0， 现在在cpu初始化的时候要重新设置为每cpu变量stack_canary的地址， 而不是变量保存的值。通过这些设置当内核代码在访问%gs:0×14的时候， 就会访问stack canry保存的值。注意：setup_stack_canary_segment是针对32位内核做设置， 因为64位内核中的irq_stack_union是每cpu共享的， 不用针对每个cpu单独设置。 然后就可以调用switch_to_new_gdt(cpu);来加载GDT表和加载gs寄存器。</p>

<p>经过上述初始化过程，在内核代码里访问%gs:0×14就可以定位stack canary的值了， 那么每个进程的stack canary是什么时候设置的呢？</p>

<p>在内核启动一个进程的时候， 会把gs寄存器的值设为KERNEL_STACK_CANARY</p>

<pre><code>    --- a/arch/x86/kernel/process_32.c
    +++ b/arch/x86/kernel/process_32.c
    @@ -212,6 +212,7 @@ int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
            regs.ds = __USER_DS;
            regs.es = __USER_DS;
            regs.fs = __KERNEL_PERCPU;
    +       regs.gs = __KERNEL_STACK_CANARY;
            regs.orig_ax = -1;
            regs.ip = (unsigned long) kernel_thread_helper;
            regs.cs = __KERNEL_CS | get_kernel_rpl();
</code></pre>

<p>内核在fork一个进程的时候， 有如下操作：</p>

<pre><code>    static struct task_struct *dup_task_struct(struct task_struct *orig)
    {
    #ifdef CONFIG_CC_STACKPROTECTOR
        tsk-&gt;stack_canary = get_random_int();
    #endif
    }
</code></pre>

<p>随机初始化了一个stack_canary保存在task_struct结构中的stack_canary变量中。当进程在切换的时候， 通过switch宏把新进程的stack canary保存在每cpu变量stack_canary中， 当前进程的stack_canary也保存在一个每cpu变量中，完成stack canary的切换。</p>

<pre><code>    diff --git a/arch/x86/include/asm/system.h b/arch/x86/include/asm/system.h
    index 79b98e5..2692ee8 100644 (file)
    --- a/arch/x86/include/asm/system.h
    +++ b/arch/x86/include/asm/system.h
    @@ -23,6 +23,22 @@ struct task_struct *__switch_to(struct task_struct *prev,

     #ifdef CONFIG_X86_32

    +#ifdef CONFIG_CC_STACKPROTECTOR
    +#define __switch_canary                                                \
    +       "movl "__percpu_arg([current_task])",%%ebx\n\t"                 \
    +       "movl %P[task_canary](%%ebx),%%ebx\n\t"                         \
    +       "movl %%ebx,"__percpu_arg([stack_canary])"\n\t"
    +#define __switch_canary_oparam                                         \
    +       , [stack_canary] "=m" (per_cpu_var(stack_canary))
    +#define __switch_canary_iparam                                         \
    +       , [current_task] "m" (per_cpu_var(current_task))                \
    +       , [task_canary] "i" (offsetof(struct task_struct, stack_canary))
    +#else  /* CC_STACKPROTECTOR */
    +#define __switch_canary
    +#define __switch_canary_oparam
    +#define __switch_canary_iparam
    +#endif /* CC_STACKPROTECTOR */
    +
     /*
      * Saving eflags is important. It switches not only IOPL between tasks,
      * it also protects other tasks from NT leaking through sysenter etc.
    @@ -46,6 +62,7 @@ do {                                                  \
                         "pushl %[next_ip]\n\t"     /* restore EIP   */     \
                         "jmp __switch_to\n"        /* regparm call  */     \
                         "1:\t"                                             \
    +                    __switch_canary                                    \
                         "popl %%ebp\n\t"           /* restore EBP   */     \
                         "popfl\n"                  /* restore flags */     \
                                                                            \
    @@ -58,6 +75,8 @@ do {                                                  \
                           "=b" (ebx), "=c" (ecx), "=d" (edx),              \
                           "=S" (esi), "=D" (edi)                           \
                                                                            \
    +                      __switch_canary_oparam                           \
    +                                                                       \
                           /* input parameters: */                          \
                         : [next_sp]  "m" (next-&gt;thread.sp),                \
                           [next_ip]  "m" (next-&gt;thread.ip),                \
    @@ -66,6 +85,8 @@ do {                                                  \
                           [prev]     "a" (prev),                           \
                           [next]     "d" (next)                            \
                                                                            \
    +                      __switch_canary_iparam                           \
    +                                                                       \
                         : /* reloaded segment registers */                 \
                            "memory");                                      \
     } while (0)
</code></pre>

<p>前面讲过当gcc检测到堆栈溢出的时候， 会调用glibc的stack_chk_fail函数， 但是当内核堆栈发生溢出的时候，不能调用glibc的函数，所以内核自己实现了一个stack_chk_fail函数：</p>

<p>kernel/panic.c</p>

<pre><code>    #ifdef CONFIG_CC_STACKPROTECTOR

    /*
     * Called when gcc's -fstack-protector feature is used, and
     * gcc detects corruption of the on-stack canary value
     */
    void __stack_chk_fail(void)
    {
        panic("stack-protector: Kernel stack is corrupted in: %p\n",
             __builtin_return_address(0));
    }
    EXPORT_SYMBOL(__stack_chk_fail);

    #endif
</code></pre>

<p>当内核堆栈发生溢出的时候，就会执行stack_chk_fail函数， 内核当机。</p>

<p>这就是这个补丁的原理，不懂的同学请参考：</p>

<p><a href="http://git.kernel.org/?p=linux/kernel/git/next/linux-next.git;a=commitdiff;h=60a5317ff0f42dd313094b88f809f63041568b08">http://git.kernel.org/?p=linux/kernel/git/next/linux-next.git;a=commitdiff;h=60a5317ff0f42dd313094b88f809f63041568b08</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ack loop]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/09/30/debug-loop_ack/"/>
    <updated>2015-09-30T15:32:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/09/30/debug-loop_ack</id>
    <content type="html"><![CDATA[<h4>patch</h4>

<pre><code>    commit 4fb17a6091674f469e8ac85dc770fbf9a9ba7cc8
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:41 2015 -0500

        tcp: mitigate ACK loops for connections as tcp_timewait_sock

        Ensure that in state FIN_WAIT2 or TIME_WAIT, where the connection is
        represented by a tcp_timewait_sock, we rate limit dupacks in response
        to incoming packets (a) with TCP timestamps that fail PAWS checks, or
        (b) with sequence numbers that are out of the acceptable window.

        We do not send a dupack in response to out-of-window packets if it has
        been less than sysctl_tcp_invalid_ratelimit (default 500ms) since we
        last sent a dupack in response to an out-of-window packet.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/include/linux/tcp.h b/include/linux/tcp.h
    index 66d85a8..1a7adb4 100644
    --- a/include/linux/tcp.h
    +++ b/include/linux/tcp.h
    @@ -342,6 +342,10 @@ struct tcp_timewait_sock {
        u32           tw_rcv_wnd;
        u32           tw_ts_offset;
        u32           tw_ts_recent;
    +
    +   /* The time we sent the last out-of-window ACK: */
    +   u32           tw_last_oow_ack_time;
    +
        long              tw_ts_recent_stamp;
     #ifdef CONFIG_TCP_MD5SIG
        struct tcp_md5sig_key     *tw_md5_key;
    diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
    index 98a8405..dd11ac7 100644
    --- a/net/ipv4/tcp_minisocks.c
    +++ b/net/ipv4/tcp_minisocks.c
    @@ -58,6 +58,25 @@ static bool tcp_in_window(u32 seq, u32 end_seq, u32 s_win, u32 e_win)
        return seq == e_win &amp;&amp; seq == end_seq;
     }

    +static enum tcp_tw_status
    +tcp_timewait_check_oow_rate_limit(struct inet_timewait_sock *tw,
    +                 const struct sk_buff *skb, int mib_idx)
    +{
    +   struct tcp_timewait_sock *tcptw = tcp_twsk((struct sock *)tw);
    +
    +   if (!tcp_oow_rate_limited(twsk_net(tw), skb, mib_idx,
    +                 &amp;tcptw-&gt;tw_last_oow_ack_time)) {
    +       /* Send ACK. Note, we do not put the bucket,
    +        * it will be released by caller.
    +        */
    +       return TCP_TW_ACK;
    +   }
    +
    +   /* We are rate-limiting, so just release the tw sock and drop skb. */
    +   inet_twsk_put(tw);
    +   return TCP_TW_SUCCESS;
    +}
    +
     /*
      * * Main purpose of TIME-WAIT state is to close connection gracefully,
      *   when one of ends sits in LAST-ACK or CLOSING retransmitting FIN
    @@ -116,7 +135,8 @@ tcp_timewait_state_process(struct inet_timewait_sock *tw, struct sk_buff *skb,
                !tcp_in_window(TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq,
                       tcptw-&gt;tw_rcv_nxt,
                       tcptw-&gt;tw_rcv_nxt + tcptw-&gt;tw_rcv_wnd))
    -           return TCP_TW_ACK;
    +           return tcp_timewait_check_oow_rate_limit(
    +               tw, skb, LINUX_MIB_TCPACKSKIPPEDFINWAIT2);

            if (th-&gt;rst)
                goto kill;
    @@ -250,10 +270,8 @@ kill:
                inet_twsk_schedule(tw, &amp;tcp_death_row, TCP_TIMEWAIT_LEN,
                           TCP_TIMEWAIT_LEN);

    -       /* Send ACK. Note, we do not put the bucket,
    -        * it will be released by caller.
    -        */
    -       return TCP_TW_ACK;
    +       return tcp_timewait_check_oow_rate_limit(
    +           tw, skb, LINUX_MIB_TCPACKSKIPPEDTIMEWAIT);
        }
        inet_twsk_put(tw);
        return TCP_TW_SUCCESS;
    @@ -289,6 +307,7 @@ void tcp_time_wait(struct sock *sk, int state, int timeo)
            tcptw-&gt;tw_ts_recent = tp-&gt;rx_opt.ts_recent;
            tcptw-&gt;tw_ts_recent_stamp = tp-&gt;rx_opt.ts_recent_stamp;
            tcptw-&gt;tw_ts_offset = tp-&gt;tsoffset;
    +       tcptw-&gt;tw_last_oow_ack_time = 0;

     #if IS_ENABLED(CONFIG_IPV6)
            if (tw-&gt;tw_family == PF_INET6) {

    commit f2b2c582e82429270d5818fbabe653f4359d7024
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:40 2015 -0500

        tcp: mitigate ACK loops for connections as tcp_sock

        Ensure that in state ESTABLISHED, where the connection is represented
        by a tcp_sock, we rate limit dupacks in response to incoming packets
        (a) with TCP timestamps that fail PAWS checks, or (b) with sequence
        numbers or ACK numbers that are out of the acceptable window.

        We do not send a dupack in response to out-of-window packets if it has
        been less than sysctl_tcp_invalid_ratelimit (default 500ms) since we
        last sent a dupack in response to an out-of-window packet.

        There is already a similar (although global) rate-limiting mechanism
        for "challenge ACKs". When deciding whether to send a challence ACK,
        we first consult the new per-connection rate limit, and then the
        global rate limit.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/include/linux/tcp.h b/include/linux/tcp.h
    index bcc828d..66d85a8 100644
    --- a/include/linux/tcp.h
    +++ b/include/linux/tcp.h
    @@ -153,6 +153,7 @@ struct tcp_sock {
        u32 snd_sml;    /* Last byte of the most recently transmitted small packet */
        u32 rcv_tstamp; /* timestamp of last received ACK (for keepalives) */
        u32 lsndtime;   /* timestamp of last sent data packet (for restart window) */
    +   u32 last_oow_ack_time;  /* timestamp of last out-of-window ACK */

        u32 tsoffset;   /* timestamp offset */

    diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
    index 9401aa43..8fdd27b 100644
    --- a/net/ipv4/tcp_input.c
    +++ b/net/ipv4/tcp_input.c
    @@ -3322,13 +3322,22 @@ static int tcp_ack_update_window(struct sock *sk, const struct sk_buff *skb, u32
     }

     /* RFC 5961 7 [ACK Throttling] */
    -static void tcp_send_challenge_ack(struct sock *sk)
    +static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)
     {
        /* unprotected vars, we dont care of overwrites */
        static u32 challenge_timestamp;
        static unsigned int challenge_count;
    -   u32 now = jiffies / HZ;
    +   struct tcp_sock *tp = tcp_sk(sk);
    +   u32 now;
    +
    +   /* First check our per-socket dupack rate limit. */
    +   if (tcp_oow_rate_limited(sock_net(sk), skb,
    +                LINUX_MIB_TCPACKSKIPPEDCHALLENGE,
    +                &amp;tp-&gt;last_oow_ack_time))
    +       return;

    +   /* Then check the check host-wide RFC 5961 rate limit. */
    +   now = jiffies / HZ;
        if (now != challenge_timestamp) {
            challenge_timestamp = now;
            challenge_count = 0;
    @@ -3424,7 +3433,7 @@ static int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)
        if (before(ack, prior_snd_una)) {
            /* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */
            if (before(ack, prior_snd_una - tp-&gt;max_window)) {
    -           tcp_send_challenge_ack(sk);
    +           tcp_send_challenge_ack(sk, skb);
                return -1;
            }
            goto old_ack;
    @@ -4993,7 +5002,10 @@ static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
            tcp_paws_discard(sk, skb)) {
            if (!th-&gt;rst) {
                NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);
    -           tcp_send_dupack(sk, skb);
    +           if (!tcp_oow_rate_limited(sock_net(sk), skb,
    +                         LINUX_MIB_TCPACKSKIPPEDPAWS,
    +                         &amp;tp-&gt;last_oow_ack_time))
    +               tcp_send_dupack(sk, skb);
                goto discard;
            }
            /* Reset is accepted even if it did not pass PAWS. */
    @@ -5010,7 +5022,10 @@ static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
            if (!th-&gt;rst) {
                if (th-&gt;syn)
                    goto syn_challenge;
    -           tcp_send_dupack(sk, skb);
    +           if (!tcp_oow_rate_limited(sock_net(sk), skb,
    +                         LINUX_MIB_TCPACKSKIPPEDSEQ,
    +                         &amp;tp-&gt;last_oow_ack_time))
    +               tcp_send_dupack(sk, skb);
            }
            goto discard;
        }
    @@ -5026,7 +5041,7 @@ static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
            if (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt)
                tcp_reset(sk);
            else
    -           tcp_send_challenge_ack(sk);
    +           tcp_send_challenge_ack(sk, skb);
            goto discard;
        }

    @@ -5040,7 +5055,7 @@ syn_challenge:
            if (syn_inerr)
                TCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);
            NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSYNCHALLENGE);
    -       tcp_send_challenge_ack(sk);
    +       tcp_send_challenge_ack(sk, skb);
            goto discard;
        }

    diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
    index 131aa49..98a8405 100644
    --- a/net/ipv4/tcp_minisocks.c
    +++ b/net/ipv4/tcp_minisocks.c
    @@ -467,6 +467,7 @@ struct sock *tcp_create_openreq_child(struct sock *sk, struct request_sock *req,
            tcp_enable_early_retrans(newtp);
            newtp-&gt;tlp_high_seq = 0;
            newtp-&gt;lsndtime = treq-&gt;snt_synack;
    +       newtp-&gt;last_oow_ack_time = 0;
            newtp-&gt;total_retrans = req-&gt;num_retrans;

            /* So many TCP implementations out there (incorrectly) count the

    commit a9b2c06dbef48ed31cff1764c5ce824829106f4f
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:39 2015 -0500

        tcp: mitigate ACK loops for connections as tcp_request_sock

        In the SYN_RECV state, where the TCP connection is represented by
        tcp_request_sock, we now rate-limit SYNACKs in response to a client's
        retransmitted SYNs: we do not send a SYNACK in response to client SYN
        if it has been less than sysctl_tcp_invalid_ratelimit (default 500ms)
        since we last sent a SYNACK in response to a client's retransmitted
        SYN.

        This allows the vast majority of legitimate client connections to
        proceed unimpeded, even for the most aggressive platforms, iOS and
        MacOS, which actually retransmit SYNs 1-second intervals for several
        times in a row. They use SYN RTO timeouts following the progression:
        1,1,1,1,1,2,4,8,16,32.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/include/linux/tcp.h b/include/linux/tcp.h
    index 67309ec..bcc828d 100644
    --- a/include/linux/tcp.h
    +++ b/include/linux/tcp.h
    @@ -115,6 +115,7 @@ struct tcp_request_sock {
        u32             rcv_isn;
        u32             snt_isn;
        u32             snt_synack; /* synack sent time */
    +   u32             last_oow_ack_time; /* last SYNACK */
        u32             rcv_nxt; /* the ack # by SYNACK. For
                              * FastOpen it's the seq#
                              * after data-in-SYN.
    diff --git a/include/net/tcp.h b/include/net/tcp.h
    index b81f45c..da4196fb 100644
    --- a/include/net/tcp.h
    +++ b/include/net/tcp.h
    @@ -1145,6 +1145,7 @@ static inline void tcp_openreq_init(struct request_sock *req,
        tcp_rsk(req)-&gt;rcv_isn = TCP_SKB_CB(skb)-&gt;seq;
        tcp_rsk(req)-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
        tcp_rsk(req)-&gt;snt_synack = tcp_time_stamp;
    +   tcp_rsk(req)-&gt;last_oow_ack_time = 0;
        req-&gt;mss = rx_opt-&gt;mss_clamp;
        req-&gt;ts_recent = rx_opt-&gt;saw_tstamp ? rx_opt-&gt;rcv_tsval : 0;
        ireq-&gt;tstamp_ok = rx_opt-&gt;tstamp_ok;
    diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
    index bc9216d..131aa49 100644
    --- a/net/ipv4/tcp_minisocks.c
    +++ b/net/ipv4/tcp_minisocks.c
    @@ -605,7 +605,11 @@ struct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,
             * Reset timer after retransmitting SYNACK, similar to
             * the idea of fast retransmit in recovery.
             */
    -       if (!inet_rtx_syn_ack(sk, req))
    +       if (!tcp_oow_rate_limited(sock_net(sk), skb,
    +                     LINUX_MIB_TCPACKSKIPPEDSYNRECV,
    +                     &amp;tcp_rsk(req)-&gt;last_oow_ack_time) &amp;&amp;
    +
    +           !inet_rtx_syn_ack(sk, req))
                req-&gt;expires = min(TCP_TIMEOUT_INIT &lt;&lt; req-&gt;num_timeout,
                           TCP_RTO_MAX) + jiffies;
            return NULL;

    commit 032ee4236954eb214651cb9bfc1b38ffa8fd7a01
    Author: Neal Cardwell &lt;ncardwell@google.com&gt;
    Date:   Fri Feb 6 16:04:38 2015 -0500

        tcp: helpers to mitigate ACK loops by rate-limiting out-of-window dupacks

        Helpers for mitigating ACK loops by rate-limiting dupacks sent in
        response to incoming out-of-window packets.

        This patch includes:

        - rate-limiting logic
        - sysctl to control how often we allow dupacks to out-of-window packets
        - SNMP counter for cases where we rate-limited our dupack sending

        The rate-limiting logic in this patch decides to not send dupacks in
        response to out-of-window segments if (a) they are SYNs or pure ACKs
        and (b) the remote endpoint is sending them faster than the configured
        rate limit.

        We rate-limit our responses rather than blocking them entirely or
        resetting the connection, because legitimate connections can rely on
        dupacks in response to some out-of-window segments. For example, zero
        window probes are typically sent with a sequence number that is below
        the current window, and ZWPs thus expect to thus elicit a dupack in
        response.

        We allow dupacks in response to TCP segments with data, because these
        may be spurious retransmissions for which the remote endpoint wants to
        receive DSACKs. This is safe because segments with data can't
        realistically be part of ACK loops, which by their nature consist of
        each side sending pure/data-less ACKs to each other.

        The dupack interval is controlled by a new sysctl knob,
        tcp_invalid_ratelimit, given in milliseconds, in case an administrator
        needs to dial this upward in the face of a high-rate DoS attack. The
        name and units are chosen to be analogous to the existing analogous
        knob for ICMP, icmp_ratelimit.

        The default value for tcp_invalid_ratelimit is 500ms, which allows at
        most one such dupack per 500ms. This is chosen to be 2x faster than
        the 1-second minimum RTO interval allowed by RFC 6298 (section 2, rule
        2.4). We allow the extra 2x factor because network delay variations
        can cause packets sent at 1 second intervals to be compressed and
        arrive much closer.

        Reported-by: Avery Fay &lt;avery@mixpanel.com&gt;
        Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
        Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;
        Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;
        Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

    diff --git a/Documentation/networking/ip-sysctl.txt b/Documentation/networking/ip-sysctl.txt
    index a5e4c81..1b8c964 100644
    --- a/Documentation/networking/ip-sysctl.txt
    +++ b/Documentation/networking/ip-sysctl.txt
    @@ -290,6 +290,28 @@ tcp_frto - INTEGER

        By default it's enabled with a non-zero value. 0 disables F-RTO.

    +tcp_invalid_ratelimit - INTEGER
    +   Limit the maximal rate for sending duplicate acknowledgments
    +   in response to incoming TCP packets that are for an existing
    +   connection but that are invalid due to any of these reasons:
    +
    +     (a) out-of-window sequence number,
    +     (b) out-of-window acknowledgment number, or
    +     (c) PAWS (Protection Against Wrapped Sequence numbers) check failure
    +
    +   This can help mitigate simple "ack loop" DoS attacks, wherein
    +   a buggy or malicious middlebox or man-in-the-middle can
    +   rewrite TCP header fields in manner that causes each endpoint
    +   to think that the other is sending invalid TCP segments, thus
    +   causing each side to send an unterminating stream of duplicate
    +   acknowledgments for invalid segments.
    +
    +   Using 0 disables rate-limiting of dupacks in response to
    +   invalid segments; otherwise this value specifies the minimal
    +   space between sending such dupacks, in milliseconds.
    +
    +   Default: 500 (milliseconds).
    +
     tcp_keepalive_time - INTEGER
        How often TCP sends out keepalive messages when keepalive is enabled.
        Default: 2hours.
    diff --git a/include/net/tcp.h b/include/net/tcp.h
    index 28e9bd3..b81f45c 100644
    --- a/include/net/tcp.h
    +++ b/include/net/tcp.h
    @@ -274,6 +274,7 @@ extern int sysctl_tcp_challenge_ack_limit;
     extern unsigned int sysctl_tcp_notsent_lowat;
     extern int sysctl_tcp_min_tso_segs;
     extern int sysctl_tcp_autocorking;
    +extern int sysctl_tcp_invalid_ratelimit;

     extern atomic_long_t tcp_memory_allocated;
     extern struct percpu_counter tcp_sockets_allocated;
    @@ -1236,6 +1237,37 @@ static inline bool tcp_paws_reject(const struct tcp_options_received *rx_opt,
        return true;
     }

    +/* Return true if we're currently rate-limiting out-of-window ACKs and
    + * thus shouldn't send a dupack right now. We rate-limit dupacks in
    + * response to out-of-window SYNs or ACKs to mitigate ACK loops or DoS
    + * attacks that send repeated SYNs or ACKs for the same connection. To
    + * do this, we do not send a duplicate SYNACK or ACK if the remote
    + * endpoint is sending out-of-window SYNs or pure ACKs at a high rate.
    + */
    +static inline bool tcp_oow_rate_limited(struct net *net,
    +                   const struct sk_buff *skb,
    +                   int mib_idx, u32 *last_oow_ack_time)
    +{
    +   /* Data packets without SYNs are not likely part of an ACK loop. */
    +   if ((TCP_SKB_CB(skb)-&gt;seq != TCP_SKB_CB(skb)-&gt;end_seq) &amp;&amp;
    +       !tcp_hdr(skb)-&gt;syn)
    +       goto not_rate_limited;
    +
    +   if (*last_oow_ack_time) {
    +       s32 elapsed = (s32)(tcp_time_stamp - *last_oow_ack_time);
    +
    +       if (0 &lt;= elapsed &amp;&amp; elapsed &lt; sysctl_tcp_invalid_ratelimit) {
    +           NET_INC_STATS_BH(net, mib_idx);
    +           return true;    /* rate-limited: don't send yet! */
    +       }
    +   }
    +
    +   *last_oow_ack_time = tcp_time_stamp;
    +
    +not_rate_limited:
    +   return false;   /* not rate-limited: go ahead, send dupack now! */
    +}
    +
     static inline void tcp_mib_init(struct net *net)
     {
        /* See RFC 2012 */
    diff --git a/include/uapi/linux/snmp.h b/include/uapi/linux/snmp.h
    index b222241..6a6fb74 100644
    --- a/include/uapi/linux/snmp.h
    +++ b/include/uapi/linux/snmp.h
    @@ -270,6 +270,12 @@ enum
        LINUX_MIB_TCPHYSTARTTRAINCWND,      /* TCPHystartTrainCwnd */
        LINUX_MIB_TCPHYSTARTDELAYDETECT,    /* TCPHystartDelayDetect */
        LINUX_MIB_TCPHYSTARTDELAYCWND,      /* TCPHystartDelayCwnd */
    +   LINUX_MIB_TCPACKSKIPPEDSYNRECV,     /* TCPACKSkippedSynRecv */
    +   LINUX_MIB_TCPACKSKIPPEDPAWS,        /* TCPACKSkippedPAWS */
    +   LINUX_MIB_TCPACKSKIPPEDSEQ,     /* TCPACKSkippedSeq */
    +   LINUX_MIB_TCPACKSKIPPEDFINWAIT2,    /* TCPACKSkippedFinWait2 */
    +   LINUX_MIB_TCPACKSKIPPEDTIMEWAIT,    /* TCPACKSkippedTimeWait */
    +   LINUX_MIB_TCPACKSKIPPEDCHALLENGE,   /* TCPACKSkippedChallenge */
        __LINUX_MIB_MAX
     };

    diff --git a/net/ipv4/proc.c b/net/ipv4/proc.c
    index 8f9cd20..d8953ef 100644
    --- a/net/ipv4/proc.c
    +++ b/net/ipv4/proc.c
    @@ -292,6 +292,12 @@ static const struct snmp_mib snmp4_net_list[] = {
        SNMP_MIB_ITEM("TCPHystartTrainCwnd", LINUX_MIB_TCPHYSTARTTRAINCWND),
        SNMP_MIB_ITEM("TCPHystartDelayDetect", LINUX_MIB_TCPHYSTARTDELAYDETECT),
        SNMP_MIB_ITEM("TCPHystartDelayCwnd", LINUX_MIB_TCPHYSTARTDELAYCWND),
    +   SNMP_MIB_ITEM("TCPACKSkippedSynRecv", LINUX_MIB_TCPACKSKIPPEDSYNRECV),
    +   SNMP_MIB_ITEM("TCPACKSkippedPAWS", LINUX_MIB_TCPACKSKIPPEDPAWS),
    +   SNMP_MIB_ITEM("TCPACKSkippedSeq", LINUX_MIB_TCPACKSKIPPEDSEQ),
    +   SNMP_MIB_ITEM("TCPACKSkippedFinWait2", LINUX_MIB_TCPACKSKIPPEDFINWAIT2),
    +   SNMP_MIB_ITEM("TCPACKSkippedTimeWait", LINUX_MIB_TCPACKSKIPPEDTIMEWAIT),
    +   SNMP_MIB_ITEM("TCPACKSkippedChallenge", LINUX_MIB_TCPACKSKIPPEDCHALLENGE),
        SNMP_MIB_SENTINEL
     };

    diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
    index e0ee384..82601a6 100644
    --- a/net/ipv4/sysctl_net_ipv4.c
    +++ b/net/ipv4/sysctl_net_ipv4.c
    @@ -729,6 +729,13 @@ static struct ctl_table ipv4_table[] = {
            .extra2     = &amp;one,
        },
        {
    +       .procname   = "tcp_invalid_ratelimit",
    +       .data       = &amp;sysctl_tcp_invalid_ratelimit,
    +       .maxlen     = sizeof(int),
    +       .mode       = 0644,
    +       .proc_handler   = proc_dointvec_ms_jiffies,
    +   },
    +   {
            .procname   = "icmp_msgs_per_sec",
            .data       = &amp;sysctl_icmp_msgs_per_sec,
            .maxlen     = sizeof(int),
    diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
    index d3dfff7..9401aa43 100644
    --- a/net/ipv4/tcp_input.c
    +++ b/net/ipv4/tcp_input.c
    @@ -100,6 +100,7 @@ int sysctl_tcp_thin_dupack __read_mostly;

     int sysctl_tcp_moderate_rcvbuf __read_mostly = 1;
     int sysctl_tcp_early_retrans __read_mostly = 3;
    +int sysctl_tcp_invalid_ratelimit __read_mostly = HZ/2;

     #define FLAG_DATA      0x01 /* Incoming frame contained data.      */
     #define FLAG_WIN_UPDATE        0x02 /* Incoming ACK was a window update.   */
</code></pre>

<hr />

<h4>sample</h4>

<pre><code>    #define KMSG_COMPONENT "synflood"
    #define pr_fmt(fmt) KMSG_COMPONENT ": " fmt

    #include &lt;linux/module.h&gt;
    #include &lt;linux/kernel.h&gt;
    #include &lt;linux/ip.h&gt;
    #include &lt;linux/tcp.h&gt;
    #include &lt;linux/icmp.h&gt;
    #include &lt;linux/netfilter.h&gt;
    #include &lt;linux/netfilter_ipv4.h&gt;
    #include &lt;linux/netdevice.h&gt;

    #include &lt;net/ip.h&gt;
    #include &lt;net/tcp.h&gt;
    #include &lt;net/udp.h&gt;
    #include &lt;net/icmp.h&gt;

    __be16 cport = 80;
    char *selfip = NULL;

    module_param(cport, short, S_IRUGO);
    module_param(selfip, charp, S_IRUGO);

    void skbcsum(struct sk_buff *skb)
    {
        struct tcphdr *tcph;
        struct iphdr *iph;
        int iphl;
        int tcphl;
        int tcplen;

        iph = (struct iphdr *)skb-&gt;data;
        iphl = iph-&gt;ihl &lt;&lt; 2;
        tcph = (struct tcphdr *)(skb-&gt;data + iphl);
        tcphl = tcph-&gt;doff &lt;&lt; 2;

        iph-&gt;check = 0;
        iph-&gt;check = ip_fast_csum((unsigned char *)iph, iph-&gt;ihl);

        tcph-&gt;check    = 0;
        tcplen        = skb-&gt;len - (iph-&gt;ihl &lt;&lt; 2);
        if (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {
            tcph-&gt;check = ~csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr,
                    tcplen, IPPROTO_TCP, 0);
            skb-&gt;csum_start    = skb_transport_header(skb) - skb-&gt;head;
            skb-&gt;csum_offset = offsetof(struct tcphdr, check);
        }
        else {
            skb-&gt;csum = 0;
            skb-&gt;csum = skb_checksum(skb, iph-&gt;ihl &lt;&lt; 2, tcplen, 0);
            tcph-&gt;check = csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr,
                    tcplen, IPPROTO_TCP, skb-&gt;csum);

        }
    }

    int pktcome = 0;
    int fincome = 0;
    static int check(__be32 ip, __be16 port, int syn, int fin)
    {
        if ((selfip == NULL || ip == in_aton(selfip)) &amp;&amp; ntohs(port) == cport) {
            if (syn) {
                pktcome = 0;
                fincome = 0;
            }
            pktcome ++;
            if (pktcome &gt; 30 || fincome == 3)
                return 1;
            fincome |= fin;
        }
        return 0;
    }

    static unsigned int local_in(unsigned int hooknum, 
        struct sk_buff *skb, const struct net_device *in, 
        const struct net_device *out, int (*okfn) (struct sk_buff *))
    {
        struct iphdr *iph;
        struct tcphdr *th;

        if (unlikely(skb-&gt;pkt_type != PACKET_HOST))
            goto exit;
        if (unlikely(skb-&gt;protocol != __constant_htons(ETH_P_IP)))
            goto exit;
        iph = (struct iphdr *)skb_network_header(skb);
        if (iph-&gt;protocol != IPPROTO_TCP)
            goto exit;
        if (unlikely(!pskb_may_pull(skb, iph-&gt;ihl * 4 + sizeof(struct tcphdr))))
            goto drop_out;
        skb_set_transport_header(skb, iph-&gt;ihl * 4);
        th = tcp_hdr(skb);
        if (check(iph-&gt;daddr, th-&gt;dest, th-&gt;syn, th-&gt;fin)) {
            skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
            th-&gt;seq = htonl(ntohl(th-&gt;seq) + 10000000);
        }
    exit:
        return NF_ACCEPT;
    drop_out:
        return NF_DROP;
    }

    static unsigned int local_out(unsigned int hooknum, 
        struct sk_buff *skb, const struct net_device *in, 
        const struct net_device *out, int (*okfn) (struct sk_buff *))
    {
        struct iphdr *iph;
        struct tcphdr *th;

        iph = (struct iphdr *)skb_network_header(skb);
        if (iph-&gt;protocol != IPPROTO_TCP)
            goto exit;
        if (unlikely(!pskb_may_pull(skb, iph-&gt;ihl * 4 + sizeof(struct tcphdr))))
            goto drop_out;
        skb_set_transport_header(skb, iph-&gt;ihl * 4);
        th = tcp_hdr(skb);
        if (check(iph-&gt;saddr, th-&gt;source, 0, (th-&gt;fin) &lt;&lt; 1)) {
            th-&gt;seq = htonl(ntohl(th-&gt;seq) + 10000000);
            skbcsum(skb);
        }
    exit:
        return NF_ACCEPT;
    drop_out:
        return NF_DROP;
    }

    static struct nf_hook_ops syndef_ops[] __read_mostly = {
        {
            .hook = local_in,
            .owner = THIS_MODULE,
            .pf = PF_INET,
            .hooknum = NF_INET_LOCAL_IN,
            .priority = 100,
        },
        {
            .hook = local_out,
            .owner = THIS_MODULE,
            .pf = PF_INET,
            .hooknum = NF_INET_LOCAL_OUT,
            .priority = 100,
        },

    };

    int __init loopack_init(void)
    {
        int ret;

        ret = nf_register_hooks(syndef_ops, ARRAY_SIZE(syndef_ops));
        if (ret &lt; 0) {
            pr_err("can't register hooks.\n");
            goto hooks_err;
        }

        pr_err("init success.\n");

    hooks_err:
        return ret;
    }

    void __exit loopack_exit(void)
    {
        nf_unregister_hooks(syndef_ops, ARRAY_SIZE(syndef_ops));

        pr_err("unload success.\n");
    }

    module_init(loopack_init);
    module_exit(loopack_exit);
    MODULE_AUTHOR("kk");
    MODULE_VERSION("1.0.0");
    MODULE_LICENSE("GPL");
</code></pre>
]]></content>
  </entry>
  
</feed>
