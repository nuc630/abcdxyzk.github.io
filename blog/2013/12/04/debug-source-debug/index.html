
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>How source debuggers work? - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>学习中......</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">How source debuggers work?</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-12-04T09:51:00+08:00'><span class='date'>2013-12-04</span> <span class='time'>09:51:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.techveda.org/howsourcedebuggerswork/">http://blog.techveda.org/howsourcedebuggerswork/</a></p>

<p>Application binaries are a result of compile and build operations performed on a single or a set of source files. Program Source files contain functions, data variables of various types (local, global, register, static), and abstract data objects, all written and neatly indented with nested control structures as per high level programming language syntax (C/C++).  Compilers translate code in each source file into machine instructions (1’s and 0’s) as per target processors Instruction set Architecture and bury that code into object files. Further, Linkers integrate compiled object files with other pre-compiled objects files (libraries, runtime binaries) to create end application binary image called executable.</p>

<p>Source debuggers are tools used to trace execution of an application executable binary. Most amazing feature of a source debugger is its ability to list source code of the program being debugged; it can show the line or expression in the source code that resulted in a particular machine code instruction of a running program loaded in memory. This helps the programmer to analyze a program’s behavior in the high-level terms like source-level flow control constructs, procedure calls, named variables, etc,  instead of machine instructions and memory locations. Source-level debugging also makes it possible to step through execution a line at a time and set source-level breakpoints. (If you do not have any prior hands on experience with source debuggers I suggest you to look at this before continuing with following.)</p>

<p>lets explore how source debuggers like gnu gdb work ? So how does a debugger know where to stop when you ask it to break at the entry to some function? How does it manage to find what to show you when you ask it for the value of a variable? The answer is – debug information.  All modern compilers are designed to generate Debug information together with the machine code of the source file. It is a representation of the relationship between the executable program and the original source code. This information is encoded as per  a pre-defined format and stored alongside the machine code. Many such formats were invented over the years for different platforms and executable files (aim of this article isn’t to survey the history of these formats, but rather to show how they work). Gnu compiler and ELF executable on Linux/ UNIX platforms use DWARF, which is widely used today as default debugging information format.</p>

<p>Word of Advice : Does an Application/ Kernel programmer need to know Dwarf?</p>

<p>Obvious answer to this question is a big NO.  It is purely subject matter for developers involved in implementation of a Debugger tool. A normal Application developer using debugger tools would never need to learn or dig into binary files for debug information. This in no way adds any edge to your debugging skills nor adds any new skills into your armory. However, if you are a developer using debuggers for years and curious about how debuggers work read this document for an outline into debug information.  If you are a beginner to systems programming or fresher’s learning programming I would  suggest  not to waste your time as you can safely ignore this.</p>

<p>ELF -DWARF sections</p>

<p>Gnu compiler generates debug information which is organized into various sections of the ELF object file. Let’s use the following source file for compiling and observing DWARF sections</p>

<p>root@techveda:~# vim sample.c</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'> 
</span><span class='line'>int add(int x, int y)
</span><span class='line'>{
</span><span class='line'>    return x + y;
</span><span class='line'>}
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    int a = 10, b = 20;
</span><span class='line'>    int result;
</span><span class='line'>    int (*fp) (int, int);
</span><span class='line'> 
</span><span class='line'>    fp = add;
</span><span class='line'>    result = (*fp) (a, b);
</span><span class='line'>    printf(" %dn", result);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>root@techveda:~# gcc -c -g sample.c -o sample.o
</span><span class='line'>root@techveda:~# objdump -h sample.o | more
</span><span class='line'>
</span><span class='line'>sample.o:     file format elf32-i386
</span><span class='line'> 
</span><span class='line'>Sections:
</span><span class='line'>Idx Name          Size      VMA       LMA       File off  Algn
</span><span class='line'>  0 .text         0000005f  00000000  00000000  00000034  2**2
</span><span class='line'>              CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
</span><span class='line'>  1 .data         00000000  00000000  00000000  00000094  2**2
</span><span class='line'>              CONTENTS, ALLOC, LOAD, DATA
</span><span class='line'>  2 .bss          00000000  00000000  00000000  00000094  2**2
</span><span class='line'>              ALLOC
</span><span class='line'>  3 .debug_abbrev 000000a2  00000000  00000000  00000094  2**0
</span><span class='line'>              CONTENTS, READONLY, DEBUGGING
</span><span class='line'>  4 .debug_info   00000114  00000000  00000000  00000136  2**0
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING
</span><span class='line'>  5 .debug_line   00000040  00000000  00000000  0000024a  2**0
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING
</span><span class='line'>  6 .rodata       00000005  00000000  00000000  0000028a  2**0
</span><span class='line'>              CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span class='line'>  7 .debug_loc    00000070  00000000  00000000  0000028f  2**0
</span><span class='line'>              CONTENTS, READONLY, DEBUGGING
</span><span class='line'>  8 .debug_pubnames 00000023  00000000  00000000  000002ff  2**0
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING
</span><span class='line'>  9 .debug_pubtypes 00000012  00000000  00000000  00000322  2**0
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING
</span><span class='line'> 10 .debug_aranges 00000020  00000000  00000000  00000334  2**0
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING
</span><span class='line'> 11 .debug_str    000000b0  00000000  00000000  00000354  2**0
</span><span class='line'>              CONTENTS, READONLY, DEBUGGING
</span><span class='line'> 12 .comment      0000002b  00000000  00000000  00000404  2**0
</span><span class='line'>              CONTENTS, READONLY
</span><span class='line'> 13 .note.GNU-stack 00000000  00000000  00000000  0000042f  2**0
</span><span class='line'>              CONTENTS, READONLY
</span><span class='line'> 14 .debug_frame  00000054  00000000  00000000  00000430  2**2
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING</span></code></pre></td></tr></table></div></figure>


<p>All of the sections with naming debug_xxx are debugging information sections.  Information in these sections is interpreted by source debugger like gdb.  Each debug_ section holds specific information like</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.debug_info               core DWARF data containing DIEs
</span><span class='line'>.debug_line               Line Number Program
</span><span class='line'>.debug_frame              Call Frame Information
</span><span class='line'>.debug_macinfo            lookup table for global objects and functions
</span><span class='line'>.debug_pubnames           lookup table for global objects and functions
</span><span class='line'>.debug_pubtypes           lookup table for global types
</span><span class='line'>.debug_loc                Macro descriptions
</span><span class='line'>.debug_abbrev             Abbreviations used in the .debug_info section
</span><span class='line'>.debug_aranges            mapping between memory address and compilation
</span><span class='line'>.debug_ranges             Address ranges referenced by DIEs
</span><span class='line'>.debug_str                String table used by .debug_info</span></code></pre></td></tr></table></div></figure>


<p>Debugging Information Entry (DIE)</p>

<p>Dwarf format organizes debug data in all of the above sections using special objects (program descriptive entities) called Debugging Information Entry (DIE).  Each DIE has a tag filed whose value specifies its type, and a set of attributes. DIEs are interlinked via sibling and child links, and values of attributes can point at other DIEs. Now let’s dig into ELF file to view how a DIE looks like. We will begin our exploration with .debug_info section of the ELF file since core DIE’s are listed in it.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@techveda:~# objdump --dwarf=info . /sample
</span><span class='line'>
</span><span class='line'>Above operation shows long list of DIE’s. Let’s limit ourselves to relevant information
</span><span class='line'>
</span><span class='line'>./sample:     file format elf32-i386
</span><span class='line'> 
</span><span class='line'>Contents of the .debug_info section:
</span><span class='line'> 
</span><span class='line'>  Compilation Unit @ offset 0x0:
</span><span class='line'>   Length:        0x110 (32-bit)
</span><span class='line'>   Version:       2
</span><span class='line'>   Abbrev Offset: 0
</span><span class='line'>   Pointer Size:  4
</span><span class='line'> &lt;0&gt;&lt;b&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
</span><span class='line'>    &lt; c&gt;   DW_AT_producer    : (indirect string, offset: 0xe): GNU C 4.5.2   
</span><span class='line'>    &lt;10&gt;   DW_AT_language    : 1  (ANSI C)
</span><span class='line'>    &lt;11&gt;   DW_AT_name        : (indirect string, offset: 0x44): sample.c 
</span><span class='line'>    &lt;15&gt;   DW_AT_comp_dir    : (indirect string, offset: 0x71): /root
</span><span class='line'>    &lt;19&gt;   DW_AT_low_pc      : 0x80483c4 
</span><span class='line'>    &lt;1d&gt;   DW_AT_high_pc     : 0x8048423 
</span><span class='line'>    &lt;21&gt;   DW_AT_stmt_list   : 0x0</span></code></pre></td></tr></table></div></figure>


<p>Each source file in the application is referred in dwarf terminology as a “compilation unit”.   Dwarf data for each compilation unit (source file) starts with a compilation unit DIE. Above dump shows the first DIE’s and tag value “DW_TAG_compile_unit “.  This DIE provides general information about compilation unit like source file name (DW_AT_name   : (indirect string, offset: 0×44): sample.c),  high level programming language used to write source file(DW_AT_language    : 1    (ANSI C))  ,   directory of the source file(DW_AT_comp_dir    : (indirect string, offset: 0×71): /root) ,  compiler and producer of dwarf data(  DW_AT_producer    : (indirect string, offset: 0xe): GNU C 4.5.2) , start virtual address of the compilation unit  (DW_AT_low_pc      : 0x80483c4), end virtual address of the unit (DW_AT_high_pc     : 0×8048423).</p>

<p>Compilation Unit DIE is the parent for all the other DIE’s that describe elements of source file. Generally, the list of DIE’s that follow will describe data types, followed by global data, then the functions that make up the source file. The DIEs for variables and functions are in the same order in which they appear in the source file.</p>

<p>How does debugger locate Function Information ?</p>

<p> While using source debuggers we often instruct debugger to insert or place break point at some function, expecting the debugger to pause program execution at functions. To be able to perform this task, debugger must have some mapping between a function name in the high-level code and the address in the machine code where the instructions for this function begin. For this mapping information debuggers rely on DIE’s that describes specified function. DIE’s describing functions in a compilation unit are assigned tag value “DW_TAG_subprogram” subprogram as per dwarf terminology is a function.</p>

<p>In our sample application source we have two functions (main, add), dwarf should generate a “DW_TAG_subprogram” DIE’s for each function, these DIE attributes would define function mapping information that debugger needs for resolving machine code addresses with function name.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Each “DW_TAG_subprogam” DIE contains
</span><span class='line'>
</span><span class='line'>    function scope
</span><span class='line'>    function name
</span><span class='line'>    source file or compilation unit in which function is located
</span><span class='line'>     line no in the source file where the function starts
</span><span class='line'>    Functions return type
</span><span class='line'>    Start address of the fucntion
</span><span class='line'>    End address of the function
</span><span class='line'>    Frame information of the function.</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@techveda:~# objdump --dwarf=info ./sample | grep "DW_TAG_subprogram"
</span><span class='line'> &lt;1&gt;&lt;72&gt;: Abbrev Number: 4 (DW_TAG_subprogram)
</span><span class='line'> &lt;1&gt;&lt;a8&gt;: Abbrev Number: 6 (DW_TAG_subprogram)
</span><span class='line'> 
</span><span class='line'>&lt;1&gt;&lt;72&gt;: Abbrev Number: 4 (DW_TAG_subprogram)
</span><span class='line'>    &lt;73&gt;   DW_AT_external    : 1 
</span><span class='line'>    &lt;74&gt;   DW_AT_name        : add   
</span><span class='line'>    &lt;78&gt;   DW_AT_decl_file   : 1 
</span><span class='line'>    &lt;79&gt;   DW_AT_decl_line   : 4 
</span><span class='line'>    &lt;7a&gt;   DW_AT_prototyped  : 1 
</span><span class='line'>    &lt;7b&gt;   DW_AT_type        : &lt;0x4f&gt;  
</span><span class='line'>    &lt;7f&gt;   DW_AT_low_pc      : 0x80483c4 
</span><span class='line'>    &lt;83&gt;   DW_AT_high_pc     : 0x80483d1 
</span><span class='line'>    &lt;87&gt;   DW_AT_frame_base  : 0x0    (location list)
</span><span class='line'>    &lt;8b&gt;   DW_AT_sibling     : &lt;0xa8&gt;  
</span><span class='line'> 
</span><span class='line'>&lt;1&gt;&lt;a8&gt;: Abbrev Number: 6 (DW_TAG_subprogram)
</span><span class='line'>    &lt;a9&gt;   DW_AT_external    : 1 
</span><span class='line'>    &lt;aa&gt;   DW_AT_name        : (indirect string, offset: 0x1a): main 
</span><span class='line'>    &lt;ae&gt;   DW_AT_decl_file   : 1 
</span><span class='line'>    &lt;af&gt;   DW_AT_decl_line   : 8 
</span><span class='line'>    &lt;b0&gt;   DW_AT_type        : &lt;0x4f&gt;  
</span><span class='line'>    &lt;b4&gt;   DW_AT_low_pc      : 0x80483d2 
</span><span class='line'>    &lt;b8&gt;   DW_AT_high_pc     : 0x8048423 
</span><span class='line'>    &lt;bc&gt;   DW_AT_frame_base  : 0x38   (location list)
</span><span class='line'>    &lt;c0&gt;   DW_AT_sibling     : &lt;0xf8&gt;</span></code></pre></td></tr></table></div></figure>


<p>We now have accessed DIE description of function’s main and add.  Let’s analyze attribute information of add fucntions DIE.</p>

<p>Function scope:    DW_AT_external    : 1 (scope external)</p>

<p>Function name:     DW_AT_name        : add</p>

<p>Source file or compilation unit in which function is located:  DW_AT_decl_file   : 1 (indicates 1st compilation unit which is sample.c)</p>

<p>line no in the source file where the function starts:  DW_AT_decl_line   : 4 ( indicates line no 4 in source file)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1#include &lt;stdio.h&gt;
</span><span class='line'>2#include &lt;stdlib.h&gt;
</span><span class='line'>3 
</span><span class='line'>4int add(int x, int y)
</span><span class='line'>5{
</span><span class='line'>6        return x + y;
</span><span class='line'>7}
</span><span class='line'>8int main()
</span><span class='line'>9{
</span><span class='line'>10        int a = 10, b = 20;
</span><span class='line'>11        int result;
</span><span class='line'>12        int (*fp) (int, int);
</span><span class='line'>13 
</span><span class='line'>14        fp = add;
</span><span class='line'>15        result = (*fp) (a, b);
</span><span class='line'>16        printf(" %dn", result);
</span><span class='line'>17}</span></code></pre></td></tr></table></div></figure>


<p>Function’s source line no matched with DIE description of line no. let’s continue with rest of the attribute values</p>

<p>Functions return type:  DW_AT_type        : <0x4f></p>

<p>As we have already understood that values of attributes can point to other DIE , here is an example of it.  Value   DW_AT_type     : <0x4f> indicates that return type description is stored in other DIE at offset 0x4f.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;4f&gt;: Abbrev Number: 3 (DW_TAG_base_type)
</span><span class='line'>    &lt;50&gt;   DW_AT_byte_size   : 4 
</span><span class='line'>    &lt;51&gt;   DW_AT_encoding    : 5  (signed)
</span><span class='line'>    &lt;52&gt;   DW_AT_name        : int</span></code></pre></td></tr></table></div></figure>


<p>This DIE describes data type and composition of return type of the function add, as per DIE attribute values return type is signed int  of size 4 bytes.</p>

<p>Start address of the function : DW_AT_low_pc   : 0x80483c4</p>

<p>End address of the function: DW_AT_high_pc     : 0x80483d1</p>

<p>Above values indicate start and end virtual address of the machine instructions of add function, we can verify that with binary dump of the function</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>080483c4 &lt;add&gt;:
</span><span class='line'> 80483c4:   55                      push   %ebp
</span><span class='line'> 80483c5:   89 e5                   mov    %esp,%ebp
</span><span class='line'> 80483c7:   8b 45 0c                mov    0xc(%ebp),%eax
</span><span class='line'> 80483ca:   8b 55 08                mov    0x8(%ebp),%edx
</span><span class='line'> 80483cd:   8d 04 02                lea    (%edx,%eax,1),%eax
</span><span class='line'> 80483d0:   5d                      pop    %ebp
</span><span class='line'> 80483d1:   c3                      ret</span></code></pre></td></tr></table></div></figure>


<p>How does debugger find program data (variables…) Information?</p>

<p>When the program hits assigned break point in a function, debugger pauses the program execution, at this time we can instruct debugger to show or print values of variables, by using debugger commands like print or display followed by variable name (ex: print a) How does debugger know where to find memory location of the variable ? Variables can be located in global storage, on the stack, and even in registers.The debugging information has to be able to reflect all these variations, and indeed DWARF does. As an example let’s take a look at complete DIE information set for main function.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;1&gt;&lt;a8&gt;: Abbrev Number: 6 (DW_TAG_subprogram)
</span><span class='line'>    &lt;a9&gt;   DW_AT_external    : 1 
</span><span class='line'>    &lt;aa&gt;   DW_AT_name        : (indirect string, offset: 0x1a): main 
</span><span class='line'>    &lt;ae&gt;   DW_AT_decl_file   : 1 
</span><span class='line'>    &lt;af&gt;   DW_AT_decl_line   : 8 
</span><span class='line'>    &lt;b0&gt;   DW_AT_type        : &lt;0x4f&gt;  
</span><span class='line'>    &lt;b4&gt;   DW_AT_low_pc      : 0x80483d2 
</span><span class='line'>    &lt;b8&gt;   DW_AT_high_pc     : 0x8048423 
</span><span class='line'>    &lt;bc&gt;   DW_AT_frame_base  : 0x38   (location list)
</span><span class='line'>    &lt;c0&gt;   DW_AT_sibling     : &lt;0xf8&gt;  
</span><span class='line'> &lt;2&gt;&lt;c4&gt;: Abbrev Number: 7 (DW_TAG_variable)
</span><span class='line'>    &lt;c5&gt;   DW_AT_name        : a 
</span><span class='line'>    &lt;c7&gt;   DW_AT_decl_file   : 1 
</span><span class='line'>    &lt;c8&gt;   DW_AT_decl_line   : 10
</span><span class='line'>    &lt;c9&gt;   DW_AT_type        : &lt;0x4f&gt;  
</span><span class='line'>    &lt;cd&gt;   DW_AT_location    : 2 byte block: 74 1c    (DW_OP_breg4 (esp): 28)
</span><span class='line'> &lt;2&gt;&lt;d0&gt;: Abbrev Number: 7 (DW_TAG_variable)
</span><span class='line'>    &lt;d1&gt;   DW_AT_name        : b 
</span><span class='line'>    &lt;d3&gt;   DW_AT_decl_file   : 1 
</span><span class='line'>    &lt;d4&gt;   DW_AT_decl_line   : 10
</span><span class='line'>    &lt;d5&gt;   DW_AT_type        : &lt;0x4f&gt;  
</span><span class='line'>    &lt;d9&gt;   DW_AT_location    : 2 byte block: 74 18    (DW_OP_breg4 (esp): 24)
</span><span class='line'> &lt;2&gt;&lt;dc&gt;: Abbrev Number: 8 (DW_TAG_variable)
</span><span class='line'>    &lt;dd&gt;           : (indirect string, offset: 0x6a): result 
</span><span class='line'>    &lt;e1&gt;   DW_AT_decl_file   : 1 
</span><span class='line'>    &lt;e2&gt;   DW_AT_decl_line   : 11
</span><span class='line'>    &lt;e3&gt;   DW_AT_type        : &lt;0x4f&gt;  
</span><span class='line'>    &lt;e7&gt;   DW_AT_location    : 2 byte block: 74 10    (DW_OP_breg4 (esp): 16)
</span><span class='line'> &lt;2&gt;&lt;ea&gt;: Abbrev Number: 7 (DW_TAG_variable)
</span><span class='line'>    &lt;eb&gt;   DW_AT_name        : fp
</span><span class='line'>    &lt;ee&gt;   DW_AT_decl_file   : 1 
</span><span class='line'>    &lt;ef&gt;   DW_AT_decl_line   : 12
</span><span class='line'>    &lt;f0&gt;   DW_AT_type        : &lt;0x10d&gt; 
</span><span class='line'>    &lt;f4&gt;   DW_AT_location    : 2 byte block: 74 14    (DW_OP_breg4 (esp): 20)</span></code></pre></td></tr></table></div></figure>


<p>Note the first number inside the angle brackets in each entry. This is the nesting level – in this example entries with <2> are children of the entry with <1>. main function has three integer variables a,b and result each of these variables are described with DW_TAG_variable nested DIE’s (0xc4, 0xd0, 0xdc). main function also has a function pointer  fp described  in DIE 0xea . Variable DIE attributes specify variable name (DW_AT_name), declaration line no in source function (DW_AT_decl_line ), pointer to address of DIE describing variables data type (DW_AT_type) and relative location of the variable within function’s frame (DW_AT_location).</p>

<p>To locate the variable in the memory image of the executing process, the debugger will look at the DW_AT_location attribute of DIE. For a its value is    DW_OP_fbreg4 (esp):28. This means that the variable is stored at offset 28  from the top in the frame of  containing function. The DW_AT_frame_base attribute of main has the value 0×38(location list), which means that this value actually has to be looked up in the location list section. Let’s look at it:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@techveda:~# objdump --dwarf=loc sample
</span><span class='line'> 
</span><span class='line'>sample:     file format elf32-i386
</span><span class='line'> 
</span><span class='line'>Contents of the .debug_loc section:
</span><span class='line'> 
</span><span class='line'>    Offset   Begin    End      Expression
</span><span class='line'>    00000000 080483c4 080483c5 (DW_OP_breg4 (esp): 4)
</span><span class='line'>    00000000 080483c5 080483c7 (DW_OP_breg4 (esp): 8)
</span><span class='line'>    00000000 080483c7 080483d1 (DW_OP_breg5 (ebp): 8)
</span><span class='line'>    00000000 080483d1 080483d2 (DW_OP_breg4 (esp): 4)
</span><span class='line'>    00000000 &lt;End of list&gt;
</span><span class='line'>    00000038 080483d2 080483d3 (DW_OP_breg4 (esp): 4)
</span><span class='line'>    00000038 080483d3 080483d5 (DW_OP_breg4 (esp): 8)
</span><span class='line'>    00000038 080483d5 08048422 (DW_OP_breg5 (ebp): 8)
</span><span class='line'>    00000038 08048422 08048423 (DW_OP_breg4 (esp): 4)
</span><span class='line'>    00000038 &lt;End of list&gt;</span></code></pre></td></tr></table></div></figure>


<p>Offset column 0×38 values are the entries for main function variables. Each entry here describes possible frame base address with respect to where debugger may be paused by break point within function instructions; it specifies the current frame base from which offsets to variables are to be computed as an offset from a register. For x86, bpreg4 refers to esp and bpreg5 refers to ebp.  Before analyzing further lets look at disassemble dump for main function</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>080483d2 &lt;main&gt;:
</span><span class='line'> 80483d2:   55                      push   %ebp
</span><span class='line'> 80483d3:   89 e5                   mov    %esp,%ebp
</span><span class='line'> 80483d5:   83 e4 f0                and    $0xfffffff0,%esp
</span><span class='line'> 80483d8:   83 ec 20                sub    $0x20,%esp
</span><span class='line'> 80483db:   c7 44 24 1c 0a 00 00    movl   $0xa,0x1c(%esp)
</span><span class='line'> 80483e2:   00
</span><span class='line'> 80483e3:   c7 44 24 18 14 00 00    movl   $0x14,0x18(%esp)
</span><span class='line'> 80483ea:   00
</span><span class='line'> 80483eb:   c7 44 24 14 c4 83 04    movl   $0x80483c4,0x14(%esp)
</span><span class='line'> 80483f2:   08
</span><span class='line'> 80483f3:   8b 44 24 18             mov    0x18(%esp),%eax
</span><span class='line'> 80483f7:   89 44 24 04             mov    %eax,0x4(%esp)
</span><span class='line'> 80483fb:   8b 44 24 1c             mov    0x1c(%esp),%eax
</span><span class='line'> 80483ff:   89 04 24                mov    %eax,(%esp)
</span><span class='line'> 8048402:   8b 44 24 14             mov    0x14(%esp),%eax
</span><span class='line'> 8048406:   ff d0                               call   *%eax
</span><span class='line'> 8048408:   89 44 24 10             mov    %eax,0x10(%esp)
</span><span class='line'> 804840c:   b8 f0 84 04 08          mov    $0x80484f0,%eax
</span><span class='line'> 8048411:   8b 54 24 10             mov    0x10(%esp),%edx
</span><span class='line'> 8048415:   89 54 24 04             mov    %edx,0x4(%esp)
</span><span class='line'> 8048419:   89 04 24                mov    %eax,(%esp)
</span><span class='line'> 804841c:   e8 d3 fe ff ff          call   80482f4 &lt;printf@plt&gt;
</span><span class='line'> 8048421:   c9                      leave 
</span><span class='line'> 8048422:   c3                      ret</span></code></pre></td></tr></table></div></figure>


<p>First two instructions deal with function’s preamble, function’s stack frame base pointer is determined after pre-amble instructions are executed.  Ebp remains constant throughout function’s execution and esp keeps changing with data being pushed and popped from the stack frame. From the above dump instructions at offset 80483db and 80483e3 are assigning values 10 and 20 to variables a, and b. These variables are being accessed their offset in stack frame relative to location of current esp( variable a: 0x1c(%esp), variable b: 0×18(%esp)). Now let’s assume that break point was set after initializing a and b variables and program paused, and we have run print command to view conents of a or b variables. Debugger would access 3rd record of the main function’s dwarf debug.loc table since our break point falls between 080483d5 – 08048422 region of the function code.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>00000038 080483d2 080483d3 (DW_OP_breg4 (esp): 4)
</span><span class='line'>00000038 080483d3 080483d5 (DW_OP_breg4 (esp): 8)
</span><span class='line'>00000038 080483d5 08048422 (DW_OP_breg5 (ebp): 8)--- 3rd record
</span><span class='line'>00000038 08048422 08048423 (DW_OP_breg4 (esp): 4)</span></code></pre></td></tr></table></div></figure>


<p>Now as per records debugger will locate a with esp + 28 , b with esp +24 and so on…</p>

<p>Looking up line number information</p>

<p>We can set breakpoints mentioning line no’s Lets now look at how debuggers resolve line no’s to machine instruction’s? DWARF encodes a full mapping between lines in the C source code and machine code addresses in the executable. This information is contained in the .debug_line section and can be extracted using objdump</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@techveda:~# objdump --dwarf=decodedline ./sample
</span><span class='line'> 
</span><span class='line'>./sample:     file format elf32-i386
</span><span class='line'> 
</span><span class='line'>Decoded dump of debug contents of section .debug_line:
</span><span class='line'> 
</span><span class='line'>CU: sample.c:
</span><span class='line'>File name                            Line number    Starting address                   
</span><span class='line'>sample.c                                       5          0x80483c4
</span><span class='line'>sample.c                                       6          0x80483c7
</span><span class='line'>sample.c                                       7          0x80483d0
</span><span class='line'>sample.c                                       9          0x80483d2
</span><span class='line'>sample.c                                      10          0x80483db
</span><span class='line'>sample.c                                      14          0x80483eb
</span><span class='line'>sample.c                                      15          0x80483f3
</span><span class='line'>sample.c                                      16          0x804840c
</span><span class='line'>sample.c                                      17          0x8048421</span></code></pre></td></tr></table></div></figure>


<p>This dump shows machine instruction line no’s for our program. It is quite obvious that line no’s for non-executable statements of the source file need not be tracked by dwarf .we can map the above dump to our source code for analysis.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 #include &lt;stdio.h&gt;
</span><span class='line'> 2 #include &lt;stdlib.h&gt;
</span><span class='line'> 3
</span><span class='line'> 4 int add(int x, int y)
</span><span class='line'> 5 {
</span><span class='line'> 6         return x + y;
</span><span class='line'> 7 }
</span><span class='line'> 8 int main()
</span><span class='line'> 9 {
</span><span class='line'>10         int a = 10, b = 20;
</span><span class='line'>11         int result;
</span><span class='line'>12         int (*fp) (int, int);
</span><span class='line'>13
</span><span class='line'>14         fp = add;
</span><span class='line'>15         result = (*fp) (a, b);
</span><span class='line'>16         printf(" %dn", result);
</span><span class='line'>17 }</span></code></pre></td></tr></table></div></figure>


<p>From the above it should be clear of what debugger does it is instructed to set breakpoint at entry into function add, it would insert break point at line no 6 and pause after pre-amble of function add is executed.</p>

<p>What’s next?</p>

<p>if you are into implementation of debugging tools or involved in writing programs/tools  that simulate debugger facilities/ read binary files , you may be interested in specific programming libraries libbfd or libdwarf.</p>

<p>Binary File Descriptor library (BFD) or libbfd as it is called provides ready to use functions to read into ELF and other popular binary files. BFD works by presenting a common abstract view of object files. An object file has a “header” with descriptive info; a variable number of “sections” that each has a name, some attributes, and a block of data; a symbol table; relocation entries; and so forth. Gnu binutils package tools like objdump, readelf and others have been written using these libraries.</p>

<p>Libdwarf is a C library intended to simplify reading (and writing) applications built with DWARF2, DWARF3 debug information.</p>

<p>Dwarfdump is an application written using libdwarf to print dwarf information in a human readable format. It is also open sourced and is copyrighted GPL. It provides an example of using libdwarf to read DWARF2/3 information as well as providing readable text output.</p>

<p>References</p>

<p><a href="http://www.dwarfstd.org/">Dwarf Standard</a><br/>
<a href="http://wiki.dwarfstd.org/index.php?title=Libdwarf_And_Dwarfdump">Libdwarf Wiki</a><br/>
<a href="http://www.skyfree.org/linux/references/bfd.pdf">Libbfd draft</a></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2013-12-04T09:51:00+08:00'><span class='date'>2013-12-04</span> <span class='time'>09:51:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/debug/'>debug</a>, <a class='category' href='/blog/cats/debug~base/'>base</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/12/02/debug-articles/" title="Previous Post: debug articles">&laquo; debug articles</a>
      
      
        <a class="basic-alignment right" href="/blog/2013/12/23/assembly-opcode/" title="Next Post: 深入浅出指令编码之三：64位计算">深入浅出指令编码之三：64位计算 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
<!--  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script> -->
</p>

</footer>
  





</body>
</html>
