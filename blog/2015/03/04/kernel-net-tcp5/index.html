
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>TCP拥塞状态机 tcp_fastretrans_alert - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>学习中......</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">TCP拥塞状态机 tcp_fastretrans_alert</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-04T17:45:00+08:00'><span class='date'>2015-03-04</span> <span class='time'>17:45:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>这里主要说的是TCP拥塞情况下的状态状态处理</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Process an event, which can update packets-in-flight not trivially.
</span><span class='line'> * Main goal of this function is to calculate new estimate for left_out,
</span><span class='line'> * taking into account both packets sitting in receiver's buffer and
</span><span class='line'> * packets lost by network.
</span><span class='line'> *
</span><span class='line'> * Besides that it does CWND reduction, when packet loss is detected
</span><span class='line'> * and changes state of machine.
</span><span class='line'> *
</span><span class='line'> * It does _not_ decide what to send, it is made in function
</span><span class='line'> * tcp_xmit_retransmit_queue().
</span><span class='line'> */
</span><span class='line'>static void tcp_fastretrans_alert(struct sock *sk, int pkts_acked, int flag)
</span><span class='line'>{
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);     
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    int is_dupack = !(flag & (FLAG_SND_UNA_ADVANCED | FLAG_NOT_DUP));   // 判断是不是重复的ACK
</span><span class='line'>    int do_lost = is_dupack || ((flag & FLAG_DATA_SACKED) &&            // 判断是不是丢包：若是重复ACK 或者 SACK而且提前确认中没有到的包数量&gt;重拍指标
</span><span class='line'>                    (tcp_fackets_out(tp) &gt; tp-&gt;reordering));            // 后面会单独说说SACK和FACK内容，觉得总是理解不好
</span><span class='line'>    int fast_rexmit = 0;
</span><span class='line'> 
</span><span class='line'>    if (WARN_ON(!tp-&gt;packets_out && tp-&gt;sacked_out))   // 如果packet_out为0，那么不可能有sacked_out
</span><span class='line'>        tp-&gt;sacked_out = 0;
</span><span class='line'>    if (WARN_ON(!tp-&gt;sacked_out && tp-&gt;fackets_out))
</span><span class='line'>        tp-&gt;fackets_out = 0;
</span><span class='line'> 
</span><span class='line'>    /* Now state machine starts.   // 下面开始状态处理
</span><span class='line'>     * A. ECE, hence prohibit cwnd undoing, the reduction is required. */
</span><span class='line'>    if (flag & FLAG_ECE)         // 如果是ECE
</span><span class='line'>        tp-&gt;prior_ssthresh = 0;    // 禁止拥塞窗口撤销，并开始减小拥塞窗口
</span><span class='line'> 
</span><span class='line'>    /* B. In all the states check for reneging SACKs. */
</span><span class='line'>    if (tcp_check_sack_reneging(sk, flag))   // 检查ACK是不是确认了已经被SACK选择确认的包了
</span><span class='line'>        return;
</span><span class='line'> 
</span><span class='line'>    /* C. Process data loss notification, provided it is valid. */
</span><span class='line'>    if (tcp_is_fack(tp) && (flag & FLAG_DATA_LOST) &&   // 提前确认、数据丢失
</span><span class='line'>        before(tp-&gt;snd_una, tp-&gt;high_seq) &&            // 我们需要注意high_seq&nbsp;可以标志为LOST的段序号的最大值
</span><span class='line'>        icsk-&gt;icsk_ca_state != TCP_CA_Open &&           // 状态不是OPEN
</span><span class='line'>        tp-&gt;fackets_out &gt; tp-&gt;reordering) {             // 同上面说的
</span><span class='line'>        tcp_mark_head_lost(sk, tp-&gt;fackets_out - tp-&gt;reordering);   // 发现丢包，需要标志出丢失的包。&nbsp;(1) 这个函数后面看
</span><span class='line'>        NET_INC_STATS_BH(LINUX_MIB_TCPLOSS);
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    /* D. Check consistency of the current state. */
</span><span class='line'>    tcp_verify_left_out(tp); // #define tcp_verify_left_out(tp) WARN_ON(tcp_left_out(tp) &gt; tp-&gt;packets_out)
</span><span class='line'>                 // 检查丢失的包应该比发送出去的包小，即确定确定left_out &lt; packets_out
</span><span class='line'>    /* E. Check state exit conditions. State can be terminated
</span><span class='line'>     *    when high_seq is ACKed. */                    // 下面检测状态退出条件！当high_seq&nbsp;被确认的时候，这个状态就可以终止了
</span><span class='line'>    if (icsk-&gt;icsk_ca_state == TCP_CA_Open) {           // 如果是open状态
</span><span class='line'>        BUG_TRAP(tp-&gt;retrans_out == 0);                 // 重传数量应该=0才是合理的
</span><span class='line'>        tp-&gt;retrans_stamp = 0;                          // 将重传发送时间置0
</span><span class='line'>    } else if (!before(tp-&gt;snd_una, tp-&gt;high_seq)) {    // 如果high_seq已经被确认
</span><span class='line'>        switch (icsk-&gt;icsk_ca_state) {
</span><span class='line'>        case TCP_CA_Loss:
</span><span class='line'>            icsk-&gt;icsk_retransmits = 0;                 // 超时重传次数归零
</span><span class='line'>            if (tcp_try_undo_recovery(sk))              // 尝试将前面的拥塞窗口的调整撤销，在这种情况下弄不清楚包的情况（2）
</span><span class='line'>                return;                                 // 如果使用了SACK，那么不管undo成功与否，都会返回Open态
</span><span class='line'>            break;
</span><span class='line'> 
</span><span class='line'>        case TCP_CA_CWR:   // 发生某些道路拥塞，需要减慢发送速度
</span><span class='line'>            /* CWR is to be held something *above* high_seq
</span><span class='line'>             * is ACKed for CWR bit to reach receiver. */
</span><span class='line'>            if (tp-&gt;snd_una != tp-&gt;high_seq) {
</span><span class='line'>                tcp_complete_cwr(sk);                   // 完成道路拥塞情况处理，就是减小cwnd（3）
</span><span class='line'>                tcp_set_ca_state(sk, TCP_CA_Open);      // 将状态设置成OPEN
</span><span class='line'>            }
</span><span class='line'>            break;
</span><span class='line'> 
</span><span class='line'>        case TCP_CA_Disorder:
</span><span class='line'>            tcp_try_undo_dsack(sk);                     // 尝试撤销cwnd的减少，因为DSACK确认了所有的重传数据（4）
</span><span class='line'>            if (!tp-&gt;undo_marker ||                     // 跟踪了重传数据包？
</span><span class='line'>                /* For SACK case do not Open to allow to undo
</span><span class='line'>                 * catching for all duplicate ACKs. */
</span><span class='line'>                tcp_is_reno(tp) || tp-&gt;snd_una != tp-&gt;high_seq) {   // 没有SACK || 两者不同步
</span><span class='line'>                tp-&gt;undo_marker = 0;
</span><span class='line'>                tcp_set_ca_state(sk, TCP_CA_Open);      // 将状态转换成OPEN
</span><span class='line'>            }
</span><span class='line'>            break;
</span><span class='line'> 
</span><span class='line'>        case TCP_CA_Recovery:
</span><span class='line'>            if (tcp_is_reno(tp))                // 没有SACK
</span><span class='line'>                tcp_reset_reno_sack(tp);        // sacked_out=0
</span><span class='line'>            if (tcp_try_undo_recovery(sk))      // 尝试撤销
</span><span class='line'>                return;
</span><span class='line'>            tcp_complete_cwr(sk);               // 完成处理
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    /* F. Process state. */
</span><span class='line'>    switch (icsk-&gt;icsk_ca_state) {
</span><span class='line'>    case TCP_CA_Recovery:
</span><span class='line'>        if (!(flag & FLAG_SND_UNA_ADVANCED)) {  // snd_una没有改变
</span><span class='line'>            if (tcp_is_reno(tp) && is_dupack)   // 不是SACK，而且是重复的ACK
</span><span class='line'>                tcp_add_reno_sack(sk);          // 接收到重复的ACK，tp-&gt;sacked_out++; 并且检查新的reorder问题（5）
</span><span class='line'>        } else
</span><span class='line'>            do_lost = tcp_try_undo_partial(sk, pkts_acked);   // 部分ACK接收并撤销窗口操作（6）注意返回的是是否需要重传表示
</span><span class='line'>        break;                                  // 1代表重传，0代表不需要重传
</span><span class='line'>    case TCP_CA_Loss:
</span><span class='line'>        if (flag & FLAG_DATA_ACKED)             // 如果是数据确认
</span><span class='line'>            icsk-&gt;icsk_retransmits = 0;         // 超时重传置次数0
</span><span class='line'>        if (tcp_is_reno(tp) && flag & FLAG_SND_UNA_ADVANCED) // 没有ACK，&& snd_una改变了
</span><span class='line'>            tcp_reset_reno_sack(tp);            // 重置sacked=0
</span><span class='line'>        if (!tcp_try_undo_loss(sk)) {           // 尝试撤销拥塞调整，然后进入OPEN状态（7）
</span><span class='line'>            tcp_moderate_cwnd(tp);              // 调整窗口（8）
</span><span class='line'>            tcp_xmit_retransmit_queue(sk);      // 重传丢失的包（9）
</span><span class='line'>            return;
</span><span class='line'>        }
</span><span class='line'>        if (icsk-&gt;icsk_ca_state != TCP_CA_Open)
</span><span class='line'>            return;
</span><span class='line'>        /* Loss is undone; fall through to processing in Open state. */
</span><span class='line'>    default:
</span><span class='line'>        if (tcp_is_reno(tp)) {                  // 么有SACK，那么就是RENO算法处理：收到三个dup-ACK(即sacked_out==3)，就开始重传
</span><span class='line'>            if (flag & FLAG_SND_UNA_ADVANCED)   // 如果收到少于 3 个 dupack 后又收到累计确认，则会重置之前的 sacked_out 计数
</span><span class='line'>                tcp_reset_reno_sack(tp);        // 重新置0
</span><span class='line'>            if (is_dupack)                      // 如果收到一个dup-ack，将sacked_out++
</span><span class='line'>                tcp_add_reno_sack(sk);
</span><span class='line'>        }
</span><span class='line'> 
</span><span class='line'>        if (icsk-&gt;icsk_ca_state == TCP_CA_Disorder)
</span><span class='line'>            tcp_try_undo_dsack(sk);             // DSACK确认了所有重传数据
</span><span class='line'> 
</span><span class='line'>        if (!tcp_time_to_recover(sk)) {         // 判断是否进入恢复状态
</span><span class='line'>            tcp_try_to_open(sk, flag);          // 如果不可以，那么会判断是否进入Open、Disorder、CWR等状态
</span><span class='line'>            return;                             // 只有收到三个dup-ack时候，才进入快速回复，否则都返回
</span><span class='line'>        }
</span><span class='line'> 
</span><span class='line'>        /* MTU probe failure: don't reduce cwnd */
</span><span class='line'>        if (icsk-&gt;icsk_ca_state &lt; TCP_CA_CWR &&
</span><span class='line'>            icsk-&gt;icsk_mtup.probe_size &&
</span><span class='line'>            tp-&gt;snd_una == tp-&gt;mtu_probe.probe_seq_start) {
</span><span class='line'>            tcp_mtup_probe_failed(sk);          // MTU探测失败
</span><span class='line'>            /* Restores the reduction we did in tcp_mtup_probe() */
</span><span class='line'>            tp-&gt;snd_cwnd++;
</span><span class='line'>            tcp_simple_retransmit(sk);          // 做一个简单的转发，而不使用回退机制。用于路径MTU发现。&nbsp;
</span><span class='line'>            return;
</span><span class='line'>        }
</span><span class='line'>        // 说明已经收到第 3 个连续 dupack，此时 sacked_out = 3，进入恢复态
</span><span class='line'>        /* Otherwise enter Recovery state */
</span><span class='line'>        // 进入恢复状态
</span><span class='line'>        if (tcp_is_reno(tp))
</span><span class='line'>            NET_INC_STATS_BH(LINUX_MIB_TCPRENORECOVERY);
</span><span class='line'>        else
</span><span class='line'>            NET_INC_STATS_BH(LINUX_MIB_TCPSACKRECOVERY);
</span><span class='line'> 
</span><span class='line'>        tp-&gt;high_seq = tp-&gt;snd_nxt;
</span><span class='line'>        tp-&gt;prior_ssthresh = 0;
</span><span class='line'>        tp-&gt;undo_marker = tp-&gt;snd_una;
</span><span class='line'>        tp-&gt;undo_retrans = tp-&gt;retrans_out;
</span><span class='line'>
</span><span class='line'>        if (icsk-&gt;icsk_ca_state &lt; TCP_CA_CWR) {
</span><span class='line'>            if (!(flag & FLAG_ECE))
</span><span class='line'>                tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk);   // 根据状态获取当前门限值
</span><span class='line'>            tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);  // 更新
</span><span class='line'>            TCP_ECN_queue_cwr(tp);
</span><span class='line'>        }
</span><span class='line'> 
</span><span class='line'>        tp-&gt;bytes_acked = 0;
</span><span class='line'>        tp-&gt;snd_cwnd_cnt = 0;
</span><span class='line'>        tcp_set_ca_state(sk, TCP_CA_Recovery);      // 键入恢复状态
</span><span class='line'>        fast_rexmit = 1;    // 快速重传
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    if (do_lost || (tcp_is_fack(tp) && tcp_head_timedout(sk))) // 如果丢失需要重传 || 超时重传
</span><span class='line'>        tcp_update_scoreboard(sk, fast_rexmit);     // 标志丢失和超时的数据包，增加lost_out(10)
</span><span class='line'>    tcp_cwnd_down(sk, flag);                        // 减小cwnd窗口（11）
</span><span class='line'>    tcp_xmit_retransmit_queue(sk);                  // 重传丢失包
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面看一下里面的函数：</p>

<p>先看：tcp_mark_head_lost：通过给丢失的数据包标志TCPCB_LOST，就可以表明哪些数据包需要重传。</p>

<p>注意参数：packets = fackets_out - reordering，其实就是sacked_out + lost_out。被标志为LOST的段数不能超过packets。</p>

<p>那么packets 就是标记丢失的包们数量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Mark head of queue up as lost. With RFC3517 SACK, the packets is
</span><span class='line'> * is against sacked "cnt", otherwise it's against facked "cnt"
</span><span class='line'> */
</span><span class='line'>static void tcp_mark_head_lost(struct sock *sk, int packets)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>    int cnt, oldcnt;
</span><span class='line'>    int err;
</span><span class='line'>    unsigned int mss;
</span><span class='line'> 
</span><span class='line'>    BUG_TRAP(packets &lt;= tp-&gt;packets_out);   // 丢失的包不可能比所有发出去的包的数量
</span><span class='line'>    if (tp-&gt;lost_skb_hint) {                // 如果已经有标识为丢失的段了 
</span><span class='line'>        skb = tp-&gt;lost_skb_hint;            // 下一个需要标记的数据段
</span><span class='line'>        cnt = tp-&gt;lost_cnt_hint;            // 已经标记了多少段
</span><span class='line'>    } else {
</span><span class='line'>        skb = tcp_write_queue_head(sk);     // 获得链表的第一个结构元素
</span><span class='line'>        cnt = 0;                            // 初始化标记了0个数据
</span><span class='line'>    }
</span><span class='line'>    // 下面开始遍历
</span><span class='line'>    tcp_for_write_queue_from(skb, sk) {
</span><span class='line'>        if (skb == tcp_send_head(sk))       // return sk-&gt;sk_send_head; 即snd_nxt，那么还没有发送不需要处理，break；
</span><span class='line'>            break;
</span><span class='line'>        /* TODO: do this better */
</span><span class='line'>        /* this is not the most efficient way to do this... */
</span><span class='line'>        tp-&gt;lost_skb_hint = skb;            // 更新丢失队列信息
</span><span class='line'>        tp-&gt;lost_cnt_hint = cnt;
</span><span class='line'> 
</span><span class='line'>        if (after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;high_seq))   // high_seq是最大的标记为LOST的号，不可以超过这个
</span><span class='line'>            break;                          // 若这个skb超过，退出
</span><span class='line'> 
</span><span class='line'>        oldcnt = cnt;                       // 保存cnt
</span><span class='line'>        if (tcp_is_fack(tp) || tcp_is_reno(tp) ||
</span><span class='line'>            (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_SACKED_ACKED))
</span><span class='line'>            cnt += tcp_skb_pcount(skb);     // 表示这个段已经被标记
</span><span class='line'> 
</span><span class='line'>        if (cnt &gt; packets) {
</span><span class='line'>            if (tcp_is_sack(tp) || (oldcnt &gt;= packets))   // 已经超过了丢失包数量，break
</span><span class='line'>                break;
</span><span class='line'> 
</span><span class='line'>            mss = skb_shinfo(skb)-&gt;gso_size;// 得到MSS
</span><span class='line'>            err = tcp_fragment(sk, skb, (packets - oldcnt) * mss, mss);   // 下面分配，前面说过了
</span><span class='line'>            if (err &lt; 0)
</span><span class='line'>                break;
</span><span class='line'>            cnt = packets;
</span><span class='line'>        }
</span><span class='line'>        // 下面这一段就是做标记动作
</span><span class='line'>        if (!(TCP_SKB_CB(skb)-&gt;sacked & (TCPCB_SACKED_ACKED|TCPCB_LOST))) {
</span><span class='line'>            TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST;   // 标识
</span><span class='line'>            tp-&gt;lost_out += tcp_skb_pcount(skb);     // 丢失包+=
</span><span class='line'>            tcp_verify_retransmit_hint(tp, skb);     // 其实就是标记这个丢失，加入重传标记队列
</span><span class='line'>           }
</span><span class='line'>    }
</span><span class='line'>    tcp_verify_left_out(tp);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>看一下tcp_verify_retransmit_hint函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_verify_retransmit_hint(struct tcp_sock *tp, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    if ((tp-&gt;retransmit_skb_hint == NULL) ||
</span><span class='line'>        before(TCP_SKB_CB(skb)-&gt;seq,
</span><span class='line'>           TCP_SKB_CB(tp-&gt;retransmit_skb_hint)-&gt;seq))
</span><span class='line'>        tp-&gt;retransmit_skb_hint = skb;    // 加入这个队列
</span><span class='line'> 
</span><span class='line'>    if (!tp-&gt;lost_out ||
</span><span class='line'>        after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;retransmit_high))   // 如果最后一个数据标号比high大，明显更新high
</span><span class='line'>        tp-&gt;retransmit_high = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>OK，再看一下这个函数tcp_try_undo_recovery：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_try_undo_recovery(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'> 
</span><span class='line'>    if (tcp_may_undo(tp)) {  // 如果可以undo
</span><span class='line'>        /* Happy end! We did not retransmit anything
</span><span class='line'>         * or our original transmission succeeded.
</span><span class='line'>         */
</span><span class='line'>        DBGUNDO(sk, inet_csk(sk)-&gt;icsk_ca_state == TCP_CA_Loss ? "loss" : "retrans");
</span><span class='line'>        tcp_undo_cwr(sk, 1);   // 具体处理
</span><span class='line'>        if (inet_csk(sk)-&gt;icsk_ca_state == TCP_CA_Loss)
</span><span class='line'>            NET_INC_STATS_BH(LINUX_MIB_TCPLOSSUNDO);
</span><span class='line'>        else
</span><span class='line'>            NET_INC_STATS_BH(LINUX_MIB_TCPFULLUNDO);
</span><span class='line'>        tp-&gt;undo_marker = 0;
</span><span class='line'>    }
</span><span class='line'>    if (tp-&gt;snd_una == tp-&gt;high_seq && tcp_is_reno(tp)) {
</span><span class='line'>        /* Hold old state until something *above* high_seq
</span><span class='line'>         * is ACKed. For Reno it is MUST to prevent false
</span><span class='line'>         * fast retransmits (RFC2582). SACK TCP is safe. */
</span><span class='line'>        tcp_moderate_cwnd(tp);   // 更新窗口大小
</span><span class='line'>        return 1;
</span><span class='line'>    }
</span><span class='line'>    tcp_set_ca_state(sk, TCP_CA_Open);
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>OK看一下tcp_may_undo函数：检测能否撤销</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline bool tcp_may_undo(const struct tcp_sock *tp)
</span><span class='line'>{
</span><span class='line'>    return tp-&gt;undo_marker && (!tp-&gt;undo_retrans || tcp_packet_delayed(tp));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>首先得有undo_marker标识才OK！然后undo_retrans的意思是最近的Recovery时间内重传的数据包个数，如果收到一个DSACK那么undo_retrans减一，如果最后等于0，那么说明都被确认了，没有必要重传，所以没有必要调整窗口。或tcp_packet_delayed(tp)条件。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_packet_delayed(struct tcp_sock *tp)
</span><span class='line'>{
</span><span class='line'>    return !tp-&gt;retrans_stamp ||
</span><span class='line'>        (tp-&gt;rx_opt.saw_tstamp && tp-&gt;rx_opt.rcv_tsecr &&
</span><span class='line'>         (__s32)(tp-&gt;rx_opt.rcv_tsecr - tp-&gt;retrans_stamp) &lt; 0); // 接收ACK时间在重传数据之前
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面 看一下这个函数tcp_complete_cwr：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void tcp_complete_cwr(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh);   // 调整窗口
</span><span class='line'>    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
</span><span class='line'>    tcp_ca_event(sk, CA_EVENT_COMPLETE_CWR); // 出发事件
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* CWND moderation, preventing bursts due to too big ACKs
</span><span class='line'> * in dubious situations.
</span><span class='line'> */
</span><span class='line'>static inline void tcp_moderate_cwnd(struct tcp_sock *tp)  // 修改窗口值
</span><span class='line'>{
</span><span class='line'>    tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd,
</span><span class='line'>               tcp_packets_in_flight(tp) + tcp_max_burst(tp));  // 防止怀疑的ACK情况，所以取min值
</span><span class='line'>    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<p>再看看这个函数tcp_try_undo_dsack：当DSACK确认所有的重传数据，那么undo_retrans=0，那么需要回复窗口原来的情况</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Try to undo cwnd reduction, because D-SACKs acked all retransmitted data */
</span><span class='line'>static void tcp_try_undo_dsack(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'> 
</span><span class='line'>    if (tp-&gt;undo_marker && !tp-&gt;undo_retrans) {  // 所有的段都被确认了
</span><span class='line'>        DBGUNDO(sk, "D-SACK");
</span><span class='line'>        tcp_undo_cwr(sk, 1);                   // 撤销（1）
</span><span class='line'>        tp-&gt;undo_marker = 0;
</span><span class='line'>        NET_INC_STATS_BH(LINUX_MIB_TCPDSACKUNDO);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>撤销函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_undo_cwr(struct sock *sk, const int undo)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'> 
</span><span class='line'>    if (tp-&gt;prior_ssthresh) {  // 如果保存了旧的门限值
</span><span class='line'>        const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'> 
</span><span class='line'>        if (icsk-&gt;icsk_ca_ops-&gt;undo_cwnd)
</span><span class='line'>            tp-&gt;snd_cwnd = icsk-&gt;icsk_ca_ops-&gt;undo_cwnd(sk);           // 这个函数可以自己添加
</span><span class='line'>        else
</span><span class='line'>            tp-&gt;snd_cwnd = max(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh &lt;&lt; 1);   // 如果没有定义那个函数，那么做简单的处理
</span><span class='line'> 
</span><span class='line'>        if (undo && tp-&gt;prior_ssthresh &gt; tp-&gt;snd_ssthresh) {
</span><span class='line'>            tp-&gt;snd_ssthresh = tp-&gt;prior_ssthresh;
</span><span class='line'>            TCP_ECN_withdraw_cwr(tp);
</span><span class='line'>        }
</span><span class='line'>    } else {                 // 没有保存旧的阈值
</span><span class='line'>        tp-&gt;snd_cwnd = max(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh);   // 
</span><span class='line'>    }
</span><span class='line'>    tcp_moderate_cwnd(tp);   // 上面已经说了
</span><span class='line'>    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
</span><span class='line'> 
</span><span class='line'>    /* There is something screwy going on with the retrans hints after
</span><span class='line'>       an undo */
</span><span class='line'>    tcp_clear_all_retrans_hints(tp);      // 清空所有的重传信息
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<p>接收到重复的ACK，那么需要对sacked_out处理，看函数tcp_add_reno_sack：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Emulate SACKs for SACKless connection: account for a new dupack. */
</span><span class='line'> 
</span><span class='line'>static void tcp_add_reno_sack(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    tp-&gt;sacked_out++;                    // 收到重复的ACK，那么这个值++
</span><span class='line'>    tcp_check_reno_reordering(sk, 0);    // 检查是否有reordering（1）
</span><span class='line'>    tcp_verify_left_out(tp);   // 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>看看这个检查reordering函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* If we receive more dupacks than we expected counting segments
</span><span class='line'> * in assumption of absent reordering, interpret this as reordering.
</span><span class='line'> * The only another reason could be bug in receiver TCP.
</span><span class='line'> */
</span><span class='line'>static void tcp_check_reno_reordering(struct sock *sk, const int addend)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    if (tcp_limit_reno_sacked(tp))    // 检查sack的数量是否超过限度
</span><span class='line'>        tcp_update_reordering(sk, tp-&gt;packets_out + addend, 0); // 如果是reordering则更新reordering
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Limits sacked_out so that sum with lost_out isn't ever larger than
</span><span class='line'> * packets_out. Returns zero if sacked_out adjustement wasn't necessary.
</span><span class='line'> */
</span><span class='line'>int tcp_limit_reno_sacked(struct tcp_sock *tp)  // 限制sacked_out目的是使得sacked_out + lost_out &lt;= packeted_out
</span><span class='line'>{                        
</span><span class='line'>    u32 holes;
</span><span class='line'> 
</span><span class='line'>    holes = max(tp-&gt;lost_out, 1U);              // 获得hole
</span><span class='line'>    holes = min(holes, tp-&gt;packets_out);
</span><span class='line'> 
</span><span class='line'>    if ((tp-&gt;sacked_out + holes) &gt; tp-&gt;packets_out) {   // 如果大于发出的包，那么reordering就需要了
</span><span class='line'>        tp-&gt;sacked_out = tp-&gt;packets_out - holes;       // 因为此处的dup-ack是reorder造成的
</span><span class='line'>        return 1;
</span><span class='line'>    }
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面看看更新reordering函数tcp_update_reordering：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_update_reordering(struct sock *sk, const int metric,
</span><span class='line'>                  const int ts)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    if (metric &gt; tp-&gt;reordering) {                          // 如果现在的数量 &gt; 之前的reorder
</span><span class='line'>        tp-&gt;reordering = min(TCP_MAX_REORDERING, metric);   // 获得ordering值(注意不能超过最大设置值)
</span><span class='line'> 
</span><span class='line'>        /* This exciting event is worth to be remembered. 8) */
</span><span class='line'>        if (ts)
</span><span class='line'>            NET_INC_STATS_BH(LINUX_MIB_TCPTSREORDER);  // 统计信息
</span><span class='line'>        else if (tcp_is_reno(tp))
</span><span class='line'>            NET_INC_STATS_BH(LINUX_MIB_TCPRENOREORDER);
</span><span class='line'>        else if (tcp_is_fack(tp))
</span><span class='line'>            NET_INC_STATS_BH(LINUX_MIB_TCPFACKREORDER);
</span><span class='line'>        else
</span><span class='line'>            NET_INC_STATS_BH(LINUX_MIB_TCPSACKREORDER);
</span><span class='line'>#if FASTRETRANS_DEBUG &gt; 1
</span><span class='line'>        printk(KERN_DEBUG "Disorder%d %d %u f%u s%u rr%d\n",
</span><span class='line'>               tp-&gt;rx_opt.sack_ok, inet_csk(sk)-&gt;icsk_ca_state,
</span><span class='line'>               tp-&gt;reordering,
</span><span class='line'>               tp-&gt;fackets_out,
</span><span class='line'>               tp-&gt;sacked_out,
</span><span class='line'>               tp-&gt;undo_marker ? tp-&gt;undo_retrans : 0);
</span><span class='line'>#endif
</span><span class='line'>        tcp_disable_fack(tp);       // 禁用fack(fack是基于有序的，因为已经使用order了，所以禁用fack)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<p>下面再看一下这个tcp_try_undo_partial函数：在恢复状态，收到部分ACK确认，使用这个函数撤销拥塞调整。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Undo during fast recovery after partial ACK. */
</span><span class='line'> 
</span><span class='line'>static int tcp_try_undo_partial(struct sock *sk, int acked)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    /* Partial ACK arrived. Force Hoe's retransmit. */ // 收到部分ACK，对于SACK来说不需要重传，对于RENO需要
</span><span class='line'>    int failed = tcp_is_reno(tp) || (tcp_fackets_out(tp) &gt; tp-&gt;reordering);  // 或者facked_out数量比reordering要大
</span><span class='line'> 
</span><span class='line'>    if (tcp_may_undo(tp)) {    // 是否可以调整（上面已说）
</span><span class='line'>        /* Plain luck! Hole if filled with delayed
</span><span class='line'>         * packet, rather than with a retransmit.
</span><span class='line'>         */
</span><span class='line'>        if (tp-&gt;retrans_out == 0)       // 重传包=0
</span><span class='line'>            tp-&gt;retrans_stamp = 0;      // 重置重传时间
</span><span class='line'> 
</span><span class='line'>        tcp_update_reordering(sk, tcp_fackets_out(tp) + acked, 1);   // 需要更新reordering( 上面 )
</span><span class='line'> 
</span><span class='line'>        DBGUNDO(sk, "Hoe");
</span><span class='line'>        tcp_undo_cwr(sk, 0);   // 撤销操作( 上面 )
</span><span class='line'>        NET_INC_STATS_BH(LINUX_MIB_TCPPARTIALUNDO);
</span><span class='line'> 
</span><span class='line'>        /* So... Do not make Hoe's retransmit yet.
</span><span class='line'>         * If the first packet was delayed, the rest
</span><span class='line'>         * ones are most probably delayed as well.
</span><span class='line'>         */
</span><span class='line'>        failed = 0;            // 表示不用重传了，可以发送新的数据
</span><span class='line'>    }
</span><span class='line'>    return failed;             // 返回是否需要重传
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<p>下面继续看tcp_try_undo_loss函数：收到部分确认之后，从loss状态撤销窗口调整</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Undo during loss recovery after partial ACK. */
</span><span class='line'>static int tcp_try_undo_loss(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'> 
</span><span class='line'>    if (tcp_may_undo(tp)) {                    // 如果可以undo
</span><span class='line'>        struct sk_buff *skb;
</span><span class='line'>        tcp_for_write_queue(skb, sk) {         // 遍历整个发送queue
</span><span class='line'>            if (skb == tcp_send_head(sk))      // 直到还没有发送的数据头之前(前面的都已经发送)
</span><span class='line'>                break;
</span><span class='line'>            TCP_SKB_CB(skb)-&gt;sacked &= ~TCPCB_LOST;  // 清除LOST标记
</span><span class='line'>        }
</span><span class='line'> 
</span><span class='line'>        tcp_clear_all_retrans_hints(tp);       // 清除所有的重传信息
</span><span class='line'> 
</span><span class='line'>        DBGUNDO(sk, "partial loss");
</span><span class='line'>        tp-&gt;lost_out = 0;                      // 重置
</span><span class='line'>        tcp_undo_cwr(sk, 1);                   // 撤销窗口调整
</span><span class='line'>        NET_INC_STATS_BH(LINUX_MIB_TCPLOSSUNDO);
</span><span class='line'>        inet_csk(sk)-&gt;icsk_retransmits = 0;
</span><span class='line'>        tp-&gt;undo_marker = 0;
</span><span class='line'>        if (tcp_is_sack(tp))
</span><span class='line'>            tcp_set_ca_state(sk, TCP_CA_Open);  // 设置状态OPEN
</span><span class='line'>        return 1;
</span><span class='line'>    }
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<p>下面看一下tcp_update_scoreboard函数：其实就是更新lost包数量，这个涉及到不同的算法不一样的结果，没有SACK(reno)，有SACK，有FACK情况</p>

<p>1) 没有SACK：每次收到重复的ACK或部分ack时，标志一个包为丢失。</p>

<p>2)    有SACK：sacked_out - reordering > 0 时候，标记为这么多丢失，若小于0，标记为1个丢失(前提是有重传标识)</p>

<p>3)    有FACK：fackets_out - reordering  >0 时候，标记为这么多丢失，若小于0，标记为1个丢失</p>

<p>( 注意：小于0的情况是因为考虑到reordering情况 )</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Account newly detected lost packet(s) */
</span><span class='line'> 
</span><span class='line'>static void tcp_update_scoreboard(struct sock *sk, int fast_rexmit)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'> 
</span><span class='line'>    if (tcp_is_reno(tp)) {              // 最普通的，没有SACK情况
</span><span class='line'>        tcp_mark_head_lost(sk, 1);      // 标记为一个丢失
</span><span class='line'>    } else if (tcp_is_fack(tp)) {       // 如果是fack
</span><span class='line'>        int lost = tp-&gt;fackets_out - tp-&gt;reordering;  // 判断这个值大小
</span><span class='line'>        if (lost &lt;= 0)
</span><span class='line'>            lost = 1;  // 小于0指标记一个
</span><span class='line'>        tcp_mark_head_lost(sk, lost);   // 否则标记所有的
</span><span class='line'>    } else {   // 仅仅有SACK情况
</span><span class='line'>        int sacked_upto = tp-&gt;sacked_out - tp-&gt;reordering;
</span><span class='line'>        if (sacked_upto &lt; fast_rexmit)
</span><span class='line'>            sacked_upto = fast_rexmit;
</span><span class='line'>        tcp_mark_head_lost(sk, sacked_upto);   // 同上
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    /* New heuristics: it is possible only after we switched
</span><span class='line'>     * to restart timer each time when something is ACKed.
</span><span class='line'>     * Hence, we can detect timed out packets during fast
</span><span class='line'>     * retransmit without falling to slow start.
</span><span class='line'>     */
</span><span class='line'>    if (tcp_is_fack(tp) && tcp_head_timedout(sk)) {   // 下面检查超时包( 先检查第一个数据包是否超时 )
</span><span class='line'>        struct sk_buff *skb;
</span><span class='line'> 
</span><span class='line'>        skb = tp-&gt;scoreboard_skb_hint ? tp-&gt;scoreboard_skb_hint
</span><span class='line'>            : tcp_write_queue_head(sk);
</span><span class='line'> 
</span><span class='line'>        tcp_for_write_queue_from(skb, sk) {
</span><span class='line'>            if (skb == tcp_send_head(sk))
</span><span class='line'>                break;
</span><span class='line'>            if (!tcp_skb_timedout(sk, skb))  // 检查所有的超时包，没有超时的就break
</span><span class='line'>                break;
</span><span class='line'> 
</span><span class='line'>            if (!(TCP_SKB_CB(skb)-&gt;sacked & (TCPCB_SACKED_ACKED|TCPCB_LOST))) {
</span><span class='line'>                TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST;   // 标记为lost
</span><span class='line'>                tp-&gt;lost_out += tcp_skb_pcount(skb);     // 增加lost数量
</span><span class='line'>                tcp_verify_retransmit_hint(tp, skb);     
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'> 
</span><span class='line'>        tp-&gt;scoreboard_skb_hint = skb;
</span><span class='line'> 
</span><span class='line'>           tcp_verify_left_out(tp);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<p>下面继续看这个减小窗口函数：tcp_cwnd_down，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Decrease cwnd each second ack. */ // 每收到2个确认将拥塞窗口减1，直到拥塞窗口等于慢启动阈值。
</span><span class='line'>static void tcp_cwnd_down(struct sock *sk, int flag)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    int decr = tp-&gt;snd_cwnd_cnt + 1; // 计数器
</span><span class='line'> 
</span><span class='line'>    if ((flag & (FLAG_ANY_PROGRESS | FLAG_DSACKING_ACK)) ||
</span><span class='line'>        (tcp_is_reno(tp) && !(flag & FLAG_NOT_DUP))) {
</span><span class='line'>        tp-&gt;snd_cwnd_cnt = decr & 1;// 因为此处只可能是0,1三个值，这样的操作其实就是切换值，
</span><span class='line'>                                    // 例如现在是第一个ACK，即之前的snd_cwnd_cnt=0，decr=1，那么1&1=1，
</span><span class='line'>                                    // 将snd_cwnd_cnt赋值为1；第二个ACK到来，decr=2，则2&1=0，
</span><span class='line'>                                    // 相当于又将snd_cwnd_cnt初始化为0，因为两个ACK就需要处理一次。
</span><span class='line'>        decr &gt;&gt;= 1;   // 除以2，是判断是第一个ACK，还是第二个；第一个的话值=0，下面不会执行，是2的话=1，下面一句会执行
</span><span class='line'> 
</span><span class='line'>        if (decr && tp-&gt;snd_cwnd &gt; tcp_cwnd_min(sk)) // 如果是第二个ACK && 比最小的门限值还大一点，那么还需要减小cwnd
</span><span class='line'>            tp-&gt;snd_cwnd -= decr;   // 减小一个，^_^
</span><span class='line'> 
</span><span class='line'>        tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tcp_packets_in_flight(tp) + 1);  // 用于微调，和外面的数据包数量比较
</span><span class='line'>        tp-&gt;snd_cwnd_stamp = tcp_time_stamp;    // 改变时间戳
</span><span class='line'>    } 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-03-04T17:45:00+08:00'><span class='date'>2015-03-04</span> <span class='time'>17:45:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~net/'>net</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/03/04/kernel-net-tcp4/" title="Previous Post: tcp重传数据包 tcp_xmit_retransmit_skb">&laquo; tcp重传数据包 tcp_xmit_retransmit_skb</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/03/13/kernel-sched-rt/" title="Next Post: linux进程调度之FIFO和RR调度策略">linux进程调度之FIFO和RR调度策略 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
