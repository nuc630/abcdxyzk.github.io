
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>FRTO—虚假超时剖析 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>学习中......</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">FRTO—虚假超时剖析</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-23T14:37:00+08:00'><span class='date'>2015-03-23</span> <span class='time'>14:37:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.csdn.net/zhangskd/article/details/7446441">http://blog.csdn.net/zhangskd/article/details/7446441</a></p>

<p>F-RTO：Forward RTO-Recovery，for a TCP sender to recover after a retransmission timeout.
F-RTO的主要目的：The main motivation of the algorithm is to recover efficiently from a spurious
RTO.</p>

<h4>F-RTO的基本思想</h4>

<p>The guideline behind F-RTO is, that an RTO either indicates a loss, or it is caused by an
excessive delay in packet delivery while there still are outstanding segments in flight. If the
RTO was due to delay, i.e. the RTO was spurious, acknowledgements for non-retransmitted
segments sent before the RTO should arrive at the sender after the RTO occurred. If no such
segments arrive, the RTO is concluded to be non-spurious and the conventional RTO
recovery with go-back-N retransmissions should take place at the TCP sender.</p>

<p>To implement the principle described above, an F-RTO sender acts as follows: if the first ACK
arriving after a RTO-triggered retransmission advances the window, transmit two new segments
instead of continuing retransmissions. If also the second incoming acknowledgement advances
the window, RTO is likely to be spurious, because the second ACK is triggered by an originally
transmitted segment that has not been retransmitted after the RTO. If either one of the two
acknowledgements after RTO is a duplicate ACK, the sender continues retransmissions similarly
to the conventional RTO recovery algorithm.</p>

<p>When the retransmission timer expires, the F-RTO algorithm takes the following steps at the TCP
sender. In the algorithm description below we use SND.UNA to indicate the first unacknowledged
segment.</p>

<p>1.When the retransmission timer expires, retransmit the segment that triggered the timeout. As
required by the TCP congestion control specifications, the ssthresh is adjusted to half of the
number of currently outstanding segments. However, the congestion window is not yet set to one
segment, but the sender waits for the next two acknowledgements before deciding on what to do
with the congestion window.</p>

<p>2.When the first acknowledgement after RTO arrives at the sender, the sender chooses the
following actions depending on whether the ACK advances the window or whether it is a duplicate
ACK.</p>

<p>（a）If the acknowledgement advances SND.UNA, transmit up to two new (previously unsent)
segments. This is the main point in which the F-RTO algorithm differs from the conventional way
of recovering from RTO. After transmitting the two new segments, the congestion window size
is set to have the same value as ssthresh. In effect this reduces the transmission rate of the
sender to half of the transmission rate before the RTO. At this point the TCP sender has transmitted
a total of three segments after the RTO, similarly to the conventional recovery algorithm. If
transmitting two new segments is not possible due to advertised window limitation, or because
there is no more data to send, the sender may transmit only one segment. If now new data can
be transmitted, the TCP sender follows the conventional RTO recovery algorithm and starts
retransmitting the unacknowledged data using slow start.</p>

<p>（b）If the acknowledgement is duplicate ACK, set the congestion window to one segment and
proceed with the conventional RTO recovery. Two new segments are not transmitted in this case,
because the conventional RTO recovery algorithm would not transmit anything at this point either.
Instead, the F-RTO sender continues with slow start and performs similarly to the conventional
TCP sender in retransmitting the unacknowledged segments. Step 3 of the F-RTO algorithm is
not entered in this case. A common reason for executing this branch is the loss of a segment,
in which case the segments injected by the sender before the RTO may still trigger duplicate
ACKs that arrive at the sender after the RTO.</p>

<p>3.When the second acknowledgement after the RTO arrives, either continue transmitting new
data, or start retransmitting with the slow start algorithm, depending on whether new data was
acknowledged.</p>

<p>（a）If the acknowledgement advances SND.UNA, continue transmitting new data following
the congestion avoidance algorithm. Because the TCP sender has retransmitted only one
segment after the RTO, this acknowledgement indicates that an originally transmitted
segment has arrived at the receiver. This is regarded as a strong indication of a suprious
RTO. However, since the TCP sender cannot surely know at this point whether the segment
that triggered the RTO was actually lost, adjusting the congestion control parameters after
the RTO is the conservative action. From this point on, the TCP sender continues as in the
normal congestion avoidance.</p>

<p>If this algorithm branch is taken, the TCP sender ignores the send_high variable that indicates
the highest sequence number transmitted so far. The send_high variable was proposed as a
bugfix for avoiding unnecessary multiple fast retransmits when RTO expires during fast recovery
with NewReon TCP. As the sender has not retransmitted other segments but the one that
triggered RTO, the problem addressed by the bugfix cannot occur. Therefore, if there are
duplicate ACKs arriving at the sender after the RTO, they are likely to indicate a packet loss,
hence fast retransmit should bu used to allow efficient recovery. Alternatively, if there are not
enough duplicate ACKs arriving at the sender after a packet loss, the retransmission timer
expires another time and the sender enters step 1 of this algorithm to detect whether the
new RTO is spurious.</p>

<p>（b）If the acknowledgement is duplicate ACK, set the congestion window to three segments,
continue with the slow start algorithm retransmitting unacknowledged segments. The duplicate
ACK indicates that at least one segment other than the segment that triggered RTO is lost in the
last window of data. There is no sufficient evidence that any of the segments was delayed.
Therefore the sender proceeds with retransmissions similarly to the conventional RTO recovery
algorithm, with the send_high variable stored when the retransmission timer expired to avoid
unnecessary fast retransmits.</p>

<h4>引起RTO的主要因素：</h4>

<p>（1）Sudden delays<br/>
The primary motivation of the F-RTO algorithm is to improve the TCP performance when sudden
delays cause spurious retransmission timeouts.</p>

<p>（2）Packet losses<br/>
These timeouts occur mainly when retransmissions are lost, since lost original packets are
usually recovered by fast retransmit.</p>

<p>（3）Bursty losses<br/>
Losses of several successive packets can result in a retransmission timeout.</p>

<h5>造成虚假RTO的原因还有：</h5>

<p>Wireless links may also suffer from link outages that cause persistent data loss for a period
of time.<br/>
Oher potential reasons for sudden delays that have been reported to trigger spurious RTOs
include a delay due to tedious actions required to complete a hand-off or re-routing of packets
to the new serving access point after the hand-off, arrival of competing traffic on a shared link
with low bandwidth, and a sudden bandwidth degradation due to reduced resources on a
wireless channel.</p>

<h5>造成真实RTO的原因：</h5>

<p>A RTO-triggered retransmission is needed when a retransmission is lost, or when nearly a whole
window of data is lost, thus making it impossible for the receiver to generate enough duplicate
ACKs for triggering TCP fast retransmit.</p>

<h4>虚假RTO的后果</h4>

<p>If no segments were lost but the retransmission timer expires spuriously, the segments retransmitted
in the slow-start are sent unnecessarily. Particularly, this phenomenon is very possible with the
various wireless access network technologies that are prone to sudden delay spikes.
The retransmission timer expires because of the delay, spuriously triggering the RTO recovery and
unnecessarily retransmission of all unacknowledged segments. This happens because after the
delay the ACKs for the original segments arrive at the sender one at the time but too late, because
the TCP sender has already entered the RTO recovery. Therefore, each of the ACKs trigger the
retransmission of segments for which the original ACKs will arrive after a while. This continues
until the whole window of segments is eventually unnecessarily retransmitted. Furthermore,
because a full window of retransmitted segments arrive unnecessarily at the receiver, it generates
duplicate ACKs for these out-of-order segments. Later on, the duplicate ACKs unnecessarily
trigger fast retransmit at the sender.</p>

<p>TCP uses the fast retransmit mechanism to trigger retransmissions after receiving three successive
duplicate acknowledgements (ACKs). If for a certain time period TCP sender does not receive ACKs
that acknowledge new data, the TCP retransmission timer expires as a backoff mechanism.
When the retransmission time expires, the TCP sender retransmits the first unacknowledged
segment assuming it was lost in the network. Because a retransmission timeout (RTO) can be
an indication of severe congestion in the network, the TCP sender resets its congestion window
to one segment and starts increasing it according to the slow start algorithm.
However, if the RTO occurs spuriously and there still are segments outstanding in the network,
a false slow start is harmful for the potentially congested network as it injects extra segments
to the network at increasing rate.</p>

<p>虚假的RTO不仅会降低吞吐量，而且由于丢包后会使用慢启动算法，快速的向网络中注入数据包，
而此时网络中还有原来发送的数据包，这样可能会造成真正的网络拥塞！</p>

<p>How about Reliable link-layer protocol ?
Since wireless networks are often subject to high packet loss rate due to corruption or hand-offs,
reliable link-layer protocols are widely employed with wireless links. The link-layer receiver often
aims to deliver the packets to the upper protocol layers in order, which implies that the later
arriving packets are blocked until the head of the queue arrives successfully. Due to the strict
link-layer ordering, the communication end point observe a pause in packet delivery that can
cause a spurious TCP RTO instead of getting out-of-order packets that could result in a false
fast retransmit instead. Either way, interaction between TCP retransmission mechanisms
and link-layer recovery can cause poor performance.</p>

<p>DSACK不能解决此问题
If the unnecessary retransmissions occurred due to spurious RTO caused by a sudden delay,
the acknowledgements with the DSACK information arrive at the sender only after the
acknowledgements of the original segments. Therefore, the unnecessary retransmissions
following the spurious RTO cannot be avoided by using DSACK. Instead, the suggested
recovery algorithm using DSACK can only revert the congestion control parameters to the
state preceding the spurious retransmissions.</p>

<h4>F-RTO实现</h4>

<p>F-RTO is implemented (mainly) in four functions:<br/>
（1）tcp_use_frto() is used to determine if TCP can use F-RTO.</p>

<p>（2）tcp_enter_frto() prepares TCP state on RTO if F-RTO is used, it is called when<br/>
          tcp_use_frto() showed green light.</p>

<p>（3）tcp_process_frto() handles incoming ACKs during F-RTO algorithm.</p>

<p>（4）tcp_enter_frto_loss() is called if there is not enough evidence to prove that the RTO is<br/>
          indeed spurious. It transfers the control from F-RTO to the conventional RTO recovery.</p>

<h4>判断是否可以使用F-RTO</h4>

<p> 调用时机：当TCP段传送超时后，会引起段的重传，在重传定时器的处理过程中会判断是否可以使用F-RTO算法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_retransmit_timer (struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    ....  
</span><span class='line'>  
</span><span class='line'>    if (tcp_use_frto(sk)) {  
</span><span class='line'>        tcp_enter_frto(sk);  
</span><span class='line'>    } else {  
</span><span class='line'>        tcp_enter_loss(sk);  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    ....  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>能够使用F-RTO的条件：<br/>
（1）tcp_frto非零，此为TCP参数<br/>
（2）MTU probe没使用，因为它和F-RTO有冲突<br/>
（3）a. 如果启用了sackfrto，则可以使用<br/>
    b. 如果没启用sackfrto，不能重传过除head以外的数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* F-RTO can only be used if TCP has never retransmitted anything other than 
</span><span class='line'> * head (SACK enhanced variant from Appendix B of RFC4138 is more robust here) 
</span><span class='line'> */  
</span><span class='line'>int tcp_use_frto(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    const struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    const struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>    struct sk_buff *skb;  
</span><span class='line'>  
</span><span class='line'>    if (! sysctl_tcp_frto)  
</span><span class='line'>        return 0;  
</span><span class='line'>  
</span><span class='line'>    /* MTU probe and F-RTO won't really play nicely along currently */  
</span><span class='line'>    if (icsk-&gt;icsk_mtup.probe_size)  
</span><span class='line'>        return 0;  
</span><span class='line'>  
</span><span class='line'>    if (tcp_is_sackfrto(tp))  
</span><span class='line'>        return 1;  
</span><span class='line'>  
</span><span class='line'>    /* Avoid expensive walking of rexmit queue if possible */  
</span><span class='line'>    if (tp-&gt;retrans_out &gt; 1)  
</span><span class='line'>        return 0; /* 不能重过传除了head以外的数据*/  
</span><span class='line'>  
</span><span class='line'>    skb = tcp_write_queue_head(sk);  
</span><span class='line'>    if (tcp_skb_is_last(sk, skb))  
</span><span class='line'>        return 1;  
</span><span class='line'>    skb = tcp_write_queue_next(sk, skb); /* Skips head */  
</span><span class='line'>    tcp_for_write_queue_from(skb, sk) {  
</span><span class='line'>        if (skb == tcp_send_head(sk))  
</span><span class='line'>            break;  
</span><span class='line'>  
</span><span class='line'>        if (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_RETRANS)  
</span><span class='line'>            return 0; /* 不允许处head以外的数据包被重传过 */  
</span><span class='line'>  
</span><span class='line'>        /* Short-circut when first non-SACKed skb has been checked */  
</span><span class='line'>        if (! (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_SACKED_ACKED))  
</span><span class='line'>        break;  
</span><span class='line'>    }  
</span><span class='line'>    return 1;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>static int tcp_is_sackfrto(const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>    return (sysctl_tcp_frto == 0x2) && ! tcp_is_reno(tp);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>进入F-RTO状态</h4>

<p>启用F-RTO后，虽然传送超时，但还没进入Loss状态，相反，先进入Disorder状态。减小慢启动阈值，而snd_cwnd暂时保持不变。此时对应head数据包还没重传前。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* RTO occurred, but do not yet enter Loss state. Instead, defer RTO recovery 
</span><span class='line'> * a bit and use heuristics in tcp_process_frto() to detect if the RTO was  
</span><span class='line'> * spurious. 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>void tcp_enter_frto (struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    const struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    struct sk_buff *skb;  
</span><span class='line'>  
</span><span class='line'>    /* Do like tcp_enter_loss() would*/  
</span><span class='line'>    if ((! tp-&gt;frto_counter && icsk-&gt;icsk_ca_state &lt;= TCP_CA_Disorder) ||  
</span><span class='line'>        tp-&gt;snd_una == tp-&gt;high_seq ||   
</span><span class='line'>        ((icsk-&gt;icsk_ca_state == TCP_CA_Loss || tp-&gt;frto_counter) &&  
</span><span class='line'>        ! icsk-&gt;icsk_retransmits)) {  
</span><span class='line'>  
</span><span class='line'>        tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk); /* 保存旧阈值*/  
</span><span class='line'>  
</span><span class='line'>        if (tp-&gt;frto_counter) {   
</span><span class='line'>            u32 stored_cwnd;  
</span><span class='line'>            stored_cwnd = tp-&gt;snd_cwnd;  
</span><span class='line'>            tp-&gt;snd_cwnd = 2;  
</span><span class='line'>            tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);  
</span><span class='line'>            tp-&gt;snd_cwnd = stored_cwnd;  
</span><span class='line'>        } else {  
</span><span class='line'>            tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk); /* 减小阈值*/  
</span><span class='line'>        }  
</span><span class='line'>  
</span><span class='line'>        tcp_ca_event(sk, CA_EVENT_FRTO); /* 触发FRTO事件 */  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    tp-&gt;undo_marker = tp-&gt;snd_una;  
</span><span class='line'>    tp-&gt;undo_retrans = 0;  
</span><span class='line'>  
</span><span class='line'>    skb = tcp_write_queue_head(sk);  
</span><span class='line'>    if (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_RETRANS)  
</span><span class='line'>        tp-&gt;undo_marker = 0;  
</span><span class='line'>  
</span><span class='line'>    /* 清除head与重传相关的标志*/  
</span><span class='line'>    if (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_SACKED_RETRANS) {  
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;sacked &= ~TCPCB_SACKED_RETRANS;  
</span><span class='line'>        tp-&gt;retrans_out -= tcp_skb_pcount(skb);  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    tcp_verfify_left_out(tp);  
</span><span class='line'>  
</span><span class='line'>    /* Too bad if TCP was application limited */  
</span><span class='line'>    tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tcp_packets_in_flight(tp) + 1);  
</span><span class='line'>  
</span><span class='line'>    /* Earlier loss recovery underway */  
</span><span class='line'>    if (tcp_is_sackfrto(tp) && (tp-&gt;frto_counter ||   
</span><span class='line'>        ((1 &lt;&lt; icsk-&gt;icsk_ca_state) & (TCPF_CA_Recovery | TCPF_CA_Loss))) &&  
</span><span class='line'>        after(tp-&gt;high_seq, tp-&gt;snd_una)) {  
</span><span class='line'>  
</span><span class='line'>        tp-&gt;frto_highmark = tp-&gt;high_seq;  
</span><span class='line'>  
</span><span class='line'>    } else {  
</span><span class='line'>        tp-&gt;frto_highmark = tp-&gt;snd_nxt;  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    tcp_set_ca_state (sk, TCP_CA_Disorder); /* 设置拥塞状态*/  
</span><span class='line'>    tp-&gt;high_seq = tp-&gt;snd_nxt;  
</span><span class='line'>    tp-&gt;frto_counter = 1; /* 表示刚进入F-RTO状态！*/  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>F-RTO算法处理</h4>

<p>F-RTO算法的处理过程主要发生在重传完超时数据包后。发送方在接收到ACK后，在处理ACK时会检查是否处于F-RTO处理阶段。如果是则会调用tcp_process_frto()进行F-RTO阶段的处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_ack (struct sock *sk, const struct sk_buff *skb, int flag)  
</span><span class='line'>{  
</span><span class='line'>    ....  
</span><span class='line'>  
</span><span class='line'>    if (tp-&gt;frto_counter )  
</span><span class='line'>        frto_cwnd = tcp_process_frto(sk, flag);  
</span><span class='line'>  
</span><span class='line'>    ....  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>2.6.20的F-RTO</h4>

<p>tcp_process_frto()用于判断RTO是否为虚假的，主要依据为RTO后的两个ACK。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_process_frto (struct sock *sk, u32 prior_snd_una)  
</span><span class='line'>{  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    tcp_sync_left_out(tp);  
</span><span class='line'>  
</span><span class='line'>    /* RTO was caused by loss, start retransmitting in 
</span><span class='line'>     * go-back-N slow start. 
</span><span class='line'>     * 包括两种情况： 
</span><span class='line'>      * （1）此ACK为dupack 
</span><span class='line'>     * （2）此ACK确认完整个窗口 
</span><span class='line'>      * 以上两种情况都表示有数据包丢失了，需要采用传统的方法。 
</span><span class='line'>      */  
</span><span class='line'>    if (tp-&gt;snd_una == prior_snd_una ||   
</span><span class='line'>        ! before(tp-&gt;snd_una, tp-&gt;frto_highmark)) {  
</span><span class='line'>  
</span><span class='line'>        tcp_enter_frto_loss(sk);  
</span><span class='line'>        return;  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    /* First ACK after RTO advances the window: allow two new  
</span><span class='line'>     * segments out. 
</span><span class='line'>     * frto_counter = 1表示收到第一个有效的ACK，则重新设置 
</span><span class='line'>     * 拥塞窗口，确保可以在F-RTO处理阶段在输出两个数据包， 
</span><span class='line'>     * 因为此时还没进入Loss状态，所以可以发送新数据包。 
</span><span class='line'>     */  
</span><span class='line'>    if (tp-&gt;frto_counter == 1) {  
</span><span class='line'>  
</span><span class='line'>        tp-&gt;snd_cwnd = tcp_packets_in_flight(tp) + 2;  
</span><span class='line'>  
</span><span class='line'>    } else {  
</span><span class='line'>  
</span><span class='line'>        /* Also the second ACK after RTO advances the window. 
</span><span class='line'>         * The RTO was likely spurious. Reduce cwnd and continue 
</span><span class='line'>         * in congestion avoidance. 
</span><span class='line'>         * 第二个ACK有效，则调整拥塞窗口，直接进入拥塞避免阶段， 
</span><span class='line'>          * 而不用重传数据包。 
</span><span class='line'>          * / 
</span><span class='line'>        tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh); 
</span><span class='line'>        tcp_moderate_cwnd(tp); 
</span><span class='line'>    } 
</span><span class='line'> 
</span><span class='line'>    /* F-RTO affects on two new ACKs following RTO. 
</span><span class='line'>     * At latest on third ACK the TCP behavior is back to normal. 
</span><span class='line'>     * 如果能连续收到两个确认了新数据的ACK，则说明RTO是虚假的，因此 
</span><span class='line'>      * 退出F-RTO。 
</span><span class='line'>      */  
</span><span class='line'>    tp-&gt;frto_counter = (tp-&gt;frto_counter + 1) % 3;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果确定RTO为虚假的，则调用tcp_enter_frto_loss()，进入RTO恢复阶段，开始慢启动。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Enter Loss state after F-RTO was applied. Dupack arrived after RTO, which 
</span><span class='line'> * indicates that we should follow the traditional RTO recovery, i.e. mark  
</span><span class='line'> * erverything lost and do go-back-N retransmission. 
</span><span class='line'> */  
</span><span class='line'>static void tcp_enter_frto_loss (struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    struct sk_buff *skb;  
</span><span class='line'>    int cnt = 0;  
</span><span class='line'>  
</span><span class='line'>    /* 进入Loss状态后，清零SACK、lost、retrans_out等数据*/  
</span><span class='line'>    tp-&gt;sacked_out = 0;  
</span><span class='line'>    tp-&gt;lost_out = 0;  
</span><span class='line'>    tp-&gt;fackets_out = 0;  
</span><span class='line'>  
</span><span class='line'>    /* 遍历重传队列，重新标志LOST。对于那些在RTO发生后传输 
</span><span class='line'>     * 的数据不用标志为LOST。 
</span><span class='line'>     */  
</span><span class='line'>    sk_stream_for_retrans_queue(skb, sk) {  
</span><span class='line'>        cnt += tcp_skb_pcount(skb);  
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;sacked &= ~TCPCB_LOST;  
</span><span class='line'>  
</span><span class='line'>        /* 对于那些没被SACK的数据包，需要把它标志为LOST。*/  
</span><span class='line'>        if (! (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_SACKED_ACKED)) {  
</span><span class='line'>            /* Do not mark those segments lost that were forward 
</span><span class='line'>             * transmitted after RTO. 
</span><span class='line'>             */  
</span><span class='line'>             if (! after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;frto_highmark))  
</span><span class='line'>             {  
</span><span class='line'>                TCP_SKB_CB(skb)-&gt;sacked |= TCP_LOST;  
</span><span class='line'>                tp-&gt;lost_out += tcp_skb_pcount(skb);  
</span><span class='line'>             }  
</span><span class='line'>  
</span><span class='line'>        } else { /* 对于那些已被sacked的数据包，则不用标志LOST。*/  
</span><span class='line'>            tp-&gt;sacked_out += tcp_skb_pcount(skb);  
</span><span class='line'>            tp-&gt;fackets_out = cnt;  
</span><span class='line'>        }  
</span><span class='line'>    }  
</span><span class='line'>    tcp_syn_left_out(tp);  
</span><span class='line'>  
</span><span class='line'>    tp-&gt;snd_cwnd = tp-&gt;frto_counter + tcp_packets_in_flight(tp) + 1;  
</span><span class='line'>    tp-&gt;snd_cwnd_cnt = 0;  
</span><span class='line'>    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;  
</span><span class='line'>    tp-&gt;undo_marker = 0; /* 不需要undo标志*/  
</span><span class='line'>    tp-&gt;frto_counter = 0; /* 表示F-RTO结束了*/  
</span><span class='line'>  
</span><span class='line'>    /* 更新乱序队列的最大值*/  
</span><span class='line'>    tp-&gt;reordering = min_t(unsigned int, tp-&gt;reordering, sysctl_tcp_reordering);  
</span><span class='line'>    tcp_set_ca_state(sk, TCP_CA_Loss); /* 进入loss状态*/  
</span><span class='line'>    tp-&gt;high_seq = tp-&gt;frto_highmark; /*RTO时的最大序列号*/  
</span><span class='line'>    TCP_ECN_queue_cwr(tp); /* 设置显示拥塞标志*/  
</span><span class='line'>    clear_all_retrans_hints(tp);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>3.2.12的F-RTO</h4>

<p>F-RTO spurious RTO detection algorithm (RFC4138)<br/>
F-RTO affects during two new ACKs following RTO (well, almost, see inline
comments). State (ACK number) is kept in frto_counter. When ACK advances
window (but not to or beyond highest sequence sent before RTO) :<br/>
On First ACK, send two new segments out.<br/>
On second ACK, RTO was likely spurious. Do spurious response (response<br/>
    algorithm is not part of the F-RTO detection algorithm given in RFC4138 but<br/>
    can be selected separately).</p>

<p>Otherwise (basically on duplicate ACK), RTO was (likely) caused by a loss and
TCP falls back to conventional RTO recovery. F-RTO allows overriding of Nagle,
this is done using frto_counter states 2 and 3, when a new data segment of any
size sent during F-RTO, state 2 is upgraded to 3.</p>

<p>Rationale: if the RTO was suprious, new ACKs should arrive from the original
window even after we transmit two new data segments.</p>

<p>SACK version:<br/>
    on first step, wait until first cumulative ACK arrives, then move to the second
    step. In second step, the next ACK decides.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_process_frto(struct sock *sk, int flag)  
</span><span class='line'>{  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    tcp_verify_left_out(tp);  
</span><span class='line'>   
</span><span class='line'>    /* Duplicate the behavior from Loss state (fastretrans_alert) */  
</span><span class='line'>    if (flag & FLAG_DATA_ACKED)  
</span><span class='line'>        inet_csk(sk)-&gt;icsk_retransmits = 0; /*重传次数归零*/  
</span><span class='line'>   
</span><span class='line'>    if ((flag & FLAG_NONHEAD_RETRANS_ACKED) ||  
</span><span class='line'>        ((tp-&gt;frto_counter &gt;= 2) && (flag & FLAG_RETRANS_DATA_ACKED)))  
</span><span class='line'>        tp-&gt;undo_marker = 0;  
</span><span class='line'>   
</span><span class='line'>    /* 一个ACK确认完RTO时整个窗口，表示出现了丢包*/  
</span><span class='line'>    if (! before(tp-&gt;snd_una, tp-&gt;frto_highmark)) {  
</span><span class='line'>        tcp_enter_frto_loss(sk, (tp-&gt;frto_counter == 1 ? 2 : 3), flag) ;  
</span><span class='line'>        return 1;  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    /* Reno的处理方式 */  
</span><span class='line'>    if (! tcp_is_sackfrto(tp)) {   
</span><span class='line'>        /* RFC4138 shortcoming in step2; should also have case c): 
</span><span class='line'>         * ACK isn't duplicate nor advances window, e.g., opposite dir 
</span><span class='line'>         * data, winupdate 
</span><span class='line'>         */  
</span><span class='line'>        if (! (flag & FLAG_ANY_PROGRESS) && (flag & FLAG_NOT_DUP))  
</span><span class='line'>            return 1; /*不采取任何措施，忽略*/  
</span><span class='line'>  
</span><span class='line'>        if (! (flag & FLAG_DATA_ACKED)) { /* 没有确认新的数据*/  
</span><span class='line'>            tcp_enter_frto_loss(sk, (tp-&gt;frto_counter == 1 ? 0 : 3), flag);  
</span><span class='line'>            return 1;  
</span><span class='line'>        }  
</span><span class='line'>  
</span><span class='line'>    } else { /* SACK的处理方式 */  
</span><span class='line'>        /* Prevent sender of new data. 表示第一个ACK没有确认新数据， 
</span><span class='line'>         * 这个时候不允许发送新的数据，直接返回。 
</span><span class='line'>         */  
</span><span class='line'>        if (! (flag & FLAG_DATA_ACKED) & (tp-&gt;frto_conter == 1) {  
</span><span class='line'>            tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tcp_packets_in_flight(tp));  
</span><span class='line'>            return 1;  
</span><span class='line'>        }  
</span><span class='line'>  
</span><span class='line'>        /* 当第二个ACK也没有确认新的数据时，判定RTO真实，退出F-RTO。*/  
</span><span class='line'>        if ( (tp-&gt;frto_counter &gt;= 2) &&   
</span><span class='line'>            (! (flag & FLAG_FORWARD_PROGRESS) ||  
</span><span class='line'>            ((flag & FLAG_DATA_SACKED) && ! (flag & FLAG_ONLY_ORIG_SACKED))) {  
</span><span class='line'>            /* RFC4138 shortcoming (see comment above) */  
</span><span class='line'>  
</span><span class='line'>            if (! (flag & FLAG_FORWARD_PROGRESS) &&   
</span><span class='line'>                (flag & FLAG_NOT_DUP);  
</span><span class='line'>                return 1;  
</span><span class='line'>   
</span><span class='line'>            tcp_enter_frto_loss(sk, 3, flag);  
</span><span class='line'>            return 1;  
</span><span class='line'>        }  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    if (tp-&gt;frto_counter == 1) {  
</span><span class='line'>        /* tcp_may_send_now needs to see updated state */  
</span><span class='line'>        tp-&gt;snd_cwnd = tcp_packets_in_flight(tp) + 2;  
</span><span class='line'>        tp-&gt;frto_counter = 2;  
</span><span class='line'>          
</span><span class='line'>        if (! tcp_may_send_now(sk))  
</span><span class='line'>            tcp_enter_frto_loss(sk, 2, flag);  
</span><span class='line'>        return 1;  
</span><span class='line'>  
</span><span class='line'>    } else {  
</span><span class='line'>        switch (sysctl_tcp_frto_response) {  
</span><span class='line'>        case 2: /* 比较激进的，恢复到RTO前的窗口和阈值*/  
</span><span class='line'>            tcp_undo_spur_to_response(sk, flag);  
</span><span class='line'>            break;  
</span><span class='line'>  
</span><span class='line'>        case 1: /* 非常保守，阈值减小B，可窗口一再减小，为B/2 */  
</span><span class='line'>            tcp_conservative_spur_to_response(sk);  
</span><span class='line'>            break;  
</span><span class='line'>  
</span><span class='line'>        default:  
</span><span class='line'>            /* 保守*/  
</span><span class='line'>            tcp_ratehalving_spur_to_response(sk);  
</span><span class='line'>            break;  
</span><span class='line'>        }  
</span><span class='line'>  
</span><span class='line'>        tp-&gt;frto_counter = 0; /*F-RTO算法结束标志*/  
</span><span class='line'>        tp-&gt;undo_marker = 0; /*清零undo标志*/  
</span><span class='line'>        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSPURIOUSRTOS);  
</span><span class='line'>    }  
</span><span class='line'>    return 0;   
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>#define FLAG_DATA_ACKED 0x04 /* This ACK acknowledged new data. */  
</span><span class='line'>#define FLAG_NONHEAD_RETRANS_ACKED 0x1000 /* Non-head rexmit data was ACKed. */  
</span><span class='line'>#define FLAG_RETRANS_DATA_ACKED 0x08 /* some of which was retransmitted.*/  
</span><span class='line'>  
</span><span class='line'>#define FLAG_ACKED (FLAG_DATA_ACKED | FLAG_SYN_ACKED)  
</span><span class='line'>#define FLAG_FORWARD_PROGRESS (FLAG_ACKED | FLAG_DATA_SACKED)  
</span><span class='line'>#define FLAG_ANY_PROGRESS (FLAG_RORWARD_PROGRESS | FLAG_SND_UNA_ADVANCED)  
</span><span class='line'>   
</span><span class='line'>#define FLAG_NOT_DUP (FLAG_DATA | FLAG_WIN_UPDATE | FLAG_ACKED)</span></code></pre></td></tr></table></div></figure>


<h4>tcp_frto_response选项</h4>

<p>tcp_frto_response表示TCP在检测到虚假的RTO后，采用什么函数来进行阈值和拥塞窗口的调整，它有三种取值：</p>

<h5>（1）值为2</h5>

<p>表示使用tcp_undo_spur_to_response()，这是一种比较激进的处理方法，它把阈值和拥塞窗口都恢复到RTO前的值。</p>

<h5>（2）值为1</h5>

<p>表示使用tcp_conservative_spur_to_response()，这是一种很保守的处理方法。<br/>
假设减小因子为B，RTO前的窗口为C，那么一般情况下（因为阈值调整算法不同）<br/>
此后ssthresh=（1 - B）C，cwnd = （1 -B ）（1- B）C</p>

<h5>（3）值为0或其它（默认为0）</h5>

<p>表示使用默认的tcp_ratehalving_spur_to_response()，也是一种保守的处理方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_undo_spur_to_response (struct sock *sk, int flag)  
</span><span class='line'>{  
</span><span class='line'>    /* 如果有显示拥塞标志，则进入CWR状态，最终阈值不变，窗口减半*/  
</span><span class='line'>    if (flag & FLAG_ECE)  
</span><span class='line'>        tcp_ratehalving_spur_to_response(sk);  
</span><span class='line'>    else  
</span><span class='line'>    /* 撤销阈值调整，撤销窗口调整，恢复RTO前的状态*/  
</span><span class='line'>        tcp_undo_cwr(sk, true);  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>/* A conservative spurious RTO response algorithm: reduce cwnd 
</span><span class='line'> * using rate halving and continue in congestion_avoidance. 
</span><span class='line'> */  
</span><span class='line'>static void tcp_ratehalving_spur_to_response(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>    tcp_enter_cwr(sk, 0);  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>/* A very conservative spurious RTO response algorithm: reduce cwnd 
</span><span class='line'> * and continue in congestion avoidance. 
</span><span class='line'> */  
</span><span class='line'>static void tcp_conservative_spur_to_response(struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>    tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh);  
</span><span class='line'>    tp-&gt;snd_cwnd_cnt = 0;  
</span><span class='line'>    tp-&gt;bytes_acked = 0;  
</span><span class='line'>    /* 竟然又设置了显示拥塞标志，那窗口就还要减小到阈值的（1-B）！ 
</span><span class='line'>     * 果然是非常保守。 
</span><span class='line'>     */  
</span><span class='line'>    TCP_ECN_queue_cwr(tp);   
</span><span class='line'>    tcp_moderate_cwnd(tp);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果判断RTO是真实的，就调用tcp_enter_frto_loss()来处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Enter Loss state after F-RTO was applied. Dupack arrived after RTO, 
</span><span class='line'> * which indicates that we should follow the tradditional RTO recovery, 
</span><span class='line'> * i.e. mark everything lost and do go-back-N retransmission. 
</span><span class='line'> */  
</span><span class='line'>static void tcp_enter_frto_loss(struct sock *sk, int allowed_segments, int flag)  
</span><span class='line'>{  
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>    struct sk_buff *skb;  
</span><span class='line'>  
</span><span class='line'>    tp-&gt;lost_out = 0;  
</span><span class='line'>    tp-&gt;retrans_out = 0;  
</span><span class='line'>  
</span><span class='line'>    if (tcp_is_reno(tp))  
</span><span class='line'>        tcp_reset_reno_sack(tp);  
</span><span class='line'>  
</span><span class='line'>    tcp_for_write_queue(skb, sk) {  
</span><span class='line'>        if (skb == tcp_send_head(sk))  
</span><span class='line'>            break;  
</span><span class='line'>  
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;sacked &= ~TCPCB_LOST;  
</span><span class='line'>        /*  
</span><span class='line'>         * Count the retransmission made on RTO correctly (only when waiting for 
</span><span class='line'>         * the first ACK and did not get it. 
</span><span class='line'>         */  
</span><span class='line'>        if ((tp-&gt;frto_counter == 1) && !(flag & FLAG_DATA_ACKED)) {  
</span><span class='line'>            /* For some reason this R-bit might get cleared ? */  
</span><span class='line'>            if (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_SACKED_RETRANS)  
</span><span class='line'>                tp-&gt;retrans_out += tcp_skb_pcount(skb);  
</span><span class='line'>  
</span><span class='line'>            /* enter this if branch just for the first segment */  
</span><span class='line'>            flag |= FLAG_DATA_ACKED;  
</span><span class='line'>        } else {  
</span><span class='line'>  
</span><span class='line'>            if (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_RETRANS)  
</span><span class='line'>                tp-&gt;undo_marker = 0;  
</span><span class='line'>            TCP_SKB_CB(skb)-&gt;sacked &= ~TCPCB_SACKED_RETRANS;  
</span><span class='line'>        }  
</span><span class='line'>  
</span><span class='line'>        /* Marking forward transmissions that were made after RTO lost can 
</span><span class='line'>        * cause unnecessary retransmissions in some scenarios, 
</span><span class='line'>        * SACK blocks will mitigate that in some but not in all cases. 
</span><span class='line'>        * We used to not mark them but it was casuing break-ups with 
</span><span class='line'>        * receivers that do only in-order receival. 
</span><span class='line'>        *  
</span><span class='line'>        * TODO: we could detect presence of such receiver and select different 
</span><span class='line'>        * behavior per flow. 
</span><span class='line'>        */  
</span><span class='line'>       if (! (TCP_SKB_CB(skb)-&gt;sacked & TCPCB_SACKED_ACKED)) {  
</span><span class='line'>          TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST;  
</span><span class='line'>           tp-&gt;lost_out += tcp_skb_pcount(skb);  
</span><span class='line'>           tp-&gt;retransmit_high = TCP_SKB_CB(skb)-&gt;end_seq;  
</span><span class='line'>       }  
</span><span class='line'>    }  
</span><span class='line'>    tcp_verify_left_out(tp);  
</span><span class='line'>  
</span><span class='line'>    /* allowed_segments应该不大于3*/  
</span><span class='line'>    tp-&gt;snd_cwnd = tcp_packets_in_flight(tp) + allowed_segments;  
</span><span class='line'>    tp-&gt;snd_cwnd_cnt = 0;  
</span><span class='line'>    tp-&gt;snd_cwnd_stamp = tcp_time_stamp;  
</span><span class='line'>    tp-&gt;frto_counter = 0; /* F-RTO结束了*/  
</span><span class='line'>    tp-&gt;bytes_acked = 0;  
</span><span class='line'>  
</span><span class='line'>    /* 更新乱序队列的最大长度*/  
</span><span class='line'>    tp-&gt;reordering = min_t(unsigned int, tp-&gt;reordering,  
</span><span class='line'>                                               sysctl_tcp_reordering);  
</span><span class='line'>  
</span><span class='line'>    tcp_set_ca_state(sk, TCP_CA_Loss); /*设置成Loss状态*/  
</span><span class='line'>    tp-&gt;high_seq = tp-&gt;snd_nxt;  
</span><span class='line'>    TCP_ECN_queue_cwr(tp); /*设置显式拥塞标志*/  
</span><span class='line'>    tcp_clear_all_retrans_hints(tp);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>总结</h4>

<p>现在内核（3.2.12）是默认使用F-RTO算法的。<br/>
其中tcp_frto默认为2，tcp_frto_response默认为0。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-03-23T14:37:00+08:00'><span class='date'>2015-03-23</span> <span class='time'>14:37:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~net/'>net</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/03/23/kernel-net-ca/" title="Previous Post: TCP拥塞状态机的实现tcp_fastretrans_alert">&laquo; TCP拥塞状态机的实现tcp_fastretrans_alert</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/03/27/kernel-net-tso3/" title="Next Post: TCP的TSO/GSO处理（二）">TCP的TSO/GSO处理（二） &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
