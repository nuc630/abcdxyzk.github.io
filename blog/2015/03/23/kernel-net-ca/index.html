
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>TCP拥塞状态机的实现tcp_fastretrans_alert - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>date [-d @int|str] [+%s|"+%F %T"]</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">TCP拥塞状态机的实现tcp_fastretrans_alert</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-23T14:03:00+08:00'><span class='date'>2015-03-23</span> <span class='time'>14:03:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.csdn.net/zhangskd/article/details/8260873">TCP拥塞状态机的实现（上）</a><br/>
<a href="http://blog.csdn.net/zhangskd/article/details/8283687">TCP拥塞状态机的实现（中）</a><br/>
<a href="http://blog.csdn.net/zhangskd/article/details/8283689">TCP拥塞状态机的实现（下）</a></p>

<hr />

<h3>TCP拥塞状态机的实现（上）</h3>

<p>内容：本文主要分析TCP拥塞状态机的实现中，主体函数tcp_fastretrans_alert()的实现。接下来的文章会对其中重要的部分进行更具体的分析。</p>

<p>内核版本：2.6.37</p>

<h4>原理</h4>

<p>先来看一下涉及到的知识。</p>

<h5>拥塞状态：</h5>

<p>（1）Open：Normal state, no dubious events, fast path.<br/>
（2）Disorder：In all respects it is Open, but requres a bit more attention.<br/>
  It is entered when we see some SACKs or dupacks. It is split of Open mainly to move some processing from fast path to slow one.<br/>
（3）CWR：cwnd was reduced due to some Congestion Notification event.<br/>
  It can be ECN, ICMP source quench, local device congestion.<br/>
（4）Recovery：cwnd was reduced, we are fast-retransmitting.<br/>
（5）Loss：cwnd was reduced due to RTO timeout or SACK reneging.</p>

<h5>tcp_fastretrans_alert() is entered：</h5>

<p>（1）each incoming ACK, if state is not Open<br/>
（2）when arrived ACK is unusual, namely:<br/>
  SACK<br/>
  Duplicate ACK<br/>
  ECN ECE</p>

<h5>Counting packets in flight is pretty simple.</h5>

<p>（1）in_flight = packets_out - left_out + retrans_out<br/>
packets_out is SND.NXT - SND.UNA counted in packets. <br/>
retrans_out is number of retransmitted segments.<br/>
left_out is number of segments left network, but not ACKed yet.</p>

<p>（2）left_out = sacked_out + lost_out<br/>
sacked_out：Packets, which arrived to receiver out of order and hence not ACKed. With SACK this number is simply amount of SACKed data. Even without SACKs it is easy to give pretty reliable estimate of this number, counting duplicate ACKs.</p>

<p>（3）lost_out：Packets lost by network. TCP has no explicit loss notification feedback from network(for now). It means that this number can be only guessed. Actually, it is the heuristics to predict lossage that distinguishes different algorithms.<br/>
F.e. after RTO, when all the queue is considered as lost, lost_out = packets_out and in_flight = retrans_out.</p>

<h5>Essentially, we have now two algorithms counting lost packets.</h5>

<p>1）FACK：It is the simplest heuristics. As soon as we decided that something is lost, we decide that all not SACKed packets until the most forward SACK are lost. I.e.<br/>
lost_out = fackets_out - sacked_out and left_out = fackets_out<br/>
It is absolutely correct estimate, if network does not reorder packets. And it loses any connection to reality when reordering takes place. We use FACK by defaut until reordering is suspected on the path to this destination.</p>

<p>2）NewReno：when Recovery is entered, we assume that one segment is lost (classic Reno). While we are in Recovery and a partial ACK arrives, we assume that one more packet is lost (NewReno).<br/>
This heuristics are the same in NewReno and SACK. <br/>
Imagine, that&rsquo;s all! Forget about all this shamanism about CWND inflation deflation etc. CWND is real congestion window, never inflated, changes only according to classic VJ rules.</p>

<p>Really tricky (and requiring careful tuning) part of algorithm is hidden in functions tcp_time_to_recover() and tcp_xmit_retransmit_queue().</p>

<h5>tcp_time_to_recover()</h5>

<p>It determines the moment when we should reduce cwnd and, hence, slow down forward transmission. In fact, it determines the moment when we decide that hole is caused by loss, rather than by a reorder.</p>

<h5>tcp_xmit_retransmit_queue()</h5>

<p>It decides what we should retransmit to fill holes, caused by lost packets.</p>

<h5>undo heuristics</h5>

<p>And the most logically complicated part of algorithm is undo heuristics. We detect false retransmits due to both too early fast retransmit (reordering) and underestimated RTO, analyzing timestamps and D-SACKs. When we detect that some segments were retransmitted by mistake and CWND reduction was wrong, we undo window reduction and abort recovery phase. This logic is hidden inside several functions named tcp_try_undo_<something>.</p>

<h4>主体函数</h4>

<p>TCP拥塞状态机主要是在tcp_fastretrans_alert()中实现的，tcp_fastretrans_alert()在tcp_ack()中被调用。</p>

<p>此函数分成几个阶段：<br/>
A. FLAG_ECE，收到包含ECE标志的ACK。<br/>
B. reneging SACKs，ACK指向已经被SACK的数据段。如果是此原因，进入超时处理，然后返回。<br/>
C. state is not Open，发现丢包，需要标志出丢失的包，这样就知道该重传哪些包了。<br/>
D. 检查是否有错误( left_out > packets_out)。<br/>
E. 各个状态是怎样退出的，当snd_una >= high_seq时候。<br/>
F. 各个状态的处理和进入。</p>

<p>下文会围绕这几个阶段进行具体分析。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Process an event, which can update packets-in-flight not trivially.
</span><span class='line'> * Main goal of this function is to calculate new estimate for left_out,
</span><span class='line'> * taking into account both packets sitting in receiver's buffer and
</span><span class='line'> * packets lost by network. 
</span><span class='line'> * 
</span><span class='line'> * Besides that it does CWND reduction, when packet loss is detected
</span><span class='line'> * and changes state of machine.
</span><span class='line'> *
</span><span class='line'> * It does not decide what to send, it is made in function
</span><span class='line'> * tcp_xmit_retransmit_queue().
</span><span class='line'> */
</span><span class='line'>
</span><span class='line'>/* 此函数被调用的条件：
</span><span class='line'> * (1) each incoming ACK, if state is not Open
</span><span class='line'> * (2) when arrived ACK is unusual, namely:
</span><span class='line'> *       SACK
</span><span class='line'> *       Duplicate ACK
</span><span class='line'> *       ECN ECE
</span><span class='line'> */
</span><span class='line'>
</span><span class='line'>static void tcp_fastretrans_alert(struct sock *sk, int pkts_acked, int flag)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>&#9;/* 判断是不是重复的ACK*/
</span><span class='line'>&#9;int is_dupack = ! (flag & (FLAG_SND_UNA_ADVANCED | FLAG_NOT_DUP));
</span><span class='line'>
</span><span class='line'>&#9;/* tcp_fackets_out()返回hole的大小，如果大于reordering，则认为发生丢包.*/
</span><span class='line'>&#9;int do_lost = is_dupack || ((flag & FLAG_DATA_SACKED) && 
</span><span class='line'>&#9;&#9;&#9;&#9;(tcp_fackets_out(tp) &gt; tp-&gt;reordering ));
</span><span class='line'>
</span><span class='line'>&#9;int fast_rexmit = 0, mib_idx;
</span><span class='line'>
</span><span class='line'>&#9;/* 如果packet_out为0，那么不可能有sacked_out */
</span><span class='line'>&#9;if (WARN_ON(!tp-&gt;packets_out && tp-&gt;sacked_out))
</span><span class='line'>&#9;&#9;tp-&gt;sacked_out = 0;
</span><span class='line'>
</span><span class='line'>&#9;/* fack的计数至少需要依赖一个SACK的段.*/
</span><span class='line'>&#9;if (WARN_ON(!tp-&gt;sacked_out && tp-&gt;fackets_out))
</span><span class='line'>&#9;&#9;tp-&gt;fackets_out = 0;
</span><span class='line'> 
</span><span class='line'>&#9;/* Now state machine starts.
</span><span class='line'>&#9; * A. ECE, hence prohibit cwnd undoing, the reduction is required. 
</span><span class='line'>&#9; * 禁止拥塞窗口撤销，并开始减小拥塞窗口。
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (flag & FLAG_ECE)
</span><span class='line'>&#9;&#9;tp-&gt;prior_ssthresh = 0;
</span><span class='line'>&#9;
</span><span class='line'>&#9;/* B. In all the states check for reneging SACKs. 
</span><span class='line'>&#9; * 检查是否为虚假的SACK，即ACK是否确认已经被SACK的数据.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (tcp_check_sack_reneging(sk, flag))
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9; 
</span><span class='line'>&#9;/* C. Process data loss notification, provided it is valid. 
</span><span class='line'>&#9; * 为什么需要这么多个条件？不太理解。
</span><span class='line'>&#9; * 此时不在Open态，发现丢包，需要标志出丢失的包。
</span><span class='line'>&#9;  */
</span><span class='line'>&#9;if (tcp_is_fack(tp) && (flag & FLAG_DATA_LOSS) &&
</span><span class='line'>&#9;&#9;before(tp-&gt;snd_una, tp-&gt;high_seq) &&
</span><span class='line'>&#9;&#9;icsk-&gt;icsk_ca_state != TCP_CA_Open &&
</span><span class='line'>&#9;&#9;tp-&gt;fackets_out &gt; tp-&gt;reordering) {
</span><span class='line'>&#9;&#9;tcp_mark_head_lost(sk, tp-&gt;fackets_out - tp-&gt;reordering, 0);
</span><span class='line'>&#9;&#9;NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPLOSS);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/* D. Check consistency of the current state. 
</span><span class='line'>&#9; * 确定left_out &lt; packets_out
</span><span class='line'>&#9; */
</span><span class='line'>&#9;tcp_verify_left_out(tp); 
</span><span class='line'>
</span><span class='line'>&#9;/* E. Check state exit conditions. State can be terminated 
</span><span class='line'>&#9; * when high_seq is ACKed. */
</span><span class='line'>&#9;if (icsk-&gt;icsk_ca_state == TCP_CA_Open) {
</span><span class='line'>&#9;&#9;/* 在Open状态，不可能有重传且尚未确认的段*/
</span><span class='line'>&#9;&#9;WARN_ON(tp-&gt;retrans_out != 0);
</span><span class='line'>&#9;&#9;/* 清除上次重传阶段第一个重传段的发送时间*/
</span><span class='line'>&#9;&#9;tp-&gt;retrans_stamp = 0;
</span><span class='line'>
</span><span class='line'>&#9;} else if (!before(tp-&gt;snd_una, tp-&gt;high_seq) {/* high_seq被确认了*/
</span><span class='line'>&#9;&#9;switch(icsk-&gt;icsk_ca_state) {
</span><span class='line'>&#9;&#9;&#9;case TCP_CA_Loss:
</span><span class='line'>&#9;&#9;&#9;&#9;icsk-&gt;icsk_retransmits = 0; /*超时重传次数归0*/ 
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;/*不管undo成功与否，都会返回Open态，除非没有使用SACK*/
</span><span class='line'>&#9;&#9;&#9;&#9;if (tcp_try_undo_recovery(sk)) 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;return;
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'> 
</span><span class='line'>&#9;&#9;&#9;case TCP_CA_CWR:
</span><span class='line'>&#9;&#9;&#9;&#9;/* CWR is to be held someting *above* high_seq is ACKed
</span><span class='line'>&#9;&#9;&#9;&#9; * for CWR bit to reach receiver.
</span><span class='line'>&#9;&#9;&#9;&#9; * 需要snd_una &gt; high_seq才能撤销
</span><span class='line'>&#9;&#9;&#9;&#9;   */
</span><span class='line'>&#9;&#9;&#9;&#9;if (tp-&gt;snd_una != tp-&gt;high_seq) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tcp_complete_cwr(sk);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tcp_set_ca_state(sk, TCP_CA_Open);
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;case TCP_CA_Disorder:
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_try_undo_dsack(sk);
</span><span class='line'>&#9;&#9;&#9;&#9; /* For SACK case do not Open to allow to undo
</span><span class='line'>&#9;&#9;&#9;&#9;  * catching for all duplicate ACKs.?*/
</span><span class='line'>&#9;&#9;&#9;&#9;if (!tp-&gt;undo_marker || tcp_is_reno(tp) || 
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tp-&gt;snd_una != tp-&gt;high_seq) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tp-&gt;undo_marker = 0;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tcp_set_ca_state(sk, TCP_CA_Open);
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;case TCP_CA_Recovery:
</span><span class='line'>&#9;&#9;&#9;&#9;if (tcp_is_reno(tp))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tcp_reset_reno_sack(tp)); /* sacked_out清零*/
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (tcp_try_undo_recovery(sk))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;return;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_complete_cwr(sk);
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/* F. Process state. */
</span><span class='line'>&#9;switch(icsk-&gt;icsk_ca_state) {
</span><span class='line'>&#9;&#9;case TCP_CA_Recovery:
</span><span class='line'>&#9;&#9;&#9;if (!(flag & FLAG_SND_UNA_ADVANCED)) {
</span><span class='line'>&#9;&#9;&#9;&#9;if (tcp_is_reno(tp) && is_dupack)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tcp_add_reno_sack(sk); /* 增加sacked_out ，检查是否出现reorder*/
</span><span class='line'>&#9;&#9;&#9;} else 
</span><span class='line'>&#9;&#9;&#9;&#9;do_lost = tcp_try_undo_partial(sk, pkts_acked);
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;case TCP_CA_Loss:
</span><span class='line'>&#9;&#9;&#9;/* 收到partical ack，超时重传的次数归零*/
</span><span class='line'>&#9;&#9;&#9;if (flag & FLAG_DATA_ACKED)
</span><span class='line'>&#9;&#9;&#9;&#9;icsk-&gt;icsk_retransmits = 0;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (tcp_is_reno(tp) && flag & FLAG_SND_UNA_ADVANCED)
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_reset_reno_sack(tp); /* sacked_out清零*/
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (!tcp_try_undo_loss(sk)) { /* 尝试撤销拥塞调整，进入Open态*/
</span><span class='line'>&#9;&#9;&#9;&#9;/* 如果不能撤销，则继续重传标志为丢失的包*/
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_moderate_cwnd(tp);
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_xmit_retransmit_queue(sk); /* 待看*/
</span><span class='line'>&#9;&#9;&#9;   return;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (icsk-&gt;icsk_ca_state != TCP_CA_Open)
</span><span class='line'>&#9;&#9;&#9;&#9;return;
</span><span class='line'> 
</span><span class='line'>&#9;&#9;/* Loss is undone; fall through to process in Open state.*/
</span><span class='line'>&#9;&#9;default:
</span><span class='line'>&#9;&#9;&#9;if (tcp_is_reno(tp)) {
</span><span class='line'>&#9;&#9;&#9;&#9;if (flag & FLAG_SND_UNA_ADVANCED)
</span><span class='line'>&#9;&#9;&#9;&#9;   tcp_reset_reno_sack(tp);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (is_dupack)
</span><span class='line'>&#9;&#9;&#9;&#9;   tcp_add_reno_sack(sk);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (icsk-&gt;icsk_ca_state == TCP_CA_Disorder)
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_try_undo_dsack(sk); /*D-SACK确认了所有重传的段*/
</span><span class='line'>&#9;&#9;&#9; 
</span><span class='line'>&#9;&#9;&#9;/* 判断是否应该进入Recovery状态*/
</span><span class='line'>&#9;&#9;&#9;if (! tcp_time_to_recover(sk)) {
</span><span class='line'>&#9;&#9;&#9;   /*此过程中，会判断是否进入Open、Disorder、CWR状态*/
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_try_to_open(sk, flag); 
</span><span class='line'>&#9;&#9;&#9;&#9;return;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* MTU probe failure: don't reduce cwnd */
</span><span class='line'>&#9;&#9;&#9;/* 关于MTU探测部分此处略过！*/
</span><span class='line'>&#9;&#9;&#9;......
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* Otherwise enter Recovery state */
</span><span class='line'>&#9;&#9;&#9;if (tcp_is_reno(tp))
</span><span class='line'>&#9;&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPRENORECOVERY;
</span><span class='line'>&#9;&#9;&#9;else
</span><span class='line'>&#9;&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPSACKRECOVERY;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9; NET_INC_STATS_BH(sock_net(sk), mib_idx);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* 进入Recovery状态前，保存那些用于恢复的数据*/
</span><span class='line'>&#9;&#9;&#9;tp-&gt;high_seq = tp-&gt;snd_nxt; /* 用于判断退出时机*/
</span><span class='line'>&#9;&#9;&#9;tp-&gt;prior_ssthresh = 0;
</span><span class='line'>&#9;&#9;&#9;tp-&gt;undo_marker = tp-&gt;snd_una;
</span><span class='line'>&#9;&#9;&#9;tp-&gt;undo_retrans=tp-&gt;retrans_out;
</span><span class='line'> 
</span><span class='line'>&#9;&#9;   if (icsk-&gt;icsk_ca_state &lt; TCP_CA_CWR) {
</span><span class='line'>&#9;&#9;&#9;   if (! (flag & FLAG_ECE))
</span><span class='line'>&#9;&#9;&#9;&#9;   tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk); /*保存旧阈值*/
</span><span class='line'>&#9;&#9;&#9;   tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);/*更新阈值*/
</span><span class='line'>&#9;&#9;&#9;   TCP_ECN_queue_cwr(tp);
</span><span class='line'>&#9;&#9;   }
</span><span class='line'>
</span><span class='line'>&#9;&#9;   tp-&gt;bytes_acked = 0;
</span><span class='line'>&#9;&#9;   tp-&gt;snd_cwnd_cnt = 0;
</span><span class='line'>
</span><span class='line'>&#9;&#9;   tcp_set_ca_state(sk, TCP_CA_Recovery); /* 进入Recovery状态*/
</span><span class='line'>&#9;&#9;   fast_rexmit = 1; /* 快速重传标志 */
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (do_lost || (tcp_is_fack(tp) && tcp_head_timeout(sk)))
</span><span class='line'>&#9;&#9;/* 更新记分牌，标志丢失和超时的数据包，增加lost_out */
</span><span class='line'>&#9;&#9;tcp_update_scoreboard(sk, fast_rexmit); 
</span><span class='line'>
</span><span class='line'>&#9;/* 减小snd_cwnd */
</span><span class='line'>&#9;tcp_cwnd_down(sk, flag);
</span><span class='line'>&#9;tcp_xmit_retransmit_queue(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>flag标志</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define FLAG_DATA 0x01  /* Incoming frame contained data. */  
</span><span class='line'>#define FLAG_WIN_UPDATE 0x02  /* Incoming ACK was a window update. */  
</span><span class='line'>#define FLAG_SND_UNA_ADVANCED 0x400  /* snd_una was changed (!= FLAG_DATA_ACKED) */  
</span><span class='line'>#define FLAG_DATA_SACKED 0x20  /* New SACK. */  
</span><span class='line'>#define FLAG_ECE 0x40  /* ECE in this ACK */  
</span><span class='line'>#define FLAG_SACK_RENEGING 0x2000  /* snd_una advanced to a sacked seq */  
</span><span class='line'>#define FLAG_DATA_LOST  /* SACK detected data lossage. */  
</span><span class='line'>   
</span><span class='line'>#define FLAG_DATA_ACKED 0x04  /* This ACK acknowledged new data. */  
</span><span class='line'>#define FLAG_SYN_ACKED 0x10    /* This ACK acknowledged SYN. */  
</span><span class='line'>#define FLAG_ACKED (FLAG_DATA_ACKED | FLAG_SYN_ACKED)  
</span><span class='line'>   
</span><span class='line'>#define FLAG_NOT_DUP (FLAG_DATA | FLAG_WIN_UPDATE | FLAG_ACKED)  /* 定义非重复ACK*/  
</span><span class='line'>   
</span><span class='line'>#define FLAG_FORWARD_PROGRESS (FLAG_ACKED | FLAG_DATA_SACKED)  
</span><span class='line'>#define FLAG_ANY_PROGRESS (FLAG_FORWARD_PROGRESS | FLAG_SND_UNA_ADVANCED)  
</span><span class='line'>#define FLAG_DSACKING_ACK 0x800  /* SACK blocks contained D-SACK info */  
</span><span class='line'>  
</span><span class='line'>struct tcp_sock {  
</span><span class='line'>&#9;...  
</span><span class='line'>&#9;u32 retrans_out; /*重传还未得到确认的TCP段数目*/  
</span><span class='line'>&#9;u32 retrans_stamp; /* 记录上次重传阶段，第一个段的发送时间，用于判断是否可以进行拥塞调整撤销*/  
</span><span class='line'>  
</span><span class='line'>&#9;struct sk_buff *highest_sack; /* highest skb with SACK received,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;*(validity guaranteed only if sacked_out &gt; 0)  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;*/  
</span><span class='line'>   ...  
</span><span class='line'>}  
</span><span class='line'>   
</span><span class='line'>struct inet_connection_sock {  
</span><span class='line'>&#9;...  
</span><span class='line'>&#9;__u8 icks_retransmits; /* 记录超时重传的次数*/  
</span><span class='line'>&#9;...  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>SACK/ RENO/ FACK是否启用</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* These function determine how the currrent flow behaves in respect of SACK 
</span><span class='line'> * handling. SACK is negotiated with the peer, and therefore it can very between 
</span><span class='line'> * different flows. 
</span><span class='line'> * 
</span><span class='line'> * tcp_is_sack - SACK enabled 
</span><span class='line'> * tcp_is_reno - No SACK 
</span><span class='line'> * tcp_is_fack - FACK enabled, implies SACK enabled 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>static inline int tcp_is_sack (const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;&#9;return tp-&gt;rx_opt.sack_ok; /* SACK seen on SYN packet */  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>static inline int tcp_is_reno (const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;&#9;return ! tcp_is_sack(tp);  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>static inline int tcp_is_fack (const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;&#9;return tp-&gt;rx_opt.sack_ok & 2;  
</span><span class='line'>}  
</span><span class='line'>   
</span><span class='line'>static inline void tcp_enable_fack(struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;&#9;tp-&gt;rx_opt.sack_ok |= 2;  
</span><span class='line'>}  
</span><span class='line'>   
</span><span class='line'>static inline int tcp_fackets_out(const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;&#9;return tcp_is_reno(tp) ? tp-&gt;sacked_out +1 : tp-&gt;fackets_out;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>（1）如果启用了FACK，那么fackets_out = left_out<br/>
  fackets_out = sacked_out + loss_out<br/>
  所以：loss_out = fackets_out - sacked_out<br/>
  这是一种比较激进的丢包估算，即FACK。</p>

<p>（2）如果没启用FACK，那么就假设只丢了一个数据包，所以left_out = sacked_out + 1<br/>
  这是一种较为保守的做法，当出现大量丢包时，这种做法会出现问题。</p>

<hr />

<h3>TCP拥塞状态机的实现（中）</h3>

<p>内容：本文主要分析TCP拥塞状态机的实现中，虚假SACK的处理、标志丢失数据包的详细过程。<br/>
内核版本：2.6.37</p>

<h4>虚假SACK</h4>

<p>state B</p>

<p>如果接收的ACK指向已记录的SACK，这说明记录的SACK并没有反应接收方的真实的状态，也就是说接收方现在已经处于严重拥塞的状态或者在处理上有bug，所以接下来就按照超时重传的方式去处理。因为按照正常的逻辑流程，接收的ACK不应该指向已记录的SACK，而应该指向SACK后面未接收的地方。通常情况下，此时接收方已经删除了保存到失序队列中的段。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* If ACK arrived pointing to a remembered SACK, it means that our remembered 
</span><span class='line'> * SACKs do not reflect real state of receiver i.e. receiver host is heavily congested 
</span><span class='line'> * or buggy. 
</span><span class='line'> * 
</span><span class='line'> * Do processing similar to RTO timeout. 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>static int tcp_check_sack_reneging (struct sock *sk, int flag)  
</span><span class='line'>{  
</span><span class='line'>&#9;if (flag & FLAG_SACK_RENEGING) {  
</span><span class='line'>&#9;&#9;struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>&#9;&#9;/* 记录mib信息，供SNMP使用*/  
</span><span class='line'>&#9;&#9;NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSACKRENEGING);  
</span><span class='line'>&#9;&#9;  
</span><span class='line'>&#9;&#9;/* 进入loss状态，1表示清除SACKED标志*/  
</span><span class='line'>&#9;&#9;tcp_enter_loss(sk, 1);  /* 此函数在前面blog中分析过：）*/  
</span><span class='line'>&#9;&#9;  
</span><span class='line'>&#9;&#9;icsk-&gt;icsk_retransmits++; /* 未恢复的RTO加一*/  
</span><span class='line'>   
</span><span class='line'>&#9;&#9;/* 重传发送队列中的第一个数据包*/  
</span><span class='line'>&#9;&#9;tcp_retransmit_skb(sk, tcp_write_queue_head(sk));   
</span><span class='line'>   
</span><span class='line'>&#9;&#9;/* 更新超时重传定时器*/  
</span><span class='line'>&#9;&#9;inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,   
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;icsk-&gt;icsk_rto, TCP_RTO_MAX);  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;return 0;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>/** 用于返回发送队列中的第一个数据包，或者NULL 
</span><span class='line'> * skb_peek - peek at the head of an &sk_buff_head 
</span><span class='line'> * @list_ : list to peek at  
</span><span class='line'> * 
</span><span class='line'> * Peek an &sk_buff. Unlike most other operations you must 
</span><span class='line'> * be careful with this one. A peek leaves the buffer on the 
</span><span class='line'> * list and someone else may run off with it. You must hold 
</span><span class='line'> * the appropriate locks or have a private queue to do this. 
</span><span class='line'> * 
</span><span class='line'> * Returns %NULL for an empty list or a pointer to the head element. 
</span><span class='line'> * The reference count is not incremented and the reference is therefore 
</span><span class='line'> * volatile. Use with caution. 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>static inline struct sk_buff *skb_peek (const struct sk_buff_head *list_)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct sk_buff *list = ((const struct sk_buff *) list_)-&gt;next;  
</span><span class='line'>&#9;if (list == (struct sk_buff *) list_)  
</span><span class='line'>&#9;&#9;list = NULL;  
</span><span class='line'>&#9;return list;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>static inline struct sk_buff *tcp_write_queue_head(const struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>&#9;return skb_peek(&sk-&gt;sk_write_queue);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>tcp_retransmit_skb()用来重传一个数据包。它最终调用tcp_transmit_skb()来发送一个数据包。这个函数在接下来的blog中会分析。</p>

<h4>重设重传定时器</h4>

<p>state B</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** inet_connection_sock - INET connection oriented sock 
</span><span class='line'> * 
</span><span class='line'> * @icsk_timeout: Timeout 
</span><span class='line'> * @icsk_retransmit_timer: Resend (no ack) 
</span><span class='line'> * @icsk_rto: Retransmission timeout 
</span><span class='line'> * @icsk_ca_ops: Pluggable congestion control hook 
</span><span class='line'> * @icsk_ca_state: Congestion control state 
</span><span class='line'> * @icsk_ca_retransmits: Number of unrecovered [RTO] timeouts 
</span><span class='line'> * @icsk_pending: scheduled timer event 
</span><span class='line'> * @icsk_ack: Delayed ACK control data 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>struct inet_connection_sock {  
</span><span class='line'>&#9;...  
</span><span class='line'>&#9;unsigned long icsk_timeout; /* 数据包超时时间*/  
</span><span class='line'>&#9;struct timer_list icsk_retransmit_timer; /* 重传定时器*/  
</span><span class='line'>&#9;struct timer_list icsk_delack_timer; /* delay ack定时器*/  
</span><span class='line'>&#9;__u32 icsk_rto; /*超时时间*/  
</span><span class='line'>&#9;const struct tcp_congestion ops *icsk_ca_ops; /*拥塞控制算法*/  
</span><span class='line'>&#9;__u8 icsk_ca_state; /*所处拥塞状态*/  
</span><span class='line'>&#9;__u8 icsk_retransmits; /*还没恢复的timeout个数*/  
</span><span class='line'>&#9;__u8 icsk_pending; /* 等待的定时器事件*/  
</span><span class='line'>&#9;...  
</span><span class='line'>&#9;struct {  
</span><span class='line'>&#9;   ...  
</span><span class='line'>&#9;&#9;__u8 pending; /* ACK is pending */  
</span><span class='line'>&#9;&#9;unsigned long timeout; /* Currently scheduled timeout */  
</span><span class='line'>&#9;&#9;...  
</span><span class='line'>&#9;} icsk_ack; /* Delayed ACK的控制模块*/  
</span><span class='line'>&#9;...  
</span><span class='line'>&#9;u32 icsk_ca_priv[16]; /*放置拥塞控制算法的参数*/  
</span><span class='line'>&#9;...  
</span><span class='line'>#define ICSK_CA_PRIV_SIZE (16*sizeof(u32))  
</span><span class='line'>}  
</span><span class='line'>   
</span><span class='line'>#define ICSK_TIME_RETRANS 1 /* Retransmit timer */  
</span><span class='line'>#define ICSK_TIME_DACK 2 /* Delayed ack timer */  
</span><span class='line'>#define ICSK_TIME_PROBE0 3 /* Zero window probe timer */  
</span><span class='line'>  
</span><span class='line'>/* 
</span><span class='line'> * Reset the retransmissiion timer 
</span><span class='line'> */  
</span><span class='line'>static inline void inet_csk_reset_xmit_timer(struct sock *sk, const int what,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;unsigned long when,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;const unsigned long max_when)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>  
</span><span class='line'>&#9;if (when &gt; max_when) {  
</span><span class='line'>#ifdef INET_CSK_DEBUG  
</span><span class='line'>&#9;&#9;pr_debug("reset_xmit_timer: sk=%p %d when=0x%lx, caller=%p\n",  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;sk, what, when, current_text_addr());  
</span><span class='line'>#endif  
</span><span class='line'>&#9;&#9;when = max_when;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;if (what == ICSK_TIME_RETRANS || what == ICSK_TIME_PROBE0) {  
</span><span class='line'>&#9;&#9;icsk-&gt;icsk_pending = what;  
</span><span class='line'>&#9;&#9;icsk-&gt;icsk_timeout = jiffies + when; /*数据包超时时刻*/  
</span><span class='line'>&#9;&#9;sk_reset_timer(sk, &icsk-&gt;icsk_retransmit_timer, icsk-&gt;icsk_timeout);  
</span><span class='line'>&#9;} else if (what == ICSK_TIME_DACK) {  
</span><span class='line'>&#9;&#9;icsk-&gt;icsk_ack.pending |= ICSK_ACK_TIMER;  
</span><span class='line'>&#9;&#9;icsk-&gt;icsk_ack.timeout = jiffies + when; /*Delay ACK定时器超时时刻*/  
</span><span class='line'>&#9;&#9;sk_reset_timer(sk, &icsk-&gt;icsk_delack_timer, icsk-&gt;icsk_ack.timeout);  
</span><span class='line'>&#9;}  
</span><span class='line'>#ifdef INET_CSK_DEBUG  
</span><span class='line'>&#9;else {  
</span><span class='line'>&#9;&#9;pr_debug("%s", inet_csk_timer_bug_msg);  
</span><span class='line'>&#9;}    
</span><span class='line'>#endif       
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>添加LOST标志</h4>

<p>state C</p>

<p>Q: 我们发现有数据包丢失了，怎么知道要重传哪些数据包呢？<br/>
A: tcp_mark_head_lost()通过给丢失的数据包标志TCPCB_LOST，就可以表明哪些数据包需要重传。<br/>
如果通过SACK发现有段丢失，则需要从重传队首或上次标志丢失段的位置开始，为记分牌为0的段添加LOST标志，直到所有被标志LOST的段数达到packets或者被标志序号超过high_seq为止。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Mark head of queue up as lost. With RFC3517 SACK, the packets is against sakced cnt, 
</span><span class='line'> * otherwise it's against fakced cnt. 
</span><span class='line'> * packets = fackets_out - reordering，表示sacked_out和lost_out的总和。 
</span><span class='line'> * 所以，被标志为LOST的段数不能超过packets。 
</span><span class='line'> * high_seq : 可以标志为LOST的段序号的最大值。 
</span><span class='line'> * mark_head: 为1表示只需要标志发送队列的第一个段。 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>static void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;struct sk_buff *skb;  
</span><span class='line'>&#9;int cnt, oldcnt;  
</span><span class='line'>&#9;int err;  
</span><span class='line'>&#9;unsigned int mss;  
</span><span class='line'>  
</span><span class='line'>&#9;/* 被标志为丢失的段不能超过发送出去的数据段数*/  
</span><span class='line'>&#9;WARN_ON(packets &gt; tp-&gt;packets_out);  
</span><span class='line'>  
</span><span class='line'>&#9;/* 如果已经有标识为丢失的段了*/  
</span><span class='line'>&#9;if (tp-&gt;lost_skb_hint) {  
</span><span class='line'>&#9;&#9;skb = tp-&gt;lost_skb_hint; /* 下一个要标志的段 */  
</span><span class='line'>&#9;&#9;cnt = tp-&gt;lost_cnt_hint; /* 已经标志了多少段 */  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* Head already handled? 如果发送队列第一个数据包已经标志了，则返回 */  
</span><span class='line'>&#9;&#9;if (mark_head && skb != tcp_write_queue_head(sk))  
</span><span class='line'>&#9;&#9;&#9;return;  
</span><span class='line'>  
</span><span class='line'>&#9;} else {  
</span><span class='line'>&#9;&#9;skb = tcp_write_queue_head(sk);  
</span><span class='line'>&#9;&#9;cnt = 0;  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;tcp_for_write_queue_from(skb, sk) {  
</span><span class='line'>&#9;&#9;if (skb == tcp_send_head(sk))  
</span><span class='line'>&#9;&#9;&#9;break; /* 如果遍历到snd_nxt，则停止*/  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* 更新丢失队列信息*/  
</span><span class='line'>&#9;&#9;tp-&gt;lost_skb_hint = skb;  
</span><span class='line'>&#9;&#9;tp-&gt;lost_cnt_hint = cnt ;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* 标志为LOST的段序号不能超过high_seq */  
</span><span class='line'>&#9;&#9;if (after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;high_seq))  
</span><span class='line'>&#9;&#9;&#9;break;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;oldcnt = cnt;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;if (tcp_is_fack(tp) || tcp_is_reno(tp) ||   
</span><span class='line'>&#9;&#9;&#9;(TCP_SKB_CB(skb)-&gt;sacked & TCPCB_SACKED_ACKED))  
</span><span class='line'>&#9;&#9;&#9;cnt += tcp_skb_pcount(skb); /* 此段已经被sacked */  
</span><span class='line'>&#9;&#9;&#9;&#9; 
</span><span class='line'>&#9;&#9;/* 主要用于判断退出时机 */  
</span><span class='line'>&#9;&#9;if (cnt &gt; packets) {  
</span><span class='line'>&#9;&#9;&#9;if ((tcp_is_sack(tp) && !tcp_is_fack(tp) ||   
</span><span class='line'>&#9;&#9;&#9;&#9;(TCP_SKB_CB(skb)-&gt;sacked & TCPCB_SACKED_ACKED) ||  
</span><span class='line'>&#9;&#9;&#9;&#9;(oldcnt &gt;= pakcets))  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;&#9;&#9;break;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;&#9; mss = skb_shinfo(skb)-&gt;gso_size;  
</span><span class='line'>&#9;&#9;&#9; err = tcp_fragment(sk, skb, (packets - oldcnt) * mss, mss);  
</span><span class='line'>&#9;&#9;&#9; if (err &lt; 0)  
</span><span class='line'>&#9;&#9;&#9;&#9; break;  
</span><span class='line'>&#9;&#9;&#9; cnt = packets;  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* 标志动作：标志一个段为LOST*/  
</span><span class='line'>&#9;&#9;tcp_skb_mark_lost(tp, skb);  
</span><span class='line'>&#9;&#9;if (mark_head)  
</span><span class='line'>&#9;&#9;&#9;break;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;tcp_verify_left_out(tp);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>涉及变量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_sock {  
</span><span class='line'>&#9;/* 在重传队列中，缓存下次要标志的段，为了加速对重传队列的标志操作 */  
</span><span class='line'>&#9;struct sk_buff *lost_skb_hint; /* 下一次要标志的段 */  
</span><span class='line'>&#9;int lost_cnt_hint; /* 已经标志了多少个段 */  
</span><span class='line'>  
</span><span class='line'>&#9;struct sk_buff *retransmit_skb_hint; /* 表示将要重传的起始包*/  
</span><span class='line'>&#9;u32 retransmit_high; /*重传队列的最大序列号*/  
</span><span class='line'>&#9;struct sk_buff *scoreboard_skb_hint; /* 记录超时的数据包，序号最大*/  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>TCP分片函数tcp_fragment</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Function to create two new TCP segments. shrinks the given segment 
</span><span class='line'> * to the specified size and appends a new segment with the rest of the 
</span><span class='line'> * packet to the list. This won't be called frequently, I hope. 
</span><span class='line'> * Remember, these are still headerless SKBs at this point. 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>int tcp_fragment (struct sock *sk, struct sk_buff *skb, u32 len,  
</span><span class='line'>&#9;&#9;&#9;&#9;unsigned int mss_now) {}  </span></code></pre></td></tr></table></div></figure>


<p>给一个段添加一个LOST标志</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_skb_mark_lost(struct tcp_sock *tp, struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>&#9;if (! (TCP_SKB_CB(skb)-&gt;sacked & (TCPCB_LOST | TCPCB_SACKED_ACKED))) {  
</span><span class='line'>&#9;&#9;tcp_verify_retransmit_hint(tp, skb); /* 更新重传队列*/  
</span><span class='line'>&#9;&#9;tp-&gt;lost_out += tcp_skb_pcount(skb); /*增加LOST的段数*/  
</span><span class='line'>&#9;&#9;TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST; /* 添加LOST标志*/  
</span><span class='line'>&#9;}  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>/* This must be called before lost_out is incremented */  
</span><span class='line'>static void tcp_verify_retransmit_hint(struct tcp_sock *tp, struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>&#9;if ((tp-&gt;retransmit_skb_hint == NULL) ||  
</span><span class='line'>&#9;&#9; before(TCP_SKB_CB(skb)-&gt;seq,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;   TCP_SKB_CB(tp-&gt;retransmit_skb_hint)-&gt;seq))  
</span><span class='line'>&#9;tp-&gt;retransmit_skb_hint = skb;   
</span><span class='line'>   
</span><span class='line'>&#9;if (! tp-&gt;lost_out ||  
</span><span class='line'>&#9;&#9;after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;retransmit_high))  
</span><span class='line'>&#9;&#9;tp-&gt;retransmit_high = TCP_SKB_CB(skb)-&gt;end_seq;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>TCP拥塞状态机的实现（下）</h3>

<p>内容：本文主要分析TCP拥塞状态机的实现中，各个拥塞状态的进入、处理和退出的详细过程。<br/>
内核版本：2.6.37</p>

<h4>各状态的退出</h4>

<p>state E</p>

<p>各状态的退出时机：tp->snd_una >= tp->high_seq</p>

<h5>（1） Open</h5>

<p>因为Open态是正常态，所以无所谓退出，保持原样。</p>

<h5>（2）Loss</h5>

<p>icsk->icsk_retransmits = 0; /<em>超时重传次数归0</em>/<br/>
tcp_try_undo_recovery(sk);</p>

<p>检查是否需要undo，不管undo成功与否，都返回Open态。</p>

<h5>（3）CWR</h5>

<p>If seq number greater than high_seq is acked, it indicates that the CWR indication has reached the peer TCP, call tcp_complete_cwr() to bring down the cwnd to ssthresh value.</p>

<p>tcp_complete_cwr(sk)中：<br/>
tp->snd_cwnd = min(tp->snd_cwnd, tp->snd_ssthresh);</p>

<h5>（4）Disorder</h5>

<p>启用sack，则tcp_try_undo_dsack(sk)，交给它处理。否则，tp->undo_marker = 0;</p>

<h5>（5）Recovery</h5>

<p>tcp_try_undo_recovery(sk);<br/>
在tcp_complete_cwr(sk)中：<br/>
tp->snd_cwnd = tp->snd_ssthresh;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*cwr状态或Recovery状态结束时调用，减小cwnd*/   
</span><span class='line'>  
</span><span class='line'>static inline void tcp_complete_cwr(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh);  
</span><span class='line'>&#9;tp-&gt;snd_cwnd_stamp = tcp_time_stamp;  
</span><span class='line'>&#9;tcp_ca_event(sk, CA_EVENT_COMPLETE_CWR);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Recovery状态处理</h4>

<p>state F</p>

<h5>（1）收到dupack</h5>

<p>如果收到的ACK并没有使snd_una前进、是重复的ACK，并且没有使用SACK，则：<br/>
    sacked_out++，增加sacked数据包的个数。<br/>
    检查是否有reordering，如果有reordering则：<br/>
        纠正sacked_out<br/>
        禁用FACK(画外音：这实际上是多此一举，没有使用SACK，哪来的FACK？)<br/>
        更新tp->reordering</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Emulate SACKs for SACKless connection: account for a new dupack.*/  
</span><span class='line'>static void tcp_add_reno_sack(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;tp-&gt;sacked_out++; /* 增加sacked数据包个数*/  
</span><span class='line'>&#9;tcp_check_reno_reordering(sk, 0); /*检查是否有reordering*/  
</span><span class='line'>&#9;tcp_verify_left_out(tp);  
</span><span class='line'>}  
</span><span class='line'>   
</span><span class='line'>/* If we receive more dupacks than we expected counting segments in  
</span><span class='line'> * assumption of absent reordering, interpret this as reordering. 
</span><span class='line'> * The only another reason could be bug in receiver TCP. 
</span><span class='line'> * tcp_limit_reno_sack()是判断是否有reordering的函数。 
</span><span class='line'> */  
</span><span class='line'>static void tcp_check_reno_reordering(struct sock *sk, const int addend)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;if (tcp_limit_reno_sack(tp)) /* 检查sack是否过多*/  
</span><span class='line'>&#9;&#9;/* 如果是reordering则更新reordering信息*/  
</span><span class='line'>&#9;&#9;tcp_update_reordering(sk, tp-&gt;packets_out + addend, 0);  
</span><span class='line'>}  
</span><span class='line'>   
</span><span class='line'>/* Limit sacked_out so that sum with lost_out isn't ever larger than packets_out. 
</span><span class='line'> * Returns zero if sacked_out adjustment wasn't necessary. 
</span><span class='line'> * 检查sacked_out是否过多，过多则限制，且返回1说明出现reordering了。 
</span><span class='line'> * Q: 怎么判断是否有reordering呢？ 
</span><span class='line'> * A: 我们知道dupack可能由lost引起，也有可能由reorder引起，那么如果 
</span><span class='line'> *    sacked_out + lost_out &gt; packets_out，则说明sacked_out偏大了，因为它错误的把由reorder 
</span><span class='line'> *    引起的dupack当客户端的sack了。 
</span><span class='line'> */  
</span><span class='line'>static int tcp_limit_reno_sacked(struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;u32 holes;  
</span><span class='line'>&#9;holes = max(tp-&gt;lost_out, 1U);  
</span><span class='line'>&#9;holes = min(holes, tp-&gt;packets_out);  
</span><span class='line'>&#9;if ((tp-&gt;sacked_out + holes) &gt; tp-&gt;packets_out) {  
</span><span class='line'>&#9;&#9;tp-&gt;sacked_out = tp-&gt;packets_out - holes;  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;return 0;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>更新reordering信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_update_reordering(struct sock *sk, const int metric,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;const int ts)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>  
</span><span class='line'>&#9;if (metric &gt; tp-&gt;reordering) {  
</span><span class='line'>&#9;&#9;int mib_idx;  
</span><span class='line'>&#9;&#9;/* 更新reordering的值，取其小者*/  
</span><span class='line'>&#9;&#9;tp-&gt;reordering = min(TCP_MAX_REORDERING, metric);  
</span><span class='line'>&#9;&#9;  
</span><span class='line'>&#9;&#9;if (ts)  
</span><span class='line'>&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPTSREORDER;  
</span><span class='line'>&#9;&#9;else if (tcp_is_reno(tp))  
</span><span class='line'>&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPRENOREORDER;  
</span><span class='line'>&#9;&#9;else if (tcp_is_fack(tp))  
</span><span class='line'>&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPFACKREORDER;  
</span><span class='line'>&#9;&#9;else   
</span><span class='line'>&#9;&#9;&#9;mib_idx = LINUX_MIB_TCPSACKREORDER;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;NET_INC_STATS_BH(sock_net(sk), mib_idx);  
</span><span class='line'>#if FASTRETRANS_DEBUG &gt; 1  
</span><span class='line'>&#9;&#9;printk(KERN_DEBUG "Disorder%d %d %u f%u s%u rr%d\n",  
</span><span class='line'>&#9;&#9;&#9;&#9;   tp-&gt;rx_opt.sack_ok, inet_csk(sk)-&gt;icsk_ca_state,  
</span><span class='line'>&#9;&#9;&#9;&#9;   tp-&gt;reordering, tp-&gt;fackets_out, tp-&gt;sacked_out,  
</span><span class='line'>&#9;&#9;&#9;&#9;   tp-&gt;undo_marker ? tp-&gt;undo_retrans : 0);  
</span><span class='line'>#endif  
</span><span class='line'>&#9;&#9;tcp_disable_fack(tp); /* 出现了reorder，再用fack就太激进了*/  
</span><span class='line'>&#9;}  
</span><span class='line'>}  
</span><span class='line'>/* Packet counting of FACK is based on in-order assumptions, therefore 
</span><span class='line'> * TCP disables it when reordering is detected. 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>static void tcp_disable_fack(struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;/* RFC3517 uses different metric in lost marker =&gt; reset on change */  
</span><span class='line'>&#9;if (tcp_is_fack(tp))  
</span><span class='line'>&#9;&#9;tp-&gt;lost_skb_hint = NULL;  
</span><span class='line'>&#9;tp-&gt;rx_opt.sack_ok &= ~2; /* 取消FACK选项*/  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>（2）收到partical ack</h5>

<p>do_lost = tcp_try_undo_partical(sk, pkts_acked);<br/>
一般情况下do_lost都会为真，除非需要undo。<br/>
具体可以看前面blog《TCP拥塞窗口调整撤销剖析》。</p>

<h5>（3）跳出F state，标志丢失的数据段</h5>

<p>执行完(1)或(2)后，就跳出F state。<br/>
如果有丢失的数据包，或者发送队列的第一个数据包超时，则调用tcp_update_scoreboard()来更新记分牌，给丢失的段加TCPCB_LOST标志，增加lost_out。</p>

<p>检查发送队列的第一个数据包是否超时。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 检验发送队列的第一个数据包是否超时*/  
</span><span class='line'>static inline int tcp_head_timeout(const struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>&#9;const struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;return tp-&gt;packets_out &&   
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_skb_timeout(sk, tcp_write_queue_head(sk));  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>/* 检验发送队列的某个数据包是否超时*/  
</span><span class='line'>static inline int tcp_skb_timeout(const struct sock *sk,  
</span><span class='line'>&#9;&#9;&#9;&#9; const struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>&#9;return tcp_time_stamp - TCP_SKB_CB(skb)-&gt;when &gt; inet_csk(sk)-&gt;icsk_rto;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为确定丢失的段更新记分牌，记分牌指的是tcp_skb_cb结构中的sacked，保存该数据包的状态信息。<br/>
(1) 没有使用SACK，每次收到dupack或partical ack时，只能标志一个包为丢失。</p>

<p>(2) 使用FACK，每次收到dupack或partical ack时，分两种情况：<br/>
  如果lost = fackets_out - reordering &lt;= 0，这时虽然不能排除是由乱序引起的，但是fack的思想较为激进，所以也标志一个包为丢失。<br/>
  如果lost >0，就可以肯定有丢包，一次性可以标志lost个包为丢失。</p>

<p>(3) 使用SACK，但是没有使用FACK。<br/>
  如果sacked_upto = sacked_out - reordering，这是不能排除是由乱序引起的，除非快速重传标志fast_rexmit为真，才标志一个包为丢失。<br/>
  如果sacked_upto > 0，就可以肯定有丢包，一次性可以标志sacked_upto个包为丢失。</p>

<p>内核默认使用的是(2)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Account newly detected lost packet(s) */  
</span><span class='line'>  
</span><span class='line'> static void tcp_update_scoreboard (struct sock *sk, int fast_rexmit)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;if (tcp_is_reno(tp)) {  
</span><span class='line'>&#9;&#9;/* 只标志第一个数据包为丢失，reno一次性只标志一个包*/  
</span><span class='line'>&#9;&#9;tcp_mark_head_lost(sk, 1, 1);  
</span><span class='line'>  
</span><span class='line'>&#9;} else if (tcp_is_fack(tp)) {  
</span><span class='line'>&#9;&#9;/* 还是考虑到乱序的，对于可能是由乱序引起的部分，一次标志一个包*/  
</span><span class='line'>&#9;&#9;int lost = tp-&gt;fackets_out - tp-&gt;reordering;  
</span><span class='line'>&#9;&#9;if (lost &lt;= 0)  
</span><span class='line'>&#9;&#9;&#9;lost = 1;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* 因为使用了FACK，可以标志多个数据包丢失*/  
</span><span class='line'>&#9;&#9;tcp_mark_head_lost(sk, lost, 0);  
</span><span class='line'>  
</span><span class='line'>&#9;} else {  
</span><span class='line'>&#9;&#9;int sacked_upto = tp-&gt;sacked_out - tp-&gt;reordering;  
</span><span class='line'>&#9;&#9;if (sacked_upto &gt;= 0)  
</span><span class='line'>&#9;&#9;&#9;tcp_mark_head_lost(sk, sacked_upto, 0);  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;else if (fast_rexmit)  
</span><span class='line'>&#9;&#9;&#9;tcp_mark_head_lost(sk, 1, 1);  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;/* 检查发送队列中的数据包是否超时，如果超时则标志为丢失*/  
</span><span class='line'>&#9;tcp_timeout_skbs(sk);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>检查发送队列中哪些数据包超时，并标志为丢失</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_timeout_skbs(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;struct sk_buff *skb;  
</span><span class='line'>  
</span><span class='line'>&#9;if (! tcp_is_fack(tp) || !tcp_head_timeout(sk))  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>  
</span><span class='line'>&#9;skb = tp-&gt;scoreboard_skb_hint;  
</span><span class='line'>  
</span><span class='line'>&#9;if (tp-&gt;scoreboard_skb_hint == NULL)  
</span><span class='line'>&#9;&#9;skb = tcp_write_queue_head(sk));  
</span><span class='line'>  
</span><span class='line'>&#9;tcp_for_write_queue_from(skb, sk) {  
</span><span class='line'>&#9;&#9;if (skb == tcp_send_head(sk)) /*遇到snd_nxt则停止*/  
</span><span class='line'>&#9;&#9;&#9;break;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;if (!tcp_skb_timeout(sk, skb)) /* 数据包不超时则停止*/  
</span><span class='line'>&#9;&#9;&#9;break;  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;tcp_skb_mark_lost(tp, skb); /* 标志为LOST，并增加lost_out */  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;tp-&gt;scoreboard_skb_hint = skb;  
</span><span class='line'>&#9;tcp_verify_left_out(tp);  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>（4）减小snd_cwnd</h5>

<p>拥塞窗口每隔一个确认段减小一个段，即每收到2个确认将拥塞窗口减1，直到拥塞窗口等于慢启动阈值为止。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Decrease cwnd each second ack. */  
</span><span class='line'>static void tcp_cwnd_down (struct sock *sk, int flag)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;int decr = tp-&gt;snd_cwnd_cnt + 1;  
</span><span class='line'>  
</span><span class='line'>&#9;if ((flag & (FLAG_ANY_PROGRESS | FLAG_DSACKING_ACK )) ||  
</span><span class='line'>&#9;&#9;(tcp_is_reno(tp) && ! (flag & FLAG_NOT_DUP))) {  
</span><span class='line'>&#9;&#9;tp-&gt;snd_cwnd_cnt = decr & 1; /* 0=&gt;1,1=&gt;0 */  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;decr &gt;&gt;= 1; /*与上个snd_cwnd_cnt相同，0或1*/  
</span><span class='line'>  
</span><span class='line'>&#9;&#9;/* 减小cwnd */  
</span><span class='line'>&#9;&#9;if (decr && tp-&gt;snd_cwnd &gt; tcp_cwnd_min(sk))  
</span><span class='line'>&#9;&#9;&#9;tp-&gt;snd_cwnd -= decr;  
</span><span class='line'>&#9;&#9;&#9;  
</span><span class='line'>&#9;&#9;/* 注：不太理解这句的用意。*/  
</span><span class='line'>&#9;&#9;tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd, tcp_packets_in_flight(tp) +1);  
</span><span class='line'>&#9;&#9;tp-&gt;snd_cwnd_stamp = tcp_time_stamp;  
</span><span class='line'>&#9;}  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>/* Lower bound on congestion window is slow start threshold 
</span><span class='line'> * unless congestion avoidance choice decides to override it. 
</span><span class='line'> */  
</span><span class='line'>static inline u32 tcp_cwnd_min(const struct sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;const struct tcp_congestion_ops *ca_ops = inet_csk(sk)-&gt;icsk_ca_ops;  
</span><span class='line'>&#9;return ca_ops-&gt;min_cwnd ? ca_ops-&gt;min_cwnd(sk) : tcp_sk(sk)-&gt;snd_ssthresh;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>（5）重传标志为丢失的段</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* This gets called after a retransmit timeout, and the initially retransmitted data is  
</span><span class='line'> * acknowledged. It tries to continue resending the rest of the retransmit queue, until  
</span><span class='line'> * either we've sent it all or the congestion window limit is reached. If doing SACK,  
</span><span class='line'> * the first ACK which comes back for a timeout based retransmit packet might feed us  
</span><span class='line'> * FACK information again. If so, we use it to avoid unnecessarily retransmissions. 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>void tcp_xmit_retransmit_queue (struct sock *sk) {}</span></code></pre></td></tr></table></div></figure>


<p>这个函数决定着发送哪些包，比较复杂，会在之后的blog单独分析。</p>

<h5>（6）什么时候进入Recovery状态</h5>

<p>tcp_time_to_recover()是一个重要函数，决定什么时候进入Recovery状态。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* This function decides, when we should leave Disordered state and enter Recovery 
</span><span class='line'> * phase, reducing congestion window. 
</span><span class='line'> * 决定什么时候离开Disorder状态，进入Recovery状态。 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>static int tcp_time_to_recover(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;__u32 packets_out;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Do not perform any recovery during F-RTO algorithm 
</span><span class='line'>&#9; * 这说明Recovery状态不能打断Loss状态。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (tp-&gt;frto_counter)  
</span><span class='line'>&#9;&#9;return 0;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Trick#1: The loss is proven.  
</span><span class='line'>&#9; * 如果传输过程中存在丢失段，则可以进入Recovery状态。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (tp-&gt;lost_out)  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>   
</span><span class='line'>&#9;/* Not-A-Trick#2 : Classic rule... 
</span><span class='line'>&#9; * 如果收到重复的ACK大于乱序的阈值，表示有数据包丢失了， 
</span><span class='line'>&#9; * 可以进入到Recovery状态。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (tcp_dupack_heuristics(tp) &gt; tp-&gt;reordering)  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>   
</span><span class='line'>&#9;/* Trick#3 : when we use RFC2988 timer restart, fast 
</span><span class='line'>&#9; * retransmit can be triggered by timeout of queue head. 
</span><span class='line'>&#9; * 如果发送队列的第一个数据包超时，则进入Recovery状态。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;  if (tcp_is_fack(tp) && tcp_head_timeout(sk))  
</span><span class='line'>&#9;&#9; return 1;  
</span><span class='line'>  
</span><span class='line'>&#9;/* Trick#4 : It is still not OK... But will it be useful to delay recovery more? 
</span><span class='line'>&#9; * 如果此时由于应用程序或接收窗口的限制而不能发包，且接收到很多的重复ACK。那么不能再等下去了， 
</span><span class='line'>&#9; * 推测发生了丢包，且马上进入Recovery状态。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (packets_out &lt;= tp-&gt;reordering &&  
</span><span class='line'>&#9;&#9;tp-&gt;sacked_out &gt;= max_t(__u32, packets_out/2, sysctl_tcp_reordering)  
</span><span class='line'>&#9;&#9;&& ! tcp_may_send_now(sk)  ) {  
</span><span class='line'>&#9;&#9;/* We have nothing to send. This connection is limited 
</span><span class='line'>&#9;&#9; * either by receiver window or by application. 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>&#9;}  
</span><span class='line'>  
</span><span class='line'>&#9;/* If a thin stream is detected, retransmit after first received 
</span><span class='line'>&#9; * dupack. Employ only if SACK is supported in order to avoid  
</span><span class='line'>&#9; * possible corner-case series of spurious retransmissions 
</span><span class='line'>&#9; * Use only if there are no unsent data. 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if ((tp-&gt;thin_dupack || sysctl_tcp_thin_dupack) &&  
</span><span class='line'>&#9;&#9; tcp_stream_is_thin(tp) && tcp_dupack_heuristics(tp) &gt; 1 &&  
</span><span class='line'>&#9;&#9; tcp_is_sack(tp) && ! tcp_send_head(sk))  
</span><span class='line'>&#9;&#9; return 1;  
</span><span class='line'>  
</span><span class='line'>&#9;return 0; /*表示为假*/  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Heurestics to calculate number of duplicate ACKs. There's no  
</span><span class='line'> * dupACKs counter when SACK is enabled (without SACK, sacked_out 
</span><span class='line'> * is used for that purpose). 
</span><span class='line'> * Instead, with FACK TCP uses fackets_out that includes both SACKed 
</span><span class='line'> * segments up to the highest received SACK block so far and holes in 
</span><span class='line'> * between them. 
</span><span class='line'> * 
</span><span class='line'> * With reordering, holes may still be in filght, so RFC3517 recovery uses 
</span><span class='line'> * pure sacked_out (total number of SACKed segment) even though it 
</span><span class='line'> * violates the RFC that uses duplicate ACKs, often these are equal but 
</span><span class='line'> * when e.g. out-of-window ACKs or packet duplication occurs, they differ. 
</span><span class='line'> * Since neither occurs due to loss, TCP shuld really ignore them. 
</span><span class='line'> */  
</span><span class='line'>static inline int tcp_dupack_heuristics(const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;return tcp_is_fack(tp) ? tp-&gt;fackets_out : tp-&gt;sacked_out + 1;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>/* Determines whether this is a thin stream (which may suffer from increased 
</span><span class='line'> * latency). Used to trigger latency-reducing mechanisms. 
</span><span class='line'> */  
</span><span class='line'>static inline unsigned int tcp_stream_is_thin(struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;return tp-&gt;packets_out &lt; 4 && ! tcp_in_initial_slowstart(tp);  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>#define TCP_INFINITE_SSTHRESH 0x7fffffff  
</span><span class='line'>  
</span><span class='line'>static inline bool tcp_in_initial_slowstart(const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>&#9;return tp-&gt;snd_ssthresh &gt;= TCP_INFINITE_SSTHRESH;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>This function examines various parameters (like number of packet lost) for TCP connection to decide whether it is the right time to move to Recovery state. It&rsquo;s time to recover when TCP heuristics suggest a strong possibility of packet loss in the network, the following checks are made.</p>

<p>总的来说，一旦确定有丢包，或者很可能丢包，就可以进入Recovery状态恢复丢包了。</p>

<p>可以进入Recovery状态的条件包括：<br/>
(1) some packets are lost (lost_out is non zero)。发现有丢包。</p>

<p>(2) SACK is an acknowledgement for out of order packets. If number of packets Sacked is greater than the<br/>
  reordering metrics of the network, then loss is assumed to have happened.<br/>
  被fack数据或收到的重复ACK，大于乱序的阈值，表明很可能发生丢包。</p>

<p>(3) If the first packet waiting to be acked (head of the write Queue) has waited for time equivalent to retransmission<br/>
  timeout, the packet is assumed to have been lost. 发送队列的第一个数据段超时，表明它可能丢失了。</p>

<p>(4) If the following three conditions are true, TCP sender is in a state where no more data can be transmitted<br/>
  and number of packets acked is big enough to assume that rest of the packets are lost in the network:<br/>
  A: If packets in flight is less than the reordering metrics.<br/>
  B: More than half of the packets in flight have been sacked by the receiver or number of packets sacked is more<br/>
   than the Fast Retransmit thresh. (Fast Retransmit thresh is the number of dupacks that sender awaits before<br/>
   fast retransmission)<br/>
  C: The sender can not send any more packets because either it is bound by the sliding window or the application<br/>
   has not delivered any more data to it in anticipation of ACK for already provided data.<br/>
  我们收到很多的重复ACK，那么很可能有数据段丢失了。如果此时由于接收窗口或应用程序的限制而不能发送数据，那么我们不打算再等下去，直接进入Recovery状态。</p>

<p>(5) 当检测到当前流量很小时（packets_out &lt; 4），如果还满足以下条件：<br/>
  A: tp->thin_dupack == 1 /<em> Fast retransmit on first dupack </em>/<br/>
   或者sysctl_tcp_thin_dupack为1，表明允许在收到第一个重复的包时就重传。<br/>
  B: 启用SACK，且FACK或SACK的数据量大于1。<br/>
  C: 没有未发送的数据，tcp_send_head(sk) == NULL。<br/>
   这是一种特殊的情况，只有当流量非常小的时候才采用。</p>

<p>（7）刚进入Recovery时的设置<br/>
保存那些用于undo的数据：<br/>
tp->prior_ssthresh = tp->snd_ssthresh; /<em> 保存旧阈值</em>/<br/>
tp->undo_marker = tp->snd_una; /<em> tracking retrans started here.</em>/<br/>
tp->undo_retrans = tp->retrans_out; /<em> Retransmitted packets out </em>/</p>

<p>保存退出点：<br/>
tp->high_seq = tp->snd_nxt;</p>

<p>重置变量：<br/>
tp->snd_ssthresh = icsk->icsk_ca_ops->ssthresh(sk);<br/>
tp->bytes_acked = 0;<br/>
tp->snd_cwnd_cnt = 0;</p>

<p>进入Recovery状态：<br/>
tcp_set_ca_state(sk, TCP_CA_Recovery);</p>

<h4>Loss状态处理</h4>

<p>state F</p>

<h5>（1）收到partical ack</h5>

<p>icsk->icsk_retransmits = 0; /<em> 超时重传的次数归零</em>/<br/>
如果使用的是reno，没有使用sack，则归零tp->sacked_out。</p>

<h5>（2）尝试undo</h5>

<p>调用tcp_try_undo_loss()，当使用时间戳检测到一个不必要的重传时：<br/>
  移除记分牌中所有段的Loss标志，从而发送新的数据而不再重传。<br/>
  调用tcp_undo_cwr()来撤销拥塞窗口和阈值的调整。</p>

<p>否则：<br/>
  tcp_moderate_cwnd()调整拥塞窗口，防止爆发式重传。<br/>
  tcp_xmit_retransmit_queue()继续重传丢失的数据段。</p>

<h4>其它状态处理</h4>

<p>state F</p>

<p>如果tcp_time_to_recover(sk)返回值为假，也就是说不能进入Recovery状态，则进行CWR、Disorder或Open状态的处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_try_to_open (struct sock *sk, int flag)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;tcp_verify_left_out(tp);  
</span><span class='line'>  
</span><span class='line'>&#9;if (!tp-&gt;frto_conter && !tcp_any_retrans_done(sk))  
</span><span class='line'>&#9;&#9;tp-&gt;retrans_stamp = 0; /* 归零，因为不需要undo了*/  
</span><span class='line'>  
</span><span class='line'>&#9;/* 判断是否需要进入CWR状态*/  
</span><span class='line'>&#9;if (flag & FLAG_ECE)  
</span><span class='line'>&#9;&#9;tcp_enter_cwr(sk, 1);  
</span><span class='line'>   
</span><span class='line'>&#9;if (inet_csk(sk)-&gt;icsk_ca_state != TCP_CA_CWR) { /*没进入CWR*/  
</span><span class='line'>&#9;&#9;tcp_try_keep_open(sk); /* 尝试保持Open状态*/  
</span><span class='line'>&#9;&#9;tcp_moderate_cwnd(tp);  
</span><span class='line'>  
</span><span class='line'>&#9;} else { /* 说明进入CWR状态*/  
</span><span class='line'>&#9;&#9;tcp_cwnd_down(sk, flag);/* 每2个ACK减小cwnd*/  
</span><span class='line'>&#9;}  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>static void tcp_try_keep_open(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>&#9;int state = TCP_CA_Open;  
</span><span class='line'>&#9;  
</span><span class='line'>&#9;/* 是否需要进入Disorder状态*/  
</span><span class='line'>&#9;if (tcp_left_out(tp) || tcp_any_retrans_done(sk) || tp-&gt;undo_marker)  
</span><span class='line'>&#9;&#9;state = TCP_CA_Disorder;  
</span><span class='line'>  
</span><span class='line'>&#9;if (inet_csk(sk)-&gt;icsk_ca_state != state) {  
</span><span class='line'>&#9;&#9;tcp_set_ca_state(sk, state);  
</span><span class='line'>&#9;&#9;tp-&gt;high_seq = tp-&gt;snd_nxt;  
</span><span class='line'>&#9;}  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>（1）CWR状态</h5>

<p>Q: 什么时候进入CWR状态？<br/>
A: 如果检测到ACK包含ECE标志，表示接收方通知发送法进行显示拥塞控制。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> @tcp_try_to_open():
</span><span class='line'> if (flag & FLAG_ECE)
</span><span class='line'>&#9; tcp_enter_cwr(sk, 1);</span></code></pre></td></tr></table></div></figure>


<p>tcp_enter_cwr()函数分析可见前面blog《TCP拥塞状态变迁》。<br/>
它主要做了：<br/>
  1. 重新设置慢启动阈值。<br/>
  2. 清除undo需要的标志，不允许undo。<br/>
  3. 记录此时的最高序号(high_seq = snd_nxt)，用于判断退出时机。<br/>
  4. 添加CWR标志，用于通知接收方它已经做出反应。<br/>
  5. 设置此时的状态为TCP_CA_CWR。</p>

<p>Q: 在CWR期间采取什么措施？<br/>
A: 拥塞窗口每隔一个确认段减小一个段，即每收到2个确认将拥塞窗口减1，直到拥塞窗口等于慢启动阈值为止。<br/>
   调用tcp_cwnd_down()。</p>

<h5>（2）Disorder状态</h5>

<p>Q: 什么时候进入Disorder状态？<br/>
A: 如果检测到有被sacked的数据包，或者有重传的数据包，则进入Disorder状态。<br/>
  当然，之前已经确认不能进入Loss或Recovery状态了。<br/>
  判断条件： sacked_out、lost_out、retrans_out、undo_marker不为0。</p>

<p>Q: 在Disorder期间采取什么措施？<br/>
A: 1. 设置CA状态为TCP_CA_Disorder。<br/>
   2. 记录此时的最高序号(high_seq = snd_nxt)，用于判断退出时机。<br/>
   3. 微调拥塞窗口，防止爆发式传输。</p>

<p>In Disorder state TCP is still unsure of genuiness of loss, after receiving acks with sack there may be a clearing ack which acks many packets non dubiously in one go. Such a clearing ack may cause a packet burst in the network, to avoid this cwnd size is reduced to allow no more than max_burst (usually 3) number of packets.</p>

<h5>（3）Open状态</h5>

<p>因为Open状态是正常的状态，是状态处理的最终目的，所以不需要进行额外处理。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-03-23T14:03:00+08:00'><span class='date'>2015-03-23</span> <span class='time'>14:03:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~net/'>net</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/03/23/kernel-net-rmem/" title="Previous Post: TCP接收缓存大小的动态调整">&laquo; TCP接收缓存大小的动态调整</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/03/23/kernel-net-frto/" title="Next Post: FRTO—虚假超时剖析">FRTO—虚假超时剖析 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
