
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>CC_STACKPROTECTOR防内核堆栈溢出补丁分析 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>date [-d @int|str] [+%s|"+%F %T"]</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">CC_STACKPROTECTOR防内核堆栈溢出补丁分析</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-17T16:01:00+08:00'><span class='date'>2015-11-17</span> <span class='time'>16:01:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.aliyun.com/1126">http://blog.aliyun.com/1126</a></p>

<p>内核堆栈溢出通常有两种情况。一种是函数调用栈超出了内核栈THREAD_SIZE的大小， 这是栈底越界，另一种是栈上缓冲越界访问，这是栈顶越界。</p>

<h4>检测栈底越界</h4>

<p>以arm平台为例，内核栈THREAD_SIZE为8K,当调用栈层次过多或某调用栈上分配过大的 空间，就会导致它越界。越界后struct thread_info结构可能被破坏，轻则内核 panic，重则内核数据被覆盖仍继续运行。</p>

<h4>检测栈顶越界</h4>

<p>对于栈顶越界，gcc提供了支持。打开内核配置CONFIG_CC_STACKPROTECTOR后，会打 开编译选项-fstack-protector.</p>

<hr />

<p>  CC_STACKPROTECT补丁是Tejun Heo在09年给主线kernel提交的一个用来防止内核堆栈溢出的补丁。默认的config是将这个选项关闭的，可以在编译内核的时候， 修改.config文件为CONFIG_CC_STACKPROTECTOR=y来启用。未来飞天内核可以将这个选项开启来防止利用内核stack溢出的0day攻击。这个补丁的防溢出原理是： 在进程启动的时候， 在每个buffer的后面放置一个预先设置好的stack canary，你可以把它理解成一个哨兵， 当buffer发生缓冲区溢出的时候， 肯定会破坏stack canary的值， 当stack canary的值被破坏的时候， 内核就会直接当机。那么是怎么判断stack canary被覆盖了呢？ 其实这个事情是gcc来做的，内核在编译的时候给gcc加了个-fstack-protector参数， 我们先来研究下这个参数是做什么用的。</p>

<p>先写个简单的有溢出的程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[wzt@localhost csaw]$ cat test.c
</span><span class='line'>
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>void test(void)
</span><span class='line'>{
</span><span class='line'>&#9;char buff[64];
</span><span class='line'>
</span><span class='line'>&#9;memset(buff, 0x41, 128);     //向64大小的buffer拷贝128字节， 肯定会发生缓冲区溢出。
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(void)
</span><span class='line'>{
</span><span class='line'>&#9;test();
</span><span class='line'>
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[wzt@localhost csaw]$ gcc -o test test.c
</span><span class='line'>[wzt@localhost csaw]$ ./test
</span><span class='line'>段错误</span></code></pre></td></tr></table></div></figure>


<p>反汇编看看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[wzt@localhost csaw]$ objdump -d test &gt; hex
</span><span class='line'>
</span><span class='line'>08048384 &lt;test&gt;:
</span><span class='line'> 8048384:       55                      push   %ebp
</span><span class='line'> 8048385:       89 e5                   mov    %esp,%ebp
</span><span class='line'> 8048387:       83 ec 58                sub    $0x58,%esp
</span><span class='line'> 804838a:       c7 44 24 08 80 00 00    movl   $0x80,0x8(%esp)
</span><span class='line'> 8048391:       00
</span><span class='line'> 8048392:       c7 44 24 04 41 00 00    movl   $0x41,0x4(%esp)
</span><span class='line'> 8048399:       00
</span><span class='line'> 804839a:       8d 45 c0                lea    0xffffffc0(%ebp),%eax
</span><span class='line'> 804839d:       89 04 24                mov    %eax,(%esp)
</span><span class='line'> 80483a0:       e8 e3 fe ff ff          call   8048288 &lt;memset@plt&gt;
</span><span class='line'> 80483a5:       c9                      leave
</span><span class='line'> 80483a6:       c3                      ret</span></code></pre></td></tr></table></div></figure>


<p>没什么特别的，我们在加上-fstack-protector参数看看：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[wzt@localhost csaw]$ gcc -o test test.c -fstack-protector
</span><span class='line'>[wzt@localhost csaw]$ ./test
</span><span class='line'>*** stack smashing detected ***: ./test terminated
</span><span class='line'>已放弃</span></code></pre></td></tr></table></div></figure>


<p>这次程序打印了一条堆栈被溢出的信息，然后就自动退出了。</p>

<p>在反汇编看下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[wzt@localhost csaw]$ objdump -d test &gt; hex1
</span><span class='line'>
</span><span class='line'>080483d4 &lt;test&gt;:
</span><span class='line'> 80483d4:       55                      push   %ebp
</span><span class='line'> 80483d5:       89 e5                   mov    %esp,%ebp
</span><span class='line'> 80483d7:       83 ec 68                sub    $0x68,%esp
</span><span class='line'> 80483da:       65 a1 14 00 00 00       mov    %gs:0x14,%eax
</span><span class='line'> 80483e0:       89 45 fc                mov    %eax,0xfffffffc(%ebp)
</span><span class='line'> 80483e3:       31 c0                   xor    %eax,%eax
</span><span class='line'> 80483e5:       c7 44 24 08 80 00 00    movl   $0x80,0x8(%esp)
</span><span class='line'> 80483ec:       00
</span><span class='line'> 80483ed:       c7 44 24 04 41 00 00    movl   $0x41,0x4(%esp)
</span><span class='line'> 80483f4:       00
</span><span class='line'> 80483f5:       8d 45 bc                lea    0xffffffbc(%ebp),%eax
</span><span class='line'> 80483f8:       89 04 24                mov    %eax,(%esp)
</span><span class='line'> 80483fb:       e8 cc fe ff ff          call   80482cc &lt;memset@plt&gt;
</span><span class='line'> 8048400:       8b 45 fc                mov    0xfffffffc(%ebp),%eax
</span><span class='line'> 8048403:       65 33 05 14 00 00 00    xor    %gs:0x14,%eax
</span><span class='line'> 804840a:       74 05                   je     8048411 &lt;test+0x3d&gt;
</span><span class='line'> 804840c:       e8 db fe ff ff          call   80482ec &lt;__stack_chk_fail@plt&gt;
</span><span class='line'> 8048411:       c9                      leave
</span><span class='line'> 8048412:       c3                      ret</span></code></pre></td></tr></table></div></figure>


<p>使用-fstack-protector参数后， gcc在函数的开头放置了几条汇编代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 80483d7:       83 ec 68                sub    $0x68,%esp
</span><span class='line'> 80483da:       65 a1 14 00 00 00       mov    %gs:0x14,%eax
</span><span class='line'> 80483e0:       89 45 fc                mov    %eax,0xfffffffc(%ebp)</span></code></pre></td></tr></table></div></figure>


<p>将代码段gs偏移0×14内存处的值赋值给了ebp-4， 也就是第一个变量值的后面。</p>

<p>在call完memeset后，有如下汇编代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 80483fb:       e8 cc fe ff ff          call   80482cc &lt;memset@plt&gt;
</span><span class='line'> 8048400:       8b 45 fc                mov    0xfffffffc(%ebp),%eax
</span><span class='line'> 8048403:       65 33 05 14 00 00 00    xor    %gs:0x14,%eax
</span><span class='line'> 804840a:       74 05                   je     8048411 &lt;test+0x3d&gt;
</span><span class='line'> 804840c:       e8 db fe ff ff          call   80482ec &lt;__stack_chk_fail@plt&gt;</span></code></pre></td></tr></table></div></figure>


<p>在memset后，gcc要检查这个操作是否发生了堆栈溢出, 将保存在ebp-4的这个值与原来的值对比一下，如果不相同， 说明堆栈发生了溢出，那么就会执行stack_chk_fail这个函数， 这个函数是glibc实现的，打印出上面看到的信息， 然后进程退出。</p>

<p>从这个例子中我们可以看出gcc使用了-fstack-protector参数后，会自动检查堆栈是否发生了溢出， 但是有一个前提就是内核要给每个进程提前设置好一个检测值放置在%gs:0×14位置处，这个值称之为stack canary。所以我们可以看到防止堆栈溢出是由内核和gcc共同来完成的。</p>

<p>gcc的任务就是放置几条汇编代码， 然后和%gs:0×14位置处的值进行对比即可。 主要任务还是内核如何来设置stack canary， 也是CC_STACKPROTECTOR补丁要实现的目的， 下面我们仔细来看下这个补丁是如何实现的。</p>

<p>既然gcc硬性规定了stack canary必须在%gs的某个偏移位置处， 那么内核也必须按着这个规定来设置。</p>

<p>对于32位和64位内核， gs寄存器有着不同的功能。</p>

<p>64位内核gcc要求stack canary是放置在gs段的40偏移处， 并且gs寄存器在每cpu变量中是共享的，每cpu变量irq_stack_union的结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>arch/x86/include/asm/processor.h
</span><span class='line'>
</span><span class='line'>union irq_stack_union {
</span><span class='line'>&#9;char irq_stack[IRQ_STACK_SIZE];
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * GCC hardcodes the stack canary as %gs:40.  Since the
</span><span class='line'>&#9; * irq_stack is the object at %gs:0, we reserve the bottom
</span><span class='line'>&#9; * 48 bytes of the irq stack for the canary. 
</span><span class='line'>&#9; */
</span><span class='line'>&#9;struct {
</span><span class='line'>&#9;&#9;char gs_base[40];
</span><span class='line'>&#9;&#9;unsigned long stack_canary;
</span><span class='line'>&#9;};
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>DECLARE_PER_CPU_FIRST(union irq_stack_union, irq_stack_union);</span></code></pre></td></tr></table></div></figure>


<p>gs_base只是一个40字节的站位空间， stack_canary就紧挨其后。并且在应用程序进出内核的时候，内核会使用swapgs指令自动更换gs寄存器的内容。</p>

<p>32位下就稍微有点复杂了。由于某些处理器在加载不同的段寄存器时很慢， 所以内核使用fs段寄存器替换了gs寄存器。 但是gcc在使用-fstack-protector的时候， 还要用到gs段寄存器， 所以内核还要管理gs寄存器，我们要把CONFIG_X86_32_LAZY_GS选项关闭， gs也只在进程切换的时候才改变。 32位用每cpu变量stack_canary保存stack canary。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct stack_canary {
</span><span class='line'>&#9;char __pad[20];         /* canary at %gs:20 */
</span><span class='line'>&#9;unsigned long canary;
</span><span class='line'>};      
</span><span class='line'>DECLARE_PER_CPU_ALIGNED(struct stack_canary, stack_canary);</span></code></pre></td></tr></table></div></figure>


<p>内核是处于保护模式的， 因此gs寄存器就变成了保护模式下的段选子，在GDT表中也要有相应的设置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diff --git a/arch/x86/include/asm/segment.h b/arch/x86/include/asm/segment.h
</span><span class='line'>index 1dc1b51..14e0ed8 100644 (file)
</span><span class='line'>--- a/arch/x86/include/asm/segment.h
</span><span class='line'>+++ b/arch/x86/include/asm/segment.h
</span><span class='line'>@@ -61,7 +61,7 @@
</span><span class='line'>  *
</span><span class='line'>  *  26 - ESPFIX small SS
</span><span class='line'>  *  27 - per-cpu                       [ offset to per-cpu data area ]
</span><span class='line'>- *  28 - unused
</span><span class='line'>+ *  28 - stack_canary-20               [ for stack protector ]
</span><span class='line'>  *  29 - unused
</span><span class='line'>  *  30 - unused
</span><span class='line'>  *  31 - TSS for double fault handler
</span><span class='line'>@@ -95,6 +95,13 @@
</span><span class='line'> #define __KERNEL_PERCPU 0
</span><span class='line'> #endif
</span><span class='line'>
</span><span class='line'>+#define GDT_ENTRY_STACK_CANARY         (GDT_ENTRY_KERNEL_BASE + 16)
</span><span class='line'>+#ifdef CONFIG_CC_STACKPROTECTOR
</span><span class='line'>+#define __KERNEL_STACK_CANARY          (GDT_ENTRY_STACK_CANARY * 8)
</span><span class='line'>+#else
</span><span class='line'>+#define __KERNEL_STACK_CANARY          0
</span><span class='line'>+#endif
</span><span class='line'>+
</span><span class='line'> #define GDT_ENTRY_DOUBLEFAULT_TSS      31</span></code></pre></td></tr></table></div></figure>


<p>GDT表中的第28个表项用来定为stack canary所在的段。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define GDT_STACK_CANARY_INIT                                           \
</span><span class='line'>        [GDT_ENTRY_STACK_CANARY] = GDT_ENTRY_INIT(0x4090, 0, 0x18),</span></code></pre></td></tr></table></div></figure>


<p>GDT_STACK_CANARY_INIT在刚进入保护模式的时候被调用， 这个段描述符项被设置为基地址为0， 段大小设为24，因为只在基地址为0， 偏移为0×14处放置一个4bytes的stack canary， 所以24字节正好。不理解的同学可以看看intel保护模式的手册， 对着段描述符结构一个个看就行了。</p>

<p>在进入保护模式后， start_kernel()会调用boot_init_stack_canary()来初始话一个stack canary。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*      
</span><span class='line'> * Initialize the stackprotector canary value.
</span><span class='line'> *
</span><span class='line'> * NOTE: this must only be called from functions that never return,
</span><span class='line'> * and it must always be inlined.
</span><span class='line'> */
</span><span class='line'>static __always_inline void boot_init_stack_canary(void)
</span><span class='line'>{
</span><span class='line'>&#9;u64 canary;
</span><span class='line'>&#9;u64 tsc;
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_X86_64
</span><span class='line'>&#9;BUILD_BUG_ON(offsetof(union irq_stack_union, stack_canary) != 40);
</span><span class='line'>#endif
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * We both use the random pool and the current TSC as a source
</span><span class='line'>&#9; * of randomness. The TSC only matters for very early init,
</span><span class='line'>&#9; * there it already has some randomness on most systems. Later
</span><span class='line'>&#9; * on during the bootup the random pool has true entropy too.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;get_random_bytes(&canary, sizeof(canary));
</span><span class='line'>&#9;tsc = __native_read_tsc();
</span><span class='line'>&#9;canary += tsc + (tsc &lt;&lt; 32UL);
</span><span class='line'>
</span><span class='line'>&#9;current-&gt;stack_canary = canary;
</span><span class='line'>#ifdef CONFIG_X86_64
</span><span class='line'>&#9;percpu_write(irq_stack_union.stack_canary, canary);
</span><span class='line'>#else
</span><span class='line'>&#9;percpu_write(stack_canary.canary, canary);
</span><span class='line'>#endif
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>随机出了一个值赋值给每cpu变量， 32位是stack_canary, 64位是irq_stack_union。</p>

<p>内核在进一步初始化cpu的时候，会调用setup_stack_canary_segment()来设置每个cpu的GDT的stack canary描述符项：</p>

<p>start_kernel()->setup_per_cpu_areas()->setup_stack_canary_segment：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void setup_stack_canary_segment(int cpu)
</span><span class='line'>{
</span><span class='line'>#ifdef CONFIG_X86_32
</span><span class='line'>&#9;unsigned long canary = (unsigned long)&per_cpu(stack_canary, cpu);
</span><span class='line'>&#9;struct desc_struct *gdt_table = get_cpu_gdt_table(cpu);
</span><span class='line'>&#9;struct desc_struct desc;
</span><span class='line'>
</span><span class='line'>&#9;desc = gdt_table[GDT_ENTRY_STACK_CANARY];
</span><span class='line'>&#9;set_desc_base(&desc, canary);
</span><span class='line'>&#9;write_gdt_entry(gdt_table, GDT_ENTRY_STACK_CANARY, &desc, DESCTYPE_S);
</span><span class='line'>#endif
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在内核刚进入保护模式的时候, stack canary描述符的基地址被初始化为0， 现在在cpu初始化的时候要重新设置为每cpu变量stack_canary的地址， 而不是变量保存的值。通过这些设置当内核代码在访问%gs:0×14的时候， 就会访问stack canry保存的值。注意：setup_stack_canary_segment是针对32位内核做设置， 因为64位内核中的irq_stack_union是每cpu共享的， 不用针对每个cpu单独设置。 然后就可以调用switch_to_new_gdt(cpu);来加载GDT表和加载gs寄存器。</p>

<p>经过上述初始化过程，在内核代码里访问%gs:0×14就可以定位stack canary的值了， 那么每个进程的stack canary是什么时候设置的呢？</p>

<p>在内核启动一个进程的时候， 会把gs寄存器的值设为KERNEL_STACK_CANARY</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>--- a/arch/x86/kernel/process_32.c
</span><span class='line'>+++ b/arch/x86/kernel/process_32.c
</span><span class='line'>@@ -212,6 +212,7 @@ int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
</span><span class='line'>&#9;    regs.ds = __USER_DS;
</span><span class='line'>&#9;    regs.es = __USER_DS;
</span><span class='line'>&#9;    regs.fs = __KERNEL_PERCPU;
</span><span class='line'>+       regs.gs = __KERNEL_STACK_CANARY;
</span><span class='line'>&#9;    regs.orig_ax = -1;
</span><span class='line'>&#9;    regs.ip = (unsigned long) kernel_thread_helper;
</span><span class='line'>&#9;    regs.cs = __KERNEL_CS | get_kernel_rpl();</span></code></pre></td></tr></table></div></figure>


<p>内核在fork一个进程的时候， 有如下操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct task_struct *dup_task_struct(struct task_struct *orig)
</span><span class='line'>{
</span><span class='line'>#ifdef CONFIG_CC_STACKPROTECTOR
</span><span class='line'>&#9;tsk-&gt;stack_canary = get_random_int();
</span><span class='line'>#endif
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>随机初始化了一个stack_canary保存在task_struct结构中的stack_canary变量中。当进程在切换的时候， 通过switch宏把新进程的stack canary保存在每cpu变量stack_canary中， 当前进程的stack_canary也保存在一个每cpu变量中，完成stack canary的切换。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diff --git a/arch/x86/include/asm/system.h b/arch/x86/include/asm/system.h
</span><span class='line'>index 79b98e5..2692ee8 100644 (file)
</span><span class='line'>--- a/arch/x86/include/asm/system.h
</span><span class='line'>+++ b/arch/x86/include/asm/system.h
</span><span class='line'>@@ -23,6 +23,22 @@ struct task_struct *__switch_to(struct task_struct *prev,
</span><span class='line'>
</span><span class='line'> #ifdef CONFIG_X86_32
</span><span class='line'>
</span><span class='line'>+#ifdef CONFIG_CC_STACKPROTECTOR
</span><span class='line'>+#define __switch_canary                                                \
</span><span class='line'>+       "movl "__percpu_arg([current_task])",%%ebx\n\t"                 \
</span><span class='line'>+       "movl %P[task_canary](%%ebx),%%ebx\n\t"                         \
</span><span class='line'>+       "movl %%ebx,"__percpu_arg([stack_canary])"\n\t"
</span><span class='line'>+#define __switch_canary_oparam                                         \
</span><span class='line'>+       , [stack_canary] "=m" (per_cpu_var(stack_canary))
</span><span class='line'>+#define __switch_canary_iparam                                         \
</span><span class='line'>+       , [current_task] "m" (per_cpu_var(current_task))                \
</span><span class='line'>+       , [task_canary] "i" (offsetof(struct task_struct, stack_canary))
</span><span class='line'>+#else  /* CC_STACKPROTECTOR */
</span><span class='line'>+#define __switch_canary
</span><span class='line'>+#define __switch_canary_oparam
</span><span class='line'>+#define __switch_canary_iparam
</span><span class='line'>+#endif /* CC_STACKPROTECTOR */
</span><span class='line'>+
</span><span class='line'> /*
</span><span class='line'>  * Saving eflags is important. It switches not only IOPL between tasks,
</span><span class='line'>  * it also protects other tasks from NT leaking through sysenter etc.
</span><span class='line'>@@ -46,6 +62,7 @@ do {                                                  \
</span><span class='line'>&#9;                 "pushl %[next_ip]\n\t"     /* restore EIP   */     \
</span><span class='line'>&#9;                 "jmp __switch_to\n"        /* regparm call  */     \
</span><span class='line'>&#9;                 "1:\t"                                             \
</span><span class='line'>+                    __switch_canary                                    \
</span><span class='line'>&#9;                 "popl %%ebp\n\t"           /* restore EBP   */     \
</span><span class='line'>&#9;                 "popfl\n"                  /* restore flags */     \
</span><span class='line'>&#9;                                                                    \
</span><span class='line'>@@ -58,6 +75,8 @@ do {                                                  \
</span><span class='line'>&#9;                   "=b" (ebx), "=c" (ecx), "=d" (edx),              \
</span><span class='line'>&#9;                   "=S" (esi), "=D" (edi)                           \
</span><span class='line'>&#9;                                                                    \
</span><span class='line'>+                      __switch_canary_oparam                           \
</span><span class='line'>+                                                                       \
</span><span class='line'>&#9;                   /* input parameters: */                          \
</span><span class='line'>&#9;                 : [next_sp]  "m" (next-&gt;thread.sp),                \
</span><span class='line'>&#9;                   [next_ip]  "m" (next-&gt;thread.ip),                \
</span><span class='line'>@@ -66,6 +85,8 @@ do {                                                  \
</span><span class='line'>&#9;                   [prev]     "a" (prev),                           \
</span><span class='line'>&#9;                   [next]     "d" (next)                            \
</span><span class='line'>&#9;                                                                    \
</span><span class='line'>+                      __switch_canary_iparam                           \
</span><span class='line'>+                                                                       \
</span><span class='line'>&#9;                 : /* reloaded segment registers */                 \
</span><span class='line'>&#9;                    "memory");                                      \
</span><span class='line'> } while (0)</span></code></pre></td></tr></table></div></figure>


<p>前面讲过当gcc检测到堆栈溢出的时候， 会调用glibc的stack_chk_fail函数， 但是当内核堆栈发生溢出的时候，不能调用glibc的函数，所以内核自己实现了一个stack_chk_fail函数：</p>

<p>kernel/panic.c</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#ifdef CONFIG_CC_STACKPROTECTOR
</span><span class='line'>
</span><span class='line'>/*
</span><span class='line'> * Called when gcc's -fstack-protector feature is used, and
</span><span class='line'> * gcc detects corruption of the on-stack canary value
</span><span class='line'> */
</span><span class='line'>void __stack_chk_fail(void)
</span><span class='line'>{
</span><span class='line'>&#9;panic("stack-protector: Kernel stack is corrupted in: %p\n",
</span><span class='line'>&#9;&#9; __builtin_return_address(0));
</span><span class='line'>}
</span><span class='line'>EXPORT_SYMBOL(__stack_chk_fail);
</span><span class='line'>
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>当内核堆栈发生溢出的时候，就会执行stack_chk_fail函数， 内核当机。</p>

<p>这就是这个补丁的原理，不懂的同学请参考：</p>

<p><a href="http://git.kernel.org/?p=linux/kernel/git/next/linux-next.git;a=commitdiff;h=60a5317ff0f42dd313094b88f809f63041568b08">http://git.kernel.org/?p=linux/kernel/git/next/linux-next.git;a=commitdiff;h=60a5317ff0f42dd313094b88f809f63041568b08</a></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-11-17T16:01:00+08:00'><span class='date'>2015-11-17</span> <span class='time'>16:01:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/debug/'>debug</a>, <a class='category' href='/blog/cats/debug~base/'>base</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/11/17/kernel-net-ixgbe/" title="Previous Post: ixgbe">&laquo; ixgbe</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/11/26/android-base-busybox/" title="Next Post: busybox">busybox &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
