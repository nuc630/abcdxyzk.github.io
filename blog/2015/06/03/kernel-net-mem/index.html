
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>内核协议栈tcp层的内存管理 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>date [-d @int|str] [+%s|"+%F %T"]</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">内核协议栈tcp层的内存管理</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-03T14:25:00+08:00'><span class='date'>2015-06-03</span> <span class='time'>14:25:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://simohayha.iteye.com/blog/532450">http://simohayha.iteye.com/blog/532450</a></p>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-hisock.html#table1">http://www.ibm.com/developerworks/cn/linux/l-hisock.html#table1</a></p>

<p><a href="http://blog.csdn.net/russell_tao/article/details/18711023">http://blog.csdn.net/russell_tao/article/details/18711023</a></p>

<p>我们先来看tcp内存管理相关的几个内核参数,这些都能通过proc文件系统来修改:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 内核写buf的最大值.
</span><span class='line'>extern __u32 sysctl_wmem_max;
</span><span class='line'>// 协议栈读buf的最大值
</span><span class='line'>extern __u32 sysctl_rmem_max;</span></code></pre></td></tr></table></div></figure>


<p>这两个值在/proc/sys/net/core 下。这里要注意，这两个值的单位是字节。</p>

<p>它们的初始化在sk_init里面,这里可以看到这两个值的大小是依赖于num_physpages的，而这个值应该是物理页数。也就是说这两个值依赖于物理内存：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __init sk_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;if (num_physpages &lt;= 4096) {
</span><span class='line'>&#9;&#9;sysctl_wmem_max = 32767;
</span><span class='line'>&#9;&#9;sysctl_rmem_max = 32767;
</span><span class='line'>&#9;&#9;sysctl_wmem_default = 32767;
</span><span class='line'>&#9;&#9;sysctl_rmem_default = 32767;
</span><span class='line'>&#9;} else if (num_physpages &gt;= 131072) {
</span><span class='line'>&#9;&#9;sysctl_wmem_max = 131071;
</span><span class='line'>&#9;&#9;sysctl_rmem_max = 131071;
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>而我通过搜索源码，只有设置套接口选项的时候，才会用到这两个值，也就是setsockopt，optname为SO_SNDBUF或者SO_RCVBUF时，来限制设置的值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>case SO_SNDBUF:
</span><span class='line'>&#9;&#9;if (val &gt; sysctl_wmem_max)
</span><span class='line'>&#9;&#9;&#9;val = sysctl_wmem_max;</span></code></pre></td></tr></table></div></figure>


<p>接下来就是整个tcp协议栈的socket的buf限制(也就是所有的socket).
这里要注意，这个东西的单位都是以页为单位的，我们下面就会看到。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>其中sysctl_tcp_mem[0]表示整个tcp sock的buf限制.
</span><span class='line'>sysctl_tcp_mem[1]也就是tcp sock内存使用的警戒线.
</span><span class='line'>sysctl_tcp_mem[2]也就是tcp sock内存使用的hard limit,当超过这个限制,我们就要禁止再分配buf.
</span><span class='line'>extern int sysctl_tcp_mem[3];</span></code></pre></td></tr></table></div></figure>


<p>接下来就是针对每个sock的读写buf限制。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 其中依次为最小buf,中等buf,以及最大buf.
</span><span class='line'>extern int sysctl_tcp_wmem[3];
</span><span class='line'>extern int sysctl_tcp_rmem[3];</span></code></pre></td></tr></table></div></figure>


<h4>tcp_init</h4>

<p>这几个值的初始化在tcp_init里面，这里就能清晰的看到sysctl_tcp_mem的单位是页。而sysctl_tcp_wmem和sysctl_tcp_rmem的单位是字节。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __init tcp_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;.................................
</span><span class='line'>&#9;// nr_pages就是页。
</span><span class='line'>&#9;nr_pages = totalram_pages - totalhigh_pages;
</span><span class='line'>&#9;limit = min(nr_pages, 1UL&lt;&lt;(28-PAGE_SHIFT)) &gt;&gt; (20-PAGE_SHIFT);
</span><span class='line'>&#9;limit = (limit * (nr_pages &gt;&gt; (20-PAGE_SHIFT))) &gt;&gt; (PAGE_SHIFT-11);
</span><span class='line'>&#9;limit = max(limit, 128UL);
</span><span class='line'>&#9;sysctl_tcp_mem[0] = limit / 4 * 3;
</span><span class='line'>&#9;sysctl_tcp_mem[1] = limit;
</span><span class='line'>&#9;sysctl_tcp_mem[2] = sysctl_tcp_mem[0] * 2;
</span><span class='line'>
</span><span class='line'>&#9;/* Set per-socket limits to no more than 1/128 the pressure threshold */
</span><span class='line'>&#9;// 转换为字节。
</span><span class='line'>&#9;limit = ((unsigned long)sysctl_tcp_mem[1]) &lt;&lt; (PAGE_SHIFT - 7);
</span><span class='line'>&#9;max_share = min(4UL*1024*1024, limit);
</span><span class='line'>
</span><span class='line'>&#9;sysctl_tcp_wmem[0] = SK_MEM_QUANTUM;
</span><span class='line'>&#9;sysctl_tcp_wmem[1] = 16*1024;
</span><span class='line'>&#9;sysctl_tcp_wmem[2] = max(64*1024, max_share);
</span><span class='line'>
</span><span class='line'>&#9;sysctl_tcp_rmem[0] = SK_MEM_QUANTUM;
</span><span class='line'>&#9;sysctl_tcp_rmem[1] = 87380;
</span><span class='line'>&#9;sysctl_tcp_rmem[2] = max(87380, max_share);
</span><span class='line'>&#9;................................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后就是读写buf的最小值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SOCK_MIN_SNDBUF 2048
</span><span class='line'>#define SOCK_MIN_RCVBUF 256</span></code></pre></td></tr></table></div></figure>


<p>最后就是当前tcp协议栈已经分配了的buf的总大小。这里要注意，这个值也是以页为单位的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>atomic_t tcp_memory_allocated</span></code></pre></td></tr></table></div></figure>


<p>而上面的这些值如何与协议栈关联起来呢，我们来看tcp_prot结构，可以看到这些值的地址都被放到对应的tcp_prot的域。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct proto tcp_prot = {
</span><span class='line'>&#9;.name = "TCP",
</span><span class='line'>&#9;.owner = THIS_MODULE,
</span><span class='line'>&#9;...................................................
</span><span class='line'>&#9;.enter_memory_pressure = tcp_enter_memory_pressure,
</span><span class='line'>&#9;.sockets_allocated = &tcp_sockets_allocated,
</span><span class='line'>&#9;.orphan_count = &tcp_orphan_count,
</span><span class='line'>&#9;.memory_allocated = &tcp_memory_allocated,
</span><span class='line'>&#9;.memory_pressure = &tcp_memory_pressure,
</span><span class='line'>&#9;.sysctl_mem = sysctl_tcp_mem,
</span><span class='line'>&#9;.sysctl_wmem = sysctl_tcp_wmem,
</span><span class='line'>&#9;.sysctl_rmem = sysctl_tcp_rmem,
</span><span class='line'>&#9;........................................................
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>而对应的sock域中的几个值，这几个域非常重要，我们来看他们表示的含义</p>

<p>sk_rcvbuf和sk_sndbuf,这两个值分别代表每个sock的读写buf的最大限制</p>

<p>sk_rmem_alloc和sk_wmem_alloc这两个值分别代表已经提交的数据包的字节数。</p>

<p>读buf意味着进入tcp层的数据大小，而当数据提交给用户空间之后，这个值会相应的减去提交的大小（也就类似写buf的sk_wmem_queued)。</p>

<p>写buf意味着提交给ip层。可以看到这个值的增加是在tcp_transmit_skb中进行的。</p>

<p>而sk_wmem_queued也就代表skb的写队列write_queue的大小。</p>

<p>还有一个sk_forward_alloc，这个值表示一个预分配置，也就是整个tcp协议栈的内存cache，第一次为一个缓冲区分配buf的时候，我们不会直接分配精确的大小，而是按页来分配，而分配的大小就是这个值，下面我们会看到这个。并且这个值初始是0.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sock {
</span><span class='line'>&#9;int sk_rcvbuf;
</span><span class='line'>&#9;atomic_t sk_rmem_alloc;
</span><span class='line'>&#9;atomic_t sk_wmem_alloc;
</span><span class='line'>&#9;int sk_forward_alloc;
</span><span class='line'>&#9;..........................
</span><span class='line'>&#9;int sk_sndbuf;
</span><span class='line'>&#9;// 这个表示写buf已经分配的字节长度
</span><span class='line'>&#9;int sk_wmem_queued;
</span><span class='line'>&#9;...........................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>sk_sndbuf和sk_rcvbuf,这两个的初始化在这里：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_v4_init_sock(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;..................................
</span><span class='line'>&#9;sk-&gt;sk_sndbuf = sysctl_tcp_wmem[1];
</span><span class='line'>&#9;sk-&gt;sk_rcvbuf = sysctl_tcp_rmem[1];
</span><span class='line'>&#9;..........................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>而当进入establish状态之后,sock会自己调整sndbuf和rcvbuf.他是通过tcp_init_buffer_space来进行调整的.这个函数会调用tcp_fixup_rcvbuf和tcp_fixup_sndbuf来调整读写buf的大小.</p>

<p>这里有用到sk_userlock这个标记，这个标记主要就是用来标记SO_SNDBUF 和SO_RCVBUF套接口选项是否被设置。而是否设置对应的值为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SOCK_SNDBUF_LOCK 1
</span><span class='line'>#define SOCK_RCVBUF_LOCK  2</span></code></pre></td></tr></table></div></figure>


<p>我们可以看下面的设置SO_SNDBUF 和SO_RCVBUF的代码片断：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 首先设置sk_userlocks.
</span><span class='line'>sk-&gt;sk_userlocks |= SOCK_SNDBUF_LOCK;
</span><span class='line'>if ((val * 2) &lt; SOCK_MIN_SNDBUF)
</span><span class='line'>&#9;sk-&gt;sk_sndbuf = SOCK_MIN_SNDBUF;
</span><span class='line'>else
</span><span class='line'>&#9;sk-&gt;sk_sndbuf = val * 2;</span></code></pre></td></tr></table></div></figure>


<p>因此内核里面的处理是这样的，如果用户已经通过套接字选项设置了读或者写buf的大小，那么这里将不会调整读写buf的大小，否则就进入tcp_fixup_XXX来调整大小。</p>

<p>还有一个要注意的就是MAX_TCP_HEADER，这个值表示了TCP + IP + link layer headers 以及option的长度。</p>

<p>我们来看代码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_init_buffer_space(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;int maxwin;
</span><span class='line'>
</span><span class='line'>&#9;// 判断sk_userlocks，来决定是否需要fix缓冲区大小。
</span><span class='line'>&#9;if (!(sk-&gt;sk_userlocks & SOCK_RCVBUF_LOCK))
</span><span class='line'>&#9;&#9;tcp_fixup_rcvbuf(sk);
</span><span class='line'>&#9;if (!(sk-&gt;sk_userlocks & SOCK_SNDBUF_LOCK))
</span><span class='line'>&#9;&#9;tcp_fixup_sndbuf(sk);
</span><span class='line'>......................................
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来来看这两个函数如何来调整读写buf的大小，不过这里还有些疑问，就是为什么是要和3<em>sndmem以及4</em>rcvmem：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_fixup_sndbuf(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;// 首先通过mss，tcp头，以及sk_buff的大小，得到一个最小范围的sndmem。
</span><span class='line'>&#9;int sndmem = tcp_sk(sk)-&gt;rx_opt.mss_clamp + MAX_TCP_HEADER + 16 +sizeof(struct sk_buff);
</span><span class='line'>
</span><span class='line'>&#9;// 然后取sysctl_tcp_wmem[2]和3倍的sndmem之间的最小值。
</span><span class='line'>&#9;if (sk-&gt;sk_sndbuf &lt; 3 * sndmem)
</span><span class='line'>&#9;&#9;sk-&gt;sk_sndbuf = min(3 * sndmem, sysctl_tcp_wmem[2]);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static void tcp_fixup_rcvbuf(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;// 这里和上面类似，也是先得到最小的一个rcvmem段。
</span><span class='line'>&#9;int rcvmem = tp-&gt;advmss + MAX_TCP_HEADER + 16 + sizeof(struct sk_buff);
</span><span class='line'>
</span><span class='line'>&#9;/* Try to select rcvbuf so that 4 mss-sized segments
</span><span class='line'>&#9; * will fit to window and corresponding skbs will fit to our rcvbuf.
</span><span class='line'>&#9; * (was 3; 4 is minimum to allow fast retransmit to work.)
</span><span class='line'>&#9; */
</span><span class='line'>&#9;// 这里则是通过sysctl_tcp_adv_win_scale来调整rcvmem的值。
</span><span class='line'>&#9;while (tcp_win_from_space(rcvmem) &lt; tp-&gt;advmss)
</span><span class='line'>&#9;&#9;rcvmem += 128;
</span><span class='line'>&#9;if (sk-&gt;sk_rcvbuf &lt; 4 * rcvmem)
</span><span class='line'>&#9;&#9;sk-&gt;sk_rcvbuf = min(4 * rcvmem, sysctl_tcp_rmem[2]);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ok，看完初始化，我们来看协议栈具体如何管理内存的，先来看发送端，发送端的主要实现是在tcp_sendmsg里面，这个函数我们前面已经详细的分析过了，我们这次只分析里面几个与内存相关的东西。</p>

<p>来看代码片断：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
</span><span class='line'>&#9;&#9;size_t size)
</span><span class='line'>{
</span><span class='line'>&#9;..................................
</span><span class='line'>
</span><span class='line'>&#9;if (copy &lt;= 0) {
</span><span class='line'>new_segment:
</span><span class='line'>&#9;&#9;if (!sk_stream_memory_free(sk))
</span><span class='line'>&#9;&#9;&#9;goto wait_for_sndbuf;
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb = sk_stream_alloc_skb(sk, select_size(sk),
</span><span class='line'>&#9;&#9;sk-&gt;sk_allocation);
</span><span class='line'>&#9;&#9;if (sk-&gt;sk_route_caps & NETIF_F_ALL_CSUM)
</span><span class='line'>&#9;&#9;&#9;skb-&gt;ip_summed = CHECKSUM_PARTIAL;
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb_entail(sk, skb);
</span><span class='line'>&#9;&#9;copy = size_goal;
</span><span class='line'>&#9;&#9;max = size_goal;
</span><span class='line'>&#9;..................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到这里第一个sk_stream_memory_free用来判断是否还有空间来供我们分配，如果没有则跳到wait_for_sndbuf来等待buf的释放。</p>

<p>然后如果有空间供我们分配，则调用sk_stream_alloc_skb来分配一个skb，然后这个大小的选择是通过select_size。</p>

<p>最后调用skb_entail来更新相关的域。</p>

<p>现在我们就来详细看上面的四个函数,先来看第一个：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int sk_stream_memory_free(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;return sk-&gt;sk_wmem_queued &lt; sk-&gt;sk_sndbuf;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>sk_stream_memory_free实现很简单，就是判断当前已经分配的写缓冲区的大小(sk_wmem_queued)是否小于当前写缓冲区(sk_sndbuf)的最大限制。</p>

<p>然后是skb_entail，这个函数主要是当我们分配完buf后，进行一些相关域的更新，以及添加skb到writequeue。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void skb_entail(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;struct tcp_skb_cb *tcb = TCP_SKB_CB(skb);
</span><span class='line'>&#9;............................
</span><span class='line'>&#9;skb_header_release(skb);
</span><span class='line'>&#9;tcp_add_write_queue_tail(sk, skb);
</span><span class='line'>&#9;// 增加sk_wmem_queued.
</span><span class='line'>&#9;sk-&gt;sk_wmem_queued += skb-&gt;truesize;
</span><span class='line'>&#9;// 这里调整sk_forward_alloc的大小，也就是预分配buf的大小(减小).
</span><span class='line'>&#9;sk_mem_charge(sk, skb-&gt;truesize);
</span><span class='line'>&#9;if (tp-&gt;nonagle & TCP_NAGLE_PUSH)
</span><span class='line'>&#9;&#9;tp-&gt;nonagle &= ~TCP_NAGLE_PUSH;
</span><span class='line'>}
</span><span class='line'>// 这个函数很简单，就是将sk_forward_alloc - size.
</span><span class='line'>static inline void sk_mem_charge(struct sock *sk, int size)
</span><span class='line'>{
</span><span class='line'>&#9;if (!sk_has_account(sk))
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;sk-&gt;sk_forward_alloc -= size;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是select_size，在看这个之前我们先来坎SKB_MAX_HEAD的实现.
SKB_MAX_HEAD主要是得到要分配的tcp数据段（不包括头)在一页中最大为多少。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SKB_WITH_OVERHEAD(X) \
</span><span class='line'>&#9;((X) - SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
</span><span class='line'>#define SKB_MAX_ORDER(X, ORDER) \
</span><span class='line'>&#9;SKB_WITH_OVERHEAD((PAGE_SIZE &lt;&lt; (ORDER)) - (X))
</span><span class='line'>#define SKB_MAX_HEAD(X)    (SKB_MAX_ORDER((X), 0))</span></code></pre></td></tr></table></div></figure>


<p>我们带入代码来看，我们下面的代码是SKB_MAX_HEAD(MAX_TCP_HEADER)，展开这个宏可以看到就是PAGE_SIZE-MAX_TCP_HEADER-SKB_DATA_ALIGN(sizeof(struct skb_shared_info).其实也就是一页还能容纳多少tcp的数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int select_size(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;// 首先取得存储的mss。
</span><span class='line'>&#9;int tmp = tp-&gt;mss_cache;
</span><span class='line'>
</span><span class='line'>&#9;// 然后判断是否使用scatter–gather(前面blog有介绍)
</span><span class='line'>&#9;if (sk-&gt;sk_route_caps & NETIF_F_SG) {
</span><span class='line'>&#9;&#9;if (sk_can_gso(sk))
</span><span class='line'>&#9;&#9;&#9;tmp = 0;
</span><span class='line'>&#9;&#9;else {
</span><span class='line'>&#9;&#9;&#9;// 然后开始计算buf的长度。
</span><span class='line'>&#9;&#9;&#9;int pgbreak = SKB_MAX_HEAD(MAX_TCP_HEADER);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;// 如果mss大于pgbreak,那么说明我们一页放不下当前需要的tcp数据，因此我们将会在skb的页区域分配，而skb的页区域是有限制的，因此tmp必须小于这个值。
</span><span class='line'>&#9;&#9;&#9;if (tmp &gt;= pgbreak &&
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tmp &lt;= pgbreak + (MAX_SKB_FRAGS - 1) * PAGE_SIZE)
</span><span class='line'>&#9;&#9;&#9;&#9;tmp = pgbreak;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;return tmp;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>sk_stream_alloc_skb</h4>

<p>接下来来看sk_stream_alloc_skb的实现。</p>

<p>1 它会调用alloc_skb_fclone来分配内存，这个函数就不详细分析了，我们只需要知道它会从slab里分配一块内存，而大小为size+max_header(上面的分析我们知道slect_size只计算数据段).</p>

<p>2 如果分配成功，则调用sk_wmem_schedule来判断我们所分配的skb的大小是否精确，是的话，就调整指针，然后返回。</p>

<p>3 否则调用tcp_enter_memory_pressure设置标志进入TCP memory pressure zone。然后再调用sk_stream_moderate_sndbuf调整sndbuf(缩小sndbuf)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sk_buff *sk_stream_alloc_skb(struct sock *sk, int size, gfp_t gfp)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>&#9;// 4字节对其
</span><span class='line'>&#9;size = ALIGN(size, 4);
</span><span class='line'>&#9;// 分配skb。
</span><span class='line'>&#9;skb = alloc_skb_fclone(size + sk-&gt;sk_prot-&gt;max_header, gfp);
</span><span class='line'>&#9;if (skb) {
</span><span class='line'>&#9;&#9;// 得到精确的大小。
</span><span class='line'>&#9;&#9;if (sk_wmem_schedule(sk, skb-&gt;truesize)) {
</span><span class='line'>&#9;&#9;&#9;// 返回skb。
</span><span class='line'>&#9;&#9;&#9;skb_reserve(skb, skb_tailroom(skb) - size);
</span><span class='line'>&#9;&#9;&#9;&#9;return skb;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;__kfree_skb(skb);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;// 否则设置全局标记进入pressure zone
</span><span class='line'>&#9;&#9;sk-&gt;sk_prot-&gt;enter_memory_pressure(sk);
</span><span class='line'>&#9;&#9;sk_stream_moderate_sndbuf(sk);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return NULL;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ok,现在就来看上面的几个函数的实现。先来看几个简单的。</p>

<p>首先是tcp_enter_memory_pressure,这个函数很简单，就是判断全局标记tcp_memory_pressure,然后设置这个标记。这个标记主要是用来通知其他模块调整的，比如窗口大小等等，详细的话自己搜索这个值，就知道了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_enter_memory_pressure(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;if (!tcp_memory_pressure) {
</span><span class='line'>&#9;&#9;NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMEMORYPRESSURES);
</span><span class='line'>&#9;&#9;// 设置压力标志。
</span><span class='line'>&#9;&#9;tcp_memory_pressure = 1;
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是sk_stream_moderate_sndbuf，这个函数也是要使用sk_userlocks,来判断是否已经被用户设置了。可以看到如果我们自己设置过了snd_buf的话，内核就不会帮我们调整它的大小了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void sk_stream_moderate_sndbuf(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;if (!(sk-&gt;sk_userlocks & SOCK_SNDBUF_LOCK)) {
</span><span class='line'>&#9;&#9;// 它的大小调整为大于最小值，小于sk-&gt;sk_wmem_queued &gt;&gt; 1。
</span><span class='line'>&#9;&#9;sk-&gt;sk_sndbuf = min(sk-&gt;sk_sndbuf, sk-&gt;sk_wmem_queued &gt;&gt; 1);
</span><span class='line'>&#9;&#9;sk-&gt;sk_sndbuf = max(sk-&gt;sk_sndbuf, SOCK_MIN_SNDBUF);
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>sk_wmem_schedule</h4>

<p>最后来看最核心的一个函数sk_wmem_schedule，这个函数只是对<code>__sk_mem_schedule</code>的简单封装。这里要知道传递进来的size是skb->truesize，也就是所分配的skb的真实大小。并且第一次进入这个函数，也就是分配第一个缓冲区包时，sk_forward_alloc是为0的，也就是说，第一次必然会执行<code>__sk_mem_schedule</code>函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int sk_wmem_schedule(struct sock *sk, int size)
</span><span class='line'>{
</span><span class='line'>&#9;if (!sk_has_account(sk))
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;// 先比较size(也就是skb-&gt;truesize)和预分配的内存大小。如果小于等于预分配的大小，则直接返回，否则调用__sk_mem_schedule进行调整。
</span><span class='line'>&#9;return size &lt;= sk-&gt;sk_forward_alloc ||
</span><span class='line'>&#9;&#9;__sk_mem_schedule(sk, size, SK_MEM_SEND);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看<code>__sk_mem_schedule</code>，这个函数的功能注释写的很清楚：</p>

<p>increase sk_forward_alloc and memory_allocated</p>

<p>然后来看源码。这里在看之前，我们要知道，协议栈通过读写buf的使用量，划分了3个区域，或者说标志。不同标志进行不同处理。这里的区域的划分是通过sysctl_tcp_mem，也就是prot->sysctl_mem这个数组进行的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 页的大小
</span><span class='line'>#define SK_MEM_QUANTUM ((int)PAGE_SIZE)
</span><span class='line'>
</span><span class='line'>int __sk_mem_schedule(struct sock *sk, int size, int kind)
</span><span class='line'>{
</span><span class='line'>&#9;struct proto *prot = sk-&gt;sk_prot;
</span><span class='line'>&#9;// 首先得到size占用几个内存页。
</span><span class='line'>&#9;int amt = sk_mem_pages(size);
</span><span class='line'>&#9;int allocated;
</span><span class='line'>&#9;// 更新sk_forward_alloc，可以看到这个值是页的大小的倍数。
</span><span class='line'>&#9;sk-&gt;sk_forward_alloc += amt * SK_MEM_QUANTUM;
</span><span class='line'>
</span><span class='line'>&#9;// amt+memory_allocated也就是当前的总得内存使用量加上将要分配的内存的话，现在的tcp协议栈的总得内存使用量。（可以看到是以页为单位的。
</span><span class='line'>&#9;allocated = atomic_add_return(amt, prot-&gt;memory_allocated);
</span><span class='line'>
</span><span class='line'>&#9;// 然后开始判断，将会落入哪一个区域。通过上面的分析我们知道sysctl_mem也就是sysctl_tcp_mem.
</span><span class='line'>
</span><span class='line'>&#9;// 先判断是否小于等于内存最小使用限额。
</span><span class='line'>&#9;if (allocated &lt;= prot-&gt;sysctl_mem[0]) {
</span><span class='line'>&#9;&#9;// 这里取消memory_pressure，然后返回。
</span><span class='line'>&#9;&#9;if (prot-&gt;memory_pressure && *prot-&gt;memory_pressure)
</span><span class='line'>&#9;&#9;&#9;*prot-&gt;memory_pressure = 0;
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;// 然后判断Under pressure。
</span><span class='line'>&#9;if (allocated &gt; prot-&gt;sysctl_mem[1])
</span><span class='line'>&#9;&#9;// 大于sysctl_mem[1]说明，已经进入pressure，一次你需要调用tcp_enter_memory_pressure来设置标志。
</span><span class='line'>&#9;&#9;if (prot-&gt;enter_memory_pressure)
</span><span class='line'>&#9;&#9;&#9;prot-&gt;enter_memory_pressure(sk);
</span><span class='line'>
</span><span class='line'>&#9;// 如果超过的hard limit。则进入另外的处理。
</span><span class='line'>&#9;if (allocated &gt; prot-&gt;sysctl_mem[2])
</span><span class='line'>&#9;&#9;goto suppress_allocation;
</span><span class='line'>
</span><span class='line'>&#9;// 判断类型，这里只有两种类型，读和写。总的内存大小判断完，这里开始判断单独的sock的读写内存。
</span><span class='line'>&#9;if (kind == SK_MEM_RECV) {
</span><span class='line'>&#9;&#9;if (atomic_read(&sk-&gt;sk_rmem_alloc) &lt; prot-&gt;sysctl_rmem[0])
</span><span class='line'>&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;} else { /* SK_MEM_SEND */
</span><span class='line'>&#9;&#9;// 这里当为tcp的时候，写队列的大小只有当对端数据确认后才会更新，因此我们要用sk_wmem_queued来判断。
</span><span class='line'>&#9;&#9;if (sk-&gt;sk_type == SOCK_STREAM) {
</span><span class='line'>&#9;&#9;&#9;if (sk-&gt;sk_wmem_queued &lt; prot-&gt;sysctl_wmem[0])
</span><span class='line'>&#9;&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;&#9;} else if (atomic_read(&sk-&gt;sk_wmem_alloc) &lt;
</span><span class='line'>&#9;&#9;&#9;   prot-&gt;sysctl_wmem[0])
</span><span class='line'>&#9;&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;// 程序到达这里说明总的内存大小在sysctl_mem[0]和sysctl_mem[2]之间，因此我们再次判断memory_pressure
</span><span class='line'>&#9;if (prot-&gt;memory_pressure) {
</span><span class='line'>&#9;&#9;int alloc;
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 如果没有在memory_pressure区域，则我们直接返回1。
</span><span class='line'>&#9;&#9;if (!*prot-&gt;memory_pressure)
</span><span class='line'>&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;&#9;// 这个其实也就是计算整个系统分配的socket的多少。
</span><span class='line'>&#9;&#9;alloc = percpu_counter_read_positive(prot-&gt;sockets_allocated);
</span><span class='line'>&#9;&#9;// 这里假设其余的每个sock所占用的buf都和当前的sock一样大的时候，如果他们的总和小于sysctl_mem[2],也就是hard limit。那么我们也认为这次内存请求是成功的。
</span><span class='line'>&#9;&#9;if (prot-&gt;sysctl_mem[2] &gt; alloc *
</span><span class='line'>&#9;&#9;&#9;sk_mem_pages(sk-&gt;sk_wmem_queued +
</span><span class='line'>&#9;&#9;&#9; atomic_read(&sk-&gt;sk_rmem_alloc) +
</span><span class='line'>&#9;&#9;&#9;&#9; sk-&gt;sk_forward_alloc))
</span><span class='line'>&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>suppress_allocation:
</span><span class='line'>
</span><span class='line'>&#9;// 到达这里说明，我们超过了hard limit或者说处于presure 区域。
</span><span class='line'>&#9;if (kind == SK_MEM_SEND && sk-&gt;sk_type == SOCK_STREAM) {
</span><span class='line'>&#9;&#9;// 调整sk_sndbuf(减小).这个函数前面已经分析过了。
</span><span class='line'>&#9;&#9;sk_stream_moderate_sndbuf(sk);
</span><span class='line'>&#9;&#9;// 然后比较和sk_sndbuf的大小，如果大于的话，就说明下次我们再次要分配buf的时候会在tcp_memory_free阻塞住，因此这次我们返回1.
</span><span class='line'>&#9;&#9;if (sk-&gt;sk_wmem_queued + size &gt;= sk-&gt;sk_sndbuf)
</span><span class='line'>&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/* Alas. Undo changes. */
</span><span class='line'>&#9;// 到达这里说明，请求内存是不被接受的，因此undo所有的操作。然后返回0.
</span><span class='line'>&#9;sk-&gt;sk_forward_alloc -= amt * SK_MEM_QUANTUM;
</span><span class='line'>&#9;atomic_sub(amt, prot-&gt;memory_allocated);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来来看个很重要的函数skb_set_owner_w。</p>

<p>顾名思义，这个函数也就是将一个skb和scok关联起来。只不过关联的时候更新sock相应的域。我们来看源码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void skb_set_owner_w(struct sk_buff *skb, struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;skb_orphan(skb);
</span><span class='line'>&#9;// 与传递进来的sock关联起来
</span><span class='line'>&#9;skb-&gt;sk = sk;
</span><span class='line'>&#9;// 设置skb的析构函数
</span><span class='line'>&#9;skb-&gt;destructor = sock_wfree;
</span><span class='line'>&#9;// 更新sk_wmem_alloc域，就是sk_wmem_alloc+truesize.
</span><span class='line'>&#9;atomic_add(skb-&gt;truesize, &sk-&gt;sk_wmem_alloc);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ok，接下来来看个scok_wfree函数，这个函数做得基本和上面函数相反。这个函数都是被kfree_skb自动调用的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void sock_wfree(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct sock *sk = skb-&gt;sk;
</span><span class='line'>&#9;int res;
</span><span class='line'>
</span><span class='line'>&#9;// 更新sk_wmem_alloc,减去skb的大小。
</span><span class='line'>&#9;res = atomic_sub_return(skb-&gt;truesize, &sk-&gt;sk_wmem_alloc);
</span><span class='line'>&#9;if (!sock_flag(sk, SOCK_USE_WRITE_QUEUE))
</span><span class='line'>&#9;// 唤醒等待队列，也就是唤醒等待内存分配。
</span><span class='line'>&#9;&#9;sk-&gt;sk_write_space(sk);
</span><span class='line'>&#9;if (res == 0)
</span><span class='line'>&#9;&#9;__sk_free(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>而skb_set_owner_w是什么时候被调用呢，我们通过搜索代码可以看到，它是在tcp_transmit_skb中被调用的。而tcp_transmit_skb我们知道是传递数据包到ip层的函数。</p>

<p>而kfree_skb被调用也就是在对端已经确认完我们发送的包后才会被调用来释放skb。</p>

<h4>tcp_rcv_established</h4>

<p>接下来来看接收数据的内存管理。我们主要来看tcp_rcv_established这个函数，我前面的blog已经断断续续的分析过了，因此这里我们只看一些重要的代码片断。</p>

<p>这里我们要知道，代码能到达下面的位置，则说明，数据并没有直接拷贝到用户空间。否则的话，是不会进入下面的片断的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!eaten) {
</span><span class='line'>&#9;..........................................
</span><span class='line'>
</span><span class='line'>&#9;// 如果skb的大小大于预分配的值,如果大于则要另外处理。
</span><span class='line'>&#9;if ((int)skb-&gt;truesize &gt; sk-&gt;sk_forward_alloc)
</span><span class='line'>&#9;&#9;&#9;goto step5;
</span><span class='line'>&#9;__skb_pull(skb, tcp_header_len);
</span><span class='line'>&#9;__skb_queue_tail(&sk-&gt;sk_receive_queue, skb);
</span><span class='line'>&#9;// 这里关联skb和对应的sk，并且更新相关的域，我们下面会分析这个函数。
</span><span class='line'>&#9;skb_set_owner_r(skb, sk);
</span><span class='line'>&#9;tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>}
</span><span class='line'>...............................................
</span><span class='line'>
</span><span class='line'>step5:
</span><span class='line'>&#9;if (th-&gt;ack && tcp_ack(sk, skb, FLAG_SLOWPATH) &lt; 0)
</span><span class='line'>&#9;&#9;goto discard;
</span><span class='line'>
</span><span class='line'>&#9;tcp_rcv_rtt_measure_ts(sk, skb);
</span><span class='line'>
</span><span class='line'>&#9;/* Process urgent data. */
</span><span class='line'>&#9;tcp_urg(sk, skb, th);
</span><span class='line'>
</span><span class='line'>&#9;/* step 7: process the segment text */
</span><span class='line'>&#9;// 最核心的函数就是这个。我们接下来会详细分析这个函数。
</span><span class='line'>&#9;tcp_data_queue(sk, skb);
</span><span class='line'>
</span><span class='line'>&#9;tcp_data_snd_check(sk);
</span><span class='line'>&#9;tcp_ack_snd_check(sk);
</span><span class='line'>&#9;return 0;</span></code></pre></td></tr></table></div></figure>


<p>先来看skb_set_owner_r函数，这个函数关联skb和sk其实它和skb_set_owner_w类似：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void skb_set_owner_r(struct sk_buff *skb, struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;skb_orphan(skb);
</span><span class='line'>&#9;// 关联sk
</span><span class='line'>&#9;skb-&gt;sk = sk;
</span><span class='line'>&#9;// 设置析构函数
</span><span class='line'>&#9;skb-&gt;destructor = sock_rfree;
</span><span class='line'>&#9;// 更新rmem_alloc
</span><span class='line'>&#9;atomic_add(skb-&gt;truesize, &sk-&gt;sk_rmem_alloc);
</span><span class='line'>&#9;// 改变forward_alloc.
</span><span class='line'>&#9;sk_mem_charge(sk, skb-&gt;truesize);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>tcp_data_queue</h4>

<p>然后是tcp_data_queue，这个函数主要用来排队接收数据，并update相关的读buf。由于这个函数比较复杂，我们只关心我们感兴趣的部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcphdr *th = tcp_hdr(skb);
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;int eaten = -1;
</span><span class='line'>&#9;.......................................
</span><span class='line'>&#9;// 首先判断skb的开始序列号和我们想要接收的序列号。如果相等开始处理这个数据包(也就是拷贝到用户空间).
</span><span class='line'>&#9;if (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) {
</span><span class='line'>&#9;&#9;if (tcp_receive_window(tp) == 0)
</span><span class='line'>&#9;&#9;&#9;goto out_of_window;
</span><span class='line'>
</span><span class='line'>&#9;&#9;// tp的ucopy我前面的blog已经详细分析过了。这里就不解释了。
</span><span class='line'>&#9;&#9;if (tp-&gt;ucopy.task == current &&
</span><span class='line'>&#9;&#9;&#9;tp-&gt;copied_seq == tp-&gt;rcv_nxt && tp-&gt;ucopy.len &&sock_owned_by_user(sk) && !tp-&gt;urg_data)
</span><span class='line'>&#9;&#9;{
</span><span class='line'>&#9;&#9;&#9;// 计算将要拷贝给用户空间的大小。
</span><span class='line'>&#9;&#9;&#9;int chunk = min_t(unsigned int, skb-&gt;len,tp-&gt;ucopy.len);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;// 设置状态，说明我们处于进程上下文。
</span><span class='line'>&#9;&#9;&#9;__set_current_state(TASK_RUNNING);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;local_bh_enable();
</span><span class='line'>&#9;&#9;&#9;// 拷贝skb
</span><span class='line'>&#9;&#9;&#9;if (!skb_copy_datagram_iovec(skb, 0, tp-&gt;ucopy.iov, chunk)) {
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;ucopy.len -= chunk;
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;copied_seq += chunk;
</span><span class='line'>&#9;&#9;&#9;&#9;// 更新eaten，它的默认值为-1.
</span><span class='line'>&#9;&#9;&#9;&#9;eaten = (chunk == skb-&gt;len && !th-&gt;fin);
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_rcv_space_adjust(sk);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;local_bh_disable();
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 如果小于0则说明没有拷贝成功，或者说就没有进行拷贝。此时需要更新sock的相关域。
</span><span class='line'>&#9;&#9;if (eaten &lt;= 0) {
</span><span class='line'>queue_and_out:
</span><span class='line'>&#9;&#9;&#9;// 最关键的tcp_try_rmem_schedule函数。接下来会详细分析。
</span><span class='line'>&#9;&#9;&#9;if (eaten &lt; 0 &&
</span><span class='line'>&#9;&#9;          tcp_try_rmem_schedule(sk, skb-&gt;truesize))
</span><span class='line'>&#9;&#9;&#9;&#9;goto drop;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;// 关联skb和sk。到达这里说明tcp_try_rmem_schedule成功，也就是返回0.
</span><span class='line'>&#9;&#9;&#9;skb_set_owner_r(skb, sk);
</span><span class='line'>&#9;&#9;&#9;// 加skb到receive_queue.
</span><span class='line'>&#9;&#9;&#9;__skb_queue_tail(&sk-&gt;sk_receive_queue, skb);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;// 更新期待序列号。
</span><span class='line'>&#9;&#9;tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>&#9;&#9;..............................................
</span><span class='line'>
</span><span class='line'>&#9;&#9;.....................................
</span><span class='line'>
</span><span class='line'>&#9;&#9;tcp_fast_path_check(sk);
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (eaten &gt; 0)
</span><span class='line'>&#9;&#9;&#9;__kfree_skb(skb);
</span><span class='line'>&#9;&#9;else if (!sock_flag(sk, SOCK_DEAD))
</span><span class='line'>&#9;&#9;&#9;sk-&gt;sk_data_ready(sk, 0);
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;// 下面就是处理乱序包。以后会详细分析。
</span><span class='line'>&#9;......................................
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>tcp_try_rmem_schedule</h4>

<p>接下来我们就来看tcp_try_rmem_schedule这个函数,这个函数如果返回0则说明sk_rmem_schedule返回1,而sk_rmem_schedule和sk_wmem_schedule是一样的。也就是看当前的skb加入后有没有超过读buf的限制。并更新相关的域。：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_try_rmem_schedule(struct sock *sk, unsigned int size)
</span><span class='line'>{
</span><span class='line'>&#9;// 首先判断rmem_alloc(当前的读buf字节数)是否大于最大buf字节数，如果大于则调用tcp_prune_queue调整分配的buf。否则调用sk_rmem_schedule来调整相关域（sk_forward_alloc）。
</span><span class='line'>&#9;if (atomic_read(&sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf ||!sk_rmem_schedule(sk, size)) {
</span><span class='line'>
</span><span class='line'>&#9;&#9;// 调整分配的buf。
</span><span class='line'>&#9;&#9;if (tcp_prune_queue(sk) &lt; 0)
</span><span class='line'>&#9;&#9;&#9;return -1;
</span><span class='line'>&#9;&#9;// 更新sk的相关域。
</span><span class='line'>&#9;&#9;if (!sk_rmem_schedule(sk, size)) {
</span><span class='line'>&#9;&#9;&#9;if (!tcp_prune_ofo_queue(sk))
</span><span class='line'>&#9;&#9;&#9;&#9;return -1;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (!sk_rmem_schedule(sk, size))
</span><span class='line'>&#9;&#9;&#9;&#9;return -1;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看sk_rmem_schedule，这个函数很简单，就是封装了<code>__sk_mem_schedule</code>。而这个函数我们上面已经分析过了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int sk_rmem_schedule(struct sock *sk, int size)
</span><span class='line'>{
</span><span class='line'>&#9;if (!sk_has_account(sk))
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;return size &lt;= sk-&gt;sk_forward_alloc ||
</span><span class='line'>&#9;&#9;__sk_mem_schedule(sk, size, SK_MEM_RECV);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>tcp_prune_queue</h4>

<p>最后是tcp_prune_queue，这个函数主要是用来丢掉一些skb，因为到这个函数就说明我们的内存使用已经到极限了，因此我们要合并一些buf。这个合并也就是将序列号连续的段进行合并。</p>

<p>这里我们要知道tcp的包是有序的，因此内核中tcp专门有一个队列来保存那些Out of order segments。因此我们这里会先处理这个队列里面的skb。</p>

<p>然后调用tcp_collapse来处理接收队列里面的skb。和上面的类似。</p>

<p>这里要注意，合并的话都是按页来合并，也就是先分配一页大小的内存，然后将老的skb复制进去，最后free掉老的buf。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_prune_queue(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;..................................
</span><span class='line'>&#9;// 如果rmem_alloc过于大，则重新计算窗口的大小。一半都会缩小窗口。
</span><span class='line'>&#9;if (atomic_read(&sk-&gt;sk_rmem_alloc) &gt;= sk-&gt;sk_rcvbuf)
</span><span class='line'>&#9;&#9;tcp_clamp_window(sk);
</span><span class='line'>&#9;// 如果处于pressure区域，则调整窗口大小。这里也是缩小窗口。
</span><span class='line'>&#9;else if (tcp_memory_pressure)
</span><span class='line'>&#9;&#9;tp-&gt;rcv_ssthresh = min(tp-&gt;rcv_ssthresh, 4U * tp-&gt;advmss);
</span><span class='line'>
</span><span class='line'>&#9;// 处理ofo队列。
</span><span class='line'>&#9;tcp_collapse_ofo_queue(sk);
</span><span class='line'>&#9;// 如果接收队列为非空，则调用tcp_collapse来处理sk_receive_queue
</span><span class='line'>&#9;if (!skb_queue_empty(&sk-&gt;sk_receive_queue))
</span><span class='line'>&#9;&#9;tcp_collapse(sk, &sk-&gt;sk_receive_queue,
</span><span class='line'>&#9;&#9;&#9;&#9; skb_peek(&sk-&gt;sk_receive_queue),
</span><span class='line'>&#9;&#9;&#9;&#9; NULL,
</span><span class='line'>&#9;&#9;&#9;&#9; tp-&gt;copied_seq, tp-&gt;rcv_nxt);
</span><span class='line'>&#9;// 更新全局的已分配内存的大小，也就是memory_allocated，接下来会详细介绍这个函数。
</span><span class='line'>&#9;sk_mem_reclaim(sk);
</span><span class='line'>
</span><span class='line'>&#9;// 如果调整后小于sk_rcvbuf,则返回0.
</span><span class='line'>&#9;if (atomic_read(&sk-&gt;sk_rmem_alloc) &lt;= sk-&gt;sk_rcvbuf)
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>
</span><span class='line'>&#9;......................................
</span><span class='line'>&#9;return -1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>tcp_collapse_ofo_queue 尝试减小ofo queue占内存的大小</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Collapse ofo queue. Algorithm: select contiguous sequence of skbs
</span><span class='line'> * and tcp_collapse() them until all the queue is collapsed.
</span><span class='line'> */
</span><span class='line'>static void tcp_collapse_ofo_queue(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;struct sk_buff *skb = skb_peek(&tp-&gt;out_of_order_queue);
</span><span class='line'>&#9;struct sk_buff *head;
</span><span class='line'>&#9;u32 start, end;
</span><span class='line'>
</span><span class='line'>&#9;if (skb == NULL)
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>
</span><span class='line'>&#9;start = TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>&#9;end = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>&#9;head = skb;
</span><span class='line'>
</span><span class='line'>&#9;for (;;) {
</span><span class='line'>&#9;&#9;struct sk_buff *next = NULL;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!skb_queue_is_last(&tp-&gt;out_of_order_queue, skb))
</span><span class='line'>&#9;&#9;&#9;next = skb_queue_next(&tp-&gt;out_of_order_queue, skb);
</span><span class='line'>&#9;&#9;skb = next;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Segment is terminated when we see gap or when
</span><span class='line'>&#9;&#9; * we are at the end of all the queue. */
</span><span class='line'>&#9;&#9;if (!skb ||
</span><span class='line'>&#9;&#9;&#9;after(TCP_SKB_CB(skb)-&gt;seq, end) ||
</span><span class='line'>&#9;&#9;&#9;before(TCP_SKB_CB(skb)-&gt;end_seq, start)) {  // 找到ofo queue中连续的一段skb，即 prev-&gt;end_seq &gt;= next-&gt;seq
</span><span class='line'>&#9;&#9;&#9;tcp_collapse(sk, &tp-&gt;out_of_order_queue,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; head, skb, start, end);            // 尝试减小这一段连续skb占用的内存
</span><span class='line'>&#9;&#9;&#9;head = skb;
</span><span class='line'>&#9;&#9;&#9;if (!skb)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;/* Start new segment */
</span><span class='line'>&#9;&#9;&#9;start = TCP_SKB_CB(skb)-&gt;seq;               // 下个skb就是新的一段的开始
</span><span class='line'>&#9;&#9;&#9;end = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;if (before(TCP_SKB_CB(skb)-&gt;seq, start))    // 这种情况只可能是tcp_collapse中大包拆成小包，拆到一半内存不够，没拆完导致。
</span><span class='line'>&#9;&#9;&#9;&#9;start = TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>&#9;&#9;&#9;if (after(TCP_SKB_CB(skb)-&gt;end_seq, end))
</span><span class='line'>&#9;&#9;&#9;&#9;end = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>tcp_collapse，gro上来的包有可能是大于4k的包，所以这个函数有时是在拆包，利弊难定</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 删除一个skb，返回下个skb
</span><span class='line'>static struct sk_buff *tcp_collapse_one(struct sock *sk, struct sk_buff *skb,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;struct sk_buff_head *list)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *next = NULL;
</span><span class='line'>
</span><span class='line'>&#9;if (!skb_queue_is_last(list, skb))
</span><span class='line'>&#9;&#9;next = skb_queue_next(list, skb);
</span><span class='line'>
</span><span class='line'>&#9;__skb_unlink(skb, list);
</span><span class='line'>&#9;__kfree_skb(skb);
</span><span class='line'>&#9;NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPRCVCOLLAPSED);
</span><span class='line'>
</span><span class='line'>&#9;return next;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/* Collapse contiguous sequence of skbs head..tail with
</span><span class='line'> * sequence numbers start..end.
</span><span class='line'> *
</span><span class='line'> * If tail is NULL, this means until the end of the list.
</span><span class='line'> *
</span><span class='line'> * Segments with FIN/SYN are not collapsed (only because this
</span><span class='line'> * simplifies code)
</span><span class='line'> */
</span><span class='line'>static void
</span><span class='line'>tcp_collapse(struct sock *sk, struct sk_buff_head *list,
</span><span class='line'>&#9;&#9; struct sk_buff *head, struct sk_buff *tail,
</span><span class='line'>&#9;&#9; u32 start, u32 end)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *skb, *n;
</span><span class='line'>&#9;bool end_of_skbs;
</span><span class='line'>
</span><span class='line'>&#9;/* First, check that queue is collapsible and find
</span><span class='line'>&#9; * the point where collapsing can be useful. */
</span><span class='line'>&#9;skb = head;
</span><span class='line'>restart:
</span><span class='line'>&#9;end_of_skbs = true;
</span><span class='line'>&#9;skb_queue_walk_from_safe(list, skb, n) {
</span><span class='line'>&#9;&#9;if (skb == tail)
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;/* No new bits? It is possible on ofo queue. */
</span><span class='line'>&#9;&#9;if (!before(start, TCP_SKB_CB(skb)-&gt;end_seq)) { // 这种情况现在是不会出现的，以前代码有可能出现？？
</span><span class='line'>&#9;&#9;&#9;skb = tcp_collapse_one(sk, skb, list);
</span><span class='line'>&#9;&#9;&#9;if (!skb)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;goto restart;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* The first skb to collapse is:
</span><span class='line'>&#9;&#9; * - not SYN/FIN and
</span><span class='line'>&#9;&#9; * - bloated or contains data before "start" or
</span><span class='line'>&#9;&#9; *   overlaps to the next one.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (!tcp_hdr(skb)-&gt;syn && !tcp_hdr(skb)-&gt;fin &&         // SYN，FIN 不合并，简化操作
</span><span class='line'>&#9;&#9;&#9;(tcp_win_from_space(skb-&gt;truesize) &gt; skb-&gt;len ||    // 合并后可能减小空间的情况才合并
</span><span class='line'>&#9;&#9;&#9; before(TCP_SKB_CB(skb)-&gt;seq, start))) {            // seq到start的数据已经被读走了，有减小空间的可能
</span><span class='line'>&#9;&#9;&#9;end_of_skbs = false;
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!skb_queue_is_last(list, skb)) {
</span><span class='line'>&#9;&#9;&#9;struct sk_buff *next = skb_queue_next(list, skb);
</span><span class='line'>&#9;&#9;&#9;if (next != tail &&
</span><span class='line'>&#9;&#9;&#9;&#9;TCP_SKB_CB(skb)-&gt;end_seq != TCP_SKB_CB(next)-&gt;seq) { // 两个skb之间有交集，有减小空间可能
</span><span class='line'>&#9;&#9;&#9;&#9;end_of_skbs = false;
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Decided to skip this, advance start seq. */
</span><span class='line'>&#9;&#9;start = TCP_SKB_CB(skb)-&gt;end_seq;     // 否则向后继续找可能减小空间的第一个skb
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (end_of_skbs || tcp_hdr(skb)-&gt;syn || tcp_hdr(skb)-&gt;fin)
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>
</span><span class='line'>&#9;while (before(start, end)) {  // 落在在start到end的包就是这次要合并的
</span><span class='line'>&#9;&#9;struct sk_buff *nskb;
</span><span class='line'>&#9;&#9;unsigned int header = skb_headroom(skb); // skb中协议头的大小
</span><span class='line'>&#9;&#9;int copy = SKB_MAX_ORDER(header, 0);     // 一个页（4k）中出去协议头空间的大小，也就是能容下的数据大小
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Too big header? This can happen with IPv6. */
</span><span class='line'>&#9;&#9;if (copy &lt; 0)
</span><span class='line'>&#9;&#9;&#9;return;
</span><span class='line'>&#9;&#9;if (end - start &lt; copy)
</span><span class='line'>&#9;&#9;&#9;copy = end - start;
</span><span class='line'>&#9;&#9;nskb = alloc_skb(copy + header, GFP_ATOMIC);
</span><span class='line'>&#9;&#9;if (!nskb)
</span><span class='line'>&#9;&#9;&#9;return;
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb_set_mac_header(nskb, skb_mac_header(skb) - skb-&gt;head);
</span><span class='line'>&#9;&#9;skb_set_network_header(nskb, (skb_network_header(skb) -
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;  skb-&gt;head));
</span><span class='line'>&#9;&#9;skb_set_transport_header(nskb, (skb_transport_header(skb) -
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;skb-&gt;head));
</span><span class='line'>&#9;&#9;skb_reserve(nskb, header);
</span><span class='line'>&#9;&#9;memcpy(nskb-&gt;head, skb-&gt;head, header);
</span><span class='line'>&#9;&#9;memcpy(nskb-&gt;cb, skb-&gt;cb, sizeof(skb-&gt;cb));
</span><span class='line'>&#9;&#9;TCP_SKB_CB(nskb)-&gt;seq = TCP_SKB_CB(nskb)-&gt;end_seq = start;
</span><span class='line'>&#9;&#9;__skb_queue_before(list, skb, nskb);
</span><span class='line'>&#9;&#9;skb_set_owner_r(nskb, sk);
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Copy data, releasing collapsed skbs. */
</span><span class='line'>&#9;&#9;while (copy &gt; 0) {    // 如果copy = 0，这里就会出BUG，但如果没有认为改，是不会的。ipv6会吗？？？。后面版本改进这函数了，也不会出现copy=0了
</span><span class='line'>&#9;&#9;&#9;int offset = start - TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>&#9;&#9;&#9;int size = TCP_SKB_CB(skb)-&gt;end_seq - start;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;BUG_ON(offset &lt; 0);
</span><span class='line'>&#9;&#9;&#9;if (size &gt; 0) { // copy旧的skb数据到新的skb上
</span><span class='line'>&#9;&#9;&#9;&#9;size = min(copy, size);
</span><span class='line'>&#9;&#9;&#9;&#9;if (skb_copy_bits(skb, offset, skb_put(nskb, size), size))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;BUG();
</span><span class='line'>&#9;&#9;&#9;&#9;TCP_SKB_CB(nskb)-&gt;end_seq += size;
</span><span class='line'>&#9;&#9;&#9;&#9;copy -= size;
</span><span class='line'>&#9;&#9;&#9;&#9;start += size;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;if (!before(start, TCP_SKB_CB(skb)-&gt;end_seq)) { // 旧的skb被copy完了就删掉
</span><span class='line'>&#9;&#9;&#9;&#9;skb = tcp_collapse_one(sk, skb, list);
</span><span class='line'>&#9;&#9;&#9;&#9;if (!skb ||
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;skb == tail ||
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tcp_hdr(skb)-&gt;syn ||
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tcp_hdr(skb)-&gt;fin)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;return;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看sk_mem_reclaim函数，它只是简单的封装了<code>__sk_mem_reclaim</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void sk_mem_reclaim(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;if (!sk_has_account(sk))
</span><span class='line'>&#9;&#9;return;
</span><span class='line'>&#9;// 如果sk_forward_alloc大于1页则调用__sk_mem_reclaim，我们知道sk_forward_alloc是以页为单位的，因此这里也就是和大于0一样。
</span><span class='line'>&#9;if (sk-&gt;sk_forward_alloc &gt;= SK_MEM_QUANTUM)
</span><span class='line'>&#9;&#9;__sk_mem_reclaim(sk);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>__sk_mem_reclaim</code>就是真正操作的函数，它会更新memory_allocated：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __sk_mem_reclaim(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>&#9;struct proto *prot = sk-&gt;sk_prot;
</span><span class='line'>&#9;// 更新memory_allocated，这里我们知道memory_allocated也是以页为单位的，因此需要将sk_forward_alloc转化为页。
</span><span class='line'>&#9;atomic_sub(sk-&gt;sk_forward_alloc &gt;&gt; SK_MEM_QUANTUM_SHIFT,prot-&gt;memory_allocated);
</span><span class='line'>
</span><span class='line'>&#9;// 更新这个sk的sk_forward_alloc为一页。
</span><span class='line'>&#9;sk-&gt;sk_forward_alloc &= SK_MEM_QUANTUM - 1;
</span><span class='line'>&#9;// 判断是否处于pressure区域，是的话更新memory_pressure变量。
</span><span class='line'>&#9;if (prot-&gt;memory_pressure && *prot-&gt;memory_pressure &&(atomic_read(prot-&gt;memory_allocated) &lt; （prot-&gt;sysctl_mem[0]))
</span><span class='line'>&#9;&#9;*prot-&gt;memory_pressure = 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后看一下读buf的释放。这个函数会在kfree_skb中被调用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void sock_rfree(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>&#9;struct sock *sk = skb-&gt;sk;
</span><span class='line'>&#9;// 更新rmem_alloc
</span><span class='line'>&#9;atomic_sub(skb-&gt;truesize, &sk-&gt;sk_rmem_alloc);
</span><span class='line'>&#9;// 更新forward_alloc.
</span><span class='line'>&#9;sk_mem_uncharge(skb-&gt;sk, skb-&gt;truesize);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-06-03T14:25:00+08:00'><span class='date'>2015-06-03</span> <span class='time'>14:25:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~net/'>net</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/06/02/kernel-base-rcu/" title="Previous Post: TREE RCU实现">&laquo; TREE RCU实现</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/06/03/kernel-net-rps/" title="Next Post: Receive packet steering patch详解">Receive packet steering patch详解 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
