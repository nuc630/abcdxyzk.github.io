
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>TREE RCU实现 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">TREE RCU实现</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-02T17:38:00+08:00'><span class='date'>2015-06-02</span> <span class='time'>17:38:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.csdn.net/junguo/article/details/8258231">http://blog.csdn.net/junguo/article/details/8258231</a></p>

<p><a href="http://blog.csdn.net/junguo/article/details/8258261">http://blog.csdn.net/junguo/article/details/8258261</a></p>

<p><a href="http://blog.csdn.net/junguo/article/details/8268277">http://blog.csdn.net/junguo/article/details/8268277</a></p>

<hr />

<h3>TREE RCU实现之一 —— 数据结构</h3>

<h4>代码分布</h4>

<p>在分析代码之前， 先看看代码的分布情况。RCU实现的代码包含在下列一些文件中，此处用到的是linux 3.6.4的代码。</p>

<p>&lt; include/linux/rcupdate.h >  RCU实现的头文件，所有使用RCU的代码都需要包含它<br/>
&lt; include/rcutree.h >  包含rcupdate.h中没有包含的函数声明。<br/>
&lt; include/rcutiny.h >  包含rcupdate.h中没有包含的函数声明。<br/>
&lt; kernel/rcupdate.c >  包括一些RCU实现的基础函数的实现。<br/>
&lt; kernel/rcutree.h >  包含Tree RCU用到的结构信息，TREE_RCU将所有的CPU组织成一颗树，通过层次结构来判别进程是否通过了宽限期，这种方式适用于多个CPU的系统。<br/>
&lt; kernel/rcutree.c >  包含Tree RCU的主要实现代码。<br/>
&lt; kernel/rcutree_plugin.h >  其实也是TREE RCU实现的一部分。主要包含了抢入式TreeRCU的代码。适用于抢入式的系统，抢入式的系统适用于需要低延迟的桌面或者嵌入式系统。<br/>
&lt; kernel/rcutiny.c >  Tiny RCU的主要实现代码，TINY_RCU适用于单个CPU，尤其是嵌入式操作系统。<br/>
&lt; kernel/rcutiny_plugin.h >  主要包含了抢入式Tiny RCU的代码<br/>
&lt; kernel/rcu.h >  定义了debug的接口，实现了<code>__rcu_reclaim</code>。<br/>
&lt; kernel/rcutorture.c>  对RCU进行稳定性测试的代码，通过配置CONFIG_RCU_TORTURE_TEST，可以在系统启动的时候运行稳定性测试。<br/>
&lt; kernel/rcutree_trace.c>  通过配置CONFIG_RCU_TRACE，可以记录RCU的运行信息。<br/>
&lt; include/trace/events/rcu.h>  为rcutree_trace.c定义的头文件。</p>

<h4>RCU处理的基本流程</h4>

<p>RCU实现的关键集中在宽限期的处理上，这个过程需要保证销毁对象前，当前系统中所有CPU上运行的进程都通过了静止状态（quiescent state）。</p>

<p>  1， 程序调用call_rcu，将要删除的对象保存起来。并标记或者开始一个宽限期（同一时间只能运行一个宽限期，所以当已经有宽限期在运行的时候，其它的宽限期必须等待）。</p>

<p>  2， 在读取数据开始和结尾处增加 rcu_read_lock 和 rcu_read_unlock来标记读过程。为了保证删除过程知道读过程的结束，在非抢占式RCU实现中是在rcu_read_lock开始处禁止进程抢占。这样做就可以保证再运行下一次进程切换的时候，读过程已经结束。其实系统也不会去统计各个CPU上是否存在过读线程，所以所有的CPU都会在进程切换的时候通知系统它处于进制状态。当所有的CPU都通过静止状态的时候，系统就会标记它通过了一个宽限期。</p>

<p>  3，由于一个宽限期结束的时候，只有最后一个通过静止状态的CPU知道当前的宽限期已经结束，它并不会去通知其它CPU；同时出于性能考虑，系统也不会在宽限期结束后，马上去执行销毁过程。所以每个CPU都有一个固定的函数去检测是否有等待执行的宽限期，如果没有特别紧急的任务时，会去执行这些过程。</p>

<p>接下来，要分析Tree RCU的实现，先来看看它提供的一些接口函数。</p>

<p>  1， call_rcu  与 synchronize_rcu都是删除对象时调用的函数。call_rcu将数据提交后会返回，而synchronize_rcu会调用call_rcu，并一直等待对象被删除后才返回。还有call_rcu_bh与synchronize_rcu_bh等接口函数，会在后续讲述。</p>

<p>  2，rcu_read_lock 和 rcu_read_unlock</p>

<p>&lt;linux/rcuupdate.h></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void __rcu_read_lock(void)
</span><span class='line'>{
</span><span class='line'>&#9;preempt_disable();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static inline void __rcu_read_unlock(void)
</span><span class='line'>{
</span><span class='line'>&#9;preempt_enable();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void rcu_read_lock(void)
</span><span class='line'>{
</span><span class='line'>&#9;__rcu_read_lock();
</span><span class='line'>&#9;__acquire(RCU);
</span><span class='line'>&#9;rcu_lock_acquire(&rcu_lock_map);
</span><span class='line'>&#9;rcu_lockdep_assert(!rcu_is_cpu_idle(),
</span><span class='line'>&#9;&#9;&#9;"rcu_read_lock() used illegally while idle");
</span><span class='line'>}
</span><span class='line'>static inline void rcu_read_unlock(void)
</span><span class='line'>{
</span><span class='line'>&#9;rcu_lockdep_assert(!rcu_is_cpu_idle(),
</span><span class='line'>&#9;&#9;&#9;"rcu_read_unlock() used illegally while idle");
</span><span class='line'>&#9;rcu_lock_release(&rcu_lock_map);
</span><span class='line'>&#9;__release(RCU);
</span><span class='line'>&#9;__rcu_read_unlock();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>rcu_read_lock与rcu_read_unlock在非抢占式下的实现比较简单就是 preempt_disable与preempt_enable。这样做的目的是当调用schedule的时候，就可以肯定读的过程已经结束。其它_acquire(RCU)等函数是调试用的代码，暂不做讨论。</p>

<p>  3， rcu_note_context_switch 在schedule中调用，每次进程切换就代表着一个静止状态。该函数会把当前的CPU状态设置为通过状态。</p>

<p>  4， rcu_check_callbacks 在每次时钟周期里调用(update_process_times)。通过它会触发软件中断，软件中断对应着rcu_process_callbacks，这是一个真正繁忙的函数，他会检测当前CPU的状态，向父节点传递静止状态信息，调用注册函数等一系列工作。</p>

<p>在进一步了解这些函数之前，我们先来看看你Tree RCU的结构。</p>

<h4>TREE RCU简介</h4>

<p>  在统计CPU的状态的时候，需要用到一个结构来存放所有CPU的状态。在早期的实现中，所有的状态都保存在一个结构中，这样做的后果是所有的CPU在更新自己状态的时候，都需要锁定该结构对象，一定程度上影响了系统性能。为了提高性能，把一定数目的CPU组成了一个节点（默认设定64个CPU为一个节点）；当节点超过64个的时候，再把这些节点按64为单位划分为归属不同的父节点；如此类推，最后的一个单独的节点作为根节点。这样在更新CPU状态的时候，只需要锁定自己所属的节点就可以了。按节点设置的数目，可见这个结构只对CPU数成百上千的系统才真正起作用（我都没见过超过32个cpu的机器，不知道是啥样的感觉）。</p>

<p><img src="/images/kernel/2015-06-02-50.png" alt="" /></p>

<p>  这样所有的CPU就按层级结构组织了起来，也就是一个树结构。当一个系统的CPU数少于64个的时候，只要一个rcu_node就可以。</p>

<p>  每个CPU在完成宽限期检测的时候，就会去更新它所属的rcu_node的值，当一个rcu_node所包含的CPU的状态都更新过以后，该node就会去更新它所属的父节点的值。直到最后一个根节点。</p>

<h4>TREE RCU数据结构</h4>

<p>为了实现该结构，系统提供了以下结构。</p>

<h5>rcu_data</h5>

<p>由于RCU需要统计每个CPU是否通过了宽限期，提供了rcu_data来保存信息。另外每个销毁的对象并不是直接删除，也保存在rcu_data中，等到合适的时机来执行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct rcu_data {  
</span><span class='line'>&#9;/* 1) 静止状态和宽限期处理: */  
</span><span class='line'>&#9;unsigned long   completed;      /* 对比 rsp-&gt;completed */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* 目的是检测宽限期是否完成. */  
</span><span class='line'>&#9;unsigned long   gpnum;          /* 当前CPU上最高的宽限期数目*/  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* 在宽限期开始的时候设置. */  
</span><span class='line'>&#9;unsigned long   passed_quiesce_gpnum;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* 已经通过的宽限期数目. */  
</span><span class='line'>&#9;bool            passed_quiesce; /* 是否通过了静止状态，在进程切换等状态会设置. */  
</span><span class='line'>&#9;bool            qs_pending;     /* 对于当前执行的宽限期，该CPU是否执行完成. */  
</span><span class='line'>&#9;bool            beenonline;     /* CPU是否在线，不在线的CPU需要特殊处理，以提高性能*/  
</span><span class='line'>&#9;bool            preemptible;    /* 是否抢占式RCU? */  
</span><span class='line'>&#9;struct rcu_node *mynode;        /* 这个CPU对应的 rcu_node */  
</span><span class='line'>&#9;unsigned long grpmask;          /* 占用1bit，对应与所属的rcu_node. */  
</span><span class='line'>#ifdef CONFIG_RCU_CPU_STALL_INFO  
</span><span class='line'>&#9;unsigned long   ticks_this_gp;  /* The number of scheduling-clock */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  ticks this CPU has handled */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  during and after the last grace */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* period it is aware of. */  
</span><span class='line'>#endif /* #ifdef CONFIG_RCU_CPU_STALL_INFO */  
</span><span class='line'>&#9;/* 2) 批处理*/  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 
</span><span class='line'>&#9; * 当nxtlist不为空的时候，会通过nxttail划分为以下几部分 
</span><span class='line'>&#9; * 每一个部分为空的时候，它的指针会被设置成与它的下一部分相同 
</span><span class='line'>&#9; * 当nxtlist为空的时候，所有的nxttail都会指向nxtlist的地址，这时候nxtlist指向NULL 
</span><span class='line'>&#9; * 
</span><span class='line'>&#9; * [nxtlist, *nxttail[RCU_DONE_TAIL]): 
</span><span class='line'>&#9; *    批处理的开始节点# &lt;= -&gt;completed 
</span><span class='line'>&#9; *    这些节点的宽限期已经完成，可以执行销毁操作。 
</span><span class='line'>&#9; *    当调用rcu_process_callbacks()的时候，下一批完成宽限期的节点也会放到这儿. 
</span><span class='line'>&#9; * [*nxttail[RCU_DONE_TAIL], *nxttail[RCU_WAIT_TAIL]): 
</span><span class='line'>&#9; *    批处理的开始节点 # &lt;= -&gt;completed - 1: 等待当前的批处理完成 
</span><span class='line'>&#9; * [*nxttail[RCU_WAIT_TAIL], *nxttail[RCU_NEXT_READY_TAIL]): 
</span><span class='line'>&#9; *    已知的当下次宽限期开始，可以开始等待的节点。 
</span><span class='line'>&#9; * [*nxttail[RCU_NEXT_READY_TAIL], *nxttail[RCU_NEXT_TAIL]): 
</span><span class='line'>&#9; *    当前不确定下次宽限期开始后，是否可以开始等待状态的节点。 
</span><span class='line'>&#9; *    *nxttail[RCU_NEXT_TAIL] 的值将永远是NULL， 
</span><span class='line'>&#9; *    它表示nxtlist的结束. 
</span><span class='line'>&#9; * 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;struct rcu_head *nxtlist;  
</span><span class='line'>&#9;struct rcu_head **nxttail[RCU_NEXT_SIZE];  
</span><span class='line'>&#9;long            qlen_lazy;      /* # kfree_rcu调用的次数，kfee_rcu等同于call_rcu，只是它不需要销毁的对象提供销毁函数*/  
</span><span class='line'>&#9;long            qlen;           /* # 当前需要执行销毁操作的次数，每次call_rcu会加一，执行过后减一*/  
</span><span class='line'>&#9;long            qlen_last_fqs_check;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* 对应与qlen，最后一次执行的次数*/  
</span><span class='line'>&#9;unsigned long   n_cbs_invoked;  /* 执行销毁操作的次数. */  
</span><span class='line'>&#9;unsigned long   n_cbs_orphaned; /* 统计离线后CPU上剩下的callback函数的个数 */  
</span><span class='line'>&#9;unsigned long   n_cbs_adopted;  /* 从离线后的CPU上移出的callback函数的个数 */  
</span><span class='line'>&#9;unsigned long   n_force_qs_snap;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* 其它CPU是否在执行fore_qs? */  
</span><span class='line'>&#9;long            blimit;         /* nxtlist保存的上限 */  
</span><span class='line'>
</span><span class='line'>&#9;/* 3) 动态时钟,*/  
</span><span class='line'>&#9;struct rcu_dynticks *dynticks;  /* 每个CPU都包含一个动态时钟. */  
</span><span class='line'>&#9;int dynticks_snap;              /* 用于检测CPU是否在线. */  
</span><span class='line'>
</span><span class='line'>&#9;/* 4) 强制执行时候处理的CPU */  
</span><span class='line'>&#9;unsigned long dynticks_fqs;     /* 由于进入dynticks idle而被处理的CPU. */  
</span><span class='line'>&#9;unsigned long offline_fqs;      /* 由于不在在线被处理的CPU. */  
</span><span class='line'>
</span><span class='line'>&#9;/* 5) __rcu_pending() 的统计信息，这些信息都是在记录调用信息的时候使用. */  
</span><span class='line'>&#9;unsigned long n_rcu_pending;    /* rcu_pending() 调用次数，自从启动. */  
</span><span class='line'>&#9;unsigned long n_rp_qs_pending;  
</span><span class='line'>&#9;unsigned long n_rp_report_qs;  
</span><span class='line'>&#9;unsigned long n_rp_cb_ready;  
</span><span class='line'>&#9;unsigned long n_rp_cpu_needs_gp;  
</span><span class='line'>&#9;unsigned long n_rp_gp_completed;  
</span><span class='line'>&#9;unsigned long n_rp_gp_started;  
</span><span class='line'>&#9;unsigned long n_rp_need_fqs;  
</span><span class='line'>&#9;unsigned long n_rp_need_nothing;  
</span><span class='line'>
</span><span class='line'>&#9;/* 6) _rcu_barrier() 的回调函数. */  
</span><span class='line'>&#9;struct rcu_head barrier_head;  
</span><span class='line'>
</span><span class='line'>&#9;int cpu;  
</span><span class='line'>&#9;struct rcu_state *rsp;  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>1，completed ，gpnum ， passed_quiesce_gpnum</p>

<p>  gpnum表示当前正在运行的宽限期的个数，每当一个宽限期开始的时候，会设置这个值与其父节点相同。passed_quiesce_gpnum为当前CPU通过的宽限期个数，它的值在宽限期开始的时候小于gpnum，当这个CPU经过一个静止状态的时候，会把它设置成gpnum的值，通过对比它与父节点中的gpnum是否相同，可以确定该CPU是否通过了宽限期。passed_quiesce_gpnum只是表示这个CPU通过了宽限期，而completed表示所有的CPU都通过了宽限期，设置该值的同时，可以将nxtlist中等待的回调函数移动到完成队列。</p>

<p>2，nxtlist 与nxttail</p>

<p>  nxtlist保存的是指向rcu_head对象，rcu_head的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct callback_head {
</span><span class='line'>&#9;struct callback_head *next;
</span><span class='line'>&#9;void (*func)(struct callback_head *head);
</span><span class='line'>};
</span><span class='line'>#define rcu_head callback_head</span></code></pre></td></tr></table></div></figure>


<p>rcu_head的结构并不复杂，它包含一个回调函数指针。而next可以把rcu_head连成一个列表。</p>

<p><img src="/images/kernel/2015-06-02-51.png" alt="" /></p>

<p>nxtlist指向一个rcu_head 列表，而nxttail的四个元素是指向指针的指针，它们指向的是rcu_head对象的next。RCU_DONE_TAIL指向的rcu_head对象之前的对象是可以销毁的对象。RCU_WAIT_TAIL指向的正在等待宽限期的元素，RCU_NEXT_READ_TAIL指向的是等待下次宽限期的元素，RCU_NEXT_TAIL指向最后一个元素，这个元素总是指向NULL。</p>

<h5>rcu_node</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct rcu_node {  
</span><span class='line'>&#9;raw_spinlock_t lock;    /* rcu_node的锁，用来保护以下的一些成员*/  
</span><span class='line'>
</span><span class='line'>&#9;unsigned long gpnum;    /* 该节点当前的宽限期的数量 */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* 该值等于或者比父节点的值小1*/  
</span><span class='line'>&#9;unsigned long completed; /* 该节点完成的宽限期数量*/  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9; /* 该值等于或者比父节点的值小1*/  
</span><span class='line'>&#9;unsigned long qsmask;   /* 标记这个节点对应的所有CPU或者子节点是否完成了当前的宽限期*/  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* 每一个bit对应一个cpu或者一个子节点.*/  
</span><span class='line'>&#9;unsigned long expmask;  /* 需要执行 -&gt;blkd_tasks 的元素 */                              
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  (应用于TREE_PREEMPT_RCU). */  
</span><span class='line'>&#9;atomic_t wakemask;      /* 需要唤醒kthread的CPU. */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;  
</span><span class='line'>&#9;unsigned long qsmaskinit;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* 每个宽限期开始时，用它来初始化qsmask，不存在或者不在线的CPU需要清除. */  
</span><span class='line'>&#9;unsigned long grpmask;  /* 对应于父节点中的位置. */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* 只是用一bit. */  
</span><span class='line'>&#9;int     grplo;          /* 该节点代表的CPU或者子节点开始的位置. */  
</span><span class='line'>&#9;int     grphi;          /* 该节点代表的CPU或者子节点结束的位置. */  
</span><span class='line'>&#9;u8      grpnum;         /* 下一级的CPU或者子节点的个数. */  
</span><span class='line'>&#9;u8      level;          /* 跟节点是 0. */  
</span><span class='line'>&#9;struct rcu_node *parent;  
</span><span class='line'>&#9;struct list_head blkd_tasks;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* 阻断读关键段的任务列表 */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  */  
</span><span class='line'>&#9;&#9;&#9;&#9; 
</span><span class='line'>&#9;struct list_head *gp_tasks;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* 指向第一个阻断读关键段的任务 */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;  
</span><span class='line'>&#9;struct list_head *exp_tasks;  
</span><span class='line'>
</span><span class='line'>&#9;/*以下为抢先式下加速RCU过程的变量*/
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_RCU_BOOST  
</span><span class='line'>&#9;struct list_head *boost_tasks;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* Pointer to first task that needs to be */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  priority boosted, or NULL if no priority */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  boosting is needed for this rcu_node */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  structure.  If there are no tasks */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  queued on this rcu_node structure that */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  are blocking the current grace period, */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  there can be no such task. */  
</span><span class='line'>&#9;unsigned long boost_time;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* When to start boosting (jiffies). */  
</span><span class='line'>&#9;struct task_struct *boost_kthread_task;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* kthread that takes care of priority */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  boosting for this rcu_node structure. */  
</span><span class='line'>&#9;unsigned int boost_kthread_status;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* State of boost_kthread_task for tracing. */  
</span><span class='line'>&#9;unsigned long n_tasks_boosted;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* Total number of tasks boosted. */  
</span><span class='line'>&#9;unsigned long n_exp_boosts;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* Number of tasks boosted for expedited GP. */  
</span><span class='line'>&#9;unsigned long n_normal_boosts;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* Number of tasks boosted for normal GP. */  
</span><span class='line'>&#9;unsigned long n_balk_blkd_tasks;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* Refused to boost: no blocked tasks. */  
</span><span class='line'>&#9;unsigned long n_balk_exp_gp_tasks;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* Refused to boost: nothing blocking GP. */  
</span><span class='line'>&#9;unsigned long n_balk_boost_tasks;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* Refused to boost: already boosting. */  
</span><span class='line'>&#9;unsigned long n_balk_notblocked;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* Refused to boost: RCU RS CS still running. */  
</span><span class='line'>&#9;unsigned long n_balk_notyet;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* Refused to boost: not yet time. */  
</span><span class='line'>&#9;unsigned long n_balk_nos;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* Refused to boost: not sure why, though. */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  This can happen due to race conditions. */  
</span><span class='line'>#endif /* #ifdef CONFIG_RCU_BOOST */  
</span><span class='line'>&#9;struct task_struct *node_kthread_task;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* kthread that takes care of this rcu_node */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  structure, for example, awakening the */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/*  per-CPU kthreads as needed. */  
</span><span class='line'>&#9;unsigned int node_kthread_status;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* State of node_kthread_task for tracing. */  
</span><span class='line'>} ____cacheline_internodealigned_in_smp;  </span></code></pre></td></tr></table></div></figure>


<p>每个rcu_node代表着 一组CPU或者子节点。在非抢占式下，它的结构并不复杂。由于可能有多个CPU对它进行处理，所有进行相应操作的时候，需要lock保护。</p>

<h5>rcu_state</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct rcu_state {  
</span><span class='line'>&#9;struct rcu_node node[NUM_RCU_NODES];    /* 保存了所有的节点. */  
</span><span class='line'>&#9;struct rcu_node *level[RCU_NUM_LVLS];   /* 每个层级所指向的节点. */  
</span><span class='line'>&#9;u32 levelcnt[MAX_RCU_LVLS + 1];         /* # 每一层的节点数. */  
</span><span class='line'>&#9;u8 levelspread[RCU_NUM_LVLS];           /* 每一层的CPU/节点数. */  
</span><span class='line'>&#9;struct rcu_data __percpu *rda;          /* 指向rcu_data. */  
</span><span class='line'>&#9;void (*call)(struct rcu_head *head,     /* rcu_barrier指向的回调函数. */  
</span><span class='line'>&#9;&#9;&#9;&#9; void (*func)(struct rcu_head *head));  
</span><span class='line'>
</span><span class='line'>&#9;/* The following fields are guarded by the root rcu_node's lock. */  
</span><span class='line'>
</span><span class='line'>&#9;u8      fqs_state ____cacheline_internodealigned_in_smp;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      /* 调用force_quiescent_state时的状态. */  
</span><span class='line'>&#9;u8      fqs_active;                     /* force_quiescent_state() 正在运行*/  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;u8      fqs_need_gp;                    /* 因为 force_quiescent_state() 正在运行*/  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      /* 一个CPU需要运行的宽限期被阻止*/  
</span><span class='line'>
</span><span class='line'>&#9;u8      boost;                          /* 加速. */  
</span><span class='line'>&#9;unsigned long gpnum;                    /* 当前的宽限起数量. */  
</span><span class='line'>&#9;unsigned long completed;                /* # 最后一次完成的宽限期数量. */  
</span><span class='line'>
</span><span class='line'>&#9;/* 以下的成员被根rcu_node的lock保护. */  
</span><span class='line'>
</span><span class='line'>&#9;raw_spinlock_t onofflock;               /* 开始一个新的宽限期的时候，阻止CPU上下线*/  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;struct rcu_head *orphan_nxtlist;        /* 等待宽限期的孤儿回调函数的列表 */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;struct rcu_head **orphan_nxttail;       /* 以上列表的结尾. */  
</span><span class='line'>&#9;struct rcu_head *orphan_donelist;       /* 需要执行的孤儿回调函数列表 */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;struct rcu_head **orphan_donetail;      /* 以上列表的结尾. */  
</span><span class='line'>&#9;long qlen_lazy;                         /* 懒惰回调函数的个数. */  
</span><span class='line'>&#9;long qlen;                              /* 总的回调函数的个数. */  
</span><span class='line'>&#9;struct task_struct *rcu_barrier_in_progress;  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      /* 调用rcu_barrier()的进程, */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      /* 没有的话指向NULL. */  
</span><span class='line'>&#9;struct mutex barrier_mutex;             /* 执行barrier需要的互斥锁. */  
</span><span class='line'>&#9;atomic_t barrier_cpu_count;             /* # 等待barrier的CPU数 . */  
</span><span class='line'>&#9;struct completion barrier_completion;   /* 在barrier结束的时候调用. */  
</span><span class='line'>&#9;unsigned long n_barrier_done;           /* 在_rcu_barrier()开始结束处都需要调用++ */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;raw_spinlock_t fqslock;                 /* 只有一个进程能调用 force_quiescent_state().*/  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;unsigned long jiffies_force_qs;         /* force_quiescent_state()开始的时间 */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;unsigned long n_force_qs;               /* 调用force_quiescent_state()的次数 */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;unsigned long n_force_qs_lh;            /* 因为lock不可用，而退出force_quiescent_state()的次数 */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;unsigned long n_force_qs_ngp;           /* 因为当前有宽限期执行，而退出force_quiescent_state()的次数*/  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;unsigned long gp_start;                 /* 宽限期开始的时间*/  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;unsigned long jiffies_stall;              
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;     
</span><span class='line'>&#9;unsigned long gp_max;                   /*  最长的宽限的jiffie数 */  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;        
</span><span class='line'>&#9;char *name;                             /* 结构的名字. */  
</span><span class='line'>&#9;struct list_head flavors;               /* 系统中的rcu_state. */  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>rcu_state 保存了所有的node，宽限期的判断只要取出根节点，也就是第一个元素就可以。还有一些初始化要用到的变量。还有孤儿回调函数用于处理离线CPU遗留的信息。剩下还有很多统计信息，这些内容在讲解代码实现的时候再仔细考虑。</p>

<hr />

<h3>TREE RCU实现之二 —— 主干函数</h3>

<p>RCU的实现集中在以下几个步骤：<br/>
  1， 调用call_rcu，将回调函数增加到列表。<br/>
  2,   开始一个宽限期。<br/>
  3,   每个CPU报告自己的状态，直到最后一个CPU，结束一个宽限期。<br/>
  4， 宽限期结束，每个CPU处理自己的回调函数。</p>

<h4>call_rcu的实现</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void  
</span><span class='line'>__call_rcu(struct rcu_head *head, void (*func)(struct rcu_head *rcu),  
</span><span class='line'>&#9;   struct rcu_state *rsp, bool lazy)  
</span><span class='line'>{  
</span><span class='line'>&#9;unsigned long flags;  
</span><span class='line'>&#9;struct rcu_data *rdp;  
</span><span class='line'>
</span><span class='line'>&#9;WARN_ON_ONCE((unsigned long)head & 0x3); /* 检测head在内存中是否对齐! */  
</span><span class='line'>&#9;debug_rcu_head_queue(head);  
</span><span class='line'>&#9;head-&gt;func = func;  
</span><span class='line'>&#9;head-&gt;next = NULL;  
</span><span class='line'>
</span><span class='line'>&#9;smp_mb(); /* Ensure RCU update seen before callback registry. */  
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 这是一个检测宽限期开始或者结束的机会。 
</span><span class='line'>&#9; * 当我们看到一个结束的时候，可能还会看到一个开始。 
</span><span class='line'>&#9; * 反过来，看到一个开始的时候，不一定能看到一个结束， 
</span><span class='line'>&#9; * 因为宽限期结束需要一定时间。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;local_irq_save(flags);  
</span><span class='line'>&#9;rdp = this_cpu_ptr(rsp-&gt;rda);  
</span><span class='line'>
</span><span class='line'>&#9;/* 将要增加callback到nxtlist. */  
</span><span class='line'>&#9;ACCESS_ONCE(rdp-&gt;qlen)++;  
</span><span class='line'>&#9;if (lazy)  
</span><span class='line'>&#9;&#9;rdp-&gt;qlen_lazy++;  
</span><span class='line'>&#9;else  
</span><span class='line'>&#9;&#9;rcu_idle_count_callbacks_posted();  
</span><span class='line'>&#9;smp_mb();  /* Count before adding callback for rcu_barrier(). */  
</span><span class='line'>&#9;*rdp-&gt;nxttail[RCU_NEXT_TAIL] = head;  
</span><span class='line'>&#9;rdp-&gt;nxttail[RCU_NEXT_TAIL] = &head-&gt;next;  
</span><span class='line'>
</span><span class='line'>&#9;if (__is_kfree_rcu_offset((unsigned long)func))  
</span><span class='line'>&#9;&#9;trace_rcu_kfree_callback(rsp-&gt;name, head, (unsigned long)func,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; rdp-&gt;qlen_lazy, rdp-&gt;qlen);  
</span><span class='line'>&#9;else  
</span><span class='line'>&#9;&#9;trace_rcu_callback(rsp-&gt;name, head, rdp-&gt;qlen_lazy, rdp-&gt;qlen);  
</span><span class='line'>
</span><span class='line'>&#9;/* 去处理rcu_core。 */  
</span><span class='line'>&#9;__call_rcu_core(rsp, rdp, head, flags);  
</span><span class='line'>&#9;local_irq_restore(flags);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>call_rcu中最主要的工作，就是将回调函数加入到CPU的nxtlist列表。这里用到了指针处理的小技巧，我们来看看。首先看看nxttail的初始化：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void init_callback_list(struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>&#9;int i;  
</span><span class='line'>
</span><span class='line'>&#9;rdp-&gt;nxtlist = NULL;  
</span><span class='line'>&#9;for (i = 0; i &lt; RCU_NEXT_SIZE; i++)  
</span><span class='line'>&#9;&#9;rdp-&gt;nxttail[i] = &rdp-&gt;nxtlist;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>我们看到nxttail的全部成员都指向了nxtlist的地址。当nxtlist为空的时候，也是这个情形。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*rdp-&gt;nxttail[RCU_NEXT_TAIL] = head;       </span></code></pre></td></tr></table></div></figure>


<p>当nxtlist为空的时候， *rdp->nxttail[RCU_NEXT_TAIL] 得到的其实就是nxtlist，将head的值赋予它。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rdp-&gt;nxttail[RCU_NEXT_TAIL] = &head-&gt;next;</span></code></pre></td></tr></table></div></figure>


<p>之后 RCU_NEXT_TAIL指向 head的next指针。这样当再有一个节点加入的时候，*rdp->nxttail[RCU_NEXT_TAIL]得到的其实就是前一次加入的head的next指针，它将指向新加入的值。如此，nxtlist就成为了一个链表。或者这样理解，rdp->nxttail[RCU_NEXT_TAIL] 指向的就是nxtlist中最后一个节点的 next指针。</p>

<p>除了将回调函数插入，该函数其它代码多为检查代码。而最后要调用<code>__call_rcu_core</code>，该函数的功用主要是在回调函数太多或者等待时间过长的状态下，强制执行RCU状态更新。我们暂时不关注。</p>

<p>开始一个宽限期</p>

<p>在一个宽限期结束，或者当一个CPU检测到自身有需要一个宽限期的时候会开始一个新的宽限期，开始宽限期的代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void  
</span><span class='line'>rcu_start_gp(struct rcu_state *rsp, unsigned long flags)  
</span><span class='line'>&#9;__releases(rcu_get_root(rsp)-&gt;lock)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct rcu_data *rdp = this_cpu_ptr(rsp-&gt;rda);  
</span><span class='line'>&#9;struct rcu_node *rnp = rcu_get_root(rsp);  
</span><span class='line'>
</span><span class='line'>&#9;if (!rcu_scheduler_fully_active ||  
</span><span class='line'>&#9;&#9;&#9;!cpu_needs_another_gp(rsp, rdp)) {  
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * 如果scheduler 还没有启动non-idle任务 
</span><span class='line'>&#9;&#9; * 或者不需要启动一个新的宽限期则退出。 
</span><span class='line'>&#9;&#9; * 需要再次判断cpu_needs_another_gp， 
</span><span class='line'>&#9;&#9; * 是因为可能有多个CPU执行这个过程。 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;raw_spin_unlock_irqrestore(&rnp-&gt;lock, flags);  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;if (rsp-&gt;fqs_active) {  
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * 这个CPU需要一个宽限期，而force_quiescent_state() 
</span><span class='line'>&#9;&#9; * 正在运行，告诉它开始一个。 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;rsp-&gt;fqs_need_gp = 1;  
</span><span class='line'>&#9;&#9;raw_spin_unlock_irqrestore(&rnp-&gt;lock, flags);  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;/* 开始一个新的宽限期并且初始化。 */  
</span><span class='line'>&#9;rsp-&gt;gpnum++;  
</span><span class='line'>&#9;trace_rcu_grace_period(rsp-&gt;name, rsp-&gt;gpnum, "start");  
</span><span class='line'>&#9;WARN_ON_ONCE(rsp-&gt;fqs_state == RCU_GP_INIT);  
</span><span class='line'>&#9;rsp-&gt;fqs_state = RCU_GP_INIT; /* 阻止 force_quiescent_state。 */  
</span><span class='line'>&#9;rsp-&gt;jiffies_force_qs = jiffies + RCU_JIFFIES_TILL_FORCE_QS;  
</span><span class='line'>&#9;record_gp_stall_check_time(rsp);  
</span><span class='line'>&#9;raw_spin_unlock(&rnp-&gt;lock);  /* leave irqs disabled. */  
</span><span class='line'>
</span><span class='line'>&#9;/* 排除CPU的热插拔。*/  
</span><span class='line'>&#9;raw_spin_lock(&rsp-&gt;onofflock);  /* irqs already disabled. */  
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 从父节点开始以广度优先的方式，遍历所有的节点，设置qsmask的值， 
</span><span class='line'>&#9; * 所有在线CPU所在bit都将被设置成1。 
</span><span class='line'>&#9; * 通过遍历rsp-&gt;node[]数组就可以达到这个目的。 
</span><span class='line'>&#9; * 其它CPU在自己所属的节点还没有被设置前，只有可能访问这个节点， 
</span><span class='line'>&#9; * 因为它所作的判断是宽限期还没有开始。 
</span><span class='line'>&#9; * 此外，我们排除了CPU热插拔。 
</span><span class='line'>&#9; *  
</span><span class='line'>&#9; * 直到初始化过程完成之前，这个宽限期不可能完成，因为至少当前的 
</span><span class='line'>&#9; * CPU所属的bit将不会被设置。这个是因为我们启动了禁止中断，所以 
</span><span class='line'>&#9; * 这个CPU不会调用到宽限期检测代码。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;rcu_for_each_node_breadth_first(rsp, rnp) {  
</span><span class='line'>&#9;&#9;raw_spin_lock(&rnp-&gt;lock);      /* irqs already disabled. */  
</span><span class='line'>&#9;&#9;rcu_preempt_check_blocked_tasks(rnp);  
</span><span class='line'>&#9;&#9;rnp-&gt;qsmask = rnp-&gt;qsmaskinit;  
</span><span class='line'>&#9;&#9;rnp-&gt;gpnum = rsp-&gt;gpnum;  
</span><span class='line'>&#9;&#9;rnp-&gt;completed = rsp-&gt;completed;  
</span><span class='line'>&#9;&#9;if (rnp == rdp-&gt;mynode)  
</span><span class='line'>&#9;&#9;&#9;rcu_start_gp_per_cpu(rsp, rnp, rdp);  
</span><span class='line'>&#9;&#9;rcu_preempt_boost_start_gp(rnp);  
</span><span class='line'>&#9;&#9;trace_rcu_grace_period_init(rsp-&gt;name, rnp-&gt;gpnum,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;rnp-&gt;level, rnp-&gt;grplo,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;rnp-&gt;grphi, rnp-&gt;qsmask);  
</span><span class='line'>&#9;&#9;raw_spin_unlock(&rnp-&gt;lock);    /* irqs remain disabled. */  
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;rnp = rcu_get_root(rsp);  
</span><span class='line'>&#9;raw_spin_lock(&rnp-&gt;lock);              /* irqs already disabled. */  
</span><span class='line'>&#9;rsp-&gt;fqs_state = RCU_SIGNAL_INIT; /* force_quiescent_state now OK. */  
</span><span class='line'>&#9;raw_spin_unlock(&rnp-&gt;lock);            /* irqs remain disabled. */  
</span><span class='line'>&#9;raw_spin_unlock_irqrestore(&rsp-&gt;onofflock, flags);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>标记一个新的宽限期开始，rcu_state要做的就是将gp_num加1。然后再设置所有node，qsmask被设置成qsmasinit，qsmask每个bit代表一个CPU，所有在线的CPU都将被设置成1；gpnum将被设置成新值。嗯，一个新宽限期的开始只需要设置这些标记位。</p>

<h4>CPU的宽限期检测</h4>

<p>当一个宽限期开始后，每个CPU都需要检测自己的状态，如果已经通过静止状态，那么就向上一级node进行报告。</p>

<p>这个处理过程，可以分为两个步骤：<br/>
  1， 检测新的处理过程开始，设置rcu_data中的gpnum和passed_quiesce，另外用qs_pending标记一个待处理的新宽限期的开始。<br/>
  2， 一个静止状态结束，向上一级node报告这个过程。</p>

<p>这两个过程通过rcu_check_quiescent_state()来实现，需要注意的是这个函数隔一段时间调用一次，并不只调用一次。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 
</span><span class='line'>* 检测这个CPU是否还不知道一个新宽限期开始，如果是设置它的变量。 
</span><span class='line'>* 否则检查它是不是第一次通过静止状态，如果是，向上报告。 
</span><span class='line'>*/  
</span><span class='line'>static void  
</span><span class='line'>rcu_check_quiescent_state(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>&#9;/* 如果有新的宽限期开始，记录它并返回。*/  
</span><span class='line'>&#9;if (check_for_new_grace_period(rsp, rdp))  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 这个CPU是否已经处理过它的宽限期?如果是返回。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (!rdp-&gt;qs_pending)  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 是否通过了静止状态？如果没有，返回。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (!rdp-&gt;passed_quiesce)  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 向所属的node报告。(但rcu_report_qs_rdp() 仍然会去判断它)。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;rcu_report_qs_rdp(rdp-&gt;cpu, rsp, rdp, rdp-&gt;passed_quiesce_gpnum);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h6>A， CPU检测新宽限期的开始</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*  
</span><span class='line'> * 为当前CPU，更新rcu_data的状态，去标记一个新宽限期的开始 
</span><span class='line'> * 如果当前CPU启动了一个宽限期或者检测到一个新的宽限期开始， 
</span><span class='line'> * 都需要调用这个函数。这个过程必须锁定父节点的lock，另外需 
</span><span class='line'> * 要禁止中断 
</span><span class='line'> */  
</span><span class='line'>static void __note_new_gpnum(struct rcu_state *rsp, struct rcu_node *rnp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>&#9;if (rdp-&gt;gpnum != rnp-&gt;gpnum) {  
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * 如果当前的宽限期需要处理这个CPU的状态，设置并 
</span><span class='line'>&#9;&#9; * 去检测它的静止状态。否则不要去管它。 
</span><span class='line'>&#9;&#9; */          
</span><span class='line'>&#9;&#9;rdp-&gt;gpnum = rnp-&gt;gpnum;  
</span><span class='line'>&#9;&#9;trace_rcu_grace_period(rsp-&gt;name, rdp-&gt;gpnum, "cpustart");  
</span><span class='line'>&#9;&#9;if (rnp-&gt;qsmask & rdp-&gt;grpmask) {  
</span><span class='line'>&#9;&#9;&#9;rdp-&gt;qs_pending = 1;  
</span><span class='line'>&#9;&#9;&#9;rdp-&gt;passed_quiesce = 0;  
</span><span class='line'>&#9;&#9;} else {  
</span><span class='line'>&#9;&#9;&#9;rdp-&gt;qs_pending = 0;  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;&#9;zero_cpu_stall_ticks(rdp);  
</span><span class='line'>&#9;}  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>static void note_new_gpnum(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>&#9;unsigned long flags;  
</span><span class='line'>&#9;struct rcu_node *rnp;  
</span><span class='line'>
</span><span class='line'>&#9;local_irq_save(flags);  
</span><span class='line'>&#9;rnp = rdp-&gt;mynode;  
</span><span class='line'>&#9;if (rdp-&gt;gpnum == ACCESS_ONCE(rnp-&gt;gpnum) || /* outside lock. */  
</span><span class='line'>&#9;&#9;&#9;!raw_spin_trylock(&rnp-&gt;lock)) { /* irqs already off, so later. */  
</span><span class='line'>&#9;&#9;local_irq_restore(flags);  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;__note_new_gpnum(rsp, rnp, rdp);  
</span><span class='line'>&#9;raw_spin_unlock_irqrestore(&rnp-&gt;lock, flags);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * 在我们的上次检测之后，其它CPU启动了一个新的宽限期？ 
</span><span class='line'> * 如果是更新相应的rcu_data的状态。 
</span><span class='line'> * 必须是在rdp对应的CPU上执行。 
</span><span class='line'> */  
</span><span class='line'>static int  
</span><span class='line'>check_for_new_grace_period(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>&#9;unsigned long flags;  
</span><span class='line'>&#9;int ret = 0;  
</span><span class='line'>
</span><span class='line'>&#9;local_irq_save(flags);  
</span><span class='line'>&#9;if (rdp-&gt;gpnum != rsp-&gt;gpnum) {  
</span><span class='line'>&#9;&#9;note_new_gpnum(rsp, rdp);  
</span><span class='line'>&#9;&#9;ret = 1;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;local_irq_restore(flags);  
</span><span class='line'>&#9;return ret;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>check_for_new_grace_period 和 note_new_gpnum分别用来检测rdp的gpnum与rsp已经对应的rnp的值是否相同，来确定是否有一个新的宽限期开始。之所以需要检测两次，是因为在rsp设置以后，rnp可能并没有设置完成。</p>

<p><code>__note_new_gpnum</code> 将设置gpnum的值。另外设置 qs_pending为1，该标记位代表该节点还没有向父节点报告自己的状态；passed_quiesce为0，表示需要一个静止状态，设置该位是因为下次调用rcu_check_quiescent_state()可能是在一个读过程还没有结束的时候。</p>

<p>qs_pending的状态有可能为0，这只在以下情形下出现：当前CPU在宽限期开始的时候实在离线状态，而现在变成了在线。</p>

<p>我们注意到在 check_for_new_grace_period检测到有新的宽限期开始后，rcu_check_quiescent_state将直接返回，因为这个宽限期可能是在该CPU的上一个静止状态之前已经开始，所以需要等待下一个静止状态。</p>

<h6>B，CPU报告静止状态</h6>

<p>当再一次调用到rcu_check_quiescent_state()的时候，check_for_new_grace_period()将返回FALSE，接着运行后面的函数来判断 qs_pending 和 passed_quiesce 的值来决定是否调用rcu_report_qs_rdp。需要判断qs_peding是因为当这次rcu_report_qs_rdp调用成功的时候，下次再运行rcu_check_quiescent_state()则不需要继续运行后续函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void  
</span><span class='line'>rcu_report_qs_rdp(int cpu, struct rcu_state *rsp, struct rcu_data *rdp, long lastgp)  
</span><span class='line'>{  
</span><span class='line'>&#9;unsigned long flags;  
</span><span class='line'>&#9;unsigned long mask;  
</span><span class='line'>&#9;struct rcu_node *rnp;  
</span><span class='line'>
</span><span class='line'>&#9;rnp = rdp-&gt;mynode;  
</span><span class='line'>&#9;raw_spin_lock_irqsave(&rnp-&gt;lock, flags);  
</span><span class='line'>&#9;if (lastgp != rnp-&gt;gpnum || rnp-&gt;completed == rnp-&gt;gpnum) {  
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * 如果宽限期的处理已经完成，那么返回。 
</span><span class='line'>&#9;&#9; */          
</span><span class='line'>&#9;&#9;rdp-&gt;passed_quiesce = 0; /* need qs for new gp. */  
</span><span class='line'>&#9;&#9;raw_spin_unlock_irqrestore(&rnp-&gt;lock, flags);  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;mask = rdp-&gt;grpmask;  
</span><span class='line'>&#9;if ((rnp-&gt;qsmask & mask) == 0) {  
</span><span class='line'>&#9;&#9;raw_spin_unlock_irqrestore(&rnp-&gt;lock, flags);  
</span><span class='line'>&#9;} else {  
</span><span class='line'>&#9;&#9;rdp-&gt;qs_pending = 0;  
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; *  可以确定这个宽限期还没有结束，所以可以确定当前CPU上的 
</span><span class='line'>&#9;&#9; *  所有回调函数可以在下次宽限期结束后处理。 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;rdp-&gt;nxttail[RCU_NEXT_READY_TAIL] = rdp-&gt;nxttail[RCU_NEXT_TAIL];  
</span><span class='line'>
</span><span class='line'>&#9;&#9;rcu_report_qs_rnp(mask, rsp, rnp, flags); /* rlses rnp-&gt;lock */  
</span><span class='line'>&#9;}  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>从我看来，这个函数只会调用到最后一个else分支，而之前的连个if分支都不会调用到。因为在调用该函数前，代码已经做了必要的检测。</p>

<p>以此来看，这个函数的功用就是设置qs_pending的值，阻止这次宽限期没有完成之前再次调用掉该函数；设置nxttail，决定下次宽限期后可以执行的回调函数；然后向父节点报告静止状态完成。</p>

<h6>C，向上报告</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void  
</span><span class='line'>rcu_report_qs_rnp(unsigned long mask, struct rcu_state *rsp,  
</span><span class='line'>&#9;  struct rcu_node *rnp, unsigned long flags)  
</span><span class='line'>&#9;__releases(rnp-&gt;lock)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct rcu_node *rnp_c;  
</span><span class='line'>
</span><span class='line'>&#9;/* 向上遍历所有层级 */  
</span><span class='line'>&#9;for (;;) {  
</span><span class='line'>&#9;&#9;if (!(rnp-&gt;qsmask & mask)) {  
</span><span class='line'>&#9;&#9;&#9;/* 这个CPU的标记已经被清除，证明已经处理过了，返回 */  
</span><span class='line'>&#9;&#9;&#9;raw_spin_unlock_irqrestore(&rnp-&gt;lock, flags);  
</span><span class='line'>&#9;&#9;&#9;return;  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;&#9;rnp-&gt;qsmask &= ~mask;  
</span><span class='line'>&#9;&#9;trace_rcu_quiescent_state_report(rsp-&gt;name, rnp-&gt;gpnum,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; mask, rnp-&gt;qsmask, rnp-&gt;level,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; rnp-&gt;grplo, rnp-&gt;grphi,  
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; !!rnp-&gt;gp_tasks);  
</span><span class='line'>&#9;&#9;if (rnp-&gt;qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {  
</span><span class='line'>&#9;&#9;&#9;/* 这个节点中还有其它CPU没有处理完成，那么返回 */  
</span><span class='line'>&#9;&#9;&#9;raw_spin_unlock_irqrestore(&rnp-&gt;lock, flags);  
</span><span class='line'>&#9;&#9;&#9;return;  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;&#9;mask = rnp-&gt;grpmask;  
</span><span class='line'>&#9;&#9;if (rnp-&gt;parent == NULL) {  
</span><span class='line'>&#9;&#9;&#9;/* 到这儿，已经到了根节点 */  
</span><span class='line'>&#9;&#9;&#9;break;  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;&#9;raw_spin_unlock_irqrestore(&rnp-&gt;lock, flags);  
</span><span class='line'>&#9;&#9;rnp_c = rnp;  
</span><span class='line'>&#9;&#9;rnp = rnp-&gt;parent;  
</span><span class='line'>&#9;&#9;raw_spin_lock_irqsave(&rnp-&gt;lock, flags);  
</span><span class='line'>&#9;&#9;WARN_ON_ONCE(rnp_c-&gt;qsmask);  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; *  程序运行到这儿，说明所有的CPU都通过了宽限期， 
</span><span class='line'>&#9; *  那么调用rcu_report_qs_rsp()来结束这个宽限期。 
</span><span class='line'>&#9; */   
</span><span class='line'>&#9;rcu_report_qs_rsp(rsp, flags); /* releases rnp-&gt;lock. */  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>这个过程并不复杂，清理rnp中qsmask对应该CPU的bit。然后判断该节点是否处理完成，如果是则继续向上调用，否则就退出函数。最后一个CPU调用后，可以调用到rcu_report_qs_rsp()。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void rcu_report_qs_rsp(struct rcu_state *rsp, unsigned long flags)  
</span><span class='line'>&#9;__releases(rcu_get_root(rsp)-&gt;lock)  
</span><span class='line'>{  
</span><span class='line'>&#9;unsigned long gp_duration;  
</span><span class='line'>&#9;struct rcu_node *rnp = rcu_get_root(rsp);  
</span><span class='line'>&#9;struct rcu_data *rdp = this_cpu_ptr(rsp-&gt;rda);  
</span><span class='line'>
</span><span class='line'>&#9;WARN_ON_ONCE(!rcu_gp_in_progress(rsp));  
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * Ensure that all grace-period and pre-grace-period activity 
</span><span class='line'>&#9; * is seen before the assignment to rsp-&gt;completed. 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;smp_mb(); /* See above block comment. */  
</span><span class='line'>&#9;gp_duration = jiffies - rsp-&gt;gp_start;  
</span><span class='line'>&#9;if (gp_duration &gt; rsp-&gt;gp_max)  
</span><span class='line'>&#9;&#9;rsp-&gt;gp_max = gp_duration;  
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 当前CPU知道宽限期已经结束，不过其它CPU都认为它还在运行。 
</span><span class='line'>&#9; * 由于completed还没有设置，其它CPU都不会对父node进行处理。 
</span><span class='line'>&#9; * 所以这时候将各个node标记为完成是安全的。 
</span><span class='line'>&#9; *  
</span><span class='line'>&#9; * 不过当前CPU有等待下一次宽限期的回调函数的时候，我们会 
</span><span class='line'>&#9; * 先去处理下一个宽限期。 
</span><span class='line'>&#9; * 这儿使用RCU_WAIT_TAIL代替了RCU_DONE_TAIL，这是因为当前 
</span><span class='line'>&#9; * CPU还没有进一步处理完成状态，当前RCU_WAIT_TAIL状态的元 
</span><span class='line'>&#9; * 素其实在这次宽限期结束后，已经可以执行了。 
</span><span class='line'>&#9; *  
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (*rdp-&gt;nxttail[RCU_WAIT_TAIL] == NULL) {  
</span><span class='line'>&#9;&#9;raw_spin_unlock(&rnp-&gt;lock);  /* irqs remain disabled. */  
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * 设置 rnp-&gt;completed的值，避免这个过程要等到下一次宽限期开始。          
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;rcu_for_each_node_breadth_first(rsp, rnp) {  
</span><span class='line'>&#9;&#9;&#9;raw_spin_lock(&rnp-&gt;lock); /* irqs already disabled. */  
</span><span class='line'>&#9;&#9;&#9;rnp-&gt;completed = rsp-&gt;gpnum;  
</span><span class='line'>&#9;&#9;&#9;raw_spin_unlock(&rnp-&gt;lock); /* irqs remain disabled. */  
</span><span class='line'>&#9;&#9;}  
</span><span class='line'>&#9;&#9;rnp = rcu_get_root(rsp);  
</span><span class='line'>&#9;&#9;raw_spin_lock(&rnp-&gt;lock); /* irqs already disabled. */  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;rsp-&gt;completed = rsp-&gt;gpnum;  /* Declare the grace period complete. */  
</span><span class='line'>&#9;trace_rcu_grace_period(rsp-&gt;name, rsp-&gt;completed, "end");  
</span><span class='line'>&#9;rsp-&gt;fqs_state = RCU_GP_IDLE;  
</span><span class='line'>&#9;rcu_start_gp(rsp, flags);  /* releases root node's rnp-&gt;lock. */  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>这个过程最主要的内容就是设置rsp->completed的值，中间多了对node的处理。因为在rcu_start_gp中也会对node进行处理，当前CPU无法判断其它CPU是否需要一个宽限期，但它自身还有等待宽限期的回调函数的时候，它确定会有一个新的宽限期马上开始，所以忽略这个过程。</p>

<h5>CPU的宽限期结束处理</h5>

<p>这个过程也可以分为两个步骤，第一步是检查宽限期是否结束，第二步是调用已完成的回调函数。</p>

<h6>A, CPU检测宽限期的结束</h6>

<p>每个CPU都会定期检查当前的宽限期是否结束，如果结束将处理自身状态已经nxtlist表。rcu_process_gp_end就是用来做这个事情:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void  
</span><span class='line'>rcu_process_gp_end(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>&#9;unsigned long flags;  
</span><span class='line'>&#9;struct rcu_node *rnp;  
</span><span class='line'>
</span><span class='line'>&#9;local_irq_save(flags);  
</span><span class='line'>&#9;rnp = rdp-&gt;mynode;  
</span><span class='line'>&#9;if (rdp-&gt;completed == ACCESS_ONCE(rnp-&gt;completed) || /* outside lock. */  
</span><span class='line'>&#9;&#9;&#9;!raw_spin_trylock(&rnp-&gt;lock)) { /* irqs already off, so later. */  
</span><span class='line'>&#9;&#9;local_irq_restore(flags);  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;__rcu_process_gp_end(rsp, rnp, rdp);  
</span><span class='line'>&#9;raw_spin_unlock_irqrestore(&rnp-&gt;lock, flags);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>当 rdp->completed与rnp->completed的值不同的时候，会调用<code>__rcu_process_gp_end</code>来完成具体的工作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void  
</span><span class='line'>__rcu_process_gp_end(struct rcu_state *rsp, struct rcu_node *rnp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>&#9;/* 之前的宽限期是否完成？ */  
</span><span class='line'>&#9;if (rdp-&gt;completed != rnp-&gt;completed) {  
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* 推进回调函数，即使是NULL指针也没关系。 */  
</span><span class='line'>&#9;&#9;rdp-&gt;nxttail[RCU_DONE_TAIL] = rdp-&gt;nxttail[RCU_WAIT_TAIL];  
</span><span class='line'>&#9;&#9;rdp-&gt;nxttail[RCU_WAIT_TAIL] = rdp-&gt;nxttail[RCU_NEXT_READY_TAIL];  
</span><span class='line'>&#9;&#9;rdp-&gt;nxttail[RCU_NEXT_READY_TAIL] = rdp-&gt;nxttail[RCU_NEXT_TAIL];  
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* 更新completed。 */  
</span><span class='line'>&#9;&#9;rdp-&gt;completed = rnp-&gt;completed;  
</span><span class='line'>&#9;&#9;trace_rcu_grace_period(rsp-&gt;name, rdp-&gt;gpnum, "cpuend");  
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;   * 如果当前的CPU在外部的静止的状态（如离线状态）， 
</span><span class='line'>&#9;&#9; * 可能已经错过了其它CPU发起的宽限期。所以需要更 
</span><span class='line'>&#9;&#9; * 新gpnum的值，同时要注意不要错过当前正在运行的 
</span><span class='line'>&#9;&#9; * 宽限期，所以它的值被设置成与rnp-&gt;completed相同， 
</span><span class='line'>&#9;&#9; * 此时rnp-&gt;gpnum 可以已经加1，那么后续的调用 
</span><span class='line'>&#9;&#9; * rcu_check_quiescent_state()会去检测新的宽限期。 
</span><span class='line'>&#9;&#9; */       
</span><span class='line'>&#9;&#9;if (ULONG_CMP_LT(rdp-&gt;gpnum, rdp-&gt;completed))  
</span><span class='line'>&#9;&#9;&#9;rdp-&gt;gpnum = rdp-&gt;completed;  
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * 如果下次的宽限期不需要当前CPU报告静止状态, 
</span><span class='line'>&#9;&#9; * 设置qs_pending为0。 
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;if ((rnp-&gt;qsmask & rdp-&gt;grpmask) == 0)  
</span><span class='line'>&#9;&#9;&#9;rdp-&gt;qs_pending = 0;  
</span><span class='line'>&#9;}  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>这个过程的重点是设置nxttail的值，将根据它来进行下一步的处理。</p>

<h6>B,回调函数的调用</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void rcu_do_batch(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>&#9;unsigned long flags;  
</span><span class='line'>&#9;struct rcu_head *next, *list, **tail;  
</span><span class='line'>&#9;int bl, count, count_lazy, i;  
</span><span class='line'>
</span><span class='line'>&#9;/* 没有回调函数，那么返回。*/  
</span><span class='line'>&#9;if (!cpu_has_callbacks_ready_to_invoke(rdp)) {  
</span><span class='line'>&#9;&#9;trace_rcu_batch_start(rsp-&gt;name, rdp-&gt;qlen_lazy, rdp-&gt;qlen, 0);  
</span><span class='line'>&#9;&#9;trace_rcu_batch_end(rsp-&gt;name, 0, !!ACCESS_ONCE(rdp-&gt;nxtlist),  
</span><span class='line'>&#9;&#9;&#9;&#9;need_resched(), is_idle_task(current),  
</span><span class='line'>&#9;&#9;&#9;&#9;rcu_is_callbacks_kthread());  
</span><span class='line'>&#9;&#9;return;  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 提取回调函数的list，需要禁用中断，以防止调用call_rcu()。  
</span><span class='line'>&#9; */   
</span><span class='line'>&#9;local_irq_save(flags);  
</span><span class='line'>&#9;WARN_ON_ONCE(cpu_is_offline(smp_processor_id()));  
</span><span class='line'>&#9;bl = rdp-&gt;blimit;  
</span><span class='line'>&#9;trace_rcu_batch_start(rsp-&gt;name, rdp-&gt;qlen_lazy, rdp-&gt;qlen, bl);  
</span><span class='line'>&#9;list = rdp-&gt;nxtlist;  
</span><span class='line'>&#9;/*  
</span><span class='line'>&#9; * 已经将list指向了nxtlist，此时将nxtlist指向 *rdp-&gt;nxttail[RCU_DONE_TAIL]。 
</span><span class='line'>&#9; * 由于nxttail指向的是 rcu_head中的next指针的地址，所以此处得到的就是next所 
</span><span class='line'>&#9; * 指向的rcu_head对象。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;rdp-&gt;nxtlist = *rdp-&gt;nxttail[RCU_DONE_TAIL];  
</span><span class='line'>&#9;/*将*rdp-&gt;nxttail[RCU_DONE_TAIL]指向NULL，也就是将list中的最后一个元素的next设置成NULL*/  
</span><span class='line'>&#9;*rdp-&gt;nxttail[RCU_DONE_TAIL] = NULL;  
</span><span class='line'>&#9;/*tail指向list最后一个元素的next指针的地址*/  
</span><span class='line'>&#9;tail = rdp-&gt;nxttail[RCU_DONE_TAIL];  
</span><span class='line'>&#9;/*此时rdp-&gt;nxttail[RCU_DONE_TAIL]指向的内容已经移出，所以让它重新指向nxtlist的地址*/  
</span><span class='line'>&#9;for (i = RCU_NEXT_SIZE - 1; i &gt;= 0; i--)  
</span><span class='line'>&#9;if (rdp-&gt;nxttail[i] == rdp-&gt;nxttail[RCU_DONE_TAIL])  
</span><span class='line'>&#9;&#9;rdp-&gt;nxttail[i] = &rdp-&gt;nxtlist;  
</span><span class='line'>&#9;local_irq_restore(flags);  
</span><span class='line'>
</span><span class='line'>&#9;/* 调用回调函数 */  
</span><span class='line'>&#9;count = count_lazy = 0;  
</span><span class='line'>&#9;while (list) {  
</span><span class='line'>&#9;&#9;next = list-&gt;next;  
</span><span class='line'>&#9;&#9;prefetch(next);  
</span><span class='line'>&#9;&#9;debug_rcu_head_unqueue(list);  
</span><span class='line'>&#9;&#9;if (__rcu_reclaim(rsp-&gt;name, list))  
</span><span class='line'>&#9;&#9;&#9;count_lazy++;  
</span><span class='line'>&#9;&#9;list = next;  
</span><span class='line'>&#9;&#9;/* 当已经全部运行完毕或者CPU有更重要的事情的时候，退出循环。 */  
</span><span class='line'>&#9;&#9;if (++count &gt;= bl &&  
</span><span class='line'>&#9;&#9;&#9;&#9;(need_resched() ||  
</span><span class='line'>&#9;&#9;&#9;&#9;(!is_idle_task(current) && !rcu_is_callbacks_kthread())))  
</span><span class='line'>&#9;&#9;&#9;break;  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;local_irq_save(flags);  
</span><span class='line'>&#9;trace_rcu_batch_end(rsp-&gt;name, count, !!list, need_resched(),  
</span><span class='line'>&#9;&#9;&#9;is_idle_task(current),  
</span><span class='line'>&#9;&#9;&#9;rcu_is_callbacks_kthread());  
</span><span class='line'>
</span><span class='line'>&#9;/* 更新数量。并将没有执行完的回调函数重新放进列表。 */  
</span><span class='line'>&#9;if (list != NULL) {  
</span><span class='line'>&#9;*tail = rdp-&gt;nxtlist;  
</span><span class='line'>&#9;rdp-&gt;nxtlist = list;  
</span><span class='line'>&#9;for (i = 0; i &lt; RCU_NEXT_SIZE; i++)  
</span><span class='line'>&#9;&#9;if (&rdp-&gt;nxtlist == rdp-&gt;nxttail[i])  
</span><span class='line'>&#9;&#9;&#9;rdp-&gt;nxttail[i] = tail;  
</span><span class='line'>&#9;&#9;else  
</span><span class='line'>&#9;&#9;&#9;break;  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;smp_mb(); /* 为了 rcu_barrier()统计运行过的回调函数 */  
</span><span class='line'>&#9;rdp-&gt;qlen_lazy -= count_lazy;  
</span><span class='line'>&#9;ACCESS_ONCE(rdp-&gt;qlen) -= count;  
</span><span class='line'>&#9;rdp-&gt;n_cbs_invoked += count;  
</span><span class='line'>
</span><span class='line'>&#9;/* Reinstate batch limit if we have worked down the excess. */  
</span><span class='line'>&#9;if (rdp-&gt;blimit == LONG_MAX && rdp-&gt;qlen &lt;= qlowmark)  
</span><span class='line'>&#9;&#9;rdp-&gt;blimit = blimit;  
</span><span class='line'>
</span><span class='line'>&#9;/* Reset -&gt;qlen_last_fqs_check trigger if enough CBs have drained. */  
</span><span class='line'>&#9;if (rdp-&gt;qlen == 0 && rdp-&gt;qlen_last_fqs_check != 0) {  
</span><span class='line'>&#9;&#9;rdp-&gt;qlen_last_fqs_check = 0;  
</span><span class='line'>&#9;&#9;rdp-&gt;n_force_qs_snap = rsp-&gt;n_force_qs;  
</span><span class='line'>&#9;} else if (rdp-&gt;qlen &lt; rdp-&gt;qlen_last_fqs_check - qhimark)  
</span><span class='line'>&#9;&#9;rdp-&gt;qlen_last_fqs_check = rdp-&gt;qlen;  
</span><span class='line'>&#9;WARN_ON_ONCE((rdp-&gt;nxtlist == NULL) != (rdp-&gt;qlen == 0));  
</span><span class='line'>
</span><span class='line'>&#9;local_irq_restore(flags);  
</span><span class='line'>
</span><span class='line'>&#9;/* 如果还有回调函数没有执行，通知再次调用软中断 */  
</span><span class='line'>&#9;if (cpu_has_callbacks_ready_to_invoke(rdp))  
</span><span class='line'>&#9;&#9;invoke_rcu_core();  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>rcu_do_batch主要作用是取出nxtlist中，nxttail[RCU_DONE_TAIL]之前的元素，遍历执行它们。这时候销毁过程真正的执行了。这段函数需要仔细想想nxttail的处理。</p>

<p>到此RCU中涉及到的主干函数介绍完了，但是还需要与进程切换等过程交互。将在下节分析它们。</p>

<hr />

<h3>TREE RCU实现之三 —— 定期调用</h3>

<p>上一节，介绍过了RCU实现中用到的主要函数。不过还需要定期的运行这些函数，整个机制才完整。</p>

<p>RCU的实现是通过在update_process_times() 中调用rcu_check_callbacks()来达到这个目的的。每个CPU都会定期的调用update_process_times()。rcu_check_callbacks()会去检查当前的RCU机制中是否有需要处理的内容，如当前CPU需要开启一个新的宽限期，当前CPU上的宽限期还没有处理完成。如果有需要处理的内容，将触发一个软件中断，真正的操作由软件中断触发的rcu_process_callbacks()来完成。</p>

<h4>rcu_check_callbacks</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void rcu_check_callbacks(int cpu, int user)  
</span><span class='line'>{  
</span><span class='line'>&#9;trace_rcu_utilization("Start scheduler-tick");  
</span><span class='line'>&#9;increment_cpu_stall_ticks();  
</span><span class='line'>&#9;if (user || rcu_is_cpu_rrupt_from_idle()) {  
</span><span class='line'>&#9;&#9; /* 
</span><span class='line'>&#9;&#9;  * 如果是从用户模式或者是idle模式调用该函数， 
</span><span class='line'>&#9;&#9;  * 那么这个CPU是静止状态。 
</span><span class='line'>&#9;&#9;  *  
</span><span class='line'>&#9;&#9;  * 此处不需要内存屏障。因为rcu_sched_qs()和 
</span><span class='line'>&#9;&#9;  * and rcu_bh_qs()支处理CPU自身的局部变量， 
</span><span class='line'>&#9;&#9;  * 其它CPU不会访问和修改,至少当CPU在线的时候。 
</span><span class='line'>&#9;&#9;  *  
</span><span class='line'>&#9;&#9;  */                  
</span><span class='line'>&#9;&#9;  rcu_sched_qs(cpu);  
</span><span class='line'>&#9;&#9;  rcu_bh_qs(cpu);          
</span><span class='line'>&#9;} else if (!in_softirq()) {                  
</span><span class='line'>&#9;&#9; /* 
</span><span class='line'>&#9;&#9;  * 运行到这儿，如果不是软件中断。如果当前CPU上运行的 
</span><span class='line'>&#9;&#9;  * 软中断的读过程，肯定已经完成，所以标记它。 
</span><span class='line'>&#9;&#9;  * 
</span><span class='line'>&#9;&#9;  */                 
</span><span class='line'>&#9;&#9; rcu_bh_qs(cpu);  
</span><span class='line'>&#9;}  
</span><span class='line'>&#9;rcu_preempt_check_callbacks(cpu); /*抢先式下的检测*/  
</span><span class='line'>&#9;if (rcu_pending(cpu))  
</span><span class='line'>&#9;&#9;invoke_rcu_core();  
</span><span class='line'>&#9;trace_rcu_utilization("End scheduler-tick");  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>该函数的主要功能是通过 rcu_pending()判断是否当前有需要处理的rcu内容，如果有调用invoke_rcu_core()。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int rcu_pending(int cpu)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct rcu_state *rsp;  
</span><span class='line'>
</span><span class='line'>&#9;for_each_rcu_flavor(rsp)  
</span><span class='line'>&#9;if (__rcu_pending(rsp, per_cpu_ptr(rsp-&gt;rda, cpu)))  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>&#9;return 0;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>rcu_pending会循环所有的rcu_state，在非抢占式模式下，有rcu_sched_state 和rcu_bh_state 两个实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int __rcu_pending(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct rcu_node *rnp = rdp-&gt;mynode;  
</span><span class='line'>
</span><span class='line'>&#9;rdp-&gt;n_rcu_pending++;  
</span><span class='line'>
</span><span class='line'>&#9;/* Check for CPU stalls, if enabled. */  
</span><span class='line'>&#9;check_cpu_stall(rsp, rdp);  
</span><span class='line'>
</span><span class='line'>&#9;/*  是否宽限期在等待这个CPU去完成静止状态呢?  */  
</span><span class='line'>&#9;if (rcu_scheduler_fully_active &&  
</span><span class='line'>&#9;&#9;&#9;rdp-&gt;qs_pending && !rdp-&gt;passed_quiesce) {  
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* 
</span><span class='line'>&#9;&#9; * 如果force_quiescent_state() 需要马上执行，而这个CPU 
</span><span class='line'>&#9;&#9; * 需要一个静止状态，强制执行本地进程切换。       
</span><span class='line'>&#9;&#9; */  
</span><span class='line'>&#9;&#9;rdp-&gt;n_rp_qs_pending++;  
</span><span class='line'>&#9;&#9;if (!rdp-&gt;preemptible &&  
</span><span class='line'>&#9;&#9;&#9;ULONG_CMP_LT(ACCESS_ONCE(rsp-&gt;jiffies_force_qs) - 1,  
</span><span class='line'>&#9;&#9;&#9; jiffies))  
</span><span class='line'>&#9;&#9;set_need_resched();  
</span><span class='line'>&#9;} else if (rdp-&gt;qs_pending && rdp-&gt;passed_quiesce) {  
</span><span class='line'>&#9;&#9;rdp-&gt;n_rp_report_qs++;  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;/* 这个CPU是否有callbacks等着调用? */  
</span><span class='line'>&#9;if (cpu_has_callbacks_ready_to_invoke(rdp)) {  
</span><span class='line'>&#9;&#9;rdp-&gt;n_rp_cb_ready++;  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;/* 当前CPU有需要执行的宽限期，而没有其它的宽限期在执行?  */  
</span><span class='line'>&#9;if (cpu_needs_another_gp(rsp, rdp)) {  
</span><span class='line'>&#9;&#9;rdp-&gt;n_rp_cpu_needs_gp++;  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;/* 另一个CPU上执行的宽限期结束?   */  
</span><span class='line'>&#9;if (ACCESS_ONCE(rnp-&gt;completed) != rdp-&gt;completed) { /* outside lock */  
</span><span class='line'>&#9;&#9;&#9;rdp-&gt;n_rp_gp_completed++;  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;/* 有新的RCU开始? */  
</span><span class='line'>&#9;if (ACCESS_ONCE(rnp-&gt;gpnum) != rdp-&gt;gpnum) { /* outside lock */  
</span><span class='line'>&#9;&#9;&#9;rdp-&gt;n_rp_gp_started++;  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;/* 一个宽限期运行了太长时间，需要强制执行? */  
</span><span class='line'>&#9;if (rcu_gp_in_progress(rsp) &&  
</span><span class='line'>&#9;&#9;&#9;ULONG_CMP_LT(ACCESS_ONCE(rsp-&gt;jiffies_force_qs), jiffies)) {  
</span><span class='line'>&#9;&#9;rdp-&gt;n_rp_need_fqs++;  
</span><span class='line'>&#9;&#9;return 1;  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;/* 无事可做 */  
</span><span class='line'>&#9;rdp-&gt;n_rp_need_nothing++;  
</span><span class='line'>&#9;return 0;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p><code>__rcu_pending</code> 判断了可能存在的各种情形，如果有需要处理的工作的话，就返回1，否则返回0。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void invoke_rcu_core(void)  
</span><span class='line'>{  
</span><span class='line'>&#9;raise_softirq(RCU_SOFTIRQ);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> invoke_rcu_core()的作用是开启软中断。在初始化的时候，系统已经注册了软中断。
</span><span class='line'>
</span><span class='line'>open_softirq(RCU_SOFTIRQ, rcu_process_callbacks);</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void rcu_process_callbacks(struct softirq_action *unused)  
</span><span class='line'>{  
</span><span class='line'>&#9;struct rcu_state *rsp;  
</span><span class='line'>
</span><span class='line'>&#9;trace_rcu_utilization("Start RCU core");  
</span><span class='line'>&#9;for_each_rcu_flavor(rsp)  
</span><span class='line'>&#9;__rcu_process_callbacks(rsp);  
</span><span class='line'>&#9;trace_rcu_utilization("End RCU core");  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void  
</span><span class='line'>__rcu_process_callbacks(struct rcu_state *rsp)  
</span><span class='line'>{  
</span><span class='line'>&#9;unsigned long flags;  
</span><span class='line'>&#9;struct rcu_data *rdp = __this_cpu_ptr(rsp-&gt;rda);  
</span><span class='line'>
</span><span class='line'>&#9;WARN_ON_ONCE(rdp-&gt;beenonline == 0);  
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 如果一个宽限期运行了很长时间，那么强制静止状态。 
</span><span class='line'>&#9; *  
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;if (ULONG_CMP_LT(ACCESS_ONCE(rsp-&gt;jiffies_force_qs), jiffies))  
</span><span class='line'>&#9;&#9;force_quiescent_state(rsp, 1);  
</span><span class='line'>
</span><span class='line'>&#9;/* 
</span><span class='line'>&#9; * 处理宽限期结束相关内容。 
</span><span class='line'>&#9; */  
</span><span class='line'>&#9;rcu_process_gp_end(rsp, rdp);  
</span><span class='line'>
</span><span class='line'>&#9;/* 检测是否有新的宽限期开始或者静止状态需要向上报告。 */  
</span><span class='line'>&#9;rcu_check_quiescent_state(rsp, rdp);  
</span><span class='line'>
</span><span class='line'>&#9;/* 当前CPU需要新的宽限期吗? */  
</span><span class='line'>&#9;if (cpu_needs_another_gp(rsp, rdp)) {  
</span><span class='line'>&#9;&#9;raw_spin_lock_irqsave(&rcu_get_root(rsp)-&gt;lock, flags);  
</span><span class='line'>&#9;&#9;rcu_start_gp(rsp, flags);  /* releases above lock */  
</span><span class='line'>&#9;}  
</span><span class='line'>
</span><span class='line'>&#9;/* 如果有等着调用的回调函数，那么调用它。 */  
</span><span class='line'>&#9;if (cpu_has_callbacks_ready_to_invoke(rdp))  
</span><span class='line'>&#9;&#9;invoke_rcu_callbacks(rsp, rdp);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>软件中断其实就是调用之前提到过的函数来完成具体的任务。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-06-02T17:38:00+08:00'><span class='date'>2015-06-02</span> <span class='time'>17:38:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~base/'>base</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/06/02/kernel-base-rcu-apply/" title="Previous Post: Linux kernel 内存屏障在RCU上的应用">&laquo; Linux kernel 内存屏障在RCU上的应用</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/06/03/kernel-net-mem/" title="Next Post: 内核协议栈tcp层的内存管理">内核协议栈tcp层的内存管理 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
