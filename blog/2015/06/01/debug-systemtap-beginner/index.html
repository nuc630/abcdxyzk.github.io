
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>SystemTap Beginner - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">SystemTap Beginner</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-01T15:03:00+08:00'><span class='date'>2015-06-01</span> <span class='time'>15:03:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.csdn.net/kafeiflynn/article/details/6429976">http://blog.csdn.net/kafeiflynn/article/details/6429976</a></p>

<h3>SystemTap</h3>

<p>应用：</p>

<p>  对管理员，SystemTap可用于监控系统性能，找出系统瓶颈，而对于开发者，可以查看他们的程序运行时在linux系统内核内部的运行情况。主要用于查看内核空间事件信息，对用户空间事件的探测，目前正加紧改进。</p>

<h4>安装</h4>

<p>1、SystemTap的安装及使用需要针对正在使用的内核安装相应的kernel-devel、kernel-debuginfo和kernel-debuginfo-common包，以插入探针。<br/>
2、安装SystemTap和SystemTap-runtime包<br/>
3、使用如下命令测试一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stap -v -e 'probe vfs.read {printf("read performed/n"); exit()}'</span></code></pre></td></tr></table></div></figure>


<p>为目标机产生SystemTap instrumentation:</p>

<p>这样就可以在一台机器上为多种内核产生SystemTap instrumentation，而且目标机上只安装SystemTap-runtime即可。</p>

<p>操作如下：<br/>
1.在目标机上安装systemtap-runtime RPM包；<br/>
2.使用uname –r查看目标机内核；<br/>
3.在host system上安装SystemTap；<br/>
4.在host system上安装目标机内核及相关RPMs<br/>
5.在host name上运行命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stap -r kernel_version script -m module_name</span></code></pre></td></tr></table></div></figure>


<p>6.把新产生的模块拷贝到目标机，并运行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>staprun module_name.ko</span></code></pre></td></tr></table></div></figure>


<p>注意：host system和目标机架构及操作系统版本必须一致。</p>

<h4>运行SystemTap脚本</h4>

<p>运行stap和staprun需要被授以权限，一般用户需要运行SystemTap，则需要被加入到以下用户组的一个：<br/>
1、stapdev：用stap编译SystemTap脚本成内核模块，并加载进内核；<br/>
2、stapusr：仅能运行staprun加载/lib/modules/kernel_version/systemtap/目录下模块。</p>

<h5>SystemTap Flight Recorder模式</h5>

<p>该模式允许长时间运行SystemTap脚本，但仅focus on 最近的输出，有2个变种：in-memory和file模式，两种情况下SystemTap都作为后台进程运行。</p>

<h5>In-memory模式：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stap -F iotime.stp</span></code></pre></td></tr></table></div></figure>


<p>一旦脚本启动后，你可以看到以下输出信息以辅助命令重新连到运行中的脚本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Disconnecting from systemtap module.
</span><span class='line'>To reconnect, type "staprun -A stap_5dd0073edcb1f13f7565d8c343063e68_19556"</span></code></pre></td></tr></table></div></figure>


<p>当感兴趣的事件发生时，可以重新连接到运行中的脚本，并在内存Buffer中输出最近的数据并持续输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>staprun -A stap_5dd0073edcb1f13f7565d8c343063e68_19556</span></code></pre></td></tr></table></div></figure>


<p>内存Buffer默认1MB，可以使用-S选项，例如-S2指定为2MB</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>File Flight Recorder
</span><span class='line'>stap -F -o /tmp/pfaults.log -S 1,2  pfaults.stp</span></code></pre></td></tr></table></div></figure>


<p>命令结果输出到/tmp/pfaults.log.[0-9]，每个文件1MB，并且仅保存最近的两个文件，-S指定了第一个参数：每个输出文件大小1MB，第二个参数：仅保留最近的两个文件，systemtap在pfaults.log后面加.[0-9]后缀。</p>

<p>该命令的输出是systemtap脚本进程ID，使用如下命令可以终止systemtap脚本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>kill -s SIGTERM 7590</span></code></pre></td></tr></table></div></figure>


<p>运行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls –sh /tmp/pfaults.log.*
</span><span class='line'>
</span><span class='line'>1020K /tmp/pfaults.log.5    44K /tmp/pfaults.log.6</span></code></pre></td></tr></table></div></figure>


<h4>SystemTap如何工作</h4>

<p>SystemTap的基本工作原理就是：event/handler，运行systemtap脚本产生的加载模块时刻监控事件的发生，一旦发生，内核就调用相关的handler处理。</p>

<p>一运行一个SystemTap脚本就会产生一个SystemTap session：<br/>
1.SystemTap检查脚本以及所使用的相关tapset库；<br/>
2.SystemTap将脚本转换成C语言文件，并运行C语言编译器编译之创建一个内核模块；<br/>
3.SystemTap加载该模块，从而使用所有探针(events和handlers)；<br/>
4.事件发生时，执行相关handlers<br/>
5.一旦SystemTap session停止，则探针被禁止，该内核模块被卸载。</p>

<p>探针：event及其handler，一个SystemTap脚本可以包含多个探针。</p>

<p>SystemTap脚本以.stp为扩展名，其基本格式如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>probe event {statements}</span></code></pre></td></tr></table></div></figure>


<p>允许一个探针内多个event，以,隔开，任一个event发生时，都会执行statements，各个语句之间不需要特殊的结束符号标记。而且可以在一个statements block中包含其他的statements block。</p>

<p>函数编写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function function_name(arguments) {statements}
</span><span class='line'>
</span><span class='line'>probe event {function_name(arguments)}</span></code></pre></td></tr></table></div></figure>


<h4>SystemTap Event</h4>

<p>可大致划分为synchronous和asynchronous。</p>

<h5>同步事件：</h5>

<p>执行到定位到内核代码中的特定位置时触发event</p>

<p>1.syscall.system_call<br/>
系统调用入口和exit处：syscall.system_call和syscall.system_call.return，比如对于close系统调用：syscall.close和syscall.close.return</p>

<p>2.vfs.file_operation<br/>
vfs.file_operation和vfs.file_operation.return</p>

<p>3.kernel.function(&ldquo;function&rdquo;)<br/>
如：kernel.function(“sys_open”)和kernel.function(“sys_open”).return</p>

<p>可使用*来代表wildcards：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>probe kernel.function("*@net/socket.c") { }
</span><span class='line'>probe kernel.function("*@net/socket.c").return { }</span></code></pre></td></tr></table></div></figure>


<p>代表了net/socket.c中所有函数的入口和exit口。</p>

<p>4.kernel.trace(&ldquo;tracepoint&rdquo;)<br/>
2.6.30及newer为内核中的特定事件定义了instrumentation，入kernel.trace(“kfree_skb”)代表内核中每次网络buffer被释放掉时的event。</p>

<p>5.module(&ldquo;module&rdquo;).function(&ldquo;function&rdquo;)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>probe module("ext3").function("*") { }
</span><span class='line'>probe module("ext3").function("*").return { }</span></code></pre></td></tr></table></div></figure>


<p>系统内核模块多存放在/lib/modules/kernel_version</p>

<h4>Asynchronous Events</h4>

<p>不绑定到内核的特定指令或位置处。包括：<br/>
1、begin：SystemTap session开始时触发，当SystemTap脚本开始运行时触发；<br/>
2、end ：SystemTap session终止时触发；<br/>
3、timer事件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>probe timer.s(4)
</span><span class='line'>{
</span><span class='line'>&#9;printf("hello world/n")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>• timer.ms(milliseconds)<br/>
• timer.us(microseconds)<br/>
• timer.ns(nanoseconds)<br/>
• timer.hz(hertz)<br/>
• timer.jiffies(jiffies)</p>

<p>可查看man stapprobes来查看其它支持的events</p>

<h4>SystemTap Handler/Body</h4>

<p>支持的函数：<br/>
1、  printf (&ldquo;format string/n&rdquo;, arguments)，%s：字符串，%d数字，以 , 隔开；<br/>
2、  tid()：当前线程ID；<br/>
3、  uid()：当前用户ID；<br/>
4、  cpu()：当前CPU号；<br/>
5、  gettimeofday_s()：自从Epoch开始的秒数；<br/>
6、  ctime()将从Unix Epoch开始的秒数转换成date；<br/>
7、  pp()：描述当前被处理的探针点的字符串；<br/>
8、  thread_indent()：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>probe kernel.function("*@net/socket.c")
</span><span class='line'>{
</span><span class='line'>&#9;printf ("%s -&gt; %s/n", thread_indent(1), probefunc())
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>probe kernel.function("*@net/socket.c").return
</span><span class='line'>{
</span><span class='line'>&#9;printf ("%s &lt;- %s/n", thread_indent(-1), probefunc())
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>0 ftp(7223): -&gt; sys_socketcall
</span><span class='line'>1159 ftp(7223):  -&gt; sys_socket
</span><span class='line'>2173 ftp(7223):   -&gt; __sock_create
</span><span class='line'>2286 ftp(7223):    -&gt; sock_alloc_inode
</span><span class='line'>2737 ftp(7223):    &lt;- sock_alloc_inode
</span><span class='line'>3349 ftp(7223):    -&gt; sock_alloc
</span><span class='line'>3389 ftp(7223):    &lt;- sock_alloc
</span><span class='line'>3417 ftp(7223):   &lt;- __sock_create
</span><span class='line'>4117 ftp(7223):   -&gt; sock_create
</span><span class='line'>4160 ftp(7223):   &lt;- sock_create
</span><span class='line'>4301 ftp(7223):   -&gt; sock_map_fd
</span><span class='line'>4644 ftp(7223):    -&gt; sock_map_file
</span><span class='line'>4699 ftp(7223):    &lt;- sock_map_file
</span><span class='line'>4715 ftp(7223):   &lt;- sock_map_fd
</span><span class='line'>4732 ftp(7223):  &lt;- sys_socket
</span><span class='line'>4775 ftp(7223): &lt;- sys_socketcall</span></code></pre></td></tr></table></div></figure>


<p>  函数thread_indent()只有1个参数：代表对线程的”indentation counter”的增减数，即系统调用显示的步数，返回字符串(自从第一次调用thread_indent()以来的描述：进程名(进程ID))</p>

<p>9、name<br/>
标记系统调用的名字，仅用于syscall.system_call中。</p>

<p>10、target()<br/>
与stap script -x process ID or stap script -c command联合使用，如果想在脚本中获得进程ID或命令可以如此做</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>probe syscall.* {
</span><span class='line'>&#9;if (pid() == target())
</span><span class='line'>&#9;&#9;printf("%s/n", name)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>SystemTap Handler构造</h4>

<h5>变量</h5>

<p>1、不必事先声明，直接使用即可，由SystemTap自动判断其属于string还是integer，整数则默认为0，默认在probe中声明的是local变量<br/>
2、在各个probe之间共享的变量使用global声明</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>global count_jiffies, count_ms
</span><span class='line'>probe timer.jiffies(100) { count_jiffies ++ }
</span><span class='line'>probe timer.ms(100) { count_ms ++ }
</span><span class='line'>probe timer.ms(12345)
</span><span class='line'>{
</span><span class='line'>&#9;hz=(1000*count_jiffies) / count_ms
</span><span class='line'>&#9;printf ("jiffies:ms ratio %d:%d =&gt; CONFIG_HZ=%d/n",
</span><span class='line'>&#9;&#9;count_jiffies, count_ms, hz)
</span><span class='line'>&#9;exit()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Target变量</h5>

<p>Probe event可以映射到代码的实际位置，如kernel.function(“function”)、kernel.statement(“statement”)，这允许使用target变量来记录代码中指定位置处可视变量的值。</p>

<p>运行如下命令：可以显示指定vfs_read处可视target变量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stap -L 'kernel.function("vfs_read")'</span></code></pre></td></tr></table></div></figure>


<p>显示</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>kernel.function("vfs_read@fs/read_write.c:277") $file:struct file* $buf:char* $count:size_t
</span><span class='line'>
</span><span class='line'>$pos:loff_t*</span></code></pre></td></tr></table></div></figure>


<p>每个target变量以$开头：变量类型。如果是结构体类型，则SystemTap可以使用->来查看其成员。对基本类型，integer或string，SystemTap有函数可以直接读取address处的值，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 好像有时对于小于8位的函数，会取出8为长度的值
</span><span class='line'>kernel_char(address)
</span><span class='line'>Obtain the character at address from kernel memory.
</span><span class='line'>
</span><span class='line'>kernel_short(address)
</span><span class='line'>Obtain the short at address from kernel memory.
</span><span class='line'>
</span><span class='line'>kernel_int(address)
</span><span class='line'>Obtain the int at address from kernel memory.
</span><span class='line'>
</span><span class='line'>kernel_long(address)
</span><span class='line'>Obtain the long at address from kernel memory
</span><span class='line'>
</span><span class='line'>kernel_string(address)
</span><span class='line'>Obtain the string at address from kernel memory.
</span><span class='line'>
</span><span class='line'>kernel_string_n(address, n)
</span><span class='line'>Obtain the string at address from the kernel memory and limits the string to n bytes.</span></code></pre></td></tr></table></div></figure>


<h5>打印target变量</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$$vars：类似sprintf("parm1=%x ... parmN=%x var1=%x ... varN=%x", parm1, ..., parmN, var1, ..., varN)，目的是打印probe点处的每个变量；
</span><span class='line'>
</span><span class='line'>$$locals：$$vars子集，仅打印local变量；
</span><span class='line'>
</span><span class='line'>$$parms：$$vars子集，仅包含函数参数；
</span><span class='line'>
</span><span class='line'>$$return：仅在return probes存在，类似sprintf("return=%x", $return)，如果没有返回值，则是空串</span></code></pre></td></tr></table></div></figure>


<p>例子如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stap -e 'probe kernel.function("vfs_read") {printf("%s/n", $$parms); exit(); }'</span></code></pre></td></tr></table></div></figure>


<p>函数vfs_read有4个参数：file、buf、count和pos，输出如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>file=0xffff8800b40d4c80 buf=0x7fff634403e0 count=0x2004 pos=0xffff8800af96df48</span></code></pre></td></tr></table></div></figure>


<p>如果你想知道数据结构里面的成员信息，可以在”$$params”后面加一个”$”，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stap -e 'probe kernel.function("vfs_read") {printf("%s/n", $$parms$); exit(); }'</span></code></pre></td></tr></table></div></figure>


<p>输出如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>file={.f_u={...}, .f_path={...}, .f_op=0xffffffffa06e1d80, .f_lock={...}, .f_count={...}, .f_flags=34818, buf="" count=8196 pos=-131938753921208</span></code></pre></td></tr></table></div></figure>


<p>仅一个”$”表示，不展开数据结构域成员，如想展开，则需使用”$$”</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stap -e 'probe kernel.function("vfs_read") {printf("%s/n", parms); exit(); }'</span></code></pre></td></tr></table></div></figure>


<p>输出受限于最大字符串大小：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>file={.f_u={.fu_list={.next=0xffff8801336ca0e8, .prev=0xffff88012ded0840}, .fu_rcuhead={.next=0xffff8801336ca0e8</span></code></pre></td></tr></table></div></figure>


<h5>强制类型转换</h5>

<p>大多数情况下，SystemTap都可以从debuginfo中获得变量类型，但对于代码中void指针则debuginfo中类型信息不可用，同样probe handler里面的类型信息在function里面也不可用，怎么办呢？</p>

<p>SystemTap函数参数使用long来代替typed pointer，SystemTap的@cast操作可以指出对象正确类型：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function task_state:long (task:long)
</span><span class='line'>{
</span><span class='line'>&#9;return @cast(task, "task_struct", "kernel&lt;linux/sched.h&gt;")-&gt;state
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>第一个参数是指向对象的指针， 第二个参数是将该对象(参数1)要强制类型转换成的类型，第三个参数指出类型定义的出处，是可选的。</p>

<h5>检查Target变量可用性</h5>

<p>随着代码运行，变量可能失效，因此需要用@defined来判断该变量是否可用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>probe vm.pagefault = kernel.function("__handle_mm_fault@mm/memory.c") ?,
</span><span class='line'>
</span><span class='line'>kernel.function("handle_mm_fault@mm/memory.c") ?
</span><span class='line'>{
</span><span class='line'>&#9;name = "pagefault"
</span><span class='line'>&#9;write_access = (@defined($flags) ? $flags & FAULT_FLAG_WRITE : $write_access)
</span><span class='line'>&#9;address = $address
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>条件语句</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (condition)
</span><span class='line'>&#9;statement1
</span><span class='line'>else
</span><span class='line'>&#9;statement2</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>global countread, countnonread
</span><span class='line'>probe kernel.function("vfs_read"),kernel.function("vfs_write")
</span><span class='line'>{
</span><span class='line'>&#9;if (probefunc()=="vfs_read")
</span><span class='line'>&#9;&#9;countread ++
</span><span class='line'>&#9;else
</span><span class='line'>&#9;&#9;countnonread ++
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>probe timer.s(5) { exit() }
</span><span class='line'>
</span><span class='line'>probe end
</span><span class='line'>{
</span><span class='line'>&#9;printf("VFS reads total %d/n VFS writes total %d/n", countread, countnonread)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>循环语句</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while (condition)
</span><span class='line'>&#9;statement
</span><span class='line'>
</span><span class='line'>for (initialization; conditional; increment) statement</span></code></pre></td></tr></table></div></figure>


<h5>比较：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>==、&gt;=、&lt;=、!=</span></code></pre></td></tr></table></div></figure>


<h5>命令行参数：</h5>

<p>使用$标志着希望输入的是integer类型命令行参数，@：string</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>probe kernel.function(@1) { }
</span><span class='line'>probe kernel.function(@1).return { }</span></code></pre></td></tr></table></div></figure>


<h4>关联数组</h4>

<p>关联数组一般在multiple probes里面处理，所以必须声明为global，不管是在一个还是多个probes里面用，要读取数组成员值，可以：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>array_name[index_expression]</span></code></pre></td></tr></table></div></figure>


<p>如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>foo["tom"] = 23
</span><span class='line'>foo["dick"] = 24
</span><span class='line'>foo["harry"] = 25</span></code></pre></td></tr></table></div></figure>


<p>一个索引可以包含最多9个索引表达式，用 , 隔开：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>device[pid(),execname(),uid(),ppid(),"W"] = devname</span></code></pre></td></tr></table></div></figure>


<h5>SystemTap的数组操作</h5>

<h6>赋值：</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>array_name[index_expression] = value</span></code></pre></td></tr></table></div></figure>


<p>例子：索引和值可以使用handler function：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>foo[tid()] = gettimeofday_s()</span></code></pre></td></tr></table></div></figure>


<p>每次触发这个语句，多次后就会构成一个关联数组，如果tid()返回值在foo索引中已有一个，则用新值代替旧值。</p>

<h6>读取数组值：</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>delta = gettimeofday_s() - foo[tid()]</span></code></pre></td></tr></table></div></figure>


<p>如果无法找到指定”索引”对应的值，则数组读返回0(int)或null/empty值(string)</p>

<h6>增加关联数组值</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>array_name[index_expression] ++</span></code></pre></td></tr></table></div></figure>


<p>处理数组的多个成员：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>global reads
</span><span class='line'>probe vfs.read
</span><span class='line'>{
</span><span class='line'>&#9;reads[execname()] ++
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>probe timer.s(3)
</span><span class='line'>{
</span><span class='line'>&#9;foreach (count in reads)
</span><span class='line'>&#9;printf("%s : %d /n", count, reads[count])
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个foreach无序打印所有reads数组值，如果想升序/降序，则需要使用升序(+)、降序(-)，也可以限制处理的数组数目：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>probe timer.s(3)
</span><span class='line'>{
</span><span class='line'>&#9;foreach (count in reads- limit 10)
</span><span class='line'>&#9;printf("%s : %d /n", count, reads[count])
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Clearing/Deleting数组和数组成员</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>global reads
</span><span class='line'>probe vfs.read
</span><span class='line'>{
</span><span class='line'>&#9;reads[execname()] ++
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>probe timer.s(3)
</span><span class='line'>{
</span><span class='line'>&#9;foreach (count in reads)
</span><span class='line'>&#9;printf("%s : %d /n", count, reads[count])
</span><span class='line'>
</span><span class='line'>&#9;delete reads
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>使用delete操作来删除数组成员或整个数组。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>global reads, totalreads
</span><span class='line'>probe vfs.read
</span><span class='line'>{
</span><span class='line'>&#9;reads[execname()] ++
</span><span class='line'>&#9;totalreads[execname()] ++
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>probe timer.s(3)
</span><span class='line'>{
</span><span class='line'>&#9;printf("=======/n")
</span><span class='line'>&#9;foreach (count in reads-)
</span><span class='line'>&#9;&#9;printf("%s : %d /n", count, reads[count])
</span><span class='line'>&#9;delete reads
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>probe end
</span><span class='line'>{
</span><span class='line'>&#9;printf("TOTALS/n")
</span><span class='line'>&#9;foreach (total in totalreads-)
</span><span class='line'>&#9;printf("%s : %d /n", total, totalreads[total])
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在if语句中使用数组：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>global reads
</span><span class='line'>probe vfs.read
</span><span class='line'>{
</span><span class='line'>&#9;reads[execname()] ++
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>probe timer.s(3)
</span><span class='line'>{
</span><span class='line'>&#9;printf("=======/n")
</span><span class='line'>&#9;foreach (count in reads-)
</span><span class='line'>&#9;if (reads[count] &gt;= 1024)
</span><span class='line'>&#9;&#9;printf("%s : %dkB /n", count, reads[count]/1024)
</span><span class='line'>&#9;else
</span><span class='line'>&#9;&#9;printf("%s : %dB /n", count, reads[count])
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>检查成员</h5>

<p>可以检查是否一个指定健是数组键值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if([index_expression] in array_name) statement</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>global reads
</span><span class='line'>probe vfs.read
</span><span class='line'>{
</span><span class='line'>&#9;reads[execname()] ++
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>probe timer.s(3)
</span><span class='line'>{
</span><span class='line'>&#9;printf("=======/n")
</span><span class='line'>&#9;foreach (count in reads+)
</span><span class='line'>&#9;&#9;printf("%s : %d /n", count, reads[count])
</span><span class='line'>&#9;if(["stapio"] in reads) {
</span><span class='line'>&#9;&#9;printf("stapio read detected, exiting/n")
</span><span class='line'>&#9;&#9;exit()
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>计算统计集合</h5>

<p>统计集合用于收集数值的统计信息，用于计算新值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>global reads
</span><span class='line'>probe vfs.read
</span><span class='line'>{
</span><span class='line'>&#9;reads[execname()] &lt;&lt;&lt; count
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>操作符&lt;&lt;&lt;用于将count返回的值存放在read数组中execname()相关的值中，即一个键值关联多个相关值。</p>

<p>为计算统计信息，使用@extractor(variable/array index expression)，extractor可以是如下integer extractor：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>count：@count(writes[execname()])返回存放在writes数组中某单一键值对应的值数目；
</span><span class='line'>sum：@sum(writes[execname()])返回在writes数组中某单一键值对应的值的和
</span><span class='line'>min：最小值
</span><span class='line'>max：最大值
</span><span class='line'>avg：variable/array作为索引的统计集合中数据的平均值</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>global reads
</span><span class='line'>probe vfs.read
</span><span class='line'>{
</span><span class='line'>&#9;reads[execname(),pid()] &lt;&lt;&lt; 1
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>probe timer.s(3)
</span><span class='line'>{
</span><span class='line'>&#9;foreach([var1,var2] in reads)
</span><span class='line'>&#9;printf("%s (%d) : %d /n", var1, var2, @count(reads[var1,var2]))
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Tapsets</h4>

<p>Tapsets是脚本库，里面预写好了probes和functions可以被SystemTap脚本调用，tapsets也使用.stp作为后缀，默认位于：/usr/share/systemtap/tapset，但无法直接运行。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-06-01T15:03:00+08:00'><span class='date'>2015-06-01</span> <span class='time'>15:03:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/debug/'>debug</a>, <a class='category' href='/blog/cats/debug~systemtap/'>systemtap</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/06/01/kernel-net-shark-hand/" title="Previous Post: TCP三次握手源码详解">&laquo; TCP三次握手源码详解</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/06/01/debug-systemtap-with-c/" title="Next Post: SystemTap---嵌入C代码">SystemTap---嵌入C代码 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
