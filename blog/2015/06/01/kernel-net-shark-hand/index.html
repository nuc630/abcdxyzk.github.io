
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>TCP三次握手源码详解 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>学习中......</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">TCP三次握手源码详解</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-01T14:24:00+08:00'><span class='date'>2015-06-01</span> <span class='time'>14:24:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.csdn.net/qy532846454/article/details/7882819">http://blog.csdn.net/qy532846454/article/details/7882819</a></p>

<p><a href="http://m.bianceng.cn/OS/Linux/201301/35179_6.htm">http://m.bianceng.cn/OS/Linux/201301/35179_6.htm</a></p>

<p>内核：2.6.34</p>

<p>TCP是应用最广泛的传输层协议，其提供了面向连接的、可靠的字节流服务，但也正是因为这些特性，使得TCP较之UDP异常复杂，还是分两部分[创建与使用]来进行分析。这篇主要包括TCP的创建及三次握手的过程。</p>

<p>编程时一般用如下语句创建TCP Socket：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>socket(AF_INET, SOCK_DGRAM, IPPROTO_TCP)  </span></code></pre></td></tr></table></div></figure>


<p>由此开始分析，调用接口[net/socket.c]: SYSCALL_DEFINE3(socket)</p>

<p>其中执行两步关键操作：sock_create()与sock_map_fd()</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>retval = sock_create(family, type, protocol, &sock);  
</span><span class='line'>if (retval &lt; 0)  
</span><span class='line'>    goto out;  
</span><span class='line'>retval = sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));  
</span><span class='line'>if (retval &lt; 0)  
</span><span class='line'>    goto out_release;  </span></code></pre></td></tr></table></div></figure>


<p>  sock_create()用于创建socket，sock_map_fd()将之映射到文件描述符，使socket能通过fd进行访问，着重分析sock_create()的创建过程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sock_create() -&gt; __sock_create()</span></code></pre></td></tr></table></div></figure>


<p>  从__sock_create()代码看到创建包含两步：sock_alloc()和pf->create()。sock_alloc()分配了sock内存空间并初始化inode；pf->create()初始化了sk。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sock = sock_alloc();  
</span><span class='line'>sock-&gt;type = type;  
</span><span class='line'>……  
</span><span class='line'>pf = rcu_dereference(net_families[family]);  
</span><span class='line'>……  
</span><span class='line'>pf-&gt;create(net, sock, protocol, kern);  </span></code></pre></td></tr></table></div></figure>


<h4>sock_alloc()</h4>

<p>  分配空间，通过new_inode()分配了节点(包括socket)，然后通过SOCKET_I宏获得sock，实际上inode和sock是在new_inode()中一起分配的，结构体叫作sock_alloc。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inode = new_inode(sock_mnt-&gt;mnt_sb);  
</span><span class='line'>sock = SOCKET_I(inode);  </span></code></pre></td></tr></table></div></figure>


<p>  设置inode的参数，并返回sock。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO;  
</span><span class='line'>inode-&gt;i_uid = current_fsuid();  
</span><span class='line'>inode-&gt;i_gid = current_fsgid();  
</span><span class='line'>return sock;  </span></code></pre></td></tr></table></div></figure>


<p>  继续往下看具体的创建过程：new_inode()，在分配后，会设置i_ino和i_state的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct inode *new_inode(struct super_block *sb)  
</span><span class='line'>{  
</span><span class='line'>    ……  
</span><span class='line'>    inode = alloc_inode(sb);  
</span><span class='line'>    if (inode) {  
</span><span class='line'>        spin_lock(&inode_lock);  
</span><span class='line'>        __inode_add_to_lists(sb, NULL, inode);  
</span><span class='line'>        inode-&gt;i_ino = ++last_ino;  
</span><span class='line'>        inode-&gt;i_state = 0;  
</span><span class='line'>        spin_unlock(&inode_lock);  
</span><span class='line'>    }  
</span><span class='line'>    return inode;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>  其中的alloc_inode() -> sb->s_op->alloc_inode()，sb是sock_mnt->mnt_sb，所以alloc_inode()指向的是sockfs的操作函数sock_alloc_inode。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const struct super_operations sockfs_ops = {  
</span><span class='line'>    .alloc_inode = sock_alloc_inode,  
</span><span class='line'>    .destroy_inode =sock_destroy_inode,  
</span><span class='line'>    .statfs = simple_statfs,  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>  sock_alloc_inode()中通过kmem_cache_alloc()分配了struct socket_alloc结构体大小的空间，而struct socket_alloc结构体定义如下，但只返回了inode，实际上socket和inode都已经分配了空间，在之后就可以通过container_of取到socket。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct inode *sock_alloc_inode(struct super_block *sb)  
</span><span class='line'>{  
</span><span class='line'>    struct socket_alloc *ei;  
</span><span class='line'>    ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);  
</span><span class='line'>    ......  
</span><span class='line'>    return &ei-&gt;vfs_inode;  
</span><span class='line'>}  
</span><span class='line'>struct socket_alloc {  
</span><span class='line'>    struct socket socket;  
</span><span class='line'>    struct inode vfs_inode;  
</span><span class='line'>};  
</span><span class='line'>
</span><span class='line'>net_families[AF_INET]:  
</span><span class='line'>static const struct net_proto_family inet_family_ops = {  
</span><span class='line'>    .family = PF_INET,  
</span><span class='line'>    .create = inet_create,  
</span><span class='line'>    .owner = THIS_MODULE,  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>err = pf->create(net, sock, protocol, kern); ==> inet_create()
这段代码就是从inetsw[]中取到适合的协议类型answer，sock->type就是传入socket()函数的type参数SOCK_DGRAM，最终取得结果answer->ops==inet_stream_ops，从上面这段代码还可以看出以下问题：</p>

<p>  socket(AF_INET, SOCK_RAW, IPPROTO_IP)这样是不合法的，因为SOCK_RAW没有默认的协议类型；同样socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)与socket(AF_INET, SOCK_DGRAM, IPPROTO_TCP)是一样的，因为TCP的默认协议类型是IPPTOTO_TCP；SOCK_STREAM与IPPROTO_UDP同上。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sock-&gt;state = SS_UNCONNECTED;  
</span><span class='line'>list_for_each_entry_rcu(answer, &inetsw[sock-&gt;type], list) {  
</span><span class='line'>    err = 0;  
</span><span class='line'>    /* Check the non-wild match. */  
</span><span class='line'>    if (protocol == answer-&gt;protocol) {  
</span><span class='line'>        if (protocol != IPPROTO_IP)  
</span><span class='line'>            break;  
</span><span class='line'>    } else {  
</span><span class='line'>        /* Check for the two wild cases. */  
</span><span class='line'>        if (IPPROTO_IP == protocol) {  
</span><span class='line'>            protocol = answer-&gt;protocol;  
</span><span class='line'>            break;  
</span><span class='line'>        }  
</span><span class='line'>        if (IPPROTO_IP == answer-&gt;protocol)  
</span><span class='line'>            break;  
</span><span class='line'>    }  
</span><span class='line'>    err = -EPROTONOSUPPORT;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>sock->ops指向inet_stream_ops，然后创建sk，sk->proto指向tcp_prot，注意这里分配的大小是struct tcp_sock，而不仅仅是struct sock大小</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sock-&gt;ops = answer-&gt;ops;  
</span><span class='line'>answer_prot = answer-&gt;prot;  
</span><span class='line'>……  
</span><span class='line'>sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot);  </span></code></pre></td></tr></table></div></figure>


<p>然后设置inet的一些参数，这里直接将sk类型转换为inet，因为在sk_alloc()中分配的是struct tcp_sock结构大小，返回的是struct sock，利用了第一个成员的特性，三者之间的关系如下图：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inet = inet_sk(sk);  
</span><span class='line'>……  
</span><span class='line'>inet-&gt;inet_id = 0;  
</span><span class='line'>sock_init_data(sock, sk);  </span></code></pre></td></tr></table></div></figure>


<p>其中有些设置是比较重要的，如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sk-&gt;sk_state = TCP_CLOSE;  
</span><span class='line'>sk_set_socket(sk, sock);  
</span><span class='line'>sk-&gt;sk_protocol = protocol;  
</span><span class='line'>sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv;  </span></code></pre></td></tr></table></div></figure>


<p>创建socket后，接下来的流程会因为客户端或服务器的不同而有所差异，下面着重于分析建立连接的三次握手过程。典型的客户端流程：<br/>
connect() -> send() -> recv()</p>

<p>典型的服务器流程：<br/>
bind() -> listen() -> accept() -> recv() -> send()</p>

<h4>客户端流程</h4>

<p>发送SYN报文，向服务器发起tcp连接</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>        connect(fd, servaddr, addrlen);
</span><span class='line'>            -&gt; SYSCALL＿DEFINE3() 
</span><span class='line'>            -&gt; sock-&gt;ops-&gt;connect() == inet_stream_connect (sock-&gt;ops即inet_stream_ops)
</span><span class='line'>            -&gt; tcp_v4_connect()</span></code></pre></td></tr></table></div></figure>


<p>查找到达[daddr, dport]的路由项，路由项的查找与更新与”路由表”章节所述一样。要注意的是由于是作为客户端调用，创建socket后调用connect，因而saddr, sport都是0，同样在未查找路由前，要走的出接口oif也是不知道的，因此也是0。在查找完路由表后(注意不是路由缓存)，可以得知出接口，但并未存储到sk中。因此插入的路由缓存是特别要注意的：它的键值与实际值是不相同的，这个不同点就在于oif与saddr，键值是[saddr=0, sport=0, daddr, dport, oif=0]，而缓存项值是[saddr, sport=0, daddr, dport, oif]。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tmp = ip_route_connect(&rt, nexthop, inet-&gt;inet_saddr,  
</span><span class='line'>                        RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,  
</span><span class='line'>                        IPPROTO_TCP,  
</span><span class='line'>                        inet-&gt;inet_sport, usin-&gt;sin_port, sk, 1);  
</span><span class='line'>if (tmp &lt; 0) {  
</span><span class='line'>    if (tmp == -ENETUNREACH)  
</span><span class='line'>        IP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);  
</span><span class='line'>    return tmp;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>通过查找到的路由项，对inet进行赋值，可以看到，除了sport，都赋予了值，sport的选择复杂点，因为它要随机从未使用的本地端口中选择一个。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!inet-&gt;inet_saddr)  
</span><span class='line'>    inet-&gt;inet_saddr = rt_rt_src;   
</span><span class='line'>inet-&gt;inet_rcv_addr = inet-&gt;inet_saddr;  
</span><span class='line'>……  
</span><span class='line'>inet-&gt;inet_dport = usin-&gt;sin_port;  
</span><span class='line'>inet-&gt;inet_daddr = daddr;  </span></code></pre></td></tr></table></div></figure>


<p>状态从CLOSING转到TCP_SYN_SENT，也就是我们熟知的TCP的状态转移图。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_set_state(sk, TCP_SYN_SENT);  </span></code></pre></td></tr></table></div></figure>


<p>插入到bind链表中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>err = inet_hash_connect(&tcp_death_row, sk); //== &gt; __inet_hash_connect()  </span></code></pre></td></tr></table></div></figure>


<p>当snum==0时，表明此时源端口没有指定，此时会随机选择一个空闲端口作为此次连接的源端口。low和high分别表示可用端口的下限和上限，remaining表示可用端口的数，注意这里的可用只是指端口可以用作源端口，其中部分端口可能已经作为其它socket的端口号在使用了，所以要循环1~remaining，直到查找到空闲的源端口。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!snum) {  
</span><span class='line'>    inet_get_local_port_range(&low, &high);  
</span><span class='line'>    remaining = (high - low) + 1;  
</span><span class='line'>    ……  
</span><span class='line'>    for (i = 1; i &lt;= remaining; i++) {  
</span><span class='line'>        ……// choose a valid port  
</span><span class='line'>    }  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>下面来看下对每个端口的检查，即//choose a valid port部分的代码。这里要先了解下tcp的内核表组成，udp的表内核表udptable只是一张hash表，tcp的表则稍复杂，它的名字是tcp_hashinfo，在tcp_init()中被初始化，这个数据结构定义如下(省略了不相关的数据)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct inet_hashinfo {  
</span><span class='line'>    struct inet_ehash_bucket *ehash;  
</span><span class='line'>    ……  
</span><span class='line'>    struct inet_bind_hashbucket *bhash;  
</span><span class='line'>    ……  
</span><span class='line'>    struct inet_listen_hashbucket  listening_hash[INET_LHTABLE_SIZE]  
</span><span class='line'>                    ____cacheline_aligned_in_smp;  
</span><span class='line'>};  </span></code></pre></td></tr></table></div></figure>


<p>从定义可以看出，tcp表又分成了三张表ehash, bhash, listening_hash，其中ehash, listening_hash对应于socket处在TCP的ESTABLISHED, LISTEN状态，bhash对应于socket已绑定了本地地址。三者间并不互斥，如一个socket可同时在bhash和ehash中，由于TIME_WAIT是一个比较特殊的状态，所以ehash又分成了chain和twchain，为TIME_WAIT的socket单独形成一张表。</p>

<p>回到刚才的代码，现在还只是建立socket连接，使用的就应该是tcp表中的bhash。首先取得内核tcp表的bind表 – bhash，查看是否已有socket占用：<br/>
  如果没有，则调用inet_bind_bucket_create()创建一个bind表项tb，并插入到bind表中，跳转至goto ok代码段；<br/>
  如果有，则跳转至goto ok代码段。<br/>
  进入ok代码段表明已找到合适的bind表项(无论是创建的还是查找到的)，调用inet_bind_hash()赋值源端口inet_num。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (i = 1; i &lt;= remaining; i++) {  
</span><span class='line'>    port = low + (i + offset) % remaining;  
</span><span class='line'>    head = &hinfo-&gt;bhash[inet_bhashfn(net, port, hinfo-&gt;bhash_size)];  
</span><span class='line'>    ……  
</span><span class='line'>    inet_bind_bucket_for_each(tb, node, &head-&gt;chain) {  
</span><span class='line'>        if (net_eq(ib_net(tb), net) && tb-&gt;port == port) {  
</span><span class='line'>            if (tb-&gt;fastreuse &gt;= 0)  
</span><span class='line'>                goto next_port;  
</span><span class='line'>            WARN_ON(hlist_empty(&tb-&gt;owners));  
</span><span class='line'>            if (!check_established(death_row, sk, port, &tw))  
</span><span class='line'>                goto ok;  
</span><span class='line'>            goto next_port;  
</span><span class='line'>        }  
</span><span class='line'>    }  
</span><span class='line'>        
</span><span class='line'>    tb = inet_bind_bucket_create(hinfo-&gt;bind_bucket_cachep, net, head, port);  
</span><span class='line'>    ……  
</span><span class='line'>    next_port:  
</span><span class='line'>        spin_unlock(&head-&gt;lock);  
</span><span class='line'>}  
</span><span class='line'>        
</span><span class='line'>ok:  
</span><span class='line'>    ……  
</span><span class='line'>inet_bind_hash(sk, tb, port);  
</span><span class='line'>    ……  
</span><span class='line'>    goto out;  </span></code></pre></td></tr></table></div></figure>


<p>在获取到合适的源端口号后，会重建路由项来进行更新：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>err = ip_route_newports(&rt, IPPROTO_TCP, inet-&gt;inet_sport, inet-&gt;inet_dport, sk);  </span></code></pre></td></tr></table></div></figure>


<p>函数比较简单，在获取sport前已经查找过一次路由表，并插入了key=[saddr=0, sport=0, daddr, dport, oif=0]的路由缓存项；现在获取到了sport，调用ip_route_output_flow()再次更新路由缓存表，它会添加key=[saddr=0, sport, daddr, dport, oif=0]的路由缓存项。这里可以看出一个策略选择，查询路由表->获取sport->查询路由表，为什么不是获取sport->查询路由表的原因可能是效率的问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (sport != (*rp)-&gt;fl.fl_ip_sport ||  
</span><span class='line'>                dport != (*rp)-&gt;fl.fl_ip_dport) {  
</span><span class='line'>    struct flowi fl;  
</span><span class='line'>        
</span><span class='line'>    memcpy(&fl, &(*rp)-&gt;fl, sizeof(fl));  
</span><span class='line'>    fl.fl_ip_sport = sport;  
</span><span class='line'>    fl.fl_ip_dport = dport;  
</span><span class='line'>    fl.proto = protocol;  
</span><span class='line'>    ip_rt_put(*rp);  
</span><span class='line'>    *rp = NULL;  
</span><span class='line'>    security_sk_classify_flow(sk, &fl);  
</span><span class='line'>    return ip_route_output_flow(sock_net(sk), rp, &fl, sk, 0);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>write_seq相当于第一次发送TCP报文的ISN，如果为0，则通过计算获取初始值，否则延用上次的值。在获取完源端口号，并查询过路由表后，TCP正式发送SYN报文，注意在这之前TCP状态已经更新成了TCP_SYN_SENT，而在函数最后才调用tcp_connect(sk)发送SYN报文，这中间是有时差的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!tp-&gt;write_seq)  
</span><span class='line'>    tp-&gt;write_seq = secure_tcp_sequence_number(inet-&gt;inet_saddr,  
</span><span class='line'>                                    inet-&gt;inet_daddr,  
</span><span class='line'>                                    inet-&gt;inet_sport,  
</span><span class='line'>                                    usin-&gt;sin_port);  
</span><span class='line'>inet-&gt;inet_id = tp-&gt;write_seq ^ jiffies;  
</span><span class='line'>err = tcp_connect(sk);  </span></code></pre></td></tr></table></div></figure>


<h5>tcp_connect()　发送SYN报文</h5>

<p>几步重要的代码如下，tcp_connect_init()中设置了tp->rcv_nxt=0，tcp_transmit_skb()负责发送报文，其中seq=tcb->seq=tp->write_seq，ack_seq=tp->rcv_nxt。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_connect_init(sk);  
</span><span class='line'>tp-&gt;snd_nxt = tp-&gt;write_seq;  
</span><span class='line'>……  
</span><span class='line'>tcp_transmit_skb(sk, buff, 1, sk-&gt;sk_allocation);  </span></code></pre></td></tr></table></div></figure>


<h5>收到服务端的SYN+ACK，发送ACK</h5>

<h5>tcp_rcv_synsent_state_process()</h5>

<p>此时已接收到对方的ACK，状态变迁到TCP_ESTABLISHED。最后发送对方SYN的ACK报文。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_set_state(sk, TCP_ESTABLISHED);  
</span><span class='line'>tcp_send_ack(sk);  </span></code></pre></td></tr></table></div></figure>


<h4>服务端流程</h4>

<h5>bind() -> inet_bind()</h5>

<p>  bind操作的主要作用是将创建的socket与给定的地址相绑定，这样创建的服务才能公开的让外部调用。当然对于socket服务器的创建来说，这一步不是必须的，在listen()时如果没有绑定地址，系统会选择一个随机可用地址作为服务器地址。</p>

<p>  一个socket地址分为ip和port，inet->inet_saddr赋值了传入的ip，snum是传入的port，对于端口，要检查它是否已被占用，这是由sk->sk_prot->get_port()完成的(这个函数前面已经分析过，在传入port时它检查是否被占用；传入port=0时它选择未用的端口)。如果没有被占用，inet->inet_sport被赋值port，因为是服务监听端，不需要远端地址，inet_daddr和inet_dport都置0。</p>

<p>  注意bind操作不会改变socket的状态，仍为创建时的TCP_CLOSE。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>snum = ntohs(addr-&gt;sin_port);  
</span><span class='line'>……  
</span><span class='line'>inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;  
</span><span class='line'>if (sk-&gt;sk_prot-&gt;get_port(sk, snum)) {  
</span><span class='line'>    inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = 0;  
</span><span class='line'>    err = -EADDRINUSE;  
</span><span class='line'>    goto out_release_sock;  
</span><span class='line'>}  
</span><span class='line'>……  
</span><span class='line'>inet-&gt;inet_sport = htons(inet-&gt;inet_num);  
</span><span class='line'>inet-&gt;inet_daddr = 0;  
</span><span class='line'>inet-&gt;inet_dport = 0;  </span></code></pre></td></tr></table></div></figure>


<h5>listen() -> inet_listen()</h5>

<p>  listen操作开始服务器的监听，此时服务就可以接受到外部连接了。在开始监听前，要检查状态是否正确，sock->state==SS_UNCONNECTED确保仍是未连接的socket，sock->type==SOCK_STREAM确保是TCP协议，old_state确保此时状态是TCP_CLOSE或TCP_LISTEN，在其它状态下进行listen都是错误的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (sock-&gt;state != SS_UNCONNECTED || sock-&gt;type != SOCK_STREAM)  
</span><span class='line'>    goto out;  
</span><span class='line'>old_state = sk-&gt;sk_state;  
</span><span class='line'>if (!((1 &lt;&lt; old_state) & (TCPF_CLOSE | TCPF_LISTEN)))  
</span><span class='line'>    goto out;  </span></code></pre></td></tr></table></div></figure>


<p>  如果已是TCP_LISTEN态，则直接跳过，不用再执行listen了，而只是重新设置listen队列长度sk_max_ack_backlog，改变listen队列长也是多次执行listen的作用。如果还没有执行listen，则还要调用inet_csk_listen_start()开始监听。</p>

<p>  inet_csk_listen_start()变迁状态至TCP_LISTEN，分配监听队列，如果之前没有调用bind()绑定地址，则这里会分配一个随机地址。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (old_state != TCP_LISTEN) {  
</span><span class='line'>    err = inet_csk_listen_start(sk, backlog);  
</span><span class='line'>    if (err)  
</span><span class='line'>        goto out;  
</span><span class='line'>}  
</span><span class='line'>sk-&gt;sk_max_ack_backlog = backlog;  </span></code></pre></td></tr></table></div></figure>


<h5>accept()</h5>

<p>accept() -> sys_accept4() -> inet_accept() -> inet_csk_accept()</p>

<p>  accept()实际要做的事件并不多，它的作用是返回一个已经建立连接的socket(即经过了三次握手)，这个过程是异步的，accept()并不亲自去处理三次握手过程，而只是监听icsk_accept_queue队列，当有socket经过了三次握手，它就会被加到icsk_accept_queue中，所以accept要做的就是等待队列中插入socket，然后被唤醒并返回这个socket。而三次握手的过程完全是协议栈本身去完成的。换句话说，协议栈相当于写者，将socket写入队列，accept()相当于读者，将socket从队列读出。这个过程从listen就已开始，所以即使不调用accept()，客户仍可以和服务器建立连接，但由于没有处理，队列很快会被占满。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (reqsk_queue_empty(&icsk-&gt;icsk_accept_queue)) {  
</span><span class='line'>    long timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);  
</span><span class='line'>    ……  
</span><span class='line'>    error = inet_csk_wait_for_connect(sk, timeo);  
</span><span class='line'>    ……  
</span><span class='line'>}  
</span><span class='line'>        
</span><span class='line'>newsk = reqsk_queue_get_child(&icsk-&gt;icsk_accept_queue, sk);  </span></code></pre></td></tr></table></div></figure>


<p>  协议栈向队列中加入socket的过程就是完成三次握手的过程，客户端通过向已知的listen fd发起连接请求，对于到来的每个连接，都会创建一个新的sock，当它经历了TCP_SYN_RCV -> TCP_ESTABLISHED后，就会被添加到icsk_accept_queue中，而监听的socket状态始终为TCP_LISTEN，保证连接的建立不会影响socket的接收。</p>

<h4>接收客户端发来的SYN，发送SYN+ACK</h4>

<h5>tcp_v4_do_rcv()</h5>

<p>  tcp_v4_do_rcv()是TCP模块接收的入口函数，客户端发起请求的对象是listen fd，所以sk->sk_state == TCP_LISTEN，调用tcp_v4_hnd_req()来检查是否处于半连接，只要三次握手没有完成，这样的连接就称为半连接，具体而言就是收到了SYN，但还没有收到ACK的连接，所以对于这个查找函数，如果是SYN报文，则会返回listen的socket(连接尚未创建)；如果是ACK报文，则会返回SYN报文处理中插入的半连接socket。其中存储这些半连接的数据结构是syn_table，它在listen()调用时被创建，大小由sys_ctl_max_syn_backlog和listen()传入的队列长度决定。</p>

<p>此时是收到SYN报文，tcp_v4_hnd_req()返回的仍是sk，调用tcp_rcv_state_process()来接收SYN报文，并发送SYN+ACK报文，同时向syn_table中插入一项表明此次连接的sk。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (sk-&gt;sk_state == TCP_LISTEN) {  
</span><span class='line'>    struct sock *nsk = tcp_v4_hnd_req(sk, skb);  
</span><span class='line'>    if (!nsk)  
</span><span class='line'>        goto discard;  
</span><span class='line'>    if (nsk != sk) {  
</span><span class='line'>        if (tcp_child_process(sk, nsk, skb)) {  
</span><span class='line'>            rsk = nsk;  
</span><span class='line'>            goto reset;  
</span><span class='line'>        }  
</span><span class='line'>        return 0;  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>TCP_CHECK_TIMER(sk);  
</span><span class='line'>if (tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb-&gt;len)) {  
</span><span class='line'>    rsk = sk;  
</span><span class='line'>    goto reset;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>  tcp_rcv_state_process()处理各个状态上socket的情况。下面是处于TCP_LISTEN的代码段，处于TCP_LISTEN的socket不会再向其它状态变迁，它负责监听，并在连接建立时创建新的socket。实际上，当收到第一个SYN报文时，会执行这段代码，conn_request() => tcp_v4_conn_request。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>case TCP_LISTEN:  
</span><span class='line'>……  
</span><span class='line'>    if (th-&gt;syn) {  
</span><span class='line'>        if (icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &lt; 0)  
</span><span class='line'>            return 1;  
</span><span class='line'>        kfree_skb(skb);  
</span><span class='line'>        return 0;  
</span><span class='line'>    }  </span></code></pre></td></tr></table></div></figure>


<p>  tcp_v4_conn_request()中注意两个函数就可以了：tcp_v4_send_synack()向客户端发送了SYN+ACK报文，inet_csk_reqsk_queue_hash_add()将sk添加到了syn_table中，填充了该客户端相关的信息。这样，再次收到客户端的ACK报文时，就可以在syn_table中找到相应项了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (tcp_v4_send_synack(sk, dst, req, (struct request_values *)&tmp_ext) || want_cookie)  
</span><span class='line'>    goto drop_and_free;  
</span><span class='line'>inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);  </span></code></pre></td></tr></table></div></figure>


<h4>接收客户端发来的ACK</h4>

<h5>tcp_v4_do_rcv()</h5>

<p>  过程与收到SYN报文相同，不同点在于syn_table中已经插入了有关该连接的条目，tcp_v4_hnd_req()会返回一个新的sock: nsk，然后会调用tcp_child_process()来进行处理。在tcp_v4_hnd_req()中会创建新的sock，下面详细看下这个函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (sk-&gt;sk_state == TCP_LISTEN) {  
</span><span class='line'>    struct sock *nsk = tcp_v4_hnd_req(sk, skb);  
</span><span class='line'>    if (!nsk)  
</span><span class='line'>        goto discard;  
</span><span class='line'>    if (nsk != sk) {  
</span><span class='line'>        if (tcp_child_process(sk, nsk, skb)) {  
</span><span class='line'>            rsk = nsk;  
</span><span class='line'>            goto reset;  
</span><span class='line'>        }  
</span><span class='line'>        return 0;  
</span><span class='line'>    }  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h5>tcp_v4_hnd_req()</h5>

<p>之前已经分析过，inet_csk_search_req()会在syn_table中找到req，此时进入tcp_check_req()</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct request_sock *req = inet_csk_search_req(sk, &prev, th-&gt;source, iph-&gt;saddr, iph-&gt;daddr);  
</span><span class='line'>if (req)  
</span><span class='line'>    return tcp_check_req(sk, skb, req, prev);  </span></code></pre></td></tr></table></div></figure>


<h5>tcp_check_req()</h5>

<p>  syn_recv_sock() -> tcp_v4_syn_recv_sock()会创建一个新的sock并返回，创建的sock状态被直接设置为TCP_SYN_RECV，然后因为此时socket已经建立，将它添加到icsk_accept_queue中。</p>

<p>  状态TCP_SYN_RECV的设置可能比较奇怪，按照TCP的状态转移图，在服务端收到SYN报文后变迁为TCP_SYN_RECV，但看到在实现中收到ACK后才有了状态TCP_SYN_RECV，并且马上会变为TCP_ESTABLISHED，所以这个状态变得无足轻重。这样做的原因是listen和accept返回的socket是不同的，而只有真正连接建立时才会创建这个新的socket，在收到SYN报文时新的socket还没有建立，就无从谈状态变迁了。这里同样是一个平衡的存在，你也可以在收到SYN时创建一个新的socket，代价就是无用的socket大大增加了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>child = inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock(sk, skb, req, NULL);  
</span><span class='line'>if (child == NULL)  
</span><span class='line'>    goto listen_overflow;  
</span><span class='line'>inet_csk_reqsk_queue_unlink(sk, req, prev);  
</span><span class='line'>inet_csk_reqsk_queue_removed(sk, req);  
</span><span class='line'>inet_csk_reqsk_queue_add(sk, req, child);  </span></code></pre></td></tr></table></div></figure>


<h5>tcp_child_process()</h5>

<p>如果此时sock: child被用户进程锁住了，那么就先添加到backlog中__sk_add_backlog()，待解锁时再处理backlog上的sock；如果此时没有被锁住，则先调用tcp_rcv_state_process()进行处理，处理完后，如果child状态到达TCP_ESTABLISHED，则表明其已就绪，调用sk_data_ready()唤醒等待在isck_accept_queue上的函数accept()。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!sock_owned_by_user(child)) {  
</span><span class='line'>    ret = tcp_rcv_state_process(child, skb, tcp_hdr(skb), skb-&gt;len);  
</span><span class='line'>    if (state == TCP_SYN_RECV && child-&gt;sk_state != state)  
</span><span class='line'>        parent-&gt;sk_data_ready(parent, 0);  
</span><span class='line'>} else {  
</span><span class='line'>    __sk_add_backlog(child, skb);  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>  tcp_rcv_state_process()处理各个状态上socket的情况。下面是处于TCP_SYN_RECV的代码段，注意此时传入函数的sk已经是新创建的sock了(在tcp_v4_hnd_req()中)，并且状态是TCP_SYN_RECV，而不再是listen socket，在收到ACK后，sk状态变迁为TCP_ESTABLISHED，而在tcp_v4_hnd_req()中也已将sk插入到了icsk_accept_queue上，此时它就已经完全就绪了，回到tcp_child_process()便可执行sk_data_ready()。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>case TCP_SYN_RECV:  
</span><span class='line'>    if (acceptable) {  
</span><span class='line'>        ……  
</span><span class='line'>        tcp_set_state(sk, TCP_ESTABLISHED);  
</span><span class='line'>        sk-&gt;sk_state_change(sk);  
</span><span class='line'>        ……  
</span><span class='line'>        tp-&gt;snd_una = TCP_SKB_CB(skb)-&gt;ack_seq;  
</span><span class='line'>        tp-&gt;snd_wnd = ntohs(th-&gt;window) &lt;&lt; tp-&gt;rx_opt.snd_wscale;  
</span><span class='line'>        tcp_init_wl(tp, TCP_SKB_CB(skb)-&gt;seq);   
</span><span class='line'>        ……  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>最后总结三次握手的过程</p>

<p><img src="/images/kernel/2015-06-01.png" alt="" /></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-06-01T14:24:00+08:00'><span class='date'>2015-06-01</span> <span class='time'>14:24:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~net/'>net</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/05/29/system-base-ext/" title="Previous Post: RHEL5/CentOS5 上支持 Ext4">&laquo; RHEL5/CentOS5 上支持 Ext4</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/06/01/debug-systemtap-beginner/" title="Next Post: SystemTap Beginner">SystemTap Beginner &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
<!--  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script> -->
</p>

</footer>
  





</body>
</html>
