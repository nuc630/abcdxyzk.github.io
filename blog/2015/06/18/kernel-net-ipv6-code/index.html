
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>IPV6 实现 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>date [-d @int|str] [+%s|"+%F %T"]</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">IPV6 实现</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-18T10:44:00+08:00'><span class='date'>2015-06-18</span> <span class='time'>10:44:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://www.cnblogs.com/super-king/p/ipv6_implement.html">http://www.cnblogs.com/super-king/p/ipv6_implement.html</a></p>

<p>code extract from 2.6.24.
在文件 net/ipv6/af_inet6.c 中包含了ipv6协议初始化的主函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int __init inet6_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *dummy_skb;
</span><span class='line'>&#9;struct list_head *r;
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;//inet6_skb_parm必须小于等于skb中的cb
</span><span class='line'>&#9;BUILD_BUG_ON(sizeof(struct inet6_skb_parm) &gt; sizeof(dummy_skb-&gt;cb));
</span><span class='line'>
</span><span class='line'>&#9;//初始化tcpv6_prot结构中的一些与slab相关的字段，然后添加到 proto_list 全局连表
</span><span class='line'>&#9;err = proto_register(&tcpv6_prot, 1);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;//udp协议同上
</span><span class='line'>&#9;err = proto_register(&udpv6_prot, 1);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto out_unregister_tcp_proto;
</span><span class='line'>&#9;//udp-lite传输协议，主要用于多媒体传输，参考kernel中的 Documentation/networking/udplite.txt
</span><span class='line'>&#9;err = proto_register(&udplitev6_prot, 1);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto out_unregister_udp_proto;
</span><span class='line'>&#9;//原始套接字同上
</span><span class='line'>&#9;err = proto_register(&rawv6_prot, 1);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto out_unregister_udplite_proto;
</span><span class='line'>
</span><span class='line'>&#9;/* Register the socket-side information for inet6_create.  */
</span><span class='line'>&#9;for(r = &inetsw6[0]; r &lt; &inetsw6[SOCK_MAX]; ++r) //初始化一个协议连表数组
</span><span class='line'>&#9;&#9;INIT_LIST_HEAD(r);
</span><span class='line'>&#9;/* We MUST register RAW sockets before we create the ICMP6, IGMP6, or NDISC control sockets. */
</span><span class='line'>&#9;//根据参数数据结构中标识的协议类型，把这数据结构添加到上面的协议连表数组中
</span><span class='line'>&#9;inet6_register_protosw(&rawv6_protosw);
</span><span class='line'>
</span><span class='line'>&#9;/* Register the family here so that the init calls below will be able to create sockets. (?? is this dangerous ??) */
</span><span class='line'>&#9;//注册ipv6协议族，主要是注册socket创建函数
</span><span class='line'>&#9;err = sock_register(&inet6_family_ops);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto out_unregister_raw_proto;
</span><span class='line'>
</span><span class='line'>&#9;/* Initialise ipv6 mibs */
</span><span class='line'>&#9;err = init_ipv6_mibs(); //所有ipv6相关的统计信息
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto out_unregister_sock;
</span><span class='line'>&#9;/* ipngwg API draft makes clear that the correct semantics for TCP and UDP is to consider one TCP and UDP instance 
</span><span class='line'>&#9; * in a host availiable by both INET and INET6 APIs and able to communicate via both network protocols.
</span><span class='line'>&#9; */
</span><span class='line'>#ifdef CONFIG_SYSCTL
</span><span class='line'>&#9;ipv6_sysctl_register(); // ipv6协议proc条件项初始化
</span><span class='line'>#endif
</span><span class='line'>&#9;//icmp协议注册
</span><span class='line'>&#9;err = icmpv6_init(&inet6_family_ops);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto icmp_fail;
</span><span class='line'>&#9;//邻居协议（arp）初始化       
</span><span class='line'>&#9;err = ndisc_init(&inet6_family_ops);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto ndisc_fail;
</span><span class='line'>&#9;//igmp协议初始化       
</span><span class='line'>&#9;err = igmp6_init(&inet6_family_ops);
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto igmp_fail;
</span><span class='line'>&#9;//ipv6协议相关的 netfilter 初始化     
</span><span class='line'>&#9;err = ipv6_netfilter_init();
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto netfilter_fail;
</span><span class='line'>
</span><span class='line'>&#9;/* Create /proc/foo6 entries. */
</span><span class='line'>#ifdef CONFIG_PROC_FS //注册/proc/中协议统计输出项
</span><span class='line'>&#9;err = -ENOMEM;
</span><span class='line'>&#9;if (raw6_proc_init())
</span><span class='line'>&#9;&#9;goto proc_raw6_fail;
</span><span class='line'>&#9;if (tcp6_proc_init())
</span><span class='line'>&#9;&#9;goto proc_tcp6_fail;
</span><span class='line'>&#9;if (udp6_proc_init())
</span><span class='line'>&#9;&#9;goto proc_udp6_fail;
</span><span class='line'>&#9;if (udplite6_proc_init())
</span><span class='line'>&#9;&#9;goto proc_udplite6_fail;
</span><span class='line'>&#9;if (ipv6_misc_proc_init())
</span><span class='line'>&#9;&#9;goto proc_misc6_fail;
</span><span class='line'>&#9;if (ac6_proc_init())
</span><span class='line'>&#9;&#9;goto proc_anycast6_fail;
</span><span class='line'>&#9;if (if6_proc_init())
</span><span class='line'>&#9;&#9;goto proc_if6_fail;
</span><span class='line'>#endif
</span><span class='line'>&#9;ip6_route_init(); //ipv6 路由初始化
</span><span class='line'>&#9;ip6_flowlabel_init();//ipv6 中流标记，注册了输出流标记的 proc
</span><span class='line'>
</span><span class='line'>&#9;//rtnetlink相关部分和路由模板中一些字段和其他一些功能的初始化
</span><span class='line'>&#9;err = addrconf_init();
</span><span class='line'>&#9;if (err)
</span><span class='line'>&#9;&#9;goto addrconf_fail;
</span><span class='line'>&#9;/* Init v6 extension headers. */
</span><span class='line'>&#9;//ipv6 新添加的扩展头初始化，参考ipv6介绍
</span><span class='line'>&#9;ipv6_rthdr_init();
</span><span class='line'>&#9;ipv6_frag_init();
</span><span class='line'>&#9;ipv6_nodata_init();
</span><span class='line'>&#9;ipv6_destopt_init();
</span><span class='line'>
</span><span class='line'>&#9;/* Init v6 transport protocols. */
</span><span class='line'>&#9;//最主要的传输层协议初始化
</span><span class='line'>&#9;udpv6_init();
</span><span class='line'>&#9;udplitev6_init();
</span><span class='line'>&#9;tcpv6_init();
</span><span class='line'>
</span><span class='line'>&#9;//最后注册ipv6协议，注册协议处理函数
</span><span class='line'>&#9;ipv6_packet_init();
</span><span class='line'>&#9;err = 0;
</span><span class='line'>out:
</span><span class='line'>&#9;return err;
</span><span class='line'>&#9;...... //下面就是错误处理的过程
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面我们主要看ipv6协议部分流程，其他部分在各自相关文章中介绍。</p>

<p>ipv6扩展头，路由包头注册</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __init ipv6_rthdr_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;if (inet6_add_protocol(&rthdr_protocol, IPPROTO_ROUTING) &lt; 0)
</span><span class='line'>&#9;&#9;printk(KERN_ERR "ipv6_rthdr_init: Could not register protocol\n");
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>ipv6扩展头，分片包头注册</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __init ipv6_frag_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;if (inet6_add_protocol(&frag_protocol, IPPROTO_FRAGMENT) &lt; 0)
</span><span class='line'>&#9;&#9;printk(KERN_ERR "ipv6_frag_init: Could not register protocol\n");
</span><span class='line'>
</span><span class='line'>&#9;ip6_frags.ctl = &ip6_frags_ctl;
</span><span class='line'>&#9;ip6_frags.hashfn = ip6_hashfn;
</span><span class='line'>&#9;ip6_frags.constructor = ip6_frag_init;
</span><span class='line'>&#9;ip6_frags.destructor = NULL;
</span><span class='line'>&#9;ip6_frags.skb_free = NULL;
</span><span class='line'>&#9;ip6_frags.qsize = sizeof(struct frag_queue);
</span><span class='line'>&#9;ip6_frags.match = ip6_frag_match;
</span><span class='line'>&#9;ip6_frags.frag_expire = ip6_frag_expire;
</span><span class='line'>&#9;inet_frags_init(&ip6_frags);
</span><span class='line'>}
</span><span class='line'>void __init ipv6_nodata_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;if (inet6_add_protocol(&nodata_protocol, IPPROTO_NONE) &lt; 0)
</span><span class='line'>&#9;&#9;printk(KERN_ERR "ipv6_nodata_init: Could not register protocol\n");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ipv6扩展头，目的选项包头注册</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __init ipv6_destopt_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;if (inet6_add_protocol(&destopt_protocol, IPPROTO_DSTOPTS) &lt; 0)
</span><span class='line'>&#9;&#9;printk(KERN_ERR "ipv6_destopt_init: Could not register protocol\n");
</span><span class='line'>}
</span><span class='line'>&#9;注册ipv6协议处理函数
</span><span class='line'>void __init ipv6_packet_init(void)
</span><span class='line'>{
</span><span class='line'>&#9;dev_add_pack(&ipv6_packet_type);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当netif_receive_skb函数向上层递交skb时会根据协议类型调用相关的协议处理函数，那么就会调用到 ipv6_rcv函数了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct packet_type ipv6_packet_type = {
</span><span class='line'>&#9;.type = __constant_htons(ETH_P_IPV6),
</span><span class='line'>&#9;.func = ipv6_rcv,
</span><span class='line'>&#9;.gso_send_check = ipv6_gso_send_check,
</span><span class='line'>&#9;.gso_segment = ipv6_gso_segment,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>ipv6协议处理函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct ipv6hdr *hdr;
</span><span class='line'>&#9;u32             pkt_len;
</span><span class='line'>&#9;struct inet6_dev *idev;
</span><span class='line'>
</span><span class='line'>&#9;if (dev-&gt;nd_net != &init_net) {
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//mac地址是其他主机的包
</span><span class='line'>&#9;if (skb-&gt;pkt_type == PACKET_OTHERHOST) {
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;//获取ipv6相关的配置结构
</span><span class='line'>&#9;idev = __in6_dev_get(skb-&gt;dev);
</span><span class='line'>
</span><span class='line'>&#9;IP6_INC_STATS_BH(idev, IPSTATS_MIB_INRECEIVES);
</span><span class='line'>&#9;//是否共享，如果是，新clone一个
</span><span class='line'>&#9;if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL) {
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDISCARDS);
</span><span class='line'>&#9;&#9;rcu_read_unlock();
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//清空保存扩展头解析结果的数据结构
</span><span class='line'>&#9;memset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));
</span><span class='line'>
</span><span class='line'>&#9;//保存接收这个数据包的设备索引
</span><span class='line'>&#9;IP6CB(skb)-&gt;iif = skb-&gt;dst ? ip6_dst_idev(skb-&gt;dst)-&gt;dev-&gt;ifindex : dev-&gt;ifindex;
</span><span class='line'>
</span><span class='line'>&#9;//有足够的头长度，ipv6是40字节
</span><span class='line'>&#9;if (unlikely(!pskb_may_pull(skb, sizeof(*hdr))))
</span><span class='line'>&#9;&#9;goto err;
</span><span class='line'>
</span><span class='line'>&#9;hdr = ipv6_hdr(skb); //获取头
</span><span class='line'>
</span><span class='line'>&#9;if (hdr-&gt;version != 6) //验证版本
</span><span class='line'>&#9;&#9;goto err;
</span><span class='line'>
</span><span class='line'>&#9;//传输头（扩展头）在网络头后面
</span><span class='line'>&#9;skb-&gt;transport_header = skb-&gt;network_header + sizeof(*hdr);
</span><span class='line'>&#9;//保存下一个扩展头协议在ipv6头结构中的偏移
</span><span class='line'>&#9;IP6CB(skb)-&gt;nhoff = offsetof(struct ipv6hdr, nexthdr);
</span><span class='line'>&#9;pkt_len = ntohs(hdr-&gt;payload_len); //ipv6负载数据长度
</span><span class='line'>
</span><span class='line'>&#9;/* pkt_len may be zero if Jumbo payload option is present */
</span><span class='line'>&#9;if (pkt_len || hdr-&gt;nexthdr != NEXTHDR_HOP) { //没有使用扩展头逐个跳段选项
</span><span class='line'>&#9;&#9;if (pkt_len + sizeof(struct ipv6hdr) &gt; skb-&gt;len) { //数据长度不对
</span><span class='line'>&#9;&#9;&#9;IP6_INC_STATS_BH(idev, IPSTATS_MIB_INTRUNCATEDPKTS);
</span><span class='line'>&#9;&#9;&#9;goto drop;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//如果skb-&gt;len &gt; (pkt_len + sizeof(struct ipv6hdr))试着缩小skb-&gt;len的长度
</span><span class='line'>&#9;&#9;//相对ipv4来说简单多了，自己看吧
</span><span class='line'>&#9;&#9;if (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr))) {
</span><span class='line'>&#9;&#9;&#9;IP6_INC_STATS_BH(idev, IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;&#9;goto drop;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;hdr = ipv6_hdr(skb); //重新获取ip头
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (hdr-&gt;nexthdr == NEXTHDR_HOP) { //使用了扩展头逐个跳段选项
</span><span class='line'>&#9;&#9;if (ipv6_parse_hopopts(skb) &lt; 0) {//处理这个选项
</span><span class='line'>&#9;&#9;&#9;IP6_INC_STATS_BH(idev, IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;&#9;rcu_read_unlock();
</span><span class='line'>&#9;&#9;&#9;return 0;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>&#9;//进入ipv6的netfilter然后调用ip6_rcv_finish
</span><span class='line'>&#9;return NF_HOOK(PF_INET6,NF_IP6_PRE_ROUTING, skb, dev, NULL, ip6_rcv_finish);
</span><span class='line'>err:
</span><span class='line'>&#9;IP6_INC_STATS_BH(idev, IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>drop:
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>out:
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>解析扩展头逐个跳段中的巨量负载选项</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int ipv6_parse_hopopts(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet6_skb_parm *opt = IP6CB(skb); //获取扩展头结果结构
</span><span class='line'>&#9;/* skb_network_header(skb) is equal to skb-&gt;data, and skb_network_header_len(skb) is always equal to
</span><span class='line'>&#9; * sizeof(struct ipv6hdr) by definition of hop-by-hop options.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;//验证数据有足够的长度
</span><span class='line'>&#9;if (!pskb_may_pull(skb, sizeof(struct ipv6hdr) + 8) || !pskb_may_pull(skb, (sizeof(struct ipv6hdr) +
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;//下面的意思是取得扩展首部中的长度
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;((skb_transport_header(skb)[1] + 1) &lt;&lt; 3)))) {
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;opt-&gt;hop = sizeof(struct ipv6hdr); //40字节
</span><span class='line'>&#9;if (ip6_parse_tlv(tlvprochopopt_lst, skb)) { //实际的解析工作
</span><span class='line'>&#9;&#9;//把传输头移动到扩展首部之后
</span><span class='line'>&#9;&#9;skb-&gt;transport_header += (skb_transport_header(skb)[1] + 1) &lt;&lt; 3;
</span><span class='line'>&#9;&#9;opt = IP6CB(skb);
</span><span class='line'>&#9;&#9;opt-&gt;nhoff = sizeof(struct ipv6hdr); //进行了ipv6扩展头解析，保存下一个扩展头协议字段的偏移
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return -1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>解析tlv编码的扩展选项头</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int ip6_parse_tlv(struct tlvtype_proc *procs, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct tlvtype_proc *curr;
</span><span class='line'>&#9;const unsigned char *nh = skb_network_header(skb); //获取网络头
</span><span class='line'>&#9;int off = skb_network_header_len(skb); //获取网络头长度
</span><span class='line'>&#9;int len = (skb_transport_header(skb)[1] + 1) &lt;&lt; 3; //首部扩展头长度
</span><span class='line'>
</span><span class='line'>&#9;if (skb_transport_offset(skb) + len &gt; skb_headlen(skb)) //长度错误
</span><span class='line'>&#9;&#9;goto bad;
</span><span class='line'>&#9;off += 2; //跳过下一个首部和首部扩展长度这两个字节
</span><span class='line'>&#9;len -= 2;
</span><span class='line'>
</span><span class='line'>&#9;while (len &gt; 0) {
</span><span class='line'>&#9;&#9;int optlen = nh[off + 1] + 2; //获取选项数据长度 + 2 (2是选项类型和选项数据长度两字节)
</span><span class='line'>&#9;&#9;switch (nh[off]) { //选项类型
</span><span class='line'>&#9;&#9;&#9;case IPV6_TLV_PAD0: //Pad1选项
</span><span class='line'>&#9;&#9;&#9;&#9;optlen = 1;
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;case IPV6_TLV_PADN://PadN选项
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;default: //其他选项
</span><span class='line'>&#9;&#9;&#9;&#9;if (optlen &gt; len)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto bad;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;for (curr = procs; curr-&gt;type &gt;= 0; curr++) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;if (curr-&gt;type == nh[off]) { //类型匹配，调用参数函数处理，参考下面ipv6选项处理
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;/* type specific length/alignment checks will be performed in the func(). */
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;if (curr-&gt;func(skb, off) == 0)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;return 0;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;if (curr-&gt;type &lt; 0) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;if (ip6_tlvopt_unknown(skb, off) == 0) //处理未知选项
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;return 0;
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;off += optlen; //偏移增加，这样到下一个选项
</span><span class='line'>&#9;&#9;len -= optlen; //长度递减
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (len == 0)
</span><span class='line'>&#9;&#9;return 1; //正确解析完毕
</span><span class='line'>bad:
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>处理未知的选项</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int ip6_tlvopt_unknown(struct sk_buff *skb, int optoff)
</span><span class='line'>{
</span><span class='line'>&#9;//根据选项类型标识符的要求进行处理
</span><span class='line'>&#9;switch ((skb_network_header(skb)[optoff] & 0xC0) &gt;&gt; 6) {
</span><span class='line'>&#9;&#9;case 0: /* ignore */
</span><span class='line'>&#9;&#9;&#9;return 1;
</span><span class='line'>&#9;&#9;case 1: /* drop packet */
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;case 3: /* Send ICMP if not a multicast address and drop packet */
</span><span class='line'>&#9;&#9;&#9;/* Actually, it is redundant check. icmp_send will recheck in any case. */
</span><span class='line'>&#9;&#9;&#9;if (ipv6_addr_is_multicast(&ipv6_hdr(skb)-&gt;daddr)) //目的是多播地址
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;case 2: /* send ICMP PARM PROB regardless and drop packet */
</span><span class='line'>&#9;&#9;&#9;//给包的源地址发送一个 ICMP "参数存在问题", 编码 2 的报文, 指针指向无法识别的选项类型
</span><span class='line'>&#9;&#9;&#9;icmpv6_param_prob(skb, ICMPV6_UNK_OPTION, optoff);
</span><span class='line'>&#9;&#9;&#9;return 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>到这需要解释一下，上面解析ipv6选项只是解析了第一层的扩展头，在后面可能还有其他扩展头会在后面解析。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inline int ip6_rcv_finish( struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;if (skb-&gt;dst == NULL) //没有路由，进行路由查找
</span><span class='line'>&#9;&#9;ip6_route_input(skb); //路由部分将在路由实现文章中介绍
</span><span class='line'>
</span><span class='line'>&#9;return dst_input(skb);
</span><span class='line'>}
</span><span class='line'>static inline int dst_input(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;for (;;) {
</span><span class='line'>&#9;&#9;err = skb-&gt;dst-&gt;input(skb); //调用路由的输入函数
</span><span class='line'>&#9;&#9;if (likely(err == 0))
</span><span class='line'>&#9;&#9;&#9;return err;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Oh, Jamal... Seems, I will not forgive you this mess. :-) */
</span><span class='line'>&#9;&#9;if (unlikely(err != NET_XMIT_BYPASS))
</span><span class='line'>&#9;&#9;&#9;return err;
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在我们假设包是到本地的，那么上面的input函数就是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int ip6_input(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;//进入ipv6 netfilter NF_IP6_LOCAL_IN hook 然后调用 ip6_input_finish
</span><span class='line'>&#9;return NF_HOOK(PF_INET6, NF_IP6_LOCAL_IN, skb, skb-&gt;dev, NULL, ip6_input_finish);
</span><span class='line'>}
</span><span class='line'>static int ip6_input_finish(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet6_protocol *ipprot;
</span><span class='line'>&#9;struct sock *raw_sk;
</span><span class='line'>&#9;unsigned int nhoff;
</span><span class='line'>&#9;int nexthdr;
</span><span class='line'>&#9;u8 hash;
</span><span class='line'>&#9;struct inet6_dev *idev;
</span><span class='line'>
</span><span class='line'>&#9;/* Parse extension headers */
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>resubmit:
</span><span class='line'>&#9;idev = ip6_dst_idev(skb-&gt;dst);
</span><span class='line'>&#9;//将skb-&gt;data指针移动到传输层头
</span><span class='line'>&#9;if (!pskb_pull(skb, skb_transport_offset(skb)))
</span><span class='line'>&#9;&#9;goto discard;
</span><span class='line'>
</span><span class='line'>&#9;nhoff = IP6CB(skb)-&gt;nhoff;
</span><span class='line'>&#9;nexthdr = skb_network_header(skb)[nhoff];//下一个扩展头协议
</span><span class='line'>
</span><span class='line'>&#9;//处理原始sock
</span><span class='line'>&#9;raw_sk = sk_head(&raw_v6_htable[nexthdr & (MAX_INET_PROTOS - 1)]);
</span><span class='line'>&#9;if (raw_sk && !ipv6_raw_deliver(skb, nexthdr))
</span><span class='line'>&#9;&#9;raw_sk = NULL;
</span><span class='line'>
</span><span class='line'>&#9;//向上层协议栈递交数据，看初始化时注册的一些协议，主要是tcp，udp等，还包括一些ip扩展头的处理
</span><span class='line'>&#9;hash = nexthdr & (MAX_INET_PROTOS - 1);
</span><span class='line'>&#9;if ((ipprot = rcu_dereference(inet6_protos[hash])) != NULL) {
</span><span class='line'>&#9;&#9;int ret;
</span><span class='line'>&#9;&#9;if (ipprot-&gt;flags & INET6_PROTO_FINAL) {
</span><span class='line'>&#9;&#9;&#9;struct ipv6hdr *hdr;
</span><span class='line'>&#9;&#9;&#9;/* Free reference early: we don't need it any more,                        
</span><span class='line'>&#9;&#9;&#9;   and it may hold ip_conntrack module loaded indefinitely. */
</span><span class='line'>&#9;&#9;&#9;nf_reset(skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;skb_postpull_rcsum(skb, skb_network_header(skb), skb_network_header_len(skb));
</span><span class='line'>&#9;&#9;&#9;hdr = ipv6_hdr(skb);
</span><span class='line'>&#9;&#9;&#9;if (ipv6_addr_is_multicast(&hdr-&gt;daddr) && !ipv6_chk_mcast_addr(skb-&gt;dev, &hdr-&gt;daddr, &hdr-&gt;saddr)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&& !ipv6_is_mld(skb, nexthdr))
</span><span class='line'>&#9;&#9;&#9;&#9;goto discard;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//处理 IPSEC v6 的相关部分
</span><span class='line'>&#9;&#9;if (!(ipprot-&gt;flags & INET6_PROTO_NOPOLICY) && !xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))
</span><span class='line'>&#9;&#9;&#9;goto discard;
</span><span class='line'>
</span><span class='line'>&#9;&#9;ret = ipprot-&gt;handler(skb); //上层协议处理，看下面ipv6扩展头处理
</span><span class='line'>&#9;&#9;if (ret &gt; 0)
</span><span class='line'>&#9;&#9;&#9;goto resubmit; //重新处理
</span><span class='line'>&#9;&#9;else if (ret == 0)
</span><span class='line'>&#9;&#9;&#9;IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDELIVERS);
</span><span class='line'>&#9;} else { //没有找到上层处理函数
</span><span class='line'>&#9;&#9;if (!raw_sk) {
</span><span class='line'>&#9;&#9;&#9;if (xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {
</span><span class='line'>&#9;&#9;&#9;&#9;IP6_INC_STATS_BH(idev, IPSTATS_MIB_INUNKNOWNPROTOS);
</span><span class='line'>&#9;&#9;&#9;&#9;icmpv6_send(skb, ICMPV6_PARAMPROB, ICMPV6_UNK_NEXTHDR, nhoff, skb-&gt;dev);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDELIVERS);
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>&#9;return 0;
</span><span class='line'>discard:
</span><span class='line'>&#9;IP6_INC_STATS_BH(idev, IPSTATS_MIB_INDISCARDS);
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>ipv6选项处理</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct tlvtype_proc tlvprochopopt_lst[] = {
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;.type   = IPV6_TLV_ROUTERALERT,
</span><span class='line'>&#9;&#9;.func   = ipv6_hop_ra,
</span><span class='line'>&#9;},
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;.type   = IPV6_TLV_JUMBO,
</span><span class='line'>&#9;&#9;.func   = ipv6_hop_jumbo,
</span><span class='line'>&#9;},
</span><span class='line'>&#9;{ -1, }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>解析路由警告选项</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int ipv6_hop_ra(struct sk_buff *skb, int optoff)
</span><span class='line'>{
</span><span class='line'>&#9;const unsigned char *nh = skb_network_header(skb); //获取网络头
</span><span class='line'>
</span><span class='line'>&#9;if (nh[optoff + 1] == 2) { //路由警告选项长度必须是2 ? rfc 要求是 4
</span><span class='line'>&#9;&#9;IP6CB(skb)-&gt;ra = optoff; //记录警告类型
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;LIMIT_NETDEBUG(KERN_DEBUG "ipv6_hop_ra: wrong RA length %d\n", nh[optoff + 1]);
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>解析jumbo frame选项</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int ipv6_hop_jumbo(struct sk_buff *skb, int optoff)
</span><span class='line'>{
</span><span class='line'>&#9;const unsigned char *nh = skb_network_header(skb);
</span><span class='line'>&#9;u32 pkt_len;
</span><span class='line'>&#9;//选项数据长度必须是4，选项类型必须是 0xc2， ＆3 后必须是2
</span><span class='line'>&#9;if (nh[optoff + 1] != 4 || (optoff & 3) != 2) {
</span><span class='line'>&#9;&#9;LIMIT_NETDEBUG(KERN_DEBUG "ipv6_hop_jumbo: wrong jumbo opt length/alignment %d\n", nh[optoff+1]);
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;goto drop;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;pkt_len = ntohl(*(__be32 *)(nh + optoff + 2)); //获取整个负载长度
</span><span class='line'>&#9;if (pkt_len &lt;= IPV6_MAXPLEN) { //小于65535 是不对地
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff+2);
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (ipv6_hdr(skb)-&gt;payload_len) { //原ipv6头中就不应该有负载长度了
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff);
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (pkt_len &gt; skb-&gt;len - sizeof(struct ipv6hdr)) { //长度超出了 skb 的实际长度
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INTRUNCATEDPKTS);
</span><span class='line'>&#9;&#9;goto drop;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//如果必要试图缩减 skb 的长度
</span><span class='line'>&#9;if (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))
</span><span class='line'>&#9;&#9;goto drop;
</span><span class='line'>
</span><span class='line'>&#9;return 1;
</span><span class='line'>drop:
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>目的选项处理</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct tlvtype_proc tlvprocdestopt_lst[] = {
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>&#9;{
</span><span class='line'>&#9;&#9;.type   = IPV6_TLV_HAO,
</span><span class='line'>&#9;&#9;.func   = ipv6_dest_hao,
</span><span class='line'>&#9;},
</span><span class='line'>#endif
</span><span class='line'>&#9;{-1,    NULL}
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>解析目的选项</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int ipv6_dest_hao(struct sk_buff *skb, int optoff)
</span><span class='line'>{
</span><span class='line'>&#9;struct ipv6_destopt_hao *hao;
</span><span class='line'>&#9;struct inet6_skb_parm *opt = IP6CB(skb);
</span><span class='line'>&#9;struct ipv6hdr *ipv6h = ipv6_hdr(skb);
</span><span class='line'>&#9;struct in6_addr tmp_addr;
</span><span class='line'>&#9;int ret;
</span><span class='line'>
</span><span class='line'>&#9;if (opt-&gt;dsthao) { //已经处理
</span><span class='line'>&#9;&#9;LIMIT_NETDEBUG(KERN_DEBUG "hao duplicated\n");
</span><span class='line'>&#9;&#9;goto discard;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;opt-&gt;dsthao = opt-&gt;dst1;
</span><span class='line'>&#9;opt-&gt;dst1 = 0;
</span><span class='line'>
</span><span class='line'>&#9;//获取网络头后面的选项部分
</span><span class='line'>&#9;hao = (struct ipv6_destopt_hao *)(skb_network_header(skb) + optoff);
</span><span class='line'>
</span><span class='line'>&#9;if (hao-&gt;length != 16) { //长度要求
</span><span class='line'>&#9;&#9;LIMIT_NETDEBUG(KERN_DEBUG "hao invalid option length = %d\n", hao-&gt;length);
</span><span class='line'>&#9;&#9;goto discard;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (!(ipv6_addr_type(&hao-&gt;addr) & IPV6_ADDR_UNICAST)) { //地址不是单播
</span><span class='line'>&#9;&#9;LIMIT_NETDEBUG(KERN_DEBUG "hao is not an unicast addr: " NIP6_FMT "\n", NIP6(hao-&gt;addr));
</span><span class='line'>&#9;&#9;goto discard;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//IPSEC相关
</span><span class='line'>&#9;ret = xfrm6_input_addr(skb, (xfrm_address_t *)&ipv6h-&gt;daddr, (xfrm_address_t *)&hao-&gt;addr, IPPROTO_DSTOPTS);
</span><span class='line'>&#9;if (unlikely(ret &lt; 0))
</span><span class='line'>&#9;&#9;goto discard;
</span><span class='line'>
</span><span class='line'>&#9;if (skb_cloned(skb)) { //如果包是cloned
</span><span class='line'>&#9;&#9;//分配新的内存数据
</span><span class='line'>&#9;&#9;if (pskb_expand_head(skb, 0, 0, GFP_ATOMIC))
</span><span class='line'>&#9;&#9;&#9;goto discard;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//重新指向各头
</span><span class='line'>&#9;&#9;hao = (struct ipv6_destopt_hao *)(skb_network_header(skb) + optoff);
</span><span class='line'>&#9;&#9;ipv6h = ipv6_hdr(skb);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)
</span><span class='line'>&#9;&#9;skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>
</span><span class='line'>&#9;//把ip头中的源地址与选项中的地址交换
</span><span class='line'>&#9;ipv6_addr_copy(&tmp_addr, &ipv6h-&gt;saddr);
</span><span class='line'>&#9;ipv6_addr_copy(&ipv6h-&gt;saddr, &hao-&gt;addr);
</span><span class='line'>&#9;ipv6_addr_copy(&hao-&gt;addr, &tmp_addr);
</span><span class='line'>
</span><span class='line'>&#9;if (skb-&gt;tstamp.tv64 == 0)
</span><span class='line'>&#9;&#9;__net_timestamp(skb); //记录时间截
</span><span class='line'>
</span><span class='line'>&#9;return 1;
</span><span class='line'>discard:
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>ipv6扩展头处理</h4>

<p>我们只介绍根ipv6扩展头相关的实现，像其他的扩展头(tcp, udp)等虽然也是叫扩展头但实际是传输层的内容，将在其他文章中介绍。</p>

<p>路由扩展首部</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct ipv6_rt_hdr {
</span><span class='line'>&#9;__u8            nexthdr;
</span><span class='line'>&#9;__u8            hdrlen;
</span><span class='line'>&#9;__u8            type;
</span><span class='line'>&#9;__u8            segments_left;
</span><span class='line'>
</span><span class='line'>&#9;/* type specific data variable length field */
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>路由扩展首部处理结构</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct inet6_protocol rthdr_protocol = {
</span><span class='line'>&#9;.handler        =       ipv6_rthdr_rcv,
</span><span class='line'>&#9;.flags          =       INET6_PROTO_NOPOLICY | INET6_PROTO_GSO_EXTHDR,
</span><span class='line'>};
</span><span class='line'>static int ipv6_rthdr_rcv(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet6_skb_parm *opt = IP6CB(skb);
</span><span class='line'>&#9;struct in6_addr *addr = NULL;
</span><span class='line'>&#9;struct in6_addr daddr;
</span><span class='line'>&#9;struct inet6_dev *idev;
</span><span class='line'>&#9;int n, i;
</span><span class='line'>&#9;struct ipv6_rt_hdr *hdr;
</span><span class='line'>&#9;struct rt0_hdr *rthdr;
</span><span class='line'>&#9;int accept_source_route = ipv6_devconf.accept_source_route;
</span><span class='line'>
</span><span class='line'>&#9;idev = in6_dev_get(skb-&gt;dev); //包进入设备
</span><span class='line'>&#9;if (idev) {
</span><span class='line'>&#9;&#9;if (accept_source_route &gt; idev-&gt;cnf.accept_source_route) //默认数量大于了手动调节(proc中）的数量
</span><span class='line'>&#9;&#9;&#9;accept_source_route = idev-&gt;cnf.accept_source_route;
</span><span class='line'>&#9;&#9;in6_dev_put(idev);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//skb长度和内存空间正确
</span><span class='line'>&#9;if (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) || !pskb_may_pull(skb, (skb_transport_offset(skb) +
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;((skb_transport_header(skb)[1] + 1) &lt;&lt; 3)))) {
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;hdr = (struct ipv6_rt_hdr *)skb_transport_header(skb); //路由扩展头
</span><span class='line'>&#9;//是到多播地址或硬件地址不是到本机的地址
</span><span class='line'>&#9;if (ipv6_addr_is_multicast(&ipv6_hdr(skb)-&gt;daddr) || skb-&gt;pkt_type != PACKET_HOST) {
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>looped_back:
</span><span class='line'>&#9;if (hdr-&gt;segments_left == 0) { //根据rfc要求 分段剩余为0
</span><span class='line'>&#9;&#9;switch (hdr-&gt;type) {
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>&#9;&#9;&#9;case IPV6_SRCRT_TYPE_2:
</span><span class='line'>&#9;&#9;&#9;&#9;/* Silently discard type 2 header unless it was processed by own */
</span><span class='line'>&#9;&#9;&#9;&#9;if (!addr) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;return -1;
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>#endif
</span><span class='line'>&#9;&#9;&#9;default:
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;opt-&gt;lastopt = opt-&gt;srcrt = skb_network_header_len(skb);
</span><span class='line'>&#9;&#9;skb-&gt;transport_header += (hdr-&gt;hdrlen + 1) &lt;&lt; 3; //下一个传输头的位置
</span><span class='line'>&#9;&#9;opt-&gt;dst0 = opt-&gt;dst1;
</span><span class='line'>&#9;&#9;opt-&gt;dst1 = 0;
</span><span class='line'>&#9;&#9;opt-&gt;nhoff = (&hdr-&gt;nexthdr) - skb_network_header(skb); //记录下一个头数据相对网络头的偏移量
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;switch (hdr-&gt;type) {
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>&#9;&#9;case IPV6_SRCRT_TYPE_2:
</span><span class='line'>&#9;&#9;&#9;if (accept_source_route &lt; 0)
</span><span class='line'>&#9;&#9;&#9;&#9;goto unknown_rh;
</span><span class='line'>&#9;&#9;&#9;/* Silently discard invalid RTH type 2 */
</span><span class='line'>&#9;&#9;&#9;if (hdr-&gt;hdrlen != 2 || hdr-&gt;segments_left != 1) {
</span><span class='line'>&#9;&#9;&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;&#9;&#9;return -1;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>#endif
</span><span class='line'>&#9;&#9;default:
</span><span class='line'>&#9;&#9;&#9;goto unknown_rh;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/* This is the routing header forwarding algorithm from RFC 2460, page 16. */
</span><span class='line'>
</span><span class='line'>&#9;n = hdr-&gt;hdrlen &gt;&gt; 1; //计算路由首部中的地址数量
</span><span class='line'>&#9;if (hdr-&gt;segments_left &gt; n) {
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, ((&hdr-&gt;segments_left) - skb_network_header(skb)));
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/* We are about to mangle packet header. Be careful!                                       
</span><span class='line'>&#9;   Do not damage packets queued somewhere.  */
</span><span class='line'>&#9;if (skb_cloned(skb)) {
</span><span class='line'>&#9;&#9;/* the copy is a forwarded packet */
</span><span class='line'>&#9;&#9;if (pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {
</span><span class='line'>&#9;&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_OUTDISCARDS);
</span><span class='line'>&#9;&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;&#9;return -1;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;hdr = (struct ipv6_rt_hdr *)skb_transport_header(skb);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)
</span><span class='line'>&#9;&#9;skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>
</span><span class='line'>&#9;i = n - --hdr-&gt;segments_left; //计算地址向量(地址列表)中要"访问"的下一个地址
</span><span class='line'>
</span><span class='line'>&#9;rthdr = (struct rt0_hdr *) hdr;
</span><span class='line'>&#9;addr = rthdr-&gt;addr; //指向地址列表首部
</span><span class='line'>&#9;addr += i - 1; //移动到下一个地址
</span><span class='line'>
</span><span class='line'>&#9;switch (hdr-&gt;type) {
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>&#9;&#9;case IPV6_SRCRT_TYPE_2:
</span><span class='line'>&#9;&#9;&#9;if (xfrm6_input_addr(skb, (xfrm_address_t *)addr, (xfrm_address_t *)&ipv6_hdr(skb)-&gt;saddr, IPPROTO_ROUTING) &lt; 0) {
</span><span class='line'>&#9;&#9;&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
</span><span class='line'>&#9;&#9;&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;&#9;&#9;return -1;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;if (!ipv6_chk_home_addr(addr)) {
</span><span class='line'>&#9;&#9;&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
</span><span class='line'>&#9;&#9;&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;&#9;&#9;return -1;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>#endif
</span><span class='line'>&#9;&#9;default:
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (ipv6_addr_is_multicast(addr)) { //这个地址是多播地址
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INADDRERRORS);
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//交换 IPv6 目的地址和这个地址
</span><span class='line'>&#9;ipv6_addr_copy(&daddr, addr);
</span><span class='line'>&#9;ipv6_addr_copy(addr, &ipv6_hdr(skb)-&gt;daddr);
</span><span class='line'>&#9;ipv6_addr_copy(&ipv6_hdr(skb)-&gt;daddr, &daddr);
</span><span class='line'>&#9;dst_release(xchg(&skb-&gt;dst, NULL));
</span><span class='line'>
</span><span class='line'>&#9;ip6_route_input(skb); //路由查找处理，将在其他文章中介绍
</span><span class='line'>
</span><span class='line'>&#9;if (skb-&gt;dst-&gt;error) {
</span><span class='line'>&#9;&#9;skb_push(skb, skb-&gt;data - skb_network_header(skb));
</span><span class='line'>&#9;&#9;dst_input(skb);
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (skb-&gt;dst-&gt;dev-&gt;flags & IFF_LOOPBACK) { //路由查找后要发送到的目的设备是回环
</span><span class='line'>&#9;&#9;if (ipv6_hdr(skb)-&gt;hop_limit &lt;= 1) { //跳数限制小于1
</span><span class='line'>&#9;&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;&#9;//给源地址发送一个 ICMP "超时 – 传输超过跳数限制" 的报文, 并且抛弃此包
</span><span class='line'>&#9;&#9;&#9;icmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0, skb-&gt;dev);
</span><span class='line'>&#9;&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;&#9;return -1;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;ipv6_hdr(skb)-&gt;hop_limit--;
</span><span class='line'>&#9;&#9;goto looped_back;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//将data之中移动到网络头
</span><span class='line'>&#9;skb_push(skb, skb-&gt;data - skb_network_header(skb));
</span><span class='line'>&#9;dst_input(skb); //这时包应该被转发了
</span><span class='line'>&#9;return -1;
</span><span class='line'>unknown_rh:
</span><span class='line'>&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, (&hdr-&gt;type) - skb_network_header(skb));
</span><span class='line'>&#9;return -1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ipv6分配包扩展首部处理</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct inet6_protocol frag_protocol =
</span><span class='line'>{
</span><span class='line'>&#9;.handler        =       ipv6_frag_rcv,
</span><span class='line'>&#9;.flags          =       INET6_PROTO_NOPOLICY,
</span><span class='line'>};
</span><span class='line'>static int ipv6_frag_rcv(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct frag_hdr *fhdr;
</span><span class='line'>&#9;struct frag_queue *fq;
</span><span class='line'>&#9;struct ipv6hdr *hdr = ipv6_hdr(skb);
</span><span class='line'>
</span><span class='line'>&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMREQDS);
</span><span class='line'>
</span><span class='line'>&#9;/* Jumbo payload inhibits frag. header */
</span><span class='line'>&#9;if (hdr-&gt;payload_len == 0) { //是Jumbo payload，不是分片包
</span><span class='line'>&#9;&#9;IP6_INC_STATS(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, skb_network_header_len(skb));
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//有碎片头空间
</span><span class='line'>&#9;if (!pskb_may_pull(skb, (skb_transport_offset(skb) + sizeof(struct frag_hdr)))) {
</span><span class='line'>&#9;&#9;IP6_INC_STATS(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, skb_network_header_len(skb));
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;hdr = ipv6_hdr(skb);
</span><span class='line'>&#9;fhdr = (struct frag_hdr *)skb_transport_header(skb); //分片头
</span><span class='line'>
</span><span class='line'>&#9;if (!(fhdr-&gt;frag_off & htons(0xFFF9))) { //没有分片偏移，不是分片包
</span><span class='line'>&#9;&#9;/* It is not a fragmented frame */
</span><span class='line'>&#9;&#9;skb-&gt;transport_header += sizeof(struct frag_hdr); //传输头向后移动到下一个头
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMOKS);
</span><span class='line'>&#9;&#9;IP6CB(skb)-&gt;nhoff = (u8 *)fhdr - skb_network_header(skb);
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (atomic_read(&ip6_frags.mem) &gt; ip6_frags_ctl.high_thresh) //内存使用超过限制
</span><span class='line'>&#9;&#9;ip6_evictor(ip6_dst_idev(skb-&gt;dst));
</span><span class='line'>
</span><span class='line'>&#9;//查找或创建分片队列头
</span><span class='line'>&#9;if ((fq = fq_find(fhdr-&gt;identification, &hdr-&gt;saddr, &hdr-&gt;daddr, ip6_dst_idev(skb-&gt;dst))) != NULL) {
</span><span class='line'>&#9;&#9;int ret;
</span><span class='line'>&#9;&#9;spin_lock(&fq-&gt;q.lock);
</span><span class='line'>&#9;&#9;ret = ip6_frag_queue(fq, skb, fhdr, IP6CB(skb)-&gt;nhoff); //入队重组
</span><span class='line'>&#9;&#9;spin_unlock(&fq-&gt;q.lock);
</span><span class='line'>&#9;&#9;fq_put(fq);
</span><span class='line'>&#9;&#9;return ret;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMFAILS);
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return -1;
</span><span class='line'>}
</span><span class='line'>static __inline__ struct frag_queue * fq_find(__be32 id, struct in6_addr *src, struct in6_addr *dst, struct inet6_dev *idev)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_frag_queue *q;
</span><span class='line'>&#9;struct ip6_create_arg arg;
</span><span class='line'>&#9;unsigned int hash;
</span><span class='line'>
</span><span class='line'>&#9;arg.id = id;
</span><span class='line'>&#9;arg.src = src;
</span><span class='line'>&#9;arg.dst = dst;
</span><span class='line'>&#9;hash = ip6qhashfn(id, src, dst); //id，源，目的进行 hash
</span><span class='line'>
</span><span class='line'>&#9;q = inet_frag_find(&ip6_frags, &arg, hash); //查找或创建
</span><span class='line'>&#9;if (q == NULL)
</span><span class='line'>&#9;&#9;goto oom;
</span><span class='line'>
</span><span class='line'>&#9;return container_of(q, struct frag_queue, q); //成功返回
</span><span class='line'>oom: //没内存了
</span><span class='line'>&#9;IP6_INC_STATS_BH(idev, IPSTATS_MIB_REASMFAILS);
</span><span class='line'>&#9;return NULL;
</span><span class='line'>}
</span><span class='line'>struct inet_frag_queue *inet_frag_find(struct inet_frags *f, void *key, unsigned int hash)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_frag_queue *q;
</span><span class='line'>&#9;struct hlist_node *n;
</span><span class='line'>
</span><span class='line'>&#9;read_lock(&f-&gt;lock);
</span><span class='line'>&#9;hlist_for_each_entry(q, n, &f-&gt;hash[hash], list) { //在hash桶中查找
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (f-&gt;match(q, key)) { //调用匹配函数进行匹配，具体函数很简单参考初始化时的ipv6_frag_init函数
</span><span class='line'>&#9;&#9;&#9;atomic_inc(&q-&gt;refcnt);
</span><span class='line'>&#9;&#9;&#9;read_unlock(&f-&gt;lock);
</span><span class='line'>&#9;&#9;&#9;return q;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//没有找到就创建一个
</span><span class='line'>&#9;return inet_frag_create(f, key, hash);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>创建分片队列</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct inet_frag_queue *inet_frag_create(struct inet_frags *f, void *arg, unsigned int hash)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_frag_queue *q;
</span><span class='line'>
</span><span class='line'>&#9;q = inet_frag_alloc(f, arg); //分配一个
</span><span class='line'>&#9;if (q == NULL)
</span><span class='line'>&#9;&#9;return NULL;
</span><span class='line'>&#9;//添加到 hash 表
</span><span class='line'>&#9;return inet_frag_intern(q, f, hash, arg);
</span><span class='line'>}
</span><span class='line'>static struct inet_frag_queue *inet_frag_alloc(struct inet_frags *f, void *arg)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_frag_queue *q;
</span><span class='line'>
</span><span class='line'>&#9;q = kzalloc(f-&gt;qsize, GFP_ATOMIC); //分配一个队列头，大小是 sizeof(struct frag_queue)
</span><span class='line'>&#9;if (q == NULL)
</span><span class='line'>&#9;&#9;return NULL;
</span><span class='line'>
</span><span class='line'>&#9;f-&gt;constructor(q, arg); //拷贝地址和 id 到队列头结构中
</span><span class='line'>&#9;atomic_add(f-&gt;qsize, &f-&gt;mem);
</span><span class='line'>&#9;setup_timer(&q-&gt;timer, f-&gt;frag_expire, (unsigned long)q);
</span><span class='line'>&#9;spin_lock_init(&q-&gt;lock);
</span><span class='line'>&#9;atomic_set(&q-&gt;refcnt, 1);
</span><span class='line'>&#9;return q;
</span><span class='line'>}
</span><span class='line'>static struct inet_frag_queue *inet_frag_intern(struct inet_frag_queue *qp_in, struct inet_frags *f, unsigned int hash, void *arg)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet_frag_queue *qp;
</span><span class='line'>#ifdef CONFIG_SMP
</span><span class='line'>&#9;struct hlist_node *n;
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>&#9;write_lock(&f-&gt;lock);
</span><span class='line'>#ifdef CONFIG_SMP
</span><span class='line'>&#9;//其他cpu可能已经创建了一个，所以要再次检查
</span><span class='line'>&#9;hlist_for_each_entry(qp, n, &f-&gt;hash[hash], list) {
</span><span class='line'>&#9;&#9;if (f-&gt;match(qp, arg)) { //已经创建
</span><span class='line'>&#9;&#9;&#9;atomic_inc(&qp-&gt;refcnt);
</span><span class='line'>&#9;&#9;&#9;write_unlock(&f-&gt;lock);
</span><span class='line'>&#9;&#9;&#9;qp_in-&gt;last_in |= COMPLETE;
</span><span class='line'>&#9;&#9;&#9;inet_frag_put(qp_in, f); //释放新分配的
</span><span class='line'>&#9;&#9;&#9;return qp;
</span><span class='line'>
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>#endif
</span><span class='line'>&#9;qp = qp_in;
</span><span class='line'>&#9;if (!mod_timer(&qp-&gt;timer, jiffies + f-&gt;ctl-&gt;timeout)) //启动定时器
</span><span class='line'>&#9;&#9;atomic_inc(&qp-&gt;refcnt);
</span><span class='line'>
</span><span class='line'>&#9;//增加引用计数，然后添加到hash表
</span><span class='line'>&#9;atomic_inc(&qp-&gt;refcnt);
</span><span class='line'>&#9;hlist_add_head(&qp-&gt;list, &f-&gt;hash[hash]);
</span><span class='line'>&#9;list_add_tail(&qp-&gt;lru_list, &f-&gt;lru_list);
</span><span class='line'>&#9;f-&gt;nqueues++;
</span><span class='line'>&#9;write_unlock(&f-&gt;lock);
</span><span class='line'>&#9;return qp;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>入队重组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb, struct frag_hdr *fhdr, int nhoff)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *prev, *next;
</span><span class='line'>&#9;struct net_device *dev;
</span><span class='line'>&#9;int offset, end;
</span><span class='line'>
</span><span class='line'>&#9;if (fq-&gt;q.last_in & COMPLETE) //重组已经完成
</span><span class='line'>&#9;&#9;goto err;
</span><span class='line'>
</span><span class='line'>&#9;//分片开始位置
</span><span class='line'>&#9;offset = ntohs(fhdr-&gt;frag_off) & ~0x7;//偏移必须8字节对齐
</span><span class='line'>&#9;//分片在整个包中的结束位置 包负载长度 - 分片头长度
</span><span class='line'>&#9;end = offset + (ntohs(ipv6_hdr(skb)-&gt;payload_len) -  ((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));
</span><span class='line'>
</span><span class='line'>&#9;//结束位置 &gt; 65535
</span><span class='line'>&#9;if ((unsigned int)end &gt; IPV6_MAXPLEN) {
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, ((u8 *)&fhdr-&gt;frag_off - skb_network_header(skb)));
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//校验和已经完成
</span><span class='line'>&#9;if (skb-&gt;ip_summed == CHECKSUM_COMPLETE) {
</span><span class='line'>&#9;&#9;const unsigned char *nh = skb_network_header(skb);
</span><span class='line'>&#9;&#9;//减去分片包头的校验和
</span><span class='line'>&#9;&#9;skb-&gt;csum = csum_sub(skb-&gt;csum, csum_partial(nh, (u8 *)(fhdr + 1) - nh, 0));
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//最后一个碎片包
</span><span class='line'>&#9;if (!(fhdr-&gt;frag_off & htons(IP6_MF))) {
</span><span class='line'>&#9;&#9;/* If we already have some bits beyond end or have different end, the segment is corrupted. */
</span><span class='line'>&#9;&#9;if (end &lt; fq-&gt;q.len || ((fq-&gt;q.last_in & LAST_IN) && end != fq-&gt;q.len)) //分片出现错误
</span><span class='line'>&#9;&#9;&#9;goto err;
</span><span class='line'>
</span><span class='line'>&#9;&#9;fq-&gt;q.last_in |= LAST_IN; //标识最后一个分片
</span><span class='line'>&#9;&#9;fq-&gt;q.len = end; //记录包总长度
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;/* Check if the fragment is rounded to 8 bytes. Required by the RFC. */
</span><span class='line'>&#9;&#9;if (end & 0x7) { //碎片结尾也需要8字节对齐
</span><span class='line'>&#9;&#9;&#9;/* RFC2460 says always send parameter problem in this case. -DaveM */
</span><span class='line'>&#9;&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), PSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;&#9;icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, offsetof(struct ipv6hdr, payload_len));
</span><span class='line'>&#9;&#9;&#9;return -1;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;if (end &gt; fq-&gt;q.len) {
</span><span class='line'>&#9;&#9;&#9;/* Some bits beyond end -&gt; corruption. */
</span><span class='line'>&#9;&#9;&#9;if (fq-&gt;q.last_in & LAST_IN)
</span><span class='line'>&#9;&#9;&#9;&#9;goto err;
</span><span class='line'>&#9;&#9;&#9;fq-&gt;q.len = end; //记录已经得到的碎片的最大长度
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (end == offset) //开始 = 结束
</span><span class='line'>&#9;&#9;goto err;
</span><span class='line'>
</span><span class='line'>&#9;//skb-&gt;data 指向碎片首部头后数据部分
</span><span class='line'>&#9;if (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb-&gt;data))
</span><span class='line'>&#9;&#9;goto err;
</span><span class='line'>&#9;//如果需要缩短skb的内存长度
</span><span class='line'>&#9;if (pskb_trim_rcsum(skb, end - offset))
</span><span class='line'>&#9;&#9;goto err;
</span><span class='line'>
</span><span class='line'>&#9;//找出碎片所在位置
</span><span class='line'>&#9;prev = NULL;
</span><span class='line'>&#9;for(next = fq-&gt;q.fragments; next != NULL; next = next-&gt;next) {
</span><span class='line'>&#9;&#9;if (FRAG6_CB(next)-&gt;offset &gt;= offset)
</span><span class='line'>&#9;&#9;&#9;break;  /* bingo! */
</span><span class='line'>&#9;&#9;prev = next;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;if (prev) { //有前一个碎片
</span><span class='line'>&#9;&#9;//前一个碎片 (开始 + 长度) - 这个碎片的开始. 计算出重叠部分
</span><span class='line'>&#9;&#9;int i = (FRAG6_CB(prev)-&gt;offset + prev-&gt;len) - offset;
</span><span class='line'>&#9;&#9;if (i &gt; 0) { //有重叠
</span><span class='line'>&#9;&#9;&#9;offset += i; //调整这个碎片的开始位置
</span><span class='line'>&#9;&#9;&#9;if (end &lt;= offset) //调整后出错
</span><span class='line'>&#9;&#9;&#9;&#9;goto err;
</span><span class='line'>&#9;&#9;&#9;if (!pskb_pull(skb, i))//skb-&gt;data += i;
</span><span class='line'>&#9;&#9;&#9;&#9;goto err;
</span><span class='line'>&#9;&#9;&#9;if (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)
</span><span class='line'>&#9;&#9;&#9;&#9;skb-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//有下一个碎片，且开始位置 &lt; 这个碎片的结束位置
</span><span class='line'>&#9;while (next && FRAG6_CB(next)-&gt;offset &lt; end) {
</span><span class='line'>&#9;&#9;//这个碎片的结束位置  - 下一个碎片的开始位置，计算重叠
</span><span class='line'>&#9;&#9;int i = end - FRAG6_CB(next)-&gt;offset; /* overlap is 'i' bytes */
</span><span class='line'>&#9;&#9;if (i &lt; next-&gt;len) { //重叠长度 &lt; 下一个碎片的长度
</span><span class='line'>&#9;&#9;&#9;if (!pskb_pull(next, i)) //next-&gt;data += i;
</span><span class='line'>&#9;&#9;&#9;&#9;goto err;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;FRAG6_CB(next)-&gt;offset += i;    //下一个碎片开始位置调整
</span><span class='line'>&#9;&#9;&#9;fq-&gt;q.meat -= i; //总长度减少
</span><span class='line'>&#9;&#9;&#9;if (next-&gt;ip_summed != CHECKSUM_UNNECESSARY)
</span><span class='line'>&#9;&#9;&#9;&#9;next-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;} else { //这个碎片完全复盖了下一个碎片
</span><span class='line'>&#9;&#9;&#9;struct sk_buff *free_it = next; //释放这个碎片
</span><span class='line'>&#9;&#9;&#9;next = next-&gt;next;//调整下一个碎片指针
</span><span class='line'>&#9;&#9;&#9;//调整队列指针
</span><span class='line'>&#9;&#9;&#9;if (prev)
</span><span class='line'>&#9;&#9;&#9;&#9;prev-&gt;next = next;
</span><span class='line'>&#9;&#9;&#9;else
</span><span class='line'>&#9;&#9;&#9;&#9;fq-&gt;q.fragments = next;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;fq-&gt;q.meat -= free_it-&gt;len;
</span><span class='line'>&#9;&#9;&#9;frag_kfree_skb(free_it, NULL); //释放被复盖的包
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;FRAG6_CB(skb)-&gt;offset = offset; //这个碎片包记录自己的开始位置
</span><span class='line'>
</span><span class='line'>&#9;//插入这个碎片到队列
</span><span class='line'>&#9;skb-&gt;next = next;
</span><span class='line'>&#9;if (prev)
</span><span class='line'>&#9;&#9;prev-&gt;next = skb;
</span><span class='line'>&#9;else
</span><span class='line'>&#9;&#9;fq-&gt;q.fragments = skb;
</span><span class='line'>
</span><span class='line'>&#9;dev = skb-&gt;dev;
</span><span class='line'>&#9;if (dev) {
</span><span class='line'>&#9;&#9;fq-&gt;iif = dev-&gt;ifindex;
</span><span class='line'>&#9;&#9;skb-&gt;dev = NULL;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;fq-&gt;q.stamp = skb-&gt;tstamp;
</span><span class='line'>&#9;fq-&gt;q.meat += skb-&gt;len; //累加总长度
</span><span class='line'>&#9;atomic_add(skb-&gt;truesize, &ip6_frags.mem);
</span><span class='line'>
</span><span class='line'>&#9;if (offset == 0) { //偏移为0
</span><span class='line'>&#9;&#9;fq-&gt;nhoffset = nhoff;
</span><span class='line'>&#9;&#9;fq-&gt;q.last_in |= FIRST_IN; //标识开始碎片
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//碎片已经聚齐，记录长度 = 包中标识的长度
</span><span class='line'>&#9;if (fq-&gt;q.last_in == (FIRST_IN | LAST_IN) && fq-&gt;q.meat == fq-&gt;q.len)
</span><span class='line'>&#9;&#9;return ip6_frag_reasm(fq, prev, dev); //重组
</span><span class='line'>&#9;//没有聚齐，移动队列连表到lru连表尾部
</span><span class='line'>&#9;write_lock(&ip6_frags.lock);
</span><span class='line'>&#9;list_move_tail(&fq-&gt;q.lru_list, &ip6_frags.lru_list);
</span><span class='line'>&#9;write_unlock(&ip6_frags.lock);
</span><span class='line'>&#9;return -1;
</span><span class='line'>err:
</span><span class='line'>&#9;IP6_INC_STATS(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_REASMFAILS);
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return -1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>重组ip头</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev, struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *fp, *head = fq-&gt;q.fragments;
</span><span class='line'>&#9;int    payload_len;
</span><span class='line'>&#9;unsigned int nhoff;
</span><span class='line'>
</span><span class='line'>&#9;fq_kill(fq); //把这个重组队列出队
</span><span class='line'>
</span><span class='line'>&#9;/* Make the one we just received the head. */
</span><span class='line'>&#9;if (prev) {
</span><span class='line'>&#9;&#9;//下面是把head指向的skb复制到fp，然后把fp插入到head指向的位置
</span><span class='line'>&#9;&#9;head = prev-&gt;next;
</span><span class='line'>&#9;&#9;fp = skb_clone(head, GFP_ATOMIC);
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!fp)
</span><span class='line'>&#9;&#9;&#9;goto out_oom;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&#9;&#9;fp-&gt;next = head-&gt;next;
</span><span class='line'>&#9;&#9;prev-&gt;next = fp;
</span><span class='line'>&#9;&#9;//把真正的头skb复制到head指针的skb
</span><span class='line'>&#9;&#9;skb_morph(head, fq-&gt;q.fragments);
</span><span class='line'>&#9;&#9;head-&gt;next = fq-&gt;q.fragments-&gt;next;
</span><span class='line'>
</span><span class='line'>&#9;&#9;kfree_skb(fq-&gt;q.fragments);//释放原来的头
</span><span class='line'>&#9;&#9;fq-&gt;q.fragments = head;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/* Unfragmented part is taken from the first segment. */
</span><span class='line'>&#9;//计算负载总长度
</span><span class='line'>&#9;payload_len = ((head-&gt;data - skb_network_header(head)) - sizeof(struct ipv6hdr) + fq-&gt;q.len -  sizeof(struct frag_hdr));
</span><span class='line'>&#9;if (payload_len &gt; IPV6_MAXPLEN) //超过65535
</span><span class='line'>&#9;&#9;goto out_oversize;
</span><span class='line'>
</span><span class='line'>&#9;/* Head of list must not be cloned. */
</span><span class='line'>&#9;//如果skb被克隆，从新分配他的data
</span><span class='line'>&#9;if (skb_cloned(head) && pskb_expand_head(head, 0, 0, GFP_ATOMIC))
</span><span class='line'>&#9;&#9;goto out_oom;
</span><span class='line'>
</span><span class='line'>&#9;/* If the first fragment is fragmented itself, we split it to two chunks: the first with data and paged part
</span><span class='line'>&#9; * and the second, holding only fragments.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (skb_shinfo(head)-&gt;frag_list) {//如果头自己已经被分片
</span><span class='line'>&#9;&#9;struct sk_buff *clone;
</span><span class='line'>&#9;&#9;int i, plen = 0;
</span><span class='line'>
</span><span class='line'>&#9;&#9;if ((clone = alloc_skb(0, GFP_ATOMIC)) == NULL)
</span><span class='line'>&#9;&#9;&#9;goto out_oom;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//把这个clone插入到头后               
</span><span class='line'>&#9;&#9;clone-&gt;next = head-&gt;next;
</span><span class='line'>&#9;&#9;head-&gt;next = clone;
</span><span class='line'>&#9;&#9;//把头的分片给这个clone
</span><span class='line'>&#9;&#9;skb_shinfo(clone)-&gt;frag_list = skb_shinfo(head)-&gt;frag_list;
</span><span class='line'>&#9;&#9;skb_shinfo(head)-&gt;frag_list = NULL;
</span><span class='line'>&#9;&#9;//头使用了页面，计算总长度
</span><span class='line'>&#9;&#9;for (i = 0; i &lt; skb_shinfo(head)-&gt;nr_frags; i++)
</span><span class='line'>&#9;&#9;&#9;plen += skb_shinfo(head)-&gt;frags[i].size;
</span><span class='line'>
</span><span class='line'>&#9;&#9;clone-&gt;len = clone-&gt;data_len = head-&gt;data_len - plen;
</span><span class='line'>&#9;&#9;head-&gt;data_len -= clone-&gt;len;
</span><span class='line'>&#9;&#9;head-&gt;len -= clone-&gt;len;
</span><span class='line'>&#9;&#9;clone-&gt;csum = 0;
</span><span class='line'>&#9;&#9;clone-&gt;ip_summed = head-&gt;ip_summed;
</span><span class='line'>&#9;&#9;atomic_add(clone-&gt;truesize, &ip6_frags.mem);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/* We have to remove fragment header from datagram and to relocate                         
</span><span class='line'>&#9; * header in order to calculate ICV correctly. */
</span><span class='line'>&#9;nhoff = fq-&gt;nhoffset;
</span><span class='line'>&#9;//把传输头（分片头）中的下一个头字段值赋给网络头中的下一个头字段
</span><span class='line'>&#9;skb_network_header(head)[nhoff] = skb_transport_header(head)[0];
</span><span class='line'>&#9;//把分片首部复盖掉
</span><span class='line'>&#9;memmove(head-&gt;head + sizeof(struct frag_hdr), head-&gt;head, (head-&gt;data - head-&gt;head) - sizeof(struct frag_hdr));
</span><span class='line'>&#9;//调整相应的各个层的头位置
</span><span class='line'>&#9;head-&gt;mac_header += sizeof(struct frag_hdr);
</span><span class='line'>&#9;head-&gt;network_header += sizeof(struct frag_hdr);
</span><span class='line'>
</span><span class='line'>&#9;skb_shinfo(head)-&gt;frag_list = head-&gt;next; //保存碎片连表
</span><span class='line'>&#9;skb_reset_transport_header(head);//重新调整网络头，现在指向分片头后的头
</span><span class='line'>&#9;skb_push(head, head-&gt;data - skb_network_header(head));//使head-&gt;data指向网络头
</span><span class='line'>&#9;atomic_sub(head-&gt;truesize, &ip6_frags.mem);
</span><span class='line'>
</span><span class='line'>&#9;for (fp = head-&gt;next; fp; fp = fp-&gt;next) { //统计分片总长度
</span><span class='line'>&#9;&#9;head-&gt;data_len += fp-&gt;len;
</span><span class='line'>&#9;&#9;head-&gt;len += fp-&gt;len;
</span><span class='line'>&#9;&#9;if (head-&gt;ip_summed != fp-&gt;ip_summed)
</span><span class='line'>&#9;&#9;&#9;head-&gt;ip_summed = CHECKSUM_NONE;
</span><span class='line'>&#9;&#9;else if (head-&gt;ip_summed == CHECKSUM_COMPLETE)
</span><span class='line'>&#9;&#9;&#9;head-&gt;csum = csum_add(head-&gt;csum, fp-&gt;csum); //添加各分片的累加和
</span><span class='line'>
</span><span class='line'>&#9;&#9;head-&gt;truesize += fp-&gt;truesize;
</span><span class='line'>&#9;&#9;atomic_sub(fp-&gt;truesize, &ip6_frags.mem);
</span><span class='line'>&#9;}
</span><span class='line'>&#9;head-&gt;next = NULL;
</span><span class='line'>&#9;head-&gt;dev = dev;
</span><span class='line'>&#9;head-&gt;tstamp = fq-&gt;q.stamp;
</span><span class='line'>&#9;ipv6_hdr(head)-&gt;payload_len = htons(payload_len); //总长度
</span><span class='line'>&#9;IP6CB(head)-&gt;nhoff = nhoff;
</span><span class='line'>
</span><span class='line'>&#9;/* Yes, and fold redundant checksum back. 8) */
</span><span class='line'>&#9;if (head-&gt;ip_summed == CHECKSUM_COMPLETE) //添加网络头累加和
</span><span class='line'>&#9;&#9;head-&gt;csum = csum_partial(skb_network_header(head), skb_network_header_len(head), head-&gt;csum);
</span><span class='line'>
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;IP6_INC_STATS_BH(__in6_dev_get(dev), IPSTATS_MIB_REASMOKS);
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>&#9;fq-&gt;q.fragments = NULL;
</span><span class='line'>&#9;return 1;
</span><span class='line'>&#9;...... //下面是错误处理
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>无数据扩展头</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct inet6_protocol nodata_protocol = {
</span><span class='line'>&#9;.handler        =       ipv6_nodata_rcv,
</span><span class='line'>&#9;.flags          =       INET6_PROTO_NOPOLICY,
</span><span class='line'>};
</span><span class='line'>static int ipv6_nodata_rcv(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>目的选项首部处理</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct inet6_protocol destopt_protocol = {
</span><span class='line'>&#9;.handler        =       ipv6_destopt_rcv,
</span><span class='line'>&#9;.flags          =       INET6_PROTO_NOPOLICY | INET6_PROTO_GSO_EXTHDR,
</span><span class='line'>};
</span><span class='line'>static int ipv6_destopt_rcv(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct inet6_skb_parm *opt = IP6CB(skb);
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>&#9;__u16 dstbuf;
</span><span class='line'>#endif
</span><span class='line'>&#9;struct dst_entry *dst;
</span><span class='line'>&#9;//长度验证
</span><span class='line'>&#9;if (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) || !pskb_may_pull(skb, (skb_transport_offset(skb) +
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;((skb_transport_header(skb)[1] + 1) &lt;&lt; 3)))) {
</span><span class='line'>&#9;&#9;IP6_INC_STATS_BH(ip6_dst_idev(skb-&gt;dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;return -1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;opt-&gt;lastopt = opt-&gt;dst1 = skb_network_header_len(skb); //网络头长度
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>&#9;dstbuf = opt-&gt;dst1;
</span><span class='line'>#endif
</span><span class='line'>&#9;dst = dst_clone(skb-&gt;dst); //增加dst的引用计数
</span><span class='line'>&#9;//解析tlv，上面已经看到过了
</span><span class='line'>&#9;if (ip6_parse_tlv(tlvprocdestopt_lst, skb)) {
</span><span class='line'>&#9;&#9;dst_release(dst);
</span><span class='line'>&#9;&#9;skb-&gt;transport_header += (skb_transport_header(skb)[1] + 1) &lt;&lt; 3; //调整网络头位置
</span><span class='line'>&#9;&#9;opt = IP6CB(skb);
</span><span class='line'>#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
</span><span class='line'>&#9;&#9;opt-&gt;nhoff = dstbuf;
</span><span class='line'>#else
</span><span class='line'>&#9;&#9;opt-&gt;nhoff = opt-&gt;dst1;
</span><span class='line'>#endif
</span><span class='line'>&#9;&#9;return 1;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;IP6_INC_STATS_BH(ip6_dst_idev(dst), IPSTATS_MIB_INHDRERRORS);
</span><span class='line'>&#9;dst_release(dst);
</span><span class='line'>&#9;return -1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-06-18T10:44:00+08:00'><span class='date'>2015-06-18</span> <span class='time'>10:44:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~net/'>net</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/06/12/kernel-net-tcp-close/" title="Previous Post: linux内核中tcp连接的断开处理">&laquo; linux内核中tcp连接的断开处理</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/06/18/android-bootloader/" title="Next Post: Android系统典型bootloader分析">Android系统典型bootloader分析 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
