
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>linux内核分析之调度算法（一） - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>date [-d @int|str] [+%s|"+%F %T"]</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">linux内核分析之调度算法（一）</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-14T23:49:00+08:00'><span class='date'>2015-01-14</span> <span class='time'>23:49:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.csdn.net/bullbat/article/details/7160246">http://blog.csdn.net/bullbat/article/details/7160246</a></p>

<p>linux调度算法在2.6.32中采用调度类实现模块式的调度方式。这样，能够很好的加入新的调度算法。</p>

<p>linux调度器是以模块方式提供的，这样做的目的是允许不同类型的进程可以有针对性地选择调度算法。这种模块化结构被称为调度器类，他允许多种不同哦可动态添加的调度算法并存，调度属于自己范畴的进程。每个调度器都有一个优先级，调度代码会按照优先级遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，去选择下面要执行的那个程序。</p>

<p>linux上主要有两大类调度算法，CFS(完全公平调度算法）和实时调度算法。宏SCHED_NOMAL主要用于CFS调度，而SCHED_FIFO和SCHED_RR主要用于实时调度。如下面的宏定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * Scheduling policies
</span><span class='line'> */
</span><span class='line'> /*支援Real-Time Task的排程,包括有SCHED_FIFO與SCHED_RR. 
</span><span class='line'> */
</span><span class='line'> 
</span><span class='line'> /*(也稱為SCHED_OTHER): 主要用以排程
</span><span class='line'> 一般目的的Task.*/
</span><span class='line'>#define SCHED_NORMAL      0
</span><span class='line'>#define SCHED_FIFO        1
</span><span class='line'>/*task預設的 Time Slice長度為100 msecs*/
</span><span class='line'>#define SCHED_RR      2
</span><span class='line'>/*主要用以讓Task可以延長執行的時間
</span><span class='line'>(Time Slice),減少被中斷發生Task Context-Switch
</span><span class='line'>的次數.藉此可以提高 Cache的利用率 
</span><span class='line'>(每次Context-Switch都會導致Cache-Flush). 比
</span><span class='line'>較適合用在固定週期執行的Batch Jobs任
</span><span class='line'>務主機上,而不適合用在需要使用者互
</span><span class='line'>動的產品 (會由於Task切換的延遲,而
</span><span class='line'>感覺到系統效能不佳或是反應太慢).*/
</span><span class='line'>#define SCHED_BATCH       3
</span><span class='line'>/* SCHED_ISO: reserved but not implemented yet */
</span><span class='line'>/*為系統中的Idle Task排程.*/
</span><span class='line'>#define SCHED_IDLE        5</span></code></pre></td></tr></table></div></figure>


<p>linux调度算法实现的高层数据结构主要有运行实体、调度类、运行队列，下面我们主要看看这几个数据结构的字段和意义。<br/>
运行实体，rq结构体每个cpu有一个，主要存储一些基本的用于调度的信息，包括实时调度的和CFS调度的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> /*每个处理器都会配置一个rq*/
</span><span class='line'>struct rq {
</span><span class='line'>&#9;/* runqueue lock: */
</span><span class='line'>&#9;spinlock_t lock;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * nr_running and cpu_load should be in the same cacheline because
</span><span class='line'>&#9; * remote CPUs use both these fields when doing load calculation.
</span><span class='line'>&#9; */
</span><span class='line'>&#9; /*用以记录目前处理器rq中执行task的数量*/
</span><span class='line'>&#9;unsigned long nr_running;
</span><span class='line'>&#9;#define CPU_LOAD_IDX_MAX 5
</span><span class='line'>&#9;/*用以表示处理器的负载，在每个处理器的rq中
</span><span class='line'>&#9;都会有对应到该处理器的cpu_load参数配置，在每次
</span><span class='line'>&#9;处理器触发scheduler tick时，都会呼叫函数
</span><span class='line'>&#9;update_cpu_load_active,进行cpu_load的更新。在系统初始化的时候
</span><span class='line'>&#9;会呼叫函数sched_init把rq的cpu_load array初始化为0.
</span><span class='line'>&#9;了解他的更新方式最好的方式是通过函数update_cpu_load,公式如下澹?
</span><span class='line'>&#9;cpu_load[0]会直接等待rq中load.weight的值。
</span><span class='line'>&#9;cpu_load[1]=(cpu_load[1]*(2-1)+cpu_load[0])/2
</span><span class='line'>&#9;cpu_load[2]=(cpu_load[2]*(4-1)+cpu_load[0])/4
</span><span class='line'>&#9;cpu_load[3]=(cpu_load[3]*(8-1)+cpu_load[0])/8
</span><span class='line'>&#9;cpu_load[4]=(cpu_load[4]*(16-1)+cpu_load[0]/16
</span><span class='line'>&#9;呼叫函数this_cpu_load时，所返回的cpu load值是cpu_load[0]
</span><span class='line'>&#9;而在进行cpu blance或migration时，就会呼叫函数
</span><span class='line'>&#9;source_load target_load取得对该处理器cpu_load index值，
</span><span class='line'>&#9;来进行计算*/
</span><span class='line'>&#9;unsigned long cpu_load[CPU_LOAD_IDX_MAX];
</span><span class='line'>#ifdef CONFIG_NO_HZ
</span><span class='line'>&#9;unsigned long last_tick_seen;
</span><span class='line'>&#9;unsigned char in_nohz_recently;
</span><span class='line'>#endif
</span><span class='line'>&#9;/* capture load from *all* tasks on this cpu: */
</span><span class='line'>&#9;/*load-&gt;weight值，会是目前所执行的schedule entity的
</span><span class='line'>&#9;load-&gt;weight的总和，也就是说rq的load-&gt;weight越高，
</span><span class='line'>&#9;也表示所负责的排程单元load-&gt;weight总和越高
</span><span class='line'>&#9;表示处理器所负荷的执行单元也越重*/
</span><span class='line'>&#9;struct load_weight load;
</span><span class='line'>&#9;/*在每次scheduler tick中呼叫update_cpu_load时，
</span><span class='line'>&#9;这个值就增加一，可以用来反馈目前cpu
</span><span class='line'>&#9;load更新的次数*/
</span><span class='line'>&#9;unsigned long nr_load_updates;
</span><span class='line'>&#9;/*用来累加处理器进行context switch的次数，会在
</span><span class='line'>&#9;函数schedule呼叫时进行累加，并可以通过函数
</span><span class='line'>&#9;nr_context_switches统计目前所有处理器总共的context switch
</span><span class='line'>&#9;次数，或是可以透过查看档案/proc/stat中的ctxt位得知目前
</span><span class='line'>&#9;整个系统触发context switch的次数*/
</span><span class='line'>&#9;u64 nr_switches;
</span><span class='line'>
</span><span class='line'>&#9;u64 nr_migrations_in;
</span><span class='line'>&#9;/*为cfs fair scheduling class 的rq*/
</span><span class='line'>&#9;struct cfs_rq cfs;
</span><span class='line'>&#9;/*为real-time scheduling class 的rq*/
</span><span class='line'>&#9;struct rt_rq rt;
</span><span class='line'>
</span><span class='line'>/*用以支援可以group cfs tasks的机制*/
</span><span class='line'>#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class='line'>&#9;/* list of leaf cfs_rq on this cpu: */
</span><span class='line'>&#9;/*在有设置fair group scheduling 的环境下，
</span><span class='line'>&#9;会基于原本cfs rq中包含有若干task的group
</span><span class='line'>&#9;所成的排程集合，也就是说当有一个group a
</span><span class='line'>&#9;就会有自己的cfs rq用来排程自己所属的tasks,
</span><span class='line'>&#9;而属于这group a的tasks所使用到的处理器时间
</span><span class='line'>&#9;就会以这group a总共所分的的时间为上限。
</span><span class='line'>&#9;基于cgroup的fair group scheduling 架构，可以创造出
</span><span class='line'>&#9;有阶层性的task组织，根据不同task的功能群组化
</span><span class='line'>&#9;在配置给该群主对应的处理器资源，让属于
</span><span class='line'>&#9;该群主下的task可以透过rq机制排程。使用属于
</span><span class='line'>&#9;该群主下的资源。
</span><span class='line'>&#9;这个变数主要是管理CFS RQ list，操作上可以透过函数
</span><span class='line'>&#9;list_add_leaf_cfs_rq把一个group cfs rq加入到list中，或透过
</span><span class='line'>&#9;函数list_del_leaf_cfs_rq把一个group cfs rq移除，并可以
</span><span class='line'>&#9;透过for_each_leaf_cfs_rq把一个rq上得所有leaf cfs_rq走一遍
</span><span class='line'>&#9;*/
</span><span class='line'>&#9;struct list_head leaf_cfs_rq_list;
</span><span class='line'>#endif
</span><span class='line'>/*用以支援可以group real-time tasks的机制*/
</span><span class='line'>#ifdef CONFIG_RT_GROUP_SCHED
</span><span class='line'>&#9;/*类似leaf_cfs_rq_list所扮演的角色，只是这里
</span><span class='line'>&#9;是针对属于real-time的task,在实际操作上可以
</span><span class='line'>&#9;透过函数list_add_leaf_rt_rq,list_del_leaf_rt_rq或
</span><span class='line'>&#9;巨集for_each_leaf_rt_rq*/
</span><span class='line'>&#9;struct list_head leaf_rt_rq_list;
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * This is part of a global counter where only the total sum
</span><span class='line'>&#9; * over all CPUs matters. A task can increase this counter on
</span><span class='line'>&#9; * one CPU and if it got migrated afterwards it may decrease
</span><span class='line'>&#9; * it on another CPU. Always updated under the runqueue lock:
</span><span class='line'>&#9; */
</span><span class='line'>&#9; /*一般来说，linux kernel 的task状态可以为TASK_RUNNING
</span><span class='line'>&#9; TASK_INTERRUPTIBLE(sleep),
</span><span class='line'>&#9; TASK_UNINTERRUPTIBLE(Deactivate Task,此时Task会从rq中
</span><span class='line'>&#9; 移除)或TASK_STOPPED.
</span><span class='line'>&#9; 透过这个变数会统计目前rq中有多少task属于
</span><span class='line'>&#9; TASK_UNINTERRUPTIBLE的状态。当呼叫函数
</span><span class='line'>&#9; active_task时，会把nr_uninterruptible值减一，并透过 该函数
</span><span class='line'>&#9;enqueue_task把对应的task依据所在的scheduling class
</span><span class='line'>&#9;放在 对应的rq中，并把目前rq中nr_running值加一*/
</span><span class='line'>&#9;unsigned long nr_uninterruptible;
</span><span class='line'>&#9;/*curr:指向目前处理器正在执行的task;
</span><span class='line'>&#9;idle:指向属于idle-task scheduling class 的idle task;
</span><span class='line'>&#9;stop:指向目前最高等级属于stop-task scheduling class
</span><span class='line'>&#9;的task;*/
</span><span class='line'>&#9;struct task_struct *curr, *idle;
</span><span class='line'>&#9;/*基于处理器的jiffies值，用以记录下次进行处理器
</span><span class='line'>&#9;balancing 的时间点*/
</span><span class='line'>&#9;unsigned long next_balance;
</span><span class='line'>&#9;/*用以存储context-switch发生时，前一个task的memory management
</span><span class='line'>&#9;结构并可用在函数finish_task_switch中，透过函数mmdrop释放前一个
</span><span class='line'>&#9;task的记忆体资源*/  
</span><span class='line'>&#9;struct mm_struct *prev_mm;
</span><span class='line'>&#9;/*用以记录目前rq的clock值，基本上该值会等于透过sched_clock_cpu
</span><span class='line'>&#9;(cpu_of(rq))的回传值，并会在每次呼叫scheduler_tick时透过
</span><span class='line'>&#9;函数update_rq_clock更新目前rq clock值。
</span><span class='line'>&#9;在实作部分，函数sched_clock_cpu会透过sched_clock_local或
</span><span class='line'>&#9;ched_clock_remote取得对应的sched_clock_data,而处理的sched_clock_data
</span><span class='line'>&#9;值，会透过函数sched_clock_tick在每次呼叫scheduler_tick时进行更新；
</span><span class='line'>&#9;*/
</span><span class='line'>&#9;u64 clock;
</span><span class='line'>&#9;/*用以记录目前rq中有多少task处于等待i/o的sleep状态
</span><span class='line'>&#9;在实际的使用上，例如当driver接受来自task的调用，但处于等待i/o
</span><span class='line'>&#9;回复的阶段时，为了充分利用处理器的执行资源，这时
</span><span class='line'>&#9;就可以在driver中呼叫函数io_schedule，此时
</span><span class='line'>&#9;就会把目前rq中的nr_iowait加一，并设定目前task的io_wait为1
</span><span class='line'>&#9;然后触发scheduling 让其他task有机会可以得到处理器执行时间*/
</span><span class='line'>&#9;atomic_t nr_iowait;
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_SMP
</span><span class='line'>&#9;/*root domain是基于多核心架构下的机制，
</span><span class='line'>&#9;会由rq结构记住目前采用的root domain，其中包括了
</span><span class='line'>&#9;目前的cpu mask(包括span,online rt overload), reference count 跟cpupri
</span><span class='line'>&#9;当root domain有被rq参考到时，refcount 就加一，反之就减一。而cpu
</span><span class='line'>&#9;mask span表示rq可挂上的cpu mask,noline为rq目前已经排程的
</span><span class='line'>&#9;cpu mask cpu上执行real-time task.可以参考函数pull_rt_task，当一个rq中属于
</span><span class='line'>&#9;real-time的task已经执行完毕，就会透过函数pull_rt_task从该
</span><span class='line'>&#9;rq中属于rto_mask cpu mask 可以执行的处理器上，找出是否有一个处理器
</span><span class='line'>&#9;有大于一个以上的real-time task，若有就会转到目前这个执行完成
</span><span class='line'>&#9;real-time task 的处理器上
</span><span class='line'>&#9;而cpupri不同于Task本身有区分140個(0-139)
</span><span class='line'>&#9;Task Priority (0-99為RT Priority 而 100-139為Nice值 -20-19). 
</span><span class='line'>&#9;CPU Priority本身有102個Priority (包括,-1 為Invalid,
</span><span class='line'>&#9;0為Idle,1為Normal,2-101對應到Real-Time Priority 0-99).
</span><span class='line'>&#9;參考函式convert_prio, Task Priority如果是 140就會對應到
</span><span class='line'>&#9;CPU Idle,如果是大於等於100就會對應到CPU Normal,
</span><span class='line'>&#9;若是Task Priority介於0-99之間,就會對應到CPU Real-Time Priority 101-2之間.) 
</span><span class='line'>&#9;在實際的操作上,例如可以透過函式cpupri_find
</span><span class='line'>&#9;帶入一個要插入的Real-Time Task,此時就會依據cpupri中
</span><span class='line'>&#9;pri_to_cpu選擇一個目前執行Real-Time Task且該Task
</span><span class='line'>&#9;的優先級比目前要插入的Task更低的處理器,
</span><span class='line'>&#9;並透過CPU Mask(lowest_mask)返回目前可以選擇的處理器Mask.
</span><span class='line'>&#9;實作的部份可以參考檔案kernel/sched_cpupri.c.
</span><span class='line'>&#9;在初始化的過程中,會透過函式sched_init呼叫函式init_defrootdomain,
</span><span class='line'>&#9;對Root Domain與 CPU Priority機制進行初始化.
</span><span class='line'>&#9;*/
</span><span class='line'>&#9;struct root_domain *rd;
</span><span class='line'>&#9;/*Schedule Domain是基於多核心架構下的機制.
</span><span class='line'>&#9;每個處理器都會有一個基礎的Scheduling Domain,
</span><span class='line'>&#9;Scheduling Domain可以有階層性的架構,透過parent
</span><span class='line'>&#9;可以找到上一層的Domain,或是透過child找到
</span><span class='line'>&#9;下一層的 Domain (NULL表示結尾.).並可透過span
</span><span class='line'>&#9;栏位,表示這個Domain所能涵蓋的處理器範圍.
</span><span class='line'>&#9;通常Base Domain會涵蓋系統中所有處理器的個數,
</span><span class='line'>&#9;而Child Domain所能涵蓋的處理器個數不超過它的
</span><span class='line'>&#9;Parent Domain. 而當在進行Scheduling Domain 中的Task Balance
</span><span class='line'>&#9;時,就會以該Domain所能涵蓋的處理器為最大範圍.
</span><span class='line'>&#9;同時,每個Schedule Domain都會包括一個或一個以上的
</span><span class='line'>&#9;CPU Groups (結構為struct sched_group),並透過next變數把
</span><span class='line'>&#9;CPU Groups串連在一起(成為一個單向的Circular linked list),
</span><span class='line'>&#9;每個CPU Group都會有變數cpumask來定义這個CPU Group
</span><span class='line'>&#9;所涵蓋的處理器範圍.並且CPU Group所包括的處理器
</span><span class='line'>&#9;範圍,必需涵蓋在所屬的Schedule Domain處理器範圍中.
</span><span class='line'>&#9;當進行Scheduling Domain的Balancing時,會以其下的CPU Groups
</span><span class='line'>&#9;為單位,根據cpu_power （會是該Group所涵蓋的處理器
</span><span class='line'>&#9;Tasks Loading的總和）來比較不同的CPU Groups的負荷,
</span><span class='line'>&#9;以進行Tasks的移動,達到Balancing的目的.
</span><span class='line'>&#9;在有支援SMP的架構下,會在函式sched_init中,呼叫open_softirq,
</span><span class='line'>&#9;註冊 SCHED_SOFTIRQ Software IRQ与其对应的 Callback函式 
</span><span class='line'>&#9;run_rebalance_domains. 並會在每次呼叫函式scheduler_tick時,
</span><span class='line'>&#9;透過函式trigger_load_balance确认是否目前的jiffies值已經
</span><span class='line'>&#9;大於RunQueue下一次要觸發Load Balance的next_balance時間值,
</span><span class='line'>&#9;並透過函式raise_softirq觸發SCHED_SOFTIRQ Software IRQ. 
</span><span class='line'>&#9;在Software IRQ觸發後,就會呼叫函式run_rebalance_domains,
</span><span class='line'>&#9;並在函式rebalance_domains中,進行后续處理器上的
</span><span class='line'>&#9;Scheduling Domain Load Balance動作.
</span><span class='line'>&#9;有關Scheduling Domain進一步的內容,也可以參考
</span><span class='line'>&#9;Linux Kernel文件 Documentation/scheduler/sched-domains.txt.
</span><span class='line'>&#9;*/
</span><span class='line'>&#9;struct sched_domain *sd;
</span><span class='line'>&#9;/*這值會等於函式idle_cpu的返回值,如果為1表示
</span><span class='line'>&#9;目前CPU RunQueue中執行的為Idle Task. 反之為0,
</span><span class='line'>&#9;則表示處理器執行的不是Idle Task (也就是說
</span><span class='line'>&#9;處理器正在忙碌中.).*/
</span><span class='line'>&#9;unsigned char idle_at_tick;
</span><span class='line'>&#9;/* For active balancing */
</span><span class='line'>&#9;/*若這值不為0,表示會有在Schedule排程動作
</span><span class='line'>&#9;結束前,要呼叫的收尾函式. (实作為inline函式
</span><span class='line'>&#9;post_schedule in kernel/sched.c),目前只有Real-Time Scheduling 
</span><span class='line'>&#9;Class有支援這個機制(會呼叫函式has_pushable_tasks 
</span><span class='line'>&#9;in kernel/sched_rt.c).*/
</span><span class='line'>&#9;int post_schedule;
</span><span class='line'>&#9;/*當RunQueue中此值為1,表示這個RunQueue正在進行
</span><span class='line'>&#9;Fair Scheduling的Load Balance,此時會呼叫stop_one_cpu_nowait
</span><span class='line'>&#9;暫停該RunQueue所屬處理器的排程,並透過函式
</span><span class='line'>&#9;active_load_balance_cpu_stop,把Tasks從最忙碌的處理器,
</span><span class='line'>&#9;移到Idle的處理器上執行.*/
</span><span class='line'>&#9;int active_balance;
</span><span class='line'>&#9;/*用以儲存目前進入Idle且負責進行 Load Balance
</span><span class='line'>&#9;流程的處理器ID. 呼叫的流程為,在呼叫函式schedule時,
</span><span class='line'>&#9;若該處理器RunQueue的nr_running為0 (也就是目前沒有
</span><span class='line'>&#9;正在執行的Task),就會呼叫idle_balance,並觸發後續Load 
</span><span class='line'>&#9;Balance流程.*/
</span><span class='line'>&#9;int push_cpu;
</span><span class='line'>&#9;/* cpu of this runqueue: */
</span><span class='line'>&#9;/*用以儲存目前运作這個RunQueue的處理器ID*/
</span><span class='line'>&#9;int cpu;
</span><span class='line'>&#9;/*為1表示目前此RunQueue有在對應的處理器掛上
</span><span class='line'>&#9;並執行.*/
</span><span class='line'>&#9;int online;
</span><span class='line'>&#9;/*如果RunQueue中目前有Task正在執行,這個值會
</span><span class='line'>&#9;等於目前該RunQueue的Load Weight除以目前RunQueue
</span><span class='line'>&#9;中Task數目的均值. 
</span><span class='line'>&#9;(rq-&gt;avg_load_per_task = rq-&gt;load.weight / nr_running;).*/
</span><span class='line'>&#9;unsigned long avg_load_per_task;
</span><span class='line'>
</span><span class='line'>&#9;struct task_struct *migration_thread;
</span><span class='line'>&#9;struct list_head migration_queue;
</span><span class='line'>&#9;/*這個值會由Real-Time Scheduling Class呼叫函式
</span><span class='line'>&#9;update_curr_rt,用以統計目前Real-Time Task執行時間的
</span><span class='line'>&#9;均值,在這函式中會以目前RunQueue的clock_task
</span><span class='line'>&#9;減去目前Task執行的起始時間,取得執行時間的
</span><span class='line'>&#9;Delta值. (delta_exec = rq-&gt;clock_task – curr-&gt;se.exec_start; ).
</span><span class='line'>&#9;在透過函式sched_rt_avg_update把這Delta值跟原本
</span><span class='line'>&#9;RunQueue中的rt_avg值取平均值. 以運作的週期來看,
</span><span class='line'>&#9;這個值可反應目前系統中Real-Time Task平均被
</span><span class='line'>&#9;分配到的執行時間值.*/
</span><span class='line'>&#9;u64 rt_avg;
</span><span class='line'>&#9;/*這個值主要在函式sched_avg_update更新,以笔者手中
</span><span class='line'>&#9;的Linux Kernel 2.6.38.6的實作來說,當RunQueue Clock
</span><span class='line'>&#9;減去age_stamp大於 0.5秒 (=sched_avg_period),就會把這值
</span><span class='line'>&#9;累加0.5秒 (單位都是nanoseconds). 從函式scale_rt_power
</span><span class='line'>&#9;的實作來說,age_stamp值離RunQueue Clock越遠,表示total
</span><span class='line'>&#9;值越大,available值也越大,而函式scale_rt_power返回的
</span><span class='line'>&#9;div_u64計算結果也越大,最終 RunQueue的cpu_power
</span><span class='line'>&#9;與Scheduling Domain中的Scheduling Group的cpu_power
</span><span class='line'>&#9;值也就越大. (可參考函式update_cpu_power的實作).*/
</span><span class='line'>&#9;u64 age_stamp;
</span><span class='line'>&#9;/*這值會在觸發Scheduling時,若判斷目前處理器
</span><span class='line'>&#9;RunQueue沒有正在運作的Task,就會透過函式
</span><span class='line'>&#9;idle_balance更新這值為為目前RunQueue的clock值.
</span><span class='line'>&#9;可用以表示這個處理器是何時進入到Idle的
</span><span class='line'>&#9;狀態*/
</span><span class='line'>&#9;u64 idle_stamp;
</span><span class='line'>&#9;/*會在有Task運作且idle_stamp不為0 (表示前一個
</span><span class='line'>&#9;狀態是在Idle)時以目前RunQueue的clock減去
</span><span class='line'>&#9;idle_stmp所計算出的Delta值為依據,更新這個值
</span><span class='line'>&#9;. 可反應目前處理器進入Idle狀態的時間長短*/
</span><span class='line'>&#9;u64 avg_idle;
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>&#9;/* calc_load related fields */
</span><span class='line'>&#9;/*用以記錄下一次計算CPU Load的時間,初始值
</span><span class='line'>&#9;為目前的jiffies加上五秒與1次的Scheduling Tick的
</span><span class='line'>&#9;間隔 (=jiffies + LOAD_FREQ,且LOAD_FREQ=(5*HZ+1))*/
</span><span class='line'>&#9;unsigned long calc_load_update;
</span><span class='line'>&#9;/*會等於RunQueue中nr_running與nr_uninterruptible的
</span><span class='line'>&#9;總和.（可參考函式calc_load_fold_active）.*/
</span><span class='line'>&#9;long calc_load_active;
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_SCHED_HRTICK
</span><span class='line'>#ifdef CONFIG_SMP
</span><span class='line'>&#9;/*在函式init_rq_hrtick初始化RunQueue High-Resolution 
</span><span class='line'>&#9;Tick時,此值預設為0.
</span><span class='line'>&#9;在函式hrtick_start中,會判斷目前觸發的RunQueue
</span><span class='line'>&#9;跟目前處理器所使用的RunQueue是否一致,
</span><span class='line'>&#9;若是,就直接呼叫函式hrtimer_restart,反之就會
</span><span class='line'>&#9;依據RunQueue中hrtick_csd_pending的值,如果
</span><span class='line'>&#9;hrtick_csd_pending為0,就會透過函式
</span><span class='line'>&#9;__smp_call_function_single讓RunQueue所在的另一個
</span><span class='line'>&#9;處理器執行rq-&gt;hrtick_csd.func 所指到的函式 
</span><span class='line'>&#9;__hrtick_start. 並等待該處理器執行完畢後,
</span><span class='line'>&#9;才重新把hrtick_csd_pending設定為1.
</span><span class='line'>&#9;也就是說, RunQueue的hrtick_csd_pending是用來作為
</span><span class='line'>&#9;SMP架構下,由處理器A觸發處理器B執行
</span><span class='line'>&#9;_hrtick_start函式的一個保護機制.而有關在
</span><span class='line'>&#9;SMP下如何由一個處理器觸發另一個處理器
</span><span class='line'>&#9;執行函式的機制,可以參考kernel/smp.c中
</span><span class='line'>&#9;相關smp_call_function_xxxxxxx的實作.s*/
</span><span class='line'>&#9;int hrtick_csd_pending;
</span><span class='line'>&#9;/*用以儲存hrtick機制中,要跨處理器執行的
</span><span class='line'>&#9;函式結構.*/
</span><span class='line'>&#9;struct call_single_data hrtick_csd;
</span><span class='line'>#endif
</span><span class='line'>&#9;/*為High-Resolution Tick的结构,會透過函式
</span><span class='line'>&#9;hrtimer_init初始化.*/
</span><span class='line'>&#9;struct hrtimer hrtick_timer;
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_SCHEDSTATS
</span><span class='line'>&#9;/* latency stats */
</span><span class='line'>&#9;/*為Scheduling Info.的統計結構,可以參考
</span><span class='line'>&#9;include/linux/sched.h中的宣告. 例如在每次觸發
</span><span class='line'>&#9;Schedule時,呼叫函式schedule_debug對上一個Task
</span><span class='line'>&#9;的lock_depth進行確認(Fork一個新的Process 時,
</span><span class='line'>&#9;會把此值預設為-1就是No-Lock,當呼叫
</span><span class='line'>&#9;Kernel Lock時, 就會把Current Task的lock_depth加一.),
</span><span class='line'>&#9;若lock_depth&gt;=0,就會累加Scheduling Info.的bkl_count值,
</span><span class='line'>&#9;用以代表Task Blocking的次數.*/
</span><span class='line'>&#9;struct sched_info rq_sched_info;
</span><span class='line'>&#9;/*可用以表示RunQueue中的Task所得到CPU執行
</span><span class='line'>&#9;時間的累加值.
</span><span class='line'>&#9;在發生Task Switch時,會透過sched_info_switch呼叫
</span><span class='line'>&#9;sched_info_arrive並以目前RunQueue Clock值更新
</span><span class='line'>&#9;Task 的sched_info.last_arrival時間,而在Task所分配時間
</span><span class='line'>&#9;結束後,會在函式sched_info_depart中以現在的
</span><span class='line'>&#9;RunQueue Clock值減去Task的sched_info.last_arrival
</span><span class='line'>&#9;時間值,得到的 Delta作為變數rq_cpu_time的累
</span><span class='line'>&#9;加值.*/
</span><span class='line'>&#9;unsigned long long rq_cpu_time;
</span><span class='line'>&#9;/* could above be rq-&gt;cfs_rq.exec_clock + rq-&gt;rt_rq.rt_runtime ? */
</span><span class='line'>
</span><span class='line'>&#9;/* sys_sched_yield() stats */
</span><span class='line'>&#9;/*用以統計呼叫System Call sys_sched_yield的次數.*/
</span><span class='line'>&#9;unsigned int yld_count;
</span><span class='line'>
</span><span class='line'>&#9;/* schedule() stats */
</span><span class='line'>&#9;unsigned int sched_switch;
</span><span class='line'>&#9;/*可用以統計觸發Scheduling的次數. 在每次觸發
</span><span class='line'>&#9;Scheduling時,會透過函式schedule呼叫schedule_debug,
</span><span class='line'>&#9;呼叫schedstat_inc對這變數進行累加.*/
</span><span class='line'>&#9;unsigned int sched_count;
</span><span class='line'>&#9;/*可用以統計進入到Idle Task的次數. 會在函式
</span><span class='line'>&#9;pick_next_task_idle中,呼叫schedstat_inc對這變數進行
</span><span class='line'>&#9;累加.*/
</span><span class='line'>&#9;unsigned int sched_goidle;
</span><span class='line'>
</span><span class='line'>&#9;/* try_to_wake_up() stats */
</span><span class='line'>&#9;/*用以統計Wake Up Task的次數.*/
</span><span class='line'>&#9;unsigned int ttwu_count;
</span><span class='line'>&#9;/*用以統計Wake Up 同一個處理器Task的次數.*/
</span><span class='line'>&#9;unsigned int ttwu_local;
</span><span class='line'>
</span><span class='line'>&#9;/* BKL stats */
</span><span class='line'>&#9;unsigned int bkl_count;
</span><span class='line'>#endif
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>调度类，sched_class为对模块编程的上层支持，对于每个linux新添加进来的调度算法都需要有自己的调度类实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*CFS排程機制在設計時,考慮到排程機制的
</span><span class='line'>彈性,定義了Scheduler Class的機制,讓排程機制
</span><span class='line'>可以根據設計的需求,延伸不同的排程模
</span><span class='line'>組進來,每個新加入的排程機制都必須要
</span><span class='line'>提供Scheduler Class的實作,結構為 struct sched_class*/
</span><span class='line'>struct sched_class {
</span><span class='line'>&#9;/*會指向下一個Scheduling Class,以筆者所採用
</span><span class='line'>&#9;的Linux Kernel 2.6.38.6而言,Scheduling Class的順序為
</span><span class='line'>&#9;stop_sched_class-&gt;rt_sched_class-&gt;fair_sched_class-&gt;idle_sched_class*/
</span><span class='line'>&#9;const struct sched_class *next;
</span><span class='line'>&#9;/*當Task屬於Runnable狀態時,就會呼叫這個函式
</span><span class='line'>&#9;把Task配置到RunQueue RBTree中,進行排程動作,
</span><span class='line'>&#9;並呼叫inc_nr_running將RunQueue中nr_running的值
</span><span class='line'>&#9;加一.(nr_running用以代表目前RunQueue有多少
</span><span class='line'>&#9;Runnable Task進行排程)*/
</span><span class='line'>&#9;void (*enqueue_task) (struct rq *rq, struct task_struct *p, int wakeup);
</span><span class='line'>&#9;/*當Task不需要執行時,就會呼叫這個函式
</span><span class='line'>&#9;把Task從RunQueue RBTree中移除,並呼叫
</span><span class='line'>&#9;dec_nr_running將RunQueue中nr_running的值減一.*/
</span><span class='line'>&#9;void (*dequeue_task) (struct rq *rq, struct task_struct *p, int sleep);
</span><span class='line'>&#9;/*用以暫停目前正在執行中的Task,如果
</span><span class='line'>&#9;sysctl_sched_compat_yield有設定,就會找出目前
</span><span class='line'>&#9;RBTree中最右邊的Task(也就是vrruntime最多
</span><span class='line'>&#9;的Task),讓目前Task的vrruntime值等於最右邊
</span><span class='line'>&#9;Task值的vrruntime加一(可參考:
</span><span class='line'>&#9;se-&gt;vruntime = rightmost-&gt;vruntime + 1),如此在下次
</span><span class='line'>&#9;排程觸發時就會透過函式put_prev_task把目前
</span><span class='line'>&#9;的Task放到RBTree的最右邊,也就等同於暫停
</span><span class='line'>&#9;Task,讓該Task下次被執行到的機會最低.*/
</span><span class='line'>&#9;void (*yield_task) (struct rq *rq);
</span><span class='line'>&#9;/*用以決定一個Task是否可以中斷目前正在
</span><span class='line'>&#9;運作的Task,取得執行權.以CFS本身的實作來說
</span><span class='line'>&#9;(in sched_fair.c).如果想要取代目前Task的Task本身
</span><span class='line'>&#9;的Scheduling Policy為 Batch或是Idle時,會直接返回,
</span><span class='line'>&#9;不會用來取代目前正在執行中的Task.反之,
</span><span class='line'>&#9;如果目前正在執行中的Task的Scheduling Policy
</span><span class='line'>&#9;為Idle,就會直接由所傳入的Task取代目前正
</span><span class='line'>&#9;在執行的Task.*/
</span><span class='line'>&#9;void (*check_preempt_curr) (struct rq *rq, struct task_struct *p, int flags);
</span><span class='line'>&#9;/*用以在排程觸發時,從RunQueue RBTree中,
</span><span class='line'>&#9;取出符合目前Scheduling邏輯的下一個要
</span><span class='line'>&#9;被執行的Task.*/
</span><span class='line'>&#9;struct task_struct * (*pick_next_task) (struct rq *rq);
</span><span class='line'>&#9;/*用以在排程觸發時,把上一個執行完畢的
</span><span class='line'>&#9;Task放到目前RunQueue RBTree中對應的位置.*/
</span><span class='line'>&#9;void (*put_prev_task) (struct rq *rq, struct task_struct *p);
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_SMP
</span><span class='line'>&#9;/*通常用在執行一個新的程序,或是WakeUp
</span><span class='line'>&#9;一個Task時,會根據目前SMP下每個處理器的
</span><span class='line'>&#9;負荷,決定Task是否要切換到另一個處理器
</span><span class='line'>&#9;的RunQueue去執行,執行時會返回最後目標
</span><span class='line'>&#9;處理器的值.*/
</span><span class='line'>&#9;int  (*select_task_rq)(struct task_struct *p, int sd_flag, int flags);
</span><span class='line'>
</span><span class='line'>&#9;unsigned long (*load_balance) (struct rq *this_rq, int this_cpu,
</span><span class='line'>&#9;&#9;&#9;struct rq *busiest, unsigned long max_load_move,
</span><span class='line'>&#9;&#9;&#9;struct sched_domain *sd, enum cpu_idle_type idle,
</span><span class='line'>&#9;&#9;&#9;int *all_pinned, int *this_best_prio);
</span><span class='line'>
</span><span class='line'>&#9;int (*move_one_task) (struct rq *this_rq, int this_cpu,
</span><span class='line'>&#9;&#9;&#9;&#9;  struct rq *busiest, struct sched_domain *sd,
</span><span class='line'>&#9;&#9;&#9;&#9;  enum cpu_idle_type idle);
</span><span class='line'>&#9;void (*pre_schedule) (struct rq *this_rq, struct task_struct *task);
</span><span class='line'>&#9;void (*post_schedule) (struct rq *this_rq);
</span><span class='line'>&#9;void (*task_wake_up) (struct rq *this_rq, struct task_struct *task);
</span><span class='line'>
</span><span class='line'>&#9;void (*set_cpus_allowed)(struct task_struct *p,
</span><span class='line'>&#9;&#9;&#9;&#9; const struct cpumask *newmask);
</span><span class='line'>
</span><span class='line'>&#9;void (*rq_online)(struct rq *rq);
</span><span class='line'>&#9;void (*rq_offline)(struct rq *rq);
</span><span class='line'>#endif
</span><span class='line'>&#9;/*這個函式用以改變Task目前所屬的Scheduling
</span><span class='line'>&#9;Class與改變Task Group.*/
</span><span class='line'>&#9;void (*set_curr_task) (struct rq *rq);
</span><span class='line'>&#9;/*這是Scheduler的 Timer Tick來源,系統中觸發的
</span><span class='line'>&#9;Scheduling Tick會呼叫這個函式 (看HZ設定多少,
</span><span class='line'>&#9;100就是每秒呼叫這函式100次,1000就是每秒
</span><span class='line'>&#9;呼叫這函式1000次),
</span><span class='line'>&#9;用以讓排程機制可以決定哪些Task應該要配
</span><span class='line'>&#9;執行與哪些Task應該要被移出RunQueue.*/
</span><span class='line'>&#9;void (*task_tick) (struct rq *rq, struct task_struct *p, int queued);
</span><span class='line'>&#9;void (*task_new) (struct rq *rq, struct task_struct *p);
</span><span class='line'>
</span><span class='line'>&#9;void (*switched_from) (struct rq *this_rq, struct task_struct *task,
</span><span class='line'>&#9;&#9;&#9;&#9;   int running);
</span><span class='line'>&#9;void (*switched_to) (struct rq *this_rq, struct task_struct *task,
</span><span class='line'>&#9;&#9;&#9;&#9; int running);
</span><span class='line'>&#9;void (*prio_changed) (struct rq *this_rq, struct task_struct *task,
</span><span class='line'>&#9;&#9;&#9;&#9; int oldprio, int running);
</span><span class='line'>
</span><span class='line'>&#9;unsigned int (*get_rr_interval) (struct task_struct *task);
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class='line'>&#9;void (*moved_group) (struct task_struct *p);
</span><span class='line'>#endif
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>调度实体，调度实体用于调度时间记账，linux中CFS和实时调度使用不同的调度实体。调度运行队列，对于不用的调度算法同样运用不用的运行队列，对于CFS调度，运用的是红黑树，而对于实时调度为组链表。在后面具体的调度算法介绍中我们会看到他们的运用。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-01-14T23:49:00+08:00'><span class='date'>2015-01-14</span> <span class='time'>23:49:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~sched/'>sched</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/01/14/kernel-sched-idle/" title="Previous Post: Idle进程的切换过程">&laquo; Idle进程的切换过程</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/01/14/debug-softirq-time-count/" title="Next Post: 中断时间统计">中断时间统计 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
