
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>dev_queue_xmi函数详解 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">dev_queue_xmi函数详解</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-25T23:20:00+08:00'><span class='date'>2015-08-25</span> <span class='time'>23:20:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>blog.chinaunix.net/uid-20788636-id-3181312.html</p>

<p>前面在分析IPv6的数据流程时，当所有的信息都准备好了之后，例如，出口设备，下一跳的地址，以及链路层地址。就会调用dev.c文件中的dev_queue_xmin函数，该函数是设备驱动程序执行传输的接口。也就是所有的数据包在填充完成后，最终发送数据时，都会调用该函数。</p>

<p>dev_queue_xmit函数只接收一个skb_buff结构作为输入的值。此数据结构包含了此函数所需要的一切信息。Skb->dev是出口设备，skb->data为有效的载荷的开头，其长度为skb->len.下面是2.6.37版本内核中的dev_queue_xmit函数，该版本的内核与之前的版本有了不少的区别。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int dev_queue_xmit(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct net_device *dev = skb-&gt;dev;
</span><span class='line'>&#9;struct netdev_queue *txq;
</span><span class='line'>&#9;struct Qdisc *q;
</span><span class='line'>&#9;int rc = -ENOMEM;
</span><span class='line'>
</span><span class='line'>&#9;/* Disable soft irqs for various locks below. Also
</span><span class='line'>&#9; * stops preemption for RCU.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;//关闭软中断 - __rcu_read_lock_bh()---&gt;local_bh_disable();
</span><span class='line'>&#9;rcu_read_lock_bh();
</span><span class='line'>&#9;// 选择一个发送队列，如果设备提供了select_queue回调函数就使用它，否则由内核选择一个队列,这里只是Linux内核多队列的实现，但是要真正的使用都队列，需要网卡支持多队列才可以，一般的网卡都只有一个队列。在调用alloc_etherdev分配net_device是，设置队列的个数
</span><span class='line'>&#9;txq = dev_pick_tx(dev, skb);
</span><span class='line'>&#9;//从netdev_queue结构上获取设备的qdisc
</span><span class='line'>&#9;q = rcu_dereference_bh(txq-&gt;qdisc);
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_NET_CLS_ACT
</span><span class='line'>&#9;skb-&gt;tc_verd = SET_TC_AT(skb-&gt;tc_verd, AT_EGRESS);
</span><span class='line'>#endif
</span><span class='line'>&#9;//如果硬件设备有队列可以使用，该函数由dev_queue_xmit函数直接调用或由dev_queue_xmit通过qdisc_run函数调用
</span><span class='line'>&#9;trace_net_dev_queue(skb);
</span><span class='line'>&#9;if (q-&gt;enqueue) {
</span><span class='line'>&#9;&#9;rc = __dev_xmit_skb(skb, q, dev, txq); //使用流控对象发送数据包(包含入队和出队)
</span><span class='line'>&#9;&#9;//更详细的内容参考说明3
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//下面的处理是在没有发送队列的情况下
</span><span class='line'>&#9;/* The device has no queue. Common case for software devices:
</span><span class='line'>&#9; loopback, all the sorts of tunnels...
</span><span class='line'>
</span><span class='line'>&#9; Really, it is unlikely that netif_tx_lock protection is necessary
</span><span class='line'>&#9; here. (f.e. loopback and IP tunnels are clean ignoring statistics
</span><span class='line'>&#9; counters.)
</span><span class='line'>&#9; However, it is possible, that they rely on protection
</span><span class='line'>&#9; made by us here.
</span><span class='line'>
</span><span class='line'>&#9; Check this and shot the lock. It is not prone from deadlocks.
</span><span class='line'>&#9; Either shot noqueue qdisc, it is even simpler 8)
</span><span class='line'>&#9; */
</span><span class='line'>&#9;//首先，确定设备是开启的，并且还要确定队列是运行的，启动和停止队列有驱动程序决定
</span><span class='line'>&#9;//设备没有输出队列典型的是回环设备。这里需要做的就是直接调用dev_start_queue_xmit、、函数，经过驱动发送出去，如果发送失败，就直接丢弃，没有队列可以保存。
</span><span class='line'>&#9;if (dev-&gt;flags & IFF_UP) {
</span><span class='line'>&#9;&#9;int cpu = smp_processor_id(); /* ok because BHs are off */
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (txq-&gt;xmit_lock_owner != cpu) {
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (__this_cpu_read(xmit_recursion) &gt; RECURSION_LIMIT)
</span><span class='line'>&#9;&#9;&#9;&#9;goto recursion_alert;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;HARD_TX_LOCK(dev, txq, cpu);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (!netif_tx_queue_stopped(txq)) {
</span><span class='line'>&#9;&#9;&#9;&#9;__this_cpu_inc(xmit_recursion);
</span><span class='line'>&#9;&#9;&#9;&#9;rc = dev_hard_start_xmit(skb, dev, txq);//见说明4
</span><span class='line'>&#9;&#9;&#9;&#9;__this_cpu_dec(xmit_recursion);
</span><span class='line'>&#9;&#9;&#9;&#9;if (dev_xmit_complete(rc)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;HARD_TX_UNLOCK(dev, txq);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto out;
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;HARD_TX_UNLOCK(dev, txq);
</span><span class='line'>&#9;&#9;&#9;if (net_ratelimit())
</span><span class='line'>&#9;&#9;&#9;&#9;printk(KERN_CRIT "Virtual device %s asks to "
</span><span class='line'>&#9;&#9;&#9;&#9; "queue packet!\n", dev-&gt;name);
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;/* Recursion is It is possible,
</span><span class='line'>&#9;&#9;&#9; * unfortunately
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>recursion_alert:
</span><span class='line'>&#9;&#9;&#9;if (net_ratelimit())
</span><span class='line'>&#9;&#9;&#9;&#9;printk(KERN_CRIT "Dead loop on virtual device "
</span><span class='line'>&#9;&#9;&#9;&#9; "%s, fix it urgently!\n", dev-&gt;name);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;rc = -ENETDOWN;
</span><span class='line'>&#9;rcu_read_unlock_bh();
</span><span class='line'>
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>&#9;return rc;
</span><span class='line'>out:
</span><span class='line'>&#9;rcu_read_unlock_bh();
</span><span class='line'>&#9;return rc;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>1. 下面是dev_pick_tx函数。</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct netdev_queue *dev_pick_tx(struct net_device *dev,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;int queue_index;
</span><span class='line'>&#9;const struct net_device_ops *ops = dev-&gt;netdev_ops;
</span><span class='line'>
</span><span class='line'>&#9;if (ops-&gt;ndo_select_queue) {
</span><span class='line'>&#9;&#9;//选择一个索引，这个策略可以设置，比如优先选择视频和音频队列，而哪个队列邦定哪个策略也是设定的。
</span><span class='line'>&#9;&#9;queue_index = ops-&gt;ndo_select_queue(dev, skb);
</span><span class='line'>&#9;&#9;queue_index = dev_cap_txqueue(dev, queue_index);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;struct sock *sk = skb-&gt;sk;
</span><span class='line'>&#9;&#9;queue_index = sk_tx_queue_get(sk);
</span><span class='line'>&#9;&#9;if (queue_index &lt; 0 || queue_index &gt;= dev-&gt;real_num_tx_queues) {
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;queue_index = 0;
</span><span class='line'>&#9;&#9;&#9;if (dev-&gt;real_num_tx_queues &gt; 1)
</span><span class='line'>&#9;&#9;&#9;&#9;queue_index = skb_tx_hash(dev, skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (sk) {
</span><span class='line'>&#9;&#9;&#9;&#9;struct dst_entry *dst = rcu_dereference_check(sk-&gt;sk_dst_cache, 1);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if (dst && skb_dst(skb) == dst)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;sk_tx_queue_set(sk, queue_index);
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;skb_set_queue_mapping(skb, queue_index);
</span><span class='line'>&#9;return netdev_get_tx_queue(dev, queue_index);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>2. 下面是其中的一种网卡类型调用函数alloc_etherdev时，</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dev = alloc_etherdev(sizeof(struct ether1_priv));</span></code></pre></td></tr></table></div></figure>


<p>其实该函数是一个宏定义：其中第二参数表示的就是队列的数量，这里在Linux2.6.37内核中找到的一种硬件网卡的实现，可用的队列是1个。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1)</span></code></pre></td></tr></table></div></figure>


<p>下面是alloc_etherdev_mq函数的定义实现。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct net_device *alloc_etherdev_mq(int sizeof_priv, unsigned int queue_count)
</span><span class='line'>{
</span><span class='line'>&#9;return alloc_netdev_mq(sizeof_priv, "eth%d", ether_setup, queue_count);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>3.</h5>

<p>几乎所有的设备都会使用队列调度出口的流量，而内核可以使用对了规则的算法安排那个帧进行发送，使其以最优效率的次序进行传输。这里检查这个队列中是否有enqueue函数，如果有则说明设备会使用这个队列，否则需另外处理。关于enqueue函数的设置，我找到dev_open->dev_activate中调用了qdisc_create_dflt来设置，需要注意的是，这里并不是将传进来的skb直接发送，而是先入队，然后调度队列，具体发送哪个数据包由enqueue和dequeue函数决定，这体现了设备的排队规则</p>

<p>Enqueue 把一个元素添加的队列</p>

<p>Dequeue 从队列中提取一个元素</p>

<p>Requeue 把一个原先已经提取的元素放回到队列，可以由于传输失败。</p>

<p>if (q->enqueue)为真的话，表明这个设备有队列，可以进行相关的流控。调用__dev_xmit_skb函数进行处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,
</span><span class='line'>&#9;&#9;&#9;&#9; struct net_device *dev,
</span><span class='line'>&#9;&#9;&#9;&#9; struct netdev_queue *txq)
</span><span class='line'>{
</span><span class='line'>&#9;spinlock_t *root_lock = qdisc_lock(q);
</span><span class='line'>&#9;bool contended = qdisc_is_running(q);
</span><span class='line'>&#9;int rc;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Heuristic to force contended enqueues to serialize on a
</span><span class='line'>&#9; * separate lock before trying to get qdisc main lock.
</span><span class='line'>&#9; * This permits __QDISC_STATE_RUNNING owner to get the lock more often
</span><span class='line'>&#9; * and dequeue packets faster.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (unlikely(contended))
</span><span class='line'>&#9;&#9;spin_lock(&q-&gt;busylock);
</span><span class='line'>
</span><span class='line'>&#9;spin_lock(root_lock);
</span><span class='line'>&#9;if (unlikely(test_bit(__QDISC_STATE_DEACTIVATED, &q-&gt;state))) {
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;rc = NET_XMIT_DROP;
</span><span class='line'>&#9;} else if ((q-&gt;flags & TCQ_F_CAN_BYPASS) && !qdisc_qlen(q) &&
</span><span class='line'>&#9;&#9; qdisc_run_begin(q)) {
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * This is a work-conserving queue; there are no old skbs
</span><span class='line'>&#9;&#9; * waiting to be sent out; and the qdisc is not running -
</span><span class='line'>&#9;&#9; * xmit the skb directly.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (!(dev-&gt;priv_flags & IFF_XMIT_DST_RELEASE))
</span><span class='line'>&#9;&#9;&#9;skb_dst_force(skb);
</span><span class='line'>&#9;&#9;__qdisc_update_bstats(q, skb-&gt;len);
</span><span class='line'>&#9;&#9;if (sch_direct_xmit(skb, q, dev, txq, root_lock)) {
</span><span class='line'>&#9;&#9;&#9;if (unlikely(contended)) {
</span><span class='line'>&#9;&#9;&#9;&#9;spin_unlock(&q-&gt;busylock);
</span><span class='line'>&#9;&#9;&#9;&#9;contended = false;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;__qdisc_run(q);
</span><span class='line'>&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;qdisc_run_end(q);
</span><span class='line'>
</span><span class='line'>&#9;&#9;rc = NET_XMIT_SUCCESS;
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;skb_dst_force(skb);
</span><span class='line'>&#9;&#9;rc = qdisc_enqueue_root(skb, q);
</span><span class='line'>&#9;&#9;if (qdisc_run_begin(q)) {
</span><span class='line'>&#9;&#9;&#9;if (unlikely(contended)) {
</span><span class='line'>&#9;&#9;&#9;&#9;spin_unlock(&q-&gt;busylock);
</span><span class='line'>&#9;&#9;&#9;&#9;contended = false;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;__qdisc_run(q);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;spin_unlock(root_lock);
</span><span class='line'>&#9;if (unlikely(contended))
</span><span class='line'>&#9;&#9;spin_unlock(&q-&gt;busylock);
</span><span class='line'>&#9;return rc;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>_dev_xmit_skb函数主要做两件事情：<br/>
 （1） 如果流控对象为空的，试图直接发送数据包。<br/>
 （2） 如果流控对象不空，将数据包加入流控对象，并运行流控对象。</p>

<p>当设备进入调度队列准备传输时，qdisc_run函数就会选出下一个要传输的帧，而该函数会间接的调用相关联的队列规则dequeue函数，从对了中取出数据进行传输。</p>

<p>有两个时机将会调用qdisc_run()：<br/>
  1.<code>__dev_xmit_skb()</code><br/>
  2.软中断服务线程NET_TX_SOFTIRQ</p>

<p>其实，真正的工作有qdisc_restart函数实现。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __qdisc_run(struct Qdisc *q)
</span><span class='line'>{
</span><span class='line'>&#9;unsigned long start_time = jiffies;
</span><span class='line'>
</span><span class='line'>&#9;while (qdisc_restart(q)) { //返回值大于0，说明流控对象非空。
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * Postpone processing if
</span><span class='line'>&#9;&#9; * 1. another process needs the CPU;
</span><span class='line'>&#9;&#9; * 2. we've been doing it for too long.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (need_resched() || jiffies != start_time) { //已经不允许继续运行本流控对象。
</span><span class='line'>&#9;&#9;&#9;__netif_schedule(q); //将本队列加入软中断的output_queue链表中。
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;qdisc_run_end(q);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果发现本队列运行的时间太长了，将会停止队列的运行，并将队列加入output_queue链表头。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int qdisc_restart(struct Qdisc *q)
</span><span class='line'>{
</span><span class='line'>&#9;struct netdev_queue *txq;
</span><span class='line'>&#9;struct net_device *dev;
</span><span class='line'>&#9;spinlock_t *root_lock;
</span><span class='line'>&#9;struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>&#9;/* Dequeue packet */
</span><span class='line'>&#9;skb = dequeue_skb(q);//一开始就调用dequeue函数。
</span><span class='line'>&#9;if (unlikely(!skb))
</span><span class='line'>&#9;&#9;return 0;
</span><span class='line'>&#9;WARN_ON_ONCE(skb_dst_is_noref(skb));
</span><span class='line'>&#9;root_lock = qdisc_lock(q);
</span><span class='line'>&#9;dev = qdisc_dev(q);
</span><span class='line'>&#9;txq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));
</span><span class='line'>
</span><span class='line'>&#9;return sch_direct_xmit(skb, q, dev, txq, root_lock);//用于发送数据包
</span><span class='line'>}
</span><span class='line'>* Returns to the caller:
</span><span class='line'> *                0 - queue is empty or throttled.
</span><span class='line'> *                &gt;0 - queue is not empty.
</span><span class='line'> */
</span><span class='line'>int sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,
</span><span class='line'>&#9;&#9; struct net_device *dev, struct netdev_queue *txq,
</span><span class='line'>&#9;&#9; spinlock_t *root_lock)
</span><span class='line'>{
</span><span class='line'>&#9;int ret = NETDEV_TX_BUSY;
</span><span class='line'>
</span><span class='line'>&#9;/* And release qdisc */
</span><span class='line'>&#9;spin_unlock(root_lock);
</span><span class='line'>
</span><span class='line'>&#9;HARD_TX_LOCK(dev, txq, smp_processor_id());
</span><span class='line'>&#9;if (!netif_tx_queue_stopped(txq) && !netif_tx_queue_frozen(txq)) //设备没有被停止，且发送队列没有被冻结
</span><span class='line'>&#9;&#9;ret = dev_hard_start_xmit(skb, dev, txq); //发送数据包
</span><span class='line'>
</span><span class='line'>&#9;HARD_TX_UNLOCK(dev, txq);
</span><span class='line'>
</span><span class='line'>&#9;spin_lock(root_lock);
</span><span class='line'>
</span><span class='line'>&#9;if (dev_xmit_complete(ret)) {
</span><span class='line'>&#9;&#9;/* Driver sent out skb successfully or skb was consumed */
</span><span class='line'>&#9;&#9;//发送成功，返回新的队列的长度
</span><span class='line'>&#9;&#9;ret = qdisc_qlen(q);
</span><span class='line'>&#9;} else if (ret == NETDEV_TX_LOCKED) {
</span><span class='line'>&#9;&#9;/* Driver try lock failed */
</span><span class='line'>&#9;&#9;ret = handle_dev_cpu_collision(skb, txq, q);
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;/* Driver returned NETDEV_TX_BUSY - requeue skb */
</span><span class='line'>&#9;&#9;if (unlikely (ret != NETDEV_TX_BUSY && net_ratelimit()))
</span><span class='line'>&#9;&#9;&#9;printk(KERN_WARNING "BUG %s code %d qlen %d\n",
</span><span class='line'>&#9;&#9;&#9; dev-&gt;name, ret, q-&gt;q.qlen);
</span><span class='line'>&#9;&#9; //设备繁忙，重新调度发送（利用softirq）
</span><span class='line'>&#9;&#9;ret = dev_requeue_skb(skb, q);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (ret && (netif_tx_queue_stopped(txq) ||
</span><span class='line'>&#9;&#9; netif_tx_queue_frozen(txq)))
</span><span class='line'>&#9;&#9;ret = 0;
</span><span class='line'>
</span><span class='line'>&#9;return ret;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>4. 我们看一下下面的发送函数。</h5>

<p> 从此函数可以看出，当驱动使用发送队列的时候会循环从队列中取出包发送, 而不使用队列的时候只发送一次，如果没发送成功就直接丢弃</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct netdev_queue *txq)
</span><span class='line'>{
</span><span class='line'>&#9;const struct net_device_ops *ops = dev-&gt;netdev_ops;//驱动程序的函数集
</span><span class='line'>&#9;int rc = NETDEV_TX_OK;
</span><span class='line'>
</span><span class='line'>&#9;if (likely(!skb-&gt;next)) {
</span><span class='line'>&#9;&#9;if (!list_empty(&ptype_all))
</span><span class='line'>&#9;&#9;&#9;dev_queue_xmit_nit(skb, dev);//如果dev_add_pack加入的是ETH_P_ALL，那么就会复制一份给你的回调函数。
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * If device doesnt need skb-&gt;dst, release it right now while
</span><span class='line'>&#9;&#9; * its hot in this cpu cache
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (dev-&gt;priv_flags & IFF_XMIT_DST_RELEASE)
</span><span class='line'>&#9;&#9;&#9;skb_dst_drop(skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb_orphan_try(skb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (vlan_tx_tag_present(skb) &&
</span><span class='line'>&#9;&#9; !(dev-&gt;features & NETIF_F_HW_VLAN_TX)) {
</span><span class='line'>&#9;&#9;&#9;skb = __vlan_put_tag(skb, vlan_tx_tag_get(skb));
</span><span class='line'>&#9;&#9;&#9;if (unlikely(!skb))
</span><span class='line'>&#9;&#9;&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;skb-&gt;vlan_tci = 0;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (netif_needs_gso(dev, skb)) {
</span><span class='line'>&#9;&#9;&#9;if (unlikely(dev_gso_segment(skb)))
</span><span class='line'>&#9;&#9;&#9;&#9;goto out_kfree_skb;
</span><span class='line'>&#9;&#9;&#9;if (skb-&gt;next)
</span><span class='line'>&#9;&#9;&#9;&#9;goto gso;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;if (skb_needs_linearize(skb, dev) &&
</span><span class='line'>&#9;&#9;&#9; __skb_linearize(skb))
</span><span class='line'>&#9;&#9;&#9;&#9;goto out_kfree_skb;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* If packet is not checksummed and device does not
</span><span class='line'>&#9;&#9;&#9; * support checksumming for this protocol, complete
</span><span class='line'>&#9;&#9;&#9; * checksumming here.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;if (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {
</span><span class='line'>&#9;&#9;&#9;&#9;skb_set_transport_header(skb, skb-&gt;csum_start -
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; skb_headroom(skb));
</span><span class='line'>&#9;&#9;&#9;&#9;if (!dev_can_checksum(dev, skb) &&
</span><span class='line'>&#9;&#9;&#9;&#9; skb_checksum_help(skb))
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;goto out_kfree_skb;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;rc = ops-&gt;ndo_start_xmit(skb, dev);//调用网卡的驱动程序发送数据。不同的网络设备有不同的发送函数
</span><span class='line'>&#9;&#9;trace_net_dev_xmit(skb, rc);
</span><span class='line'>&#9;&#9;if (rc == NETDEV_TX_OK)
</span><span class='line'>&#9;&#9;&#9;txq_trans_update(txq);
</span><span class='line'>&#9;&#9;return rc;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>gso:
</span><span class='line'>&#9;do {
</span><span class='line'>&#9;&#9;struct sk_buff *nskb = skb-&gt;next;
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb-&gt;next = nskb-&gt;next;
</span><span class='line'>&#9;&#9;nskb-&gt;next = NULL;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * If device doesnt need nskb-&gt;dst, release it right now while
</span><span class='line'>&#9;&#9; * its hot in this cpu cache
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (dev-&gt;priv_flags & IFF_XMIT_DST_RELEASE)
</span><span class='line'>&#9;&#9;&#9;skb_dst_drop(nskb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;rc = ops-&gt;ndo_start_xmit(nskb, dev); //调用网卡的驱动程序发送数据。不同的网络设备有不同的发送函数
</span><span class='line'>&#9;&#9;trace_net_dev_xmit(nskb, rc);
</span><span class='line'>&#9;&#9;if (unlikely(rc != NETDEV_TX_OK)) {
</span><span class='line'>&#9;&#9;&#9;if (rc & ~NETDEV_TX_MASK)
</span><span class='line'>&#9;&#9;&#9;&#9;goto out_kfree_gso_skb;
</span><span class='line'>&#9;&#9;&#9;nskb-&gt;next = skb-&gt;next;
</span><span class='line'>&#9;&#9;&#9;skb-&gt;next = nskb;
</span><span class='line'>&#9;&#9;&#9;return rc;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;txq_trans_update(txq);
</span><span class='line'>&#9;&#9;if (unlikely(netif_tx_queue_stopped(txq) && skb-&gt;next))
</span><span class='line'>&#9;&#9;&#9;return NETDEV_TX_BUSY;
</span><span class='line'>&#9;} while (skb-&gt;next);
</span><span class='line'>
</span><span class='line'>out_kfree_gso_skb:
</span><span class='line'>&#9;if (likely(skb-&gt;next == NULL))
</span><span class='line'>&#9;&#9;skb-&gt;destructor = DEV_GSO_CB(skb)-&gt;destructor;
</span><span class='line'>out_kfree_skb:
</span><span class='line'>&#9;kfree_skb(skb);
</span><span class='line'>out:
</span><span class='line'>&#9;return rc;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>5.下面看一下dev_queue_xmit_nit函数。</h5>

<p>对于通过socket(AF_PACKET,SOCK_RAW,htons(ETH_P_ALL))创建的原始套接口，不但可以接受从外部输入的数据包，而且对于由于本地输出的数据包，如果满足条件，也可以能接受。</p>

<p>该函数就是用来接收由于本地输出的数据包，在链路层的输出过程中，会调用此函数，将满足条件的数据包输入到RAW套接口，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void dev_queue_xmit_nit(struct sk_buff *skb, struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct packet_type *ptype;
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_NET_CLS_ACT
</span><span class='line'>&#9;if (!(skb-&gt;tstamp.tv64 && (G_TC_FROM(skb-&gt;tc_verd) & AT_INGRESS)))
</span><span class='line'>&#9;&#9;net_timestamp_set(skb);-----------------（1）
</span><span class='line'>#else
</span><span class='line'>&#9;net_timestamp_set(skb);
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;list_for_each_entry_rcu(ptype, &ptype_all, list) {-----------------（2）
</span><span class='line'>&#9;&#9;/* Never send packets back to the socket
</span><span class='line'>&#9;&#9; * they originated from - MvS (miquels@drinkel.ow.org)
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if ((ptype-&gt;dev == dev || !ptype-&gt;dev) &&
</span><span class='line'>&#9;&#9; (ptype-&gt;af_packet_priv == NULL ||
</span><span class='line'>&#9;&#9; (struct sock *)ptype-&gt;af_packet_priv != skb-&gt;sk)) {-----------------（3）
</span><span class='line'>&#9;&#9;&#9;struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC); -----------------（4）
</span><span class='line'>&#9;&#9;&#9;if (!skb2)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* skb-&gt;nh should be correctly
</span><span class='line'>&#9;&#9;&#9; set by sender, so that the second statement is
</span><span class='line'>&#9;&#9;&#9; just protection against buggy protocols.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;skb_reset_mac_header(skb2);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (skb_network_header(skb2) &lt; skb2-&gt;data ||
</span><span class='line'>&#9;&#9;&#9; skb2-&gt;network_header &gt; skb2-&gt;tail) {
</span><span class='line'>&#9;&#9;&#9;&#9;if (net_ratelimit())
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;printk(KERN_CRIT "protocol %04x is "
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; "buggy, dev %s\n",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; ntohs(skb2-&gt;protocol),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9; dev-&gt;name);
</span><span class='line'>&#9;&#9;&#9;&#9;skb_reset_network_header(skb2); -----------------（5）
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;skb2-&gt;transport_header = skb2-&gt;network_header;
</span><span class='line'>&#9;&#9;&#9;skb2-&gt;pkt_type = PACKET_OUTGOING;
</span><span class='line'>&#9;&#9;&#9;ptype-&gt;func(skb2, skb-&gt;dev, ptype, skb-&gt;dev); -----------------（6）
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>说明：<br/>
（1） 记录该数据包输入的时间戳<br/>
（2） 遍历ptype_all链表，查找所有符合输入条件的原始套接口，并循环将数据包输入到满足条件的套接口<br/>
（3） 数据包的输出设备与套接口的输入设备相符或者套接口不指定输入设备，并且该数据包不是有当前用于比较的套接口输出，此时该套接口满足条件，数据包可以输入<br/>
（4） 由于该数据包是额外输入到这个原始套接口的，因此需要克隆一个数据包<br/>
（5） 校验数据包是否有效<br/>
（6） 将数据包输入原始套接口</p>

<h5>6. 对于lookback设备来说处理有些不同。它的hard_start_xmit函数是loopback_xmit</h5>

<p>在net/lookback.c文件中，定义的struct net_device_ops loopback_ops结构体</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const struct net_device_ops loopback_ops = {
</span><span class='line'>&#9;.ndo_init = loopback_dev_init,
</span><span class='line'>&#9;.ndo_start_xmit= loopback_xmit,
</span><span class='line'>&#9;.ndo_get_stats64 = loopback_get_stats64,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>从这里可以看到起发送函数为loopback_xmit函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static netdev_tx_t loopback_xmit(struct sk_buff *skb,
</span><span class='line'>&#9;&#9;&#9;&#9; struct net_device *dev)
</span><span class='line'>{
</span><span class='line'>&#9;struct pcpu_lstats *lb_stats;
</span><span class='line'>&#9;int len;
</span><span class='line'>
</span><span class='line'>&#9;skb_orphan(skb);
</span><span class='line'>
</span><span class='line'>&#9;skb-&gt;protocol = eth_type_trans(skb, dev);
</span><span class='line'>
</span><span class='line'>&#9;/* it's OK to use per_cpu_ptr() because BHs are off */
</span><span class='line'>&#9;lb_stats = this_cpu_ptr(dev-&gt;lstats);
</span><span class='line'>
</span><span class='line'>&#9;len = skb-&gt;len;
</span><span class='line'>&#9;if (likely(netif_rx(skb) == NET_RX_SUCCESS)) {//直接调用了netif_rx进行了接收处理
</span><span class='line'>&#9;&#9;u64_stats_update_begin(&lb_stats-&gt;syncp);
</span><span class='line'>&#9;&#9;lb_stats-&gt;bytes += len;
</span><span class='line'>&#9;&#9;lb_stats-&gt;packets++;
</span><span class='line'>&#9;&#9;u64_stats_update_end(&lb_stats-&gt;syncp);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;return NETDEV_TX_OK;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>7. 已经有了dev_queue_xmit函数，为什么还需要软中断来发送呢？</h5>

<p>dev_queue_xmit是对skb做些最后的处理并且第一次尝试发送,软中断是将前者发送失败或者没发完的包发送出去。</p>

<p>主要参考文献：</p>

<p>Linux发送函数dev_queue_xmit分析  <a href="http://shaojiashuai123456.iteye.com/blog/842236">http://shaojiashuai123456.iteye.com/blog/842236</a></p>

<p>TC流量控制实现分析（初步）  <a href="http://blog.csdn.net/wwwlkk/article/details/5929308">http://blog.csdn.net/wwwlkk/article/details/5929308</a></p>

<p>Linux内核源码剖析 TCP/IP实现</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-08-25T23:20:00+08:00'><span class='date'>2015-08-25</span> <span class='time'>23:20:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~net/'>net</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/08/25/kernel-net-rtable/" title="Previous Post: 路由表 rtable">&laquo; 路由表 rtable</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/08/25/kernel-net-ipv4/" title="Next Post: linux下ip协议(V4)的实现">linux下ip协议(V4)的实现 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
