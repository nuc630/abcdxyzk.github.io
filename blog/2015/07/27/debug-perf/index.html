
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>系统级性能分析工具 --- Perf - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">系统级性能分析工具 --- Perf</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-27T17:09:00+08:00'><span class='date'>2015-07-27</span> <span class='time'>17:09:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.csdn.net/zhangskd/article/details/37902159">http://blog.csdn.net/zhangskd/article/details/37902159</a></p>

<p>从2.6.31内核开始，linux内核自带了一个性能分析工具perf，能够进行函数级与指令级的热点查找。</p>

<h4>perf</h4>

<p>Performance analysis tools for Linux.<br/>
Performance counters for Linux are a new kernel-based subsystem that provide a framework for all things performance analysis. It covers hardware level (CPU/PMU, Performance Monitoring Unit) features and software features (software counters, tracepoints) as well.</p>

<p>perf是内置于Linux内核源码树中的性能剖析(profiling)工具。</p>

<p>它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。</p>

<p>常用于性能瓶颈的查找与热点代码的定位。</p>

<p>CPU周期(cpu-cycles)是默认的性能事件，所谓的CPU周期是指CPU所能识别的最小时间单元，通常为亿分之几秒，是CPU执行最简单的指令时所需要的时间，例如读取寄存器中的内容，也叫做clock tick。</p>

<p>perf是一个包含22种子工具的工具集，以下是最常用的5种：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf list
</span><span class='line'>perf stat
</span><span class='line'>perf top
</span><span class='line'>perf record
</span><span class='line'>perf report</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>perf list</h4>

<p>perf list用来查看perf所支持的性能事件，有软件的也有硬件的。</p>

<p>List all symbolic event types.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf list [hw | sw | cache | tracepoint | event_glob]</span></code></pre></td></tr></table></div></figure>


<h5>(1) 性能事件的分布</h5>

<p>hw：Hardware event，9个<br/>
sw：Software event，9个<br/>
cache：Hardware cache event，26个<br/>
tracepoint：Tracepoint event，775个</p>

<p>sw实际上是内核的计数器，与硬件无关。<br/>
hw和cache是CPU架构相关的，依赖于具体硬件。<br/>
tracepoint是基于内核的ftrace，主线2.6.3x以上的内核版本才支持。</p>

<h5>(2) 指定性能事件(以它的属性)</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-e &lt;event&gt; : u // userspace
</span><span class='line'>-e &lt;event&gt; : k // kernel
</span><span class='line'>-e &lt;event&gt; : h // hypervisor
</span><span class='line'>-e &lt;event&gt; : G // guest counting (in KVM guests)
</span><span class='line'>-e &lt;event&gt; : H // host counting (not in KVM guests)</span></code></pre></td></tr></table></div></figure>


<h5>(3) 使用例子</h5>

<p>显示内核和模块中，消耗最多CPU周期的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf top -e cycles:k</span></code></pre></td></tr></table></div></figure>


<p>显示分配高速缓存最多的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf top -e kmem:kmem_cache_alloc</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>perf top</h4>

<p>对于一个指定的性能事件(默认是CPU周期)，显示消耗最多的函数或指令。</p>

<p>System profiling tool.<br/>
Generates and displays a performance counter profile in real time.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf top [-e &lt;EVENT&gt; | --event=EVENT] [&lt;options&gt;]</span></code></pre></td></tr></table></div></figure>


<p>perf top主要用于实时分析各个函数在某个性能事件上的热度，能够快速的定位热点函数，包括应用程序函数、模块函数与内核函数，甚至能够定位到热点指令。默认的性能事件为cpu cycles。</p>

<h5>(1) 输出格式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf top
</span><span class='line'>
</span><span class='line'>Samples: 1M of event 'cycles', Event count (approx.): 73891391490
</span><span class='line'>     5.44%  perf              [.] 0x0000000000023256
</span><span class='line'>     4.86%  [kernel]          [k] _spin_lock
</span><span class='line'>     2.43%  [kernel]          [k] _spin_lock_bh
</span><span class='line'>     2.29%  [kernel]          [k] _spin_lock_irqsave
</span><span class='line'>     1.77%  [kernel]          [k] __d_lookup
</span><span class='line'>     1.55%  libc-2.12.so      [.] __strcmp_sse42
</span><span class='line'>     1.43%  nginx             [.] ngx_vslprintf
</span><span class='line'>     1.37%  [kernel]          [k] tcp_poll</span></code></pre></td></tr></table></div></figure>


<p>第一列：符号引发的性能事件的比例，默认指占用的cpu周期比例。<br/>
第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。<br/>
第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库)。[k]表述此符号属于内核或模块。<br/>
第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p>

<h5>(2) 常用交互命令</h5>

<p>h：显示帮助<br/>
UP/DOWN/PGUP/PGDN/SPACE：上下和翻页。<br/>
a：annotate current symbol，注解当前符号。能够给出汇编语言的注解，给出各条指令的采样率。<br/>
d：过滤掉所有不属于此DSO的符号。非常方便查看同一类别的符号。<br/>
P：将当前信息保存到perf.hist.N中。<br/>
s：输入函数，查看函数内部热点。</p>

<h5>(3) 常用命令行参数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-e &lt;event&gt;：指明要分析的性能事件。
</span><span class='line'>-p &lt;pid&gt;：Profile events on existing Process ID (comma sperated list). 仅分析目标进程及其创建的线程。
</span><span class='line'>-k &lt;path&gt;：Path to vmlinux. Required for annotation functionality. 带符号表的内核映像所在的路径。
</span><span class='line'>-K：不显示属于内核或模块的符号。
</span><span class='line'>-U：不显示属于用户态程序的符号。
</span><span class='line'>-d &lt;n&gt;：界面的刷新周期，默认为2s，因为perf top默认每2s从mmap的内存区域读取一次性能数据。
</span><span class='line'>-G：得到函数的调用关系图。
</span><span class='line'>perf top -G [fractal]，路径概率为相对值，加起来为100%，调用顺序为从下往上。
</span><span class='line'>perf top -G graph，路径概率为绝对值，加起来为该函数的热度。</span></code></pre></td></tr></table></div></figure>


<h5>(4) 使用例子</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf top // 默认配置
</span><span class='line'># perf top -G // 得到调用关系图
</span><span class='line'># perf top -e cycles // 指定性能事件
</span><span class='line'># perf top -p 23015,32476 // 查看这两个进程的cpu cycles使用情况
</span><span class='line'># perf top -s comm,pid,symbol // 显示调用symbol的进程名和进程号
</span><span class='line'># perf top --comms nginx,top // 仅显示属于指定进程的符号
</span><span class='line'># perf top --symbols kfree // 仅显示指定的符号</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>perf stat</h4>

<p>用于分析指定程序的性能概况。</p>

<p>Run a command and gather performance counter statistics.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] &lt;command&gt;
</span><span class='line'>perf stat [-e &lt;EVENT&gt; | --event=EVENT] [-a] - &lt;command&gt; [&lt;options&gt;]</span></code></pre></td></tr></table></div></figure>


<h5>(1) 输出格式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat ls
</span><span class='line'>
</span><span class='line'>Performance counter stats for 'ls':
</span><span class='line'>
</span><span class='line'>         0.653782 task-clock                #    0.691 CPUs utilized
</span><span class='line'>                0 context-switches          #    0.000 K/sec
</span><span class='line'>                0 CPU-migrations            #    0.000 K/sec
</span><span class='line'>              247 page-faults               #    0.378 M/sec
</span><span class='line'>        1,625,426 cycles                    #    2.486 GHz
</span><span class='line'>        1,050,293 stalled-cycles-frontend   #   64.62% frontend cycles idle
</span><span class='line'>          838,781 stalled-cycles-backend    #   51.60% backend  cycles idle
</span><span class='line'>        1,055,735 instructions              #    0.65  insns per cycle
</span><span class='line'>                                            #    0.99  stalled cycles per insn
</span><span class='line'>          210,587 branches                  #  322.106 M/sec
</span><span class='line'>           10,809 branch-misses             #    5.13% of all branches
</span><span class='line'>
</span><span class='line'>      0.000945883 seconds time elapsed</span></code></pre></td></tr></table></div></figure>


<p>输出包括ls的执行时间，以及10个性能事件的统计。</p>

<p>task-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized = task-clock / time elapsed，CPU的占用率。<br/>
context-switches：上下文的切换次数。<br/>
CPU-migrations：处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。<br/>
page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。<br/>
cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles / task-clock算出。<br/>
stalled-cycles-frontend：略过。<br/>
stalled-cycles-backend：略过。<br/>
instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。<br/>
branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p>

<h5>(2) 常用参数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-p：stat events on existing process id (comma separated list). 仅分析目标进程及其创建的线程。
</span><span class='line'>-a：system-wide collection from all CPUs. 从所有CPU上收集性能数据。
</span><span class='line'>-r：repeat command and print average + stddev (max: 100). 重复执行命令求平均。
</span><span class='line'>-C：Count only on the list of CPUs provided (comma separated list), 从指定CPU上收集性能数据。
</span><span class='line'>-v：be more verbose (show counter open errors, etc), 显示更多性能数据。
</span><span class='line'>-n：null run - don't start any counters，只显示任务的执行时间 。
</span><span class='line'>-x SEP：指定输出列的分隔符。
</span><span class='line'>-o file：指定输出文件，--append指定追加模式。
</span><span class='line'>--pre &lt;cmd&gt;：执行目标程序前先执行的程序。
</span><span class='line'>--post &lt;cmd&gt;：执行目标程序后再执行的程序。</span></code></pre></td></tr></table></div></figure>


<h5>(3) 使用例子</h5>

<p>执行10次程序，给出标准偏差与期望的比值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat -r 10 ls &gt; /dev/null</span></code></pre></td></tr></table></div></figure>


<p>显示更详细的信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat -v ls &gt; /dev/null</span></code></pre></td></tr></table></div></figure>


<p>只显示任务执行时间，不显示性能计数器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat -n ls &gt; /dev/null</span></code></pre></td></tr></table></div></figure>


<p>单独给出每个CPU上的信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat -a -A ls &gt; /dev/null</span></code></pre></td></tr></table></div></figure>


<p>ls命令执行了多少次系统调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf stat -e syscalls:sys_enter ls </span></code></pre></td></tr></table></div></figure>


<hr />

<h4>perf record</h4>

<p>收集采样信息，并将其记录在数据文件中。随后可以通过其它工具(perf-report)对数据文件进行分析，结果类似于perf-top的。</p>

<p>Run a command and record its profile into perf.data.<br/>
This command runs a command and gathers a performance counter profile from it, into perf.data,without displaying anything. This file can then be inspected later on, using perf report.</p>

<h5>(1) 常用参数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-e：Select the PMU event.
</span><span class='line'>-a：System-wide collection from all CPUs.
</span><span class='line'>-p：Record events on existing process ID (comma separated list).
</span><span class='line'>-A：Append to the output file to do incremental profiling.
</span><span class='line'>-f：Overwrite existing data file.
</span><span class='line'>-o：Output file name.
</span><span class='line'>-g：Do call-graph (stack chain/backtrace) recording.
</span><span class='line'>-C：Collect samples only on the list of CPUs provided.</span></code></pre></td></tr></table></div></figure>


<h5>(2) 使用例子</h5>

<p>记录nginx进程的性能数据：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf record -p `pgrep -d ',' nginx`</span></code></pre></td></tr></table></div></figure>


<p>记录执行ls时的性能数据：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf record ls -g</span></code></pre></td></tr></table></div></figure>


<p>记录执行ls时的系统调用，可以知道哪些系统调用最频繁：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf record -e syscalls:sys_enter ls</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>perf report</h4>

<p>读取perf record创建的数据文件，并给出热点分析结果。</p>

<p>Read perf.data (created by perf record) and display the profile.<br/>
This command displays the performance counter profile information recorded via perf record.</p>

<h5>(1) 常用参数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-i：Input file name. (default: perf.data)</span></code></pre></td></tr></table></div></figure>


<h5>(2) 使用例子</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf report -i perf.data.2</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>More</h3>

<p>除了以上5个常用工具外，还有一些适用于较特殊场景的工具， 比如内核锁、slab分配器、调度器，也支持自定义探测点。</p>

<h4>perf lock</h4>

<p>内核锁的性能分析。</p>

<p>Analyze lock events.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf lock {record | report | script | info}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>需要编译选项的支持：CONFIG_LOCKDEP、CONFIG_LOCK_STAT。</li>
</ul>


<p>CONFIG_LOCKDEP defines acquired and release events.<br/>
CONFIG_LOCK_STAT defines contended and acquired lock events.</p>

<h5>(1) 常用选项</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-i &lt;file&gt;：输入文件
</span><span class='line'>-k &lt;value&gt;：sorting key，默认为acquired，还可以按contended、wait_total、wait_max和wait_min来排序。</span></code></pre></td></tr></table></div></figure>


<h5>(2) 使用例子</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf lock record ls // 记录
</span><span class='line'># perf lock report // 报告</span></code></pre></td></tr></table></div></figure>


<h5>(3) 输出格式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>               Name   acquired  contended total wait (ns)   max wait (ns)   min wait (ns)
</span><span class='line'>
</span><span class='line'>&mm-&gt;page_table_...        382          0               0               0               0
</span><span class='line'>&mm-&gt;page_table_...         72          0               0               0               0
</span><span class='line'>          &fs-&gt;lock         64          0               0               0               0
</span><span class='line'>        dcache_lock         62          0               0               0               0
</span><span class='line'>      vfsmount_lock         43          0               0               0               0
</span><span class='line'>&newf-&gt;file_lock...         41          0               0               0               0</span></code></pre></td></tr></table></div></figure>


<p>Name：内核锁的名字。<br/>
aquired：该锁被直接获得的次数，因为没有其它内核路径占用该锁，此时不用等待。<br/>
contended：该锁等待后获得的次数，此时被其它内核路径占用，需要等待。<br/>
total wait：为了获得该锁，总共的等待时间。<br/>
max wait：为了获得该锁，最大的等待时间。<br/>
min wait：为了获得该锁，最小的等待时间。</p>

<p>最后还有一个Summary：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>=== output for debug===  
</span><span class='line'>
</span><span class='line'>bad: 10, total: 246  
</span><span class='line'>bad rate: 4.065041 %  
</span><span class='line'>histogram of events caused bad sequence  
</span><span class='line'>    acquire: 0  
</span><span class='line'>   acquired: 0  
</span><span class='line'>  contended: 0  
</span><span class='line'>    release: 10  </span></code></pre></td></tr></table></div></figure>


<hr />

<h5>perf kmem</h5>

<p>slab分配器的性能分析。</p>

<p>Tool to trace/measure kernel memory(slab) properties.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf kmem {record | stat} [&lt;options&gt;]</span></code></pre></td></tr></table></div></figure>


<h5>(1) 常用选项</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>--i &lt;file&gt;：输入文件
</span><span class='line'>--caller：show per-callsite statistics，显示内核中调用kmalloc和kfree的地方。
</span><span class='line'>--alloc：show per-allocation statistics，显示分配的内存地址。
</span><span class='line'>-l &lt;num&gt;：print n lines only，只显示num行。
</span><span class='line'>-s &lt;key[,key2...]&gt;：sort the output (default: frag,hit,bytes)</span></code></pre></td></tr></table></div></figure>


<h5>(2) 使用例子</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf kmem record ls // 记录
</span><span class='line'># perf kmem stat --caller --alloc -l 20 // 报告</span></code></pre></td></tr></table></div></figure>


<h5>(3) 输出格式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>------------------------------------------------------------------------------------------------------
</span><span class='line'> Callsite                           | Total_alloc/Per | Total_req/Per   | Hit      | Ping-pong | Frag
</span><span class='line'>------------------------------------------------------------------------------------------------------
</span><span class='line'> perf_event_mmap+ec                 |    311296/8192  |    155952/4104  |       38 |        0 | 49.902%
</span><span class='line'> proc_reg_open+41                   |        64/64    |        40/40    |        1 |        0 | 37.500%
</span><span class='line'> __kmalloc_node+4d                  |      1024/1024  |       664/664   |        1 |        0 | 35.156%
</span><span class='line'> ext3_readdir+5bd                   |        64/64    |        48/48    |        1 |        0 | 25.000%
</span><span class='line'> load_elf_binary+8ec                |       512/512   |       392/392   |        1 |        0 | 23.438%</span></code></pre></td></tr></table></div></figure>


<p>Callsite：内核代码中调用kmalloc和kfree的地方。<br/>
Total_alloc/Per：总共分配的内存大小，平均每次分配的内存大小。<br/>
Total_req/Per：总共请求的内存大小，平均每次请求的内存大小。<br/>
Hit：调用的次数。<br/>
Ping-pong：kmalloc和kfree不被同一个CPU执行时的次数，这会导致cache效率降低。<br/>
Frag：碎片所占的百分比，碎片 = 分配的内存 - 请求的内存，这部分是浪费的。<br/>
有使用&ndash;alloc选项，还会看到Alloc Ptr，即所分配内存的地址。</p>

<p>最后还有一个Summary：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SUMMARY
</span><span class='line'>=======
</span><span class='line'>Total bytes requested: 290544
</span><span class='line'>Total bytes allocated: 447016
</span><span class='line'>Total bytes wasted on internal fragmentation: 156472
</span><span class='line'>Internal fragmentation: 35.003669%
</span><span class='line'>Cross CPU allocations: 2/509</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>probe sched</h4>

<p>调度模块分析。</p>

<p>trace/measure scheduler properties (latencies)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>perf sched {record | latency | map | replay | script}</span></code></pre></td></tr></table></div></figure>


<h5>(1) 使用例子</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf sched record sleep 10 // perf sched record &lt;command&gt;
</span><span class='line'># perf report latency --sort max</span></code></pre></td></tr></table></div></figure>


<h5>(2) 输出格式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>---------------------------------------------------------------------------------------------------------------
</span><span class='line'> Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at     |
</span><span class='line'>---------------------------------------------------------------------------------------------------------------
</span><span class='line'> events/10:61          |      0.655 ms |       10 | avg:    0.045 ms | max:    0.161 ms | max at: 9804.958730 s
</span><span class='line'> sleep:11156           |      2.263 ms |        4 | avg:    0.052 ms | max:    0.118 ms | max at: 9804.865552 s
</span><span class='line'> edac-poller:1125      |      0.598 ms |       10 | avg:    0.042 ms | max:    0.113 ms | max at: 9804.958698 s
</span><span class='line'> events/2:53           |      0.676 ms |       10 | avg:    0.037 ms | max:    0.102 ms | max at: 9814.751605 s
</span><span class='line'> perf:11155            |      2.109 ms |        1 | avg:    0.068 ms | max:    0.068 ms | max at: 9814.867918 s</span></code></pre></td></tr></table></div></figure>


<p>TASK：进程名和pid。<br/>
Runtime：实际的运行时间。<br/>
Switches：进程切换的次数。<br/>
Average delay：平均的调度延迟。<br/>
Maximum delay：最大的调度延迟。<br/>
Maximum delay at：最大调度延迟发生的时刻。</p>

<hr />

<h4>perf probe</h4>

<p>可以自定义探测点。</p>

<p>Define new dynamic tracepoints.</p>

<h5>使用例子</h5>

<p>(1) Display which lines in schedule() can be probed</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf probe --line schedule</span></code></pre></td></tr></table></div></figure>


<p>前面有行号的可以探测，没有行号的就不行了。</p>

<p>(2) Add a probe on schedule() function 12th line.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># perf probe -a schedule:12</span></code></pre></td></tr></table></div></figure>


<p>在schedule函数的12处增加一个探测点。</p>

<hr />

<h4>Reference</h4>

<p>[1]. Linux的系统级性能剖析工具系列，by 承刚</p>

<p>[2]. <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/">http://www.ibm.com/developerworks/cn/linux/l-cn-perf1/</a></p>

<p>[3]. <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/">http://www.ibm.com/developerworks/cn/linux/l-cn-perf2/</a></p>

<p>[4]. <a href="https://perf.wiki.kernel.org/index.php/Tutorial">https://perf.wiki.kernel.org/index.php/Tutorial</a></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-07-27T17:09:00+08:00'><span class='date'>2015-07-27</span> <span class='time'>17:09:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/debug/'>debug</a>, <a class='category' href='/blog/cats/debug~perf/'>perf</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/07/24/tools-haproxy-splice/" title="Previous Post: haproxy splice">&laquo; haproxy splice</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/07/28/kvm-pic/" title="Next Post: qemu-kvm部分流程/源代码分析">qemu-kvm部分流程/源代码分析 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
