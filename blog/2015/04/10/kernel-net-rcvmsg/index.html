
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Linux TCP数据包接收处理 tcp_recvmsg - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">Linux TCP数据包接收处理 tcp_recvmsg</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-10T15:29:00+08:00'><span class='date'>2015-04-10</span> <span class='time'>15:29:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.csdn.net/mrpre/article/details/33347221">http://blog.csdn.net/mrpre/article/details/33347221</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 
</span><span class='line'> *    This routine copies from a sock struct into the user buffer.
</span><span class='line'> *
</span><span class='line'> *    Technical note: in 2.3 we work on _locked_ socket, so that
</span><span class='line'> *    tricks with *seq access order and skb-&gt;users are not required.
</span><span class='line'> *    Probably, code can be easily improved even more.
</span><span class='line'> */
</span><span class='line'>
</span><span class='line'>int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
</span><span class='line'>&#9;&#9;size_t len, int nonblock, int flags, int *addr_len)
</span><span class='line'>{
</span><span class='line'>&#9;struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>&#9;int copied = 0;
</span><span class='line'>&#9;u32 peek_seq;
</span><span class='line'>&#9;u32 *seq;
</span><span class='line'>&#9;unsigned long used;
</span><span class='line'>&#9;int err;
</span><span class='line'>&#9;int target;    /* Read at least this many bytes */
</span><span class='line'>&#9;long timeo;
</span><span class='line'>&#9;struct task_struct *user_recv = NULL;
</span><span class='line'>&#9;int copied_early = 0;
</span><span class='line'>&#9;struct sk_buff *skb;
</span><span class='line'>&#9;u32 urg_hole = 0;
</span><span class='line'>
</span><span class='line'>&#9;//功能：“锁住sk”，并非真正的加锁，而是执行sk-&gt;sk_lock.owned = 1 
</span><span class='line'>&#9;//目的：这样软中断上下文能够通过owned ，判断该sk是否处于进程上下文。
</span><span class='line'>&#9;//提供一种同步机制。
</span><span class='line'>&#9;lock_sock(sk);
</span><span class='line'>
</span><span class='line'>&#9;TCP_CHECK_TIMER(sk);
</span><span class='line'>
</span><span class='line'>&#9;err = -ENOTCONN;
</span><span class='line'>&#9;if (sk-&gt;sk_state == TCP_LISTEN)
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>
</span><span class='line'>&#9;//获取延迟，如果用户设置为非阻塞，那么timeo ==0000 0000 0000 0000
</span><span class='line'>&#9;//如果用户使用默认recv系统调用
</span><span class='line'>&#9;//则为阻塞，此时timeo ==0111 1111 1111 1111
</span><span class='line'>&#9;//timeo 就2个值
</span><span class='line'>&#9;timeo = sock_rcvtimeo(sk, nonblock);
</span><span class='line'>
</span><span class='line'>&#9;/* Urgent data needs to be handled specially. */
</span><span class='line'>&#9;if (flags & MSG_OOB)
</span><span class='line'>&#9;&#9;goto recv_urg;
</span><span class='line'>
</span><span class='line'>&#9;//待拷贝的下一个序列号
</span><span class='line'>&#9;seq = &tp-&gt;copied_seq;
</span><span class='line'>
</span><span class='line'>&#9;//设置了MSG_PEEK，表示不让数据从缓冲区移除，目的是下一次调用recv函数
</span><span class='line'>&#9;//仍然能够读到相同数据
</span><span class='line'>&#9;if (flags & MSG_PEEK) {
</span><span class='line'>&#9;&#9;peek_seq = tp-&gt;copied_seq;
</span><span class='line'>&#9;&#9;seq = &peek_seq;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;//如果设置了MSG_WAITALL，则target  ==len，即recv函数中的参数len
</span><span class='line'>&#9;//如果没设置MSG_WAITALL，则target  == 1
</span><span class='line'>&#9;target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);
</span><span class='line'>
</span><span class='line'>&#9;//大循环
</span><span class='line'>&#9;do {
</span><span class='line'>&#9;&#9;u32 offset;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Are we at urgent data? Stop if we have read anything or have SIGURG pending. */
</span><span class='line'>&#9;&#9;if (tp-&gt;urg_data && tp-&gt;urg_seq == *seq) {
</span><span class='line'>&#9;&#9;&#9;if (copied)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;if (signal_pending(current)) {
</span><span class='line'>&#9;&#9;&#9;&#9;copied = timeo ? sock_intr_errno(timeo) : -EAGAIN;
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Next get a buffer. */
</span><span class='line'>
</span><span class='line'>&#9;&#9;//小循环
</span><span class='line'>&#9;&#9;skb_queue_walk(&sk-&gt;sk_receive_queue, skb) {
</span><span class='line'>&#9;&#9;&#9;/* Now that we have two receive queues this
</span><span class='line'>&#9;&#9;&#9;&#9;* shouldn't happen.
</span><span class='line'>&#9;&#9;&#9;&#9;*/
</span><span class='line'>&#9;&#9;&#9;if (WARN(before(*seq, TCP_SKB_CB(skb)-&gt;seq),
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;KERN_INFO "recvmsg bug: copied %X "
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      "seq %X rcvnxt %X fl %X\n", *seq,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      flags))
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;//如果用户的缓冲区(即用户malloc的buf)长度够大，offset一般是0。
</span><span class='line'>&#9;&#9;&#9;//即 “下次准备拷贝数据的序列号”==此时获取报文的起始序列号
</span><span class='line'>&#9;&#9;&#9;//什么情况下offset &gt;0呢？很简答，如果用户缓冲区12字节，而这个skb有120字节
</span><span class='line'>&#9;&#9;&#9;//那么一次recv系统调用，只能获取skb中的前12个字节，下一次执行recv系统调用
</span><span class='line'>&#9;&#9;&#9;//offset就是12了，offset表示从第12个字节开始读取数据，前12个字节已经读取了。
</span><span class='line'>&#9;&#9;&#9;//那这个"已经读取12字节"这个消息，存在哪呢？
</span><span class='line'>&#9;&#9;&#9;//在*seq = &tp-&gt;copied_seq;中
</span><span class='line'>&#9;&#9;&#9;offset = *seq - TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>&#9;&#9;&#9;if (tcp_hdr(skb)-&gt;syn)
</span><span class='line'>&#9;&#9;&#9;&#9;offset--;
</span><span class='line'>&#9;&#9;&#9;if (offset &lt; skb-&gt;len)
</span><span class='line'>&#9;&#9;&#9;&#9;goto found_ok_skb;
</span><span class='line'>&#9;&#9;&#9;if (tcp_hdr(skb)-&gt;fin)
</span><span class='line'>&#9;&#9;&#9;&#9;goto found_fin_ok;
</span><span class='line'>&#9;&#9;&#9;WARN(!(flags & MSG_PEEK), KERN_INFO "recvmsg bug 2: "
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;"copied %X seq %X rcvnxt %X fl %X\n",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;*seq, TCP_SKB_CB(skb)-&gt;seq,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;tp-&gt;rcv_nxt, flags);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;//执行到了这里，表明小循环中break了，既然break了，说明sk_receive_queue中
</span><span class='line'>&#9;&#9;//已经没有skb可以读取了
</span><span class='line'>&#9;&#9;//如果没有执行到这里说明前面的小循环中执行了goto，读到有用的skb，或者读到fin都会goto。
</span><span class='line'>&#9;&#9;//没有skb可以读取，说明什么？
</span><span class='line'>&#9;&#9;//可能性1：当用户第一次调用recv时，压根没有数据到来
</span><span class='line'>&#9;&#9;//可能性2：skb-&gt;len一共20字节，假设用户调用一次 recv，读取12字节，再调用recv，
</span><span class='line'>&#9;&#9;//读取12字节，此时skb由于上次已经被读取了12字节，只剩下8字节。
</span><span class='line'>&#9;&#9;//于是代码的逻辑上，再会要求获取skb，来读取剩下的8字节。
</span><span class='line'>
</span><span class='line'>&#9;&#9;//可能性1的情况下，copied == 0，肯定不会进这个if。后续将执行休眠
</span><span class='line'>&#9;&#9;//可能性2的情况下，情况比较复杂。可能性2表明数据没有读够用户想要的len长度
</span><span class='line'>&#9;&#9;//虽然进程上下文中，没有读够数据，但是可能我们在读数据的时候
</span><span class='line'>&#9;&#9;//软中断把数据放到backlog队列中了，而backlog对队列中的数据或许恰好让我们读够数
</span><span class='line'>&#9;&#9;//据。
</span><span class='line'>
</span><span class='line'>&#9;&#9;//copied了数据的，copied肯定&gt;=1，而target 是1或者len
</span><span class='line'>&#9;&#9;//copied只能取0(可能性1)，或者0~len(可能性2)
</span><span class='line'>&#9;&#9;//copied &gt;= target 表示我们取得我们想要的数据了，何必进行休眠，直接return
</span><span class='line'>&#9;&#9;//如果copied 没有达到我们想要的数据，则看看sk_backlog是否为空
</span><span class='line'>&#9;&#9;//空的话，尽力了，只能尝试休眠
</span><span class='line'>&#9;&#9;//非空的话，还有一线希望，我们去sk_backlog找找数据，看看是否能够达到我们想要的
</span><span class='line'>&#9;&#9;//数据大小
</span><span class='line'>
</span><span class='line'>&#9;&#9;//我觉得copied == target是会出现的，但是出现的话，也不会进现在这个流程
</span><span class='line'>&#9;&#9;//，如有不对，请各位大神指正，告诉我
</span><span class='line'>&#9;&#9;//说明情况下copied == target
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Well, if we have backlog, try to process it now yet. */
</span><span class='line'>&#9;&#9;if (copied &gt;= target && !sk-&gt;sk_backlog.tail)
</span><span class='line'>&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (copied) {
</span><span class='line'>&#9;&#9;&#9;//可能性2，拷贝了数据，但是没有拷贝到指定大小
</span><span class='line'>&#9;&#9;&#9;if (sk-&gt;sk_err ||
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;sk-&gt;sk_state == TCP_CLOSE ||
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;(sk-&gt;sk_shutdown & RCV_SHUTDOWN) ||
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;!timeo ||
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;signal_pending(current))
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;} else {
</span><span class='line'>&#9;&#9;&#9;//可能性1
</span><span class='line'>&#9;&#9;&#9;if (sock_flag(sk, SOCK_DONE))
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (sk-&gt;sk_err) {
</span><span class='line'>&#9;&#9;&#9;&#9;copied = sock_error(sk);
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (sk-&gt;sk_shutdown & RCV_SHUTDOWN)
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (sk-&gt;sk_state == TCP_CLOSE) {
</span><span class='line'>&#9;&#9;&#9;&#9;if (!sock_flag(sk, SOCK_DONE)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;/* This occurs when user tries to read
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;* from never connected socket.
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;*/
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;copied = -ENOTCONN;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;//是否是阻塞的，不是，就return了。
</span><span class='line'>&#9;&#9;&#9;if (!timeo) {
</span><span class='line'>&#9;&#9;&#9;&#9;copied = -EAGAIN;
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (signal_pending(current)) {
</span><span class='line'>&#9;&#9;&#9;&#9;copied = sock_intr_errno(timeo);
</span><span class='line'>&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;tcp_cleanup_rbuf(sk, copied);
</span><span class='line'>
</span><span class='line'>&#9;&#9;//sysctl_tcp_low_latency 默认0tp-&gt;ucopy.task == user_recv肯定也成立
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!sysctl_tcp_low_latency && tp-&gt;ucopy.task == user_recv) {
</span><span class='line'>&#9;&#9;&#9;/* Install new reader */
</span><span class='line'>&#9;&#9;&#9;if (!user_recv && !(flags & (MSG_TRUNC | MSG_PEEK))) {
</span><span class='line'>&#9;&#9;&#9;&#9;user_recv = current;
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;ucopy.task = user_recv;
</span><span class='line'>&#9;&#9;&#9;&#9;tp-&gt;ucopy.iov = msg-&gt;msg_iov;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;tp-&gt;ucopy.len = len;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;WARN_ON(tp-&gt;copied_seq != tp-&gt;rcv_nxt &&
</span><span class='line'>&#9;&#9;&#9;&#9;!(flags & (MSG_PEEK | MSG_TRUNC)));
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* Ugly... If prequeue is not empty, we have to
</span><span class='line'>&#9;&#9;&#9;&#9;* process it before releasing socket, otherwise
</span><span class='line'>&#9;&#9;&#9;&#9;* order will be broken at second iteration.
</span><span class='line'>&#9;&#9;&#9;&#9;* More elegant solution is required!!!
</span><span class='line'>&#9;&#9;&#9;&#9;*
</span><span class='line'>&#9;&#9;&#9;&#9;* Look: we have the following (pseudo)queues:
</span><span class='line'>&#9;&#9;&#9;&#9;*
</span><span class='line'>&#9;&#9;&#9;&#9;* 1. packets in flight
</span><span class='line'>&#9;&#9;&#9;&#9;* 2. backlog
</span><span class='line'>&#9;&#9;&#9;&#9;* 3. prequeue
</span><span class='line'>&#9;&#9;&#9;&#9;* 4. receive_queue
</span><span class='line'>&#9;&#9;&#9;&#9;*
</span><span class='line'>&#9;&#9;&#9;&#9;* Each queue can be processed only if the next ones
</span><span class='line'>&#9;&#9;&#9;&#9;* are empty. At this point we have empty receive_queue.
</span><span class='line'>&#9;&#9;&#9;&#9;* But prequeue _can_ be not empty after 2nd iteration,
</span><span class='line'>&#9;&#9;&#9;&#9;* when we jumped to start of loop because backlog
</span><span class='line'>&#9;&#9;&#9;&#9;* processing added something to receive_queue.
</span><span class='line'>&#9;&#9;&#9;&#9;* We cannot release_sock(), because backlog contains
</span><span class='line'>&#9;&#9;&#9;&#9;* packets arrived _after_ prequeued ones.
</span><span class='line'>&#9;&#9;&#9;&#9;*
</span><span class='line'>&#9;&#9;&#9;&#9;* Shortly, algorithm is clear --- to process all
</span><span class='line'>&#9;&#9;&#9;&#9;* the queues in order. We could make it more directly,
</span><span class='line'>&#9;&#9;&#9;&#9;* requeueing packets from backlog to prequeue, if
</span><span class='line'>&#9;&#9;&#9;&#9;* is not empty. It is more elegant, but eats cycles,
</span><span class='line'>&#9;&#9;&#9;&#9;* unfortunately.
</span><span class='line'>&#9;&#9;&#9;&#9;*/
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (!skb_queue_empty(&tp-&gt;ucopy.prequeue))
</span><span class='line'>&#9;&#9;&#9;&#9;goto do_prequeue;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* __ Set realtime policy in scheduler __ */
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (copied &gt;= target) {
</span><span class='line'>&#9;&#9;&#9;/* Do not sleep, just process backlog. */
</span><span class='line'>&#9;&#9;&#9;release_sock(sk);
</span><span class='line'>&#9;&#9;&#9;lock_sock(sk);
</span><span class='line'>&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;sk_wait_data(sk, &timeo); 
</span><span class='line'>&#9;&#9;//在此处睡眠了，将在tcp_prequeue函数中调用wake_up_interruptible_poll唤醒
</span><span class='line'>&#9;&#9;
</span><span class='line'>&#9;&#9;//软中断会判断用户是正在读取检查并且睡眠了，如果是的话，就直接把数据拷贝
</span><span class='line'>&#9;&#9;//到prequeue队列，然后唤醒睡眠的进程。因为进程睡眠，表示没有读到想要的字节数
</span><span class='line'>&#9;&#9;//此时，软中断有数据到来，直接给进程，这样进程就能以最快的速度被唤醒。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (user_recv) {
</span><span class='line'>&#9;&#9;&#9;int chunk;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/* __ Restore normal policy in scheduler __ */
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if ((chunk = len - tp-&gt;ucopy.len) != 0) {
</span><span class='line'>&#9;&#9;&#9;&#9;NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMBACKLOG, chunk);
</span><span class='line'>&#9;&#9;&#9;&#9;len -= chunk;
</span><span class='line'>&#9;&#9;&#9;&#9;copied += chunk;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (tp-&gt;rcv_nxt == tp-&gt;copied_seq &&
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;!skb_queue_empty(&tp-&gt;ucopy.prequeue)) {
</span><span class='line'>do_prequeue:
</span><span class='line'>&#9;&#9;&#9;&#9;tcp_prequeue_process(sk);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;if ((chunk = len - tp-&gt;ucopy.len) != 0) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE, chunk);
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;len -= chunk;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;copied += chunk;
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;if ((flags & MSG_PEEK) &&
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;(peek_seq - copied - urg_hole != tp-&gt;copied_seq)) {
</span><span class='line'>&#9;&#9;&#9;if (net_ratelimit())
</span><span class='line'>&#9;&#9;&#9;&#9;printk(KERN_DEBUG "TCP(%s:%d): Application bug, race in MSG_PEEK.\n",
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;      current-&gt;comm, task_pid_nr(current));
</span><span class='line'>&#9;&#9;&#9;peek_seq = tp-&gt;copied_seq;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;continue;
</span><span class='line'>
</span><span class='line'>&#9;found_ok_skb:
</span><span class='line'>&#9;&#9;/* Ok so how much can we use? */
</span><span class='line'>&#9;&#9;//skb中还有多少聚聚没有拷贝。
</span><span class='line'>&#9;&#9;//正如前面所说的，offset是上次已经拷贝了的，这次从offset开始接下去拷贝
</span><span class='line'>&#9;&#9;&#9;&#9;used = skb-&gt;len - offset;
</span><span class='line'>&#9;&#9;//很有可能used的大小，即skb剩余长度，依然大于用户的缓冲区大小(len)。所以依然
</span><span class='line'>&#9;&#9;//只能拷贝len长度。一般来说，用户还得执行一次recv系统调用。直到skb中的数据读完
</span><span class='line'>&#9;&#9;if (len &lt; used)
</span><span class='line'>&#9;&#9;&#9;used = len;
</span><span class='line'>
</span><span class='line'>&#9;&#9;/* Do we have urgent data here? */
</span><span class='line'>&#9;&#9;if (tp-&gt;urg_data) {
</span><span class='line'>&#9;&#9;&#9;u32 urg_offset = tp-&gt;urg_seq - *seq;
</span><span class='line'>&#9;&#9;&#9;if (urg_offset &lt; used) {
</span><span class='line'>&#9;&#9;&#9;&#9;if (!urg_offset) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;if (!sock_flag(sk, SOCK_URGINLINE)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;++*seq;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;urg_hole++;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;offset++;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;used--;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;if (!used)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;goto skip_copy;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;used = urg_offset;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;if (!(flags & MSG_TRUNC)) {
</span><span class='line'>&#9;&#9;&#9;{
</span><span class='line'>&#9;&#9;&#9;&#9;//一般都会进这个if，进行数据的拷贝，把能够读到的数据，放到用户的缓冲区
</span><span class='line'>&#9;&#9;&#9;&#9;err = skb_copy_datagram_iovec(skb, offset,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;msg-&gt;msg_iov, used);
</span><span class='line'>&#9;&#9;&#9;&#9;if (err) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;/* Exception. Bailout! */
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;if (!copied)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;copied = -EFAULT;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;//更新标志位，seq 是指针，指向了tp-&gt;copied_seq
</span><span class='line'>&#9;&#9;//used是我们有能力拷贝的数据大小，即已经拷贝到用户缓冲区的大小
</span><span class='line'>&#9;&#9;//正如前面所说，如果用户的缓冲区很小，一次recv拷贝不玩skb中的数据，
</span><span class='line'>&#9;&#9;//我们需要保存已经拷贝了的大小，下次recv时，从这个大小处继续拷贝。
</span><span class='line'>&#9;&#9;//所以需要更新copied_seq。
</span><span class='line'>&#9;&#9;*seq += used;
</span><span class='line'>&#9;&#9;copied += used;
</span><span class='line'>&#9;&#9;len -= used;
</span><span class='line'>
</span><span class='line'>&#9;&#9;tcp_rcv_space_adjust(sk);
</span><span class='line'>
</span><span class='line'>skip_copy:
</span><span class='line'>&#9;&#9;if (tp-&gt;urg_data && after(tp-&gt;copied_seq, tp-&gt;urg_seq)) {
</span><span class='line'>&#9;&#9;&#9;tp-&gt;urg_data = 0;
</span><span class='line'>&#9;&#9;&#9;tcp_fast_path_check(sk);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;//这个就是判断我们是否拷贝完了skb中的数据，如果没有continue
</span><span class='line'>&#9;&#9;//这种情况下，len经过 len -= used; ，已经变成0，所以continue的效果相当于
</span><span class='line'>&#9;&#9;//退出了这个大循环。可以理解，你只能拷贝len长度，拷贝完之后，那就return了。
</span><span class='line'>
</span><span class='line'>&#9;&#9;//还有一种情况used + offset ==  skb-&gt;len，表示skb拷贝完了。这时我们只需要释放skb
</span><span class='line'>&#9;&#9;//下面会讲到
</span><span class='line'>&#9;&#9;if (used + offset &lt; skb-&gt;len)
</span><span class='line'>&#9;&#9;&#9;continue;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//看看这个数据报文是否含有fin，含有fin，则goto到found_fin_ok
</span><span class='line'>&#9;&#9;if (tcp_hdr(skb)-&gt;fin)
</span><span class='line'>&#9;&#9;&#9;goto found_fin_ok;
</span><span class='line'>
</span><span class='line'>&#9;&#9;//执行到这里，标明used + offset ==  skb-&gt;len，报文也拷贝完了，那就把skb摘链释放
</span><span class='line'>&#9;&#9;if (!(flags & MSG_PEEK)) {
</span><span class='line'>&#9;&#9;&#9;sk_eat_skb(sk, skb, copied_early);
</span><span class='line'>&#9;&#9;&#9;copied_early = 0;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//这个cintinue不一定是退出大循环，可能还会执行循环。
</span><span class='line'>&#9;&#9;//假设用户设置缓冲区12字节，你skb-&gt;len长度20字节。
</span><span class='line'>&#9;&#9;//第一次recv读取了12字节，skb剩下8，下一次调用recv再想读取12，
</span><span class='line'>&#9;&#9;//但是只能读取到这8字节了。
</span><span class='line'>&#9;&#9;//此时len 变量长度为4，那么这个continue依旧在这个循环中，
</span><span class='line'>&#9;&#9;//函数还是再次从do开始，使用skb_queue_walk，找skb
</span><span class='line'>&#9;&#9;//如果sk_receive_queue中skb仍旧有，那么继续读，直到len == 0
</span><span class='line'>&#9;&#9;//如果没有skb了，我们怎么办？我们的len还有4字节怎么办？
</span><span class='line'>&#9;&#9;//这得看用户设置的recv函数阻塞与否，即和timeo变量相关了。
</span><span class='line'>&#9;&#9;continue;
</span><span class='line'>
</span><span class='line'>&#9;found_fin_ok:
</span><span class='line'>&#9;&#9;/* Process the FIN. */
</span><span class='line'>&#9;&#9;++*seq;
</span><span class='line'>&#9;&#9;if (!(flags & MSG_PEEK)) {
</span><span class='line'>&#9;&#9;&#9;//把skb从sk_receive_queue中摘链
</span><span class='line'>&#9;&#9;&#9;sk_eat_skb(sk, skb, copied_early);
</span><span class='line'>&#9;&#9;&#9;copied_early = 0;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;} while (len &gt; 0);
</span><span class='line'>
</span><span class='line'>&#9;//到这里是大循环退出
</span><span class='line'>&#9;//休眠过的进程，然后退出大循环 ，才满足 if (user_recv) 条件
</span><span class='line'>&#9;if (user_recv) {
</span><span class='line'>&#9;&#9;if (!skb_queue_empty(&tp-&gt;ucopy.prequeue)) {
</span><span class='line'>&#9;&#9;&#9;int chunk;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;tp-&gt;ucopy.len = copied &gt; 0 ? len : 0;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;tcp_prequeue_process(sk);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;if (copied &gt; 0 && (chunk = len - tp-&gt;ucopy.len) != 0) {
</span><span class='line'>&#9;&#9;&#9;&#9;NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE, chunk);
</span><span class='line'>&#9;&#9;&#9;&#9;len -= chunk;
</span><span class='line'>&#9;&#9;&#9;&#9;copied += chunk;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;}
</span><span class='line'>
</span><span class='line'>&#9;&#9;//数据读取完毕，清零
</span><span class='line'>&#9;&#9;tp-&gt;ucopy.task = NULL;
</span><span class='line'>&#9;&#9;tp-&gt;ucopy.len = 0;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/* According to UNIX98, msg_name/msg_namelen are ignored
</span><span class='line'>&#9;&#9;* on connected socket. I was just happy when found this 8) --ANK
</span><span class='line'>&#9;&#9;*/
</span><span class='line'>
</span><span class='line'>&#9;/* Clean up data we have read: This will do ACK frames. */
</span><span class='line'>&#9;//很重要，将更新缓存，并且适当的时候发送ack
</span><span class='line'>&#9;tcp_cleanup_rbuf(sk, copied);
</span><span class='line'>
</span><span class='line'>&#9;TCP_CHECK_TIMER(sk);
</span><span class='line'>&#9;release_sock(sk);
</span><span class='line'>&#9;return copied;
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>&#9;TCP_CHECK_TIMER(sk);
</span><span class='line'>&#9;release_sock(sk);
</span><span class='line'>&#9;return err;
</span><span class='line'>
</span><span class='line'>recv_urg:
</span><span class='line'>&#9;err = tcp_recv_urg(sk, msg, len, flags);
</span><span class='line'>&#9;goto out;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-04-10T15:29:00+08:00'><span class='date'>2015-04-10</span> <span class='time'>15:29:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~net/'>net</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/04/10/kernel-net-v4rcv/" title="Previous Post: Linux TCP数据包接收处理 tcp_v4_rcv">&laquo; Linux TCP数据包接收处理 tcp_v4_rcv</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/04/10/kernel-net-skbuff/" title="Next Post: sk_buff详解">sk_buff详解 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
