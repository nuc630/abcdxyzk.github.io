
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>linux kernel 网络协议栈之GRO(Generic receive offload) - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>cp -rf * .</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">linux kernel 网络协议栈之GRO(Generic receive offload)</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-18T15:48:00+08:00'><span class='date'>2015-04-18</span> <span class='time'>15:48:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><hr />

<h2>Attention: gro会合并多个gso_size不同的包, 会将gso_size设置成第一个包的gso_size.</h2>

<p><a href="http://www.pagefault.info/?p=159">http://www.pagefault.info/?p=159</a></p>

<p>GRO(Generic receive offload)在内核2.6.29之后合并进去的，作者是一个华裔Herbert Xu ,GRO的简介可以看这里：</p>

<p><a href="http://lwn.net/Articles/358910/">http://lwn.net/Articles/358910/</a></p>

<p>先来描述一下GRO的作用，GRO是针对网络接受包的处理的，并且只是针对NAPI类型的驱动，因此如果要支持GRO，不仅要内核支持，而且驱动也必须调用相应的借口，用ethtool -K gro on来设置，如果报错就说明网卡驱动本身就不支持GRO。</p>

<p>GRO类似tso，可是tso只支持发送数据包，这样你tcp层大的段会在网卡被切包，然后再传递给对端，而如果没有gro，则小的段会被一个个送到协议栈，有了gro之后，就会在接收端做一个反向的操作(想对于tso).也就是将tso切好的数据包组合成大包再传递给协议栈。</p>

<p>如果实现了GRO支持的驱动是这样子处理数据的，在NAPI的回调poll方法中读取数据包，然后调用GRO的接口napi_gro_receive或者napi_gro_frags来将数据包feed进协议栈。而具体GRO的工作就是在这两个函数中进行的，他们最终都会调用<code>__napi_gro_receive</code>。下面就是napi_gro_receive，它最终会调用napi_skb_finish以及<code>__napi_gro_receive</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gro_result_t napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;skb_gro_reset_offset(skb);
</span><span class='line'> 
</span><span class='line'>&#9;return napi_skb_finish(__napi_gro_receive(napi, skb), skb);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后GRO什么时候会将数据feed进协议栈呢，这里会有两个退出点，一个是在napi_skb_finish里，他会通过判断<code>__napi_gro_receive</code>的返回值，来决定是需要将数据包立即feed进协议栈还是保存起来，还有一个点是当napi的循环执行完毕时，也就是执行napi_complete的时候，先来看napi_skb_finish,napi_complete我们后面会详细介绍。</p>

<p>在NAPI驱动中，直接调用netif_receive_skb会将数据feed 进协议栈，因此这里如果返回值是NORMAL，则直接调用netif_receive_skb来将数据送进协议栈。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gro_result_t napi_skb_finish(gro_result_t ret, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;switch (ret) {
</span><span class='line'>&#9;case GRO_NORMAL:
</span><span class='line'>&#9;&#9;//将数据包送进协议栈
</span><span class='line'>&#9;&#9;if (netif_receive_skb(skb))
</span><span class='line'>&#9;&#9;&#9;ret = GRO_DROP;
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;//表示skb可以被free，因为gro已经将skb合并并保存起来。
</span><span class='line'>&#9;case GRO_DROP:
</span><span class='line'>&#9;case GRO_MERGED_FREE:
</span><span class='line'>&#9;&#9;//free skb
</span><span class='line'>&#9;&#9;kfree_skb(skb);
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;//这个表示当前数据已经被gro保存起来，但是并没有进行合并，因此skb还需要保存。
</span><span class='line'>&#9;case GRO_HELD:
</span><span class='line'>&#9;case GRO_MERGED:
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;}
</span><span class='line'> 
</span><span class='line'>&#9;return ret;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>GRO的主要思想就是，组合一些类似的数据包(基于一些数据域，后面会介绍到)为一个大的数据包(一个skb)，然后feed给协议栈，这里主要是利用Scatter-gather IO，也就是skb的struct skb_shared_info域(我前面的blog讲述ip分片的时候有详细介绍这个域)来合并数据包。</p>

<p>在每个NAPI的实例都会包括一个域叫gro_list,保存了我们积攒的数据包(将要被merge的).然后每次进来的skb都会在这个链表里面进行查找，看是否需要merge。而gro_count表示当前的gro_list中的skb的个数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct napi_struct {
</span><span class='line'>................................................
</span><span class='line'>&#9;//个数
</span><span class='line'>&#9;unsigned int        gro_count;
</span><span class='line'>......................................
</span><span class='line'>&#9;//积攒的数据包
</span><span class='line'>&#9;struct sk_buff      *gro_list;
</span><span class='line'>&#9;struct sk_buff      *skb;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>紧接着是gro最核心的一个数据结构napi_gro_cb,它是保存在skb的cb域中，它保存了gro要使用到的一些上下文，这里每个域kernel的注释都比较清楚。到后面我们会看到这些域的具体用途。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct napi_gro_cb {
</span><span class='line'>&#9;/* Virtual address of skb_shinfo(skb)-&gt;frags[0].page + offset. */
</span><span class='line'>&#9;void *frag0;
</span><span class='line'> 
</span><span class='line'>&#9;/* Length of frag0. */
</span><span class='line'>&#9;unsigned int frag0_len;
</span><span class='line'> 
</span><span class='line'>&#9;/* This indicates where we are processing relative to skb-&gt;data. */
</span><span class='line'>&#9;int data_offset;
</span><span class='line'> 
</span><span class='line'>&#9;/* This is non-zero if the packet may be of the same flow. */
</span><span class='line'>&#9;int same_flow;
</span><span class='line'> 
</span><span class='line'>&#9;/* This is non-zero if the packet cannot be merged with the new skb. */
</span><span class='line'>&#9;int flush;
</span><span class='line'> 
</span><span class='line'>&#9;/* Number of segments aggregated. */
</span><span class='line'>&#9;int count;
</span><span class='line'> 
</span><span class='line'>&#9;/* Free the skb? */
</span><span class='line'>&#9;int free;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>每一层协议都实现了自己的gro回调函数，gro_receive和gro_complete，gro系统会根据协议来调用对应回调函数，其中gro_receive是将输入skb尽量合并到我们gro_list中。而gro_complete则是当我们需要提交gro合并的数据包到协议栈时被调用的。</p>

<p>下面就是ip层和tcp层对应的回调方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const struct net_protocol tcp_protocol = {
</span><span class='line'>&#9;.handler =  tcp_v4_rcv,
</span><span class='line'>&#9;.err_handler =  tcp_v4_err,
</span><span class='line'>&#9;.gso_send_check = tcp_v4_gso_send_check,
</span><span class='line'>&#9;.gso_segment =  tcp_tso_segment,
</span><span class='line'>&#9;//gso回调
</span><span class='line'>&#9;.gro_receive =  tcp4_gro_receive,
</span><span class='line'>&#9;.gro_complete = tcp4_gro_complete,
</span><span class='line'>&#9;.no_policy =    1,
</span><span class='line'>&#9;.netns_ok = 1,
</span><span class='line'>};
</span><span class='line'> 
</span><span class='line'>static struct packet_type ip_packet_type __read_mostly = {
</span><span class='line'>&#9;.type = cpu_to_be16(ETH_P_IP),
</span><span class='line'>&#9;.func = ip_rcv,
</span><span class='line'>&#9;.gso_send_check = inet_gso_send_check,
</span><span class='line'>&#9;.gso_segment = inet_gso_segment,
</span><span class='line'>&#9;//gso回调
</span><span class='line'>&#9;.gro_receive = inet_gro_receive,
</span><span class='line'>&#9;.gro_complete = inet_gro_complete,
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>gro的入口函数是napi_gro_receive，它的实现很简单，就是将skb包含的gro上下文reset，然后调用<code>__napi_gro_receive</code>,最终通过napi_skb_finis来判断是否需要讲数据包feed进协议栈。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gro_result_t napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;//reset gro对应的域
</span><span class='line'>&#9;skb_gro_reset_offset(skb);
</span><span class='line'> 
</span><span class='line'>&#9;return napi_skb_finish(__napi_gro_receive(napi, skb), skb);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>napi_skb_finish一开始已经介绍过了，这个函数主要是通过判断传递进来的ret(<code>__napi_gro_receive</code>的返回值),来决定是否需要feed数据进协议栈。它的第二个参数是前面处理过的skb。</p>

<p>这里再来看下skb_gro_reset_offset，首先要知道一种情况，那就是skb本身不包含数据(包括头也没有),而所有的数据都保存在skb_shared_info中(支持S/G的网卡有可能会这么做).此时我们如果想要合并的话，就需要将包头这些信息取出来，也就是从skb_shared_info的frags[0]中去的，在 skb_gro_reset_offset中就有做这个事情,而这里就会把头的信息保存到napi_gro_cb 的frags0中。并且此时frags必然不会在high mem,要么是线性区，要么是dma(S/G io)。 来看skb_gro_reset_offset。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void skb_gro_reset_offset(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;NAPI_GRO_CB(skb)-&gt;data_offset = 0;
</span><span class='line'>&#9;NAPI_GRO_CB(skb)-&gt;frag0 = NULL;
</span><span class='line'>&#9;NAPI_GRO_CB(skb)-&gt;frag0_len = 0;
</span><span class='line'>&#9;//如果mac_header和skb-&gt;tail相等并且地址不在高端内存，则说明包头保存在skb_shinfo中，所以我们需要从frags中取得对应的数据包
</span><span class='line'>&#9;if (skb-&gt;mac_header == skb-&gt;tail &&
</span><span class='line'>&#9;&#9;!PageHighMem(skb_shinfo(skb)-&gt;frags[0].page)) {
</span><span class='line'>&#9;&#9;// 可以看到frag0保存的就是对应的skb的frags的第一个元素的地址
</span><span class='line'>&#9;&#9;// frag0的作用是: 有些包的包头会存在skb-&gt;frag[0]里面，gro合并时会调用skb_gro_header_slow将包头拉到线性空间中，那么在非线性skb-&gt;frag[0]中的包头部分就应该删掉。
</span><span class='line'>&#9;&#9;&#9;NAPI_GRO_CB(skb)-&gt;frag0 =
</span><span class='line'>&#9;&#9;&#9;&#9;page_address(skb_shinfo(skb)-&gt;frags[0].page) +
</span><span class='line'>&#9;&#9;&#9;&#9;skb_shinfo(skb)-&gt;frags[0].page_offset;
</span><span class='line'>&#9;&#9;//然后保存对应的大小。
</span><span class='line'>&#9;&#9;NAPI_GRO_CB(skb)-&gt;frag0_len = skb_shinfo(skb)-&gt;frags[0].size;
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来就是<code>__napi_gro_receive</code>，它主要是遍历gro_list,然后给same_flow赋值，这里要注意，same_flow是一个标记，表示某个skb是否有可能会和当前要处理的skb是相同的流,而这里的相同会在每层都进行判断，也就是在设备层，ip层，tcp层都会判断，这里就是设备层的判断了。这里的判断很简单，有2个条件：<br/>
1 设备是否相同<br/>
2 mac的头必须相等</p>

<p>如果上面两个条件都满足，则说明两个skb有可能是相同的flow，所以设置same_flow,以便与我们后面合并。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static gro_result_t
</span><span class='line'>__napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff *p;
</span><span class='line'> 
</span><span class='line'>&#9;if (netpoll_rx_on(skb))
</span><span class='line'>&#9;&#9;return GRO_NORMAL;
</span><span class='line'>&#9;//遍历gro_list,然后判断是否有可能两个skb 相似。
</span><span class='line'>&#9;for (p = napi-&gt;gro_list; p; p = p-&gt;next) {
</span><span class='line'>&#9;&#9;//给same_flow赋值
</span><span class='line'>&#9;&#9;NAPI_GRO_CB(p)-&gt;same_flow =
</span><span class='line'>&#9;&#9;&#9;(p-&gt;dev == skb-&gt;dev) &&
</span><span class='line'>&#9;&#9;&#9;!compare_ether_header(skb_mac_header(p),
</span><span class='line'>&#9;&#9;&#9;&#9;skb_gro_mac_header(skb));
</span><span class='line'>&#9;&#9;NAPI_GRO_CB(p)-&gt;flush = 0;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//调用dev_gro_receiv
</span><span class='line'>&#9;return dev_gro_receive(napi, skb);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来来看dev_gro_receive，这个函数我们分做两部分来看，第一部分是正常处理部分，第二部份是处理frag0的部分。</p>

<p>来看如何判断是否支持GRO，这里每个设备的features会在驱动初始化的时候被初始化，然后如果支持GRO，则会包括NETIF_F_GRO。 还有要注意的就是，gro不支持切片的ip包，因为ip切片的组包在内核的ip会做一遍，因此这里gro如果合并的话，没有多大意义，而且还增加复杂度。</p>

<p>在dev_gro_receive中会遍历对应的ptype(也就是协议的类链表，以前的blog有详细介绍),然后调用对应的回调函数，一般来说这里会调用文章开始说的ip_packet_type，也就是 inet_gro_receive。</p>

<p>而 inet_gro_receive的返回值表示我们需要立刻feed 进协议栈的数据包，如果为空，则说明不需要feed数据包进协议栈。后面会分析到这里他的详细算法。</p>

<p>而如果当inet_gro_receive正确返回后，如果same_flow没有被设置，则说明gro list中不存在能和当前的skb合并的项，因此此时需要将skb插入到gro list中。这个时候的返回值就是HELD。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>&#9;struct sk_buff **pp = NULL;
</span><span class='line'>&#9;struct packet_type *ptype;
</span><span class='line'>&#9;__be16 type = skb-&gt;protocol;
</span><span class='line'>&#9;struct list_head *head = &ptype_base[ntohs(type) & PTYPE_HASH_MASK];
</span><span class='line'>&#9;int same_flow;
</span><span class='line'>&#9;int mac_len;
</span><span class='line'>&#9;enum gro_result ret;
</span><span class='line'>&#9;//判断是否支持gro
</span><span class='line'>&#9;if (!(skb-&gt;dev-&gt;features & NETIF_F_GRO))
</span><span class='line'>&#9;&#9;goto normal;
</span><span class='line'>&#9;//判断是否为切片的ip包
</span><span class='line'>&#9;if (skb_is_gso(skb) || skb_has_frags(skb))
</span><span class='line'>&#9;&#9;goto normal;
</span><span class='line'>
</span><span class='line'>&#9;rcu_read_lock();
</span><span class='line'>&#9;//开始遍历对应的协议表
</span><span class='line'>&#9;list_for_each_entry_rcu(ptype, head, list) {
</span><span class='line'>&#9;&#9;if (ptype-&gt;type != type || ptype-&gt;dev || !ptype-&gt;gro_receive)
</span><span class='line'>&#9;&#9;&#9;continue;
</span><span class='line'>
</span><span class='line'>&#9;&#9;skb_set_network_header(skb, skb_gro_offset(skb));
</span><span class='line'>&#9;&#9;mac_len = skb-&gt;network_header - skb-&gt;mac_header;
</span><span class='line'>&#9;&#9;skb-&gt;mac_len = mac_len;
</span><span class='line'>&#9;&#9;NAPI_GRO_CB(skb)-&gt;same_flow = 0;
</span><span class='line'>&#9;&#9;NAPI_GRO_CB(skb)-&gt;flush = 0;
</span><span class='line'>&#9;&#9;NAPI_GRO_CB(skb)-&gt;free = 0;
</span><span class='line'>&#9;&#9;//调用对应的gro接收函数
</span><span class='line'>&#9;&#9;pp = ptype-&gt;gro_receive(&napi-&gt;gro_list, skb);
</span><span class='line'>&#9;&#9;break;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'>&#9;//如果是没有实现gro的协议则也直接调到normal处理
</span><span class='line'>&#9;if (&ptype-&gt;list == head)
</span><span class='line'>&#9;&#9;goto normal;
</span><span class='line'> 
</span><span class='line'>&#9;//到达这里，则说明gro_receive已经调用过了，因此进行后续的处理
</span><span class='line'> 
</span><span class='line'>&#9;//得到same_flow
</span><span class='line'>&#9;same_flow = NAPI_GRO_CB(skb)-&gt;same_flow;
</span><span class='line'>&#9;//看是否有需要free对应的skb
</span><span class='line'>&#9;ret = NAPI_GRO_CB(skb)-&gt;free ? GRO_MERGED_FREE : GRO_MERGED;
</span><span class='line'>&#9;//如果返回值pp部位空，则说明pp需要马上被feed进协议栈
</span><span class='line'>&#9;if (pp) {
</span><span class='line'>&#9;&#9;struct sk_buff *nskb = *pp;
</span><span class='line'> 
</span><span class='line'>&#9;&#9;*pp = nskb-&gt;next;
</span><span class='line'>&#9;&#9;nskb-&gt;next = NULL;
</span><span class='line'>&#9;&#9;//调用napi_gro_complete 将pp刷进协议栈
</span><span class='line'>&#9;&#9;napi_gro_complete(nskb);
</span><span class='line'>&#9;&#9;napi-&gt;gro_count--;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;//如果same_flow有设置，则说明skb已经被正确的合并，因此直接返回。
</span><span class='line'>&#9;if (same_flow)
</span><span class='line'>&#9;&#9;goto ok;
</span><span class='line'>&#9;//查看是否有设置flush和gro list的个数是否已经超过限制
</span><span class='line'>&#9;// BUG: 这里是有点不对的，因为这时的skb是比gro_list中的skb更晚到的，但是却被先feed进了协议栈
</span><span class='line'>&#9;if (NAPI_GRO_CB(skb)-&gt;flush || napi-&gt;gro_count &gt;= MAX_GRO_SKBS)
</span><span class='line'>&#9;&#9;goto normal;
</span><span class='line'> 
</span><span class='line'>&#9;//到达这里说明skb对应gro list来说是一个新的skb，也就是说当前的gro list并不存在可以和skb合并的数据包，因此此时将这个skb插入到gro_list的头。
</span><span class='line'>&#9;napi-&gt;gro_count++;
</span><span class='line'>&#9;NAPI_GRO_CB(skb)-&gt;count = 1;
</span><span class='line'>&#9;skb_shinfo(skb)-&gt;gso_size = skb_gro_len(skb);
</span><span class='line'>&#9;//将skb插入到gro list的头
</span><span class='line'>&#9;skb-&gt;next = napi-&gt;gro_list;
</span><span class='line'>&#9;napi-&gt;gro_list = skb;
</span><span class='line'>&#9;//设置返回值
</span><span class='line'>&#9;ret = GRO_HELD;</span></code></pre></td></tr></table></div></figure>


<p>然后就是处理frag0的部分，以及不支持gro的处理。
frag0的作用是: 有些包的包头会存在skb->frag[0]里面，gro合并时会调用skb_gro_header_slow将包头拉到线性空间中，那么在非线性skb->frag[0]中的包头部分就应该删掉。</p>

<p>这里要需要对skb_shinfo的结构比较了解，我在以前的blog对这个有很详细的介绍，可以去查阅。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pull:
</span><span class='line'>&#9;//是否需要拷贝头
</span><span class='line'>&#9;if (skb_headlen(skb) &lt; skb_gro_offset(skb)) {
</span><span class='line'>&#9;&#9;//得到对应的头的大小
</span><span class='line'>&#9;&#9;int grow = skb_gro_offset(skb) - skb_headlen(skb);
</span><span class='line'> 
</span><span class='line'>&#9;&#9;BUG_ON(skb-&gt;end - skb-&gt;tail &lt; grow);
</span><span class='line'>&#9;&#9;//开始拷贝
</span><span class='line'>&#9;&#9;memcpy(skb_tail_pointer(skb), NAPI_GRO_CB(skb)-&gt;frag0, grow);
</span><span class='line'> 
</span><span class='line'>&#9;&#9;skb-&gt;tail += grow;
</span><span class='line'>&#9;&#9;skb-&gt;data_len -= grow;
</span><span class='line'>&#9;&#9;//更新对应的frags[0]
</span><span class='line'>&#9;&#9;skb_shinfo(skb)-&gt;frags[0].page_offset += grow;
</span><span class='line'>&#9;&#9;skb_shinfo(skb)-&gt;frags[0].size -= grow;
</span><span class='line'>&#9;&#9;//如果size为0了，则说明第一个页全部包含头，因此需要将后面的页全部移动到前面。
</span><span class='line'>&#9;&#9;if (unlikely(!skb_shinfo(skb)-&gt;frags[0].size)) {
</span><span class='line'>&#9;&#9;&#9;put_page(skb_shinfo(skb)-&gt;frags[0].page);
</span><span class='line'>&#9;&#9;&#9;//开始移动。
</span><span class='line'>&#9;&#9;&#9;memmove(skb_shinfo(skb)-&gt;frags,
</span><span class='line'>&#9;&#9;&#9;&#9;skb_shinfo(skb)-&gt;frags + 1,
</span><span class='line'>&#9;&#9;&#9;&#9;--skb_shinfo(skb)-&gt;nr_frags * sizeof(skb_frag_t));
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'> 
</span><span class='line'>ok:
</span><span class='line'>&#9;return ret;
</span><span class='line'> 
</span><span class='line'>normal:
</span><span class='line'>&#9;ret = GRO_NORMAL;
</span><span class='line'>&#9;goto pull;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来就是inet_gro_receive，这个函数是ip层的gro receive回调函数，函数很简单，首先取得ip头，然后判断是否需要从frag复制数据，如果需要则复制数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//得到偏移
</span><span class='line'>off = skb_gro_offset(skb);
</span><span class='line'>//得到头的整个长度(mac+ip)
</span><span class='line'>hlen = off + sizeof(*iph);
</span><span class='line'>//得到ip头
</span><span class='line'>iph = skb_gro_header_fast(skb, off);
</span><span class='line'>//是否需要复制
</span><span class='line'>if (skb_gro_header_hard(skb, hlen)) {
</span><span class='line'>&#9;iph = skb_gro_header_slow(skb, hlen, off);
</span><span class='line'>&#9;if (unlikely(!iph))
</span><span class='line'>&#9;&#9;goto out;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后就是一些校验工作，比如协议是否支持gro_reveive,ip头是否合法等等</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>proto = iph-&gt;protocol & (MAX_INET_PROTOS - 1);
</span><span class='line'> 
</span><span class='line'>rcu_read_lock();
</span><span class='line'>ops = rcu_dereference(inet_protos[proto]);
</span><span class='line'>//是否支持gro
</span><span class='line'>if (!ops || !ops-&gt;gro_receive)
</span><span class='line'>&#9;goto out_unlock;
</span><span class='line'>//ip头是否合法, iph-&gt;version = 4, iph-&gt;ipl = 5
</span><span class='line'>if (*(u8 *)iph != 0x45)
</span><span class='line'>&#9;goto out_unlock;
</span><span class='line'>//ip头教研
</span><span class='line'>if (unlikely(ip_fast_csum((u8 *)iph, iph-&gt;ihl)))
</span><span class='line'>&#9;goto out_unlock;</span></code></pre></td></tr></table></div></figure>


<p>然后就是核心的处理部分，它会遍历整个gro_list,然后进行same_flow和是否需要flush的判断。</p>

<p>这里ip层设置same_flow是根据下面的规则的:<br/>
1 4层的协议必须相同<br/>
2 tos域必须相同<br/>
3 源，目的地址必须相同</p>

<p>如果3个条件一个不满足，则会设置same_flow为0。
这里还有一个就是判断是否需要flush 对应的skb到协议栈，这里的判断条件是这样子的。<br/>
1 ip包的ttl不一样<br/>
2 ip包的id顺序不对<br/>
3 如果是切片包</p>

<p>如果上面两个条件某一个满足，则说明skb需要被flush出gro。</p>

<p>不过这里要注意只有两个数据包是same flow的情况下，才会进行flush判断。原因很简单，都不是有可能进行merge的包，自然没必要进行flush了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;//取出id
</span><span class='line'>&#9;id = ntohl(*(__be32 *)&iph-&gt;id);
</span><span class='line'>&#9;//判断是否需要切片
</span><span class='line'>&#9;flush = (u16)((ntohl(*(__be32 *)iph) ^ skb_gro_len(skb)) | (id ^ IP_DF));
</span><span class='line'>&#9;id &gt;&gt;= 16;
</span><span class='line'>&#9;//开始遍历gro list
</span><span class='line'>&#9;for (p = *head; p; p = p-&gt;next) {
</span><span class='line'>&#9;&#9;struct iphdr *iph2;
</span><span class='line'>&#9;&#9;//如果上一层已经不可能same flow则直接继续下一个
</span><span class='line'>&#9;&#9;if (!NAPI_GRO_CB(p)-&gt;same_flow)
</span><span class='line'>&#9;&#9;&#9;continue;
</span><span class='line'>&#9;&#9;//取出ip头
</span><span class='line'>&#9;&#9;iph2 = ip_hdr(p);
</span><span class='line'>&#9;&#9;//开始same flow的判断
</span><span class='line'>&#9;&#9;if ((iph-&gt;protocol ^ iph2-&gt;protocol) |
</span><span class='line'>&#9;&#9;&#9;(iph-&gt;tos ^ iph2-&gt;tos) |
</span><span class='line'>&#9;&#9;&#9;((__force u32)iph-&gt;saddr ^ (__force u32)iph2-&gt;saddr) |
</span><span class='line'>&#9;&#9;&#9;((__force u32)iph-&gt;daddr ^ (__force u32)iph2-&gt;daddr)) {
</span><span class='line'>&#9;&#9;&#9;NAPI_GRO_CB(p)-&gt;same_flow = 0;
</span><span class='line'>&#9;&#9;&#9;continue;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;//开始flush的判断。这里注意如果不是same_flow的话，就没必要进行flush的判断。
</span><span class='line'>&#9;&#9;/* All fields must match except length and checksum. */
</span><span class='line'>&#9;&#9;NAPI_GRO_CB(p)-&gt;flush |=
</span><span class='line'>&#9;&#9;&#9;(iph-&gt;ttl ^ iph2-&gt;ttl) |
</span><span class='line'>&#9;&#9;&#9;((u16)(ntohs(iph2-&gt;id) + NAPI_GRO_CB(p)-&gt;count) ^ id);
</span><span class='line'> 
</span><span class='line'>&#9;&#9;NAPI_GRO_CB(p)-&gt;flush |= flush;
</span><span class='line'>&#9;}
</span><span class='line'> 
</span><span class='line'>&#9;NAPI_GRO_CB(skb)-&gt;flush |= flush;
</span><span class='line'>&#9;//pull ip头进gro，这里更新data_offset
</span><span class='line'>&#9;skb_gro_pull(skb, sizeof(*iph));
</span><span class='line'>&#9;//设置传输层的头的位置
</span><span class='line'>&#9;skb_set_transport_header(skb, skb_gro_offset(skb));
</span><span class='line'>&#9;//调用传输层的reveive方法。
</span><span class='line'>&#9;pp = ops-&gt;gro_receive(head, skb);
</span><span class='line'> 
</span><span class='line'>out_unlock:
</span><span class='line'>&#9;rcu_read_unlock();
</span><span class='line'> 
</span><span class='line'>out:
</span><span class='line'>&#9;NAPI_GRO_CB(skb)-&gt;flush |= flush;
</span><span class='line'> 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后就是tcp层的gro方法，它的主要实现函数是tcp_gro_receive，他的流程和inet_gro_receiv类似，就是取得tcp的头，然后对gro list进行遍历，最终会调用合并方法。</p>

<p>首先来看gro list遍历的部分,它对same flow的要求就是source必须相同，如果不同则设置same flow为0.如果相同则跳到found部分，进行合并处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//遍历gro list
</span><span class='line'>for (; (p = *head); head = &p-&gt;next) {
</span><span class='line'>&#9;//如果ip层已经不可能same flow则直接进行下一次匹配
</span><span class='line'>&#9;if (!NAPI_GRO_CB(p)-&gt;same_flow)
</span><span class='line'>&#9;&#9;continue;
</span><span class='line'> 
</span><span class='line'>&#9;th2 = tcp_hdr(p);
</span><span class='line'>&#9;//判断源地址
</span><span class='line'>&#9;if (*(u32 *)&th-&gt;source ^ *(u32 *)&th2-&gt;source) {
</span><span class='line'>&#9;&#9;NAPI_GRO_CB(p)-&gt;same_flow = 0;
</span><span class='line'>&#9;&#9;continue;
</span><span class='line'>&#9;}
</span><span class='line'> 
</span><span class='line'>&#9;goto found;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来就是当找到能够合并的skb的时候的处理，这里首先来看flush的设置,这里会有4个条件：<br/>
1 拥塞状态被设置(TCP_FLAG_CWR).<br/>
2 tcp的ack的序列号不匹配 (这是肯定的，因为它只是对tso或者说gso进行反向操作)<br/>
3 skb的flag和从gro list中查找到要合并skb的flag 如果他们中的不同位 不包括TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH，这三个任意一个域。<br/>
4 tcp的option域不同</p>

<p>如果上面4个条件有一个满足，则会设置flush为1，也就是找到的这个skb(gro list中)必须被刷出到协议栈。</p>

<p>这里谈一下flags域的设置问题首先如果当前的skb设置了cwr，也就是发生了拥塞，那么自然前面被缓存的数据包需要马上被刷到协议栈，以便与tcp的拥塞控制马上进行。</p>

<p>而FIN和PSH这两个flag自然不需要一致，因为这两个和其他的不是互斥的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>found:
</span><span class='line'>&#9;flush = NAPI_GRO_CB(p)-&gt;flush;
</span><span class='line'>&#9;//如果设置拥塞，则肯定需要刷出skb到协议栈
</span><span class='line'>&#9;flush |= (__force int)(flags & TCP_FLAG_CWR);
</span><span class='line'>&#9;//如果相差的域是除了这3个中的，就需要flush出skb
</span><span class='line'>&#9;flush |= (__force int)((flags ^ tcp_flag_word(th2)) &
</span><span class='line'>&#9;&#9;  ~(TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH));
</span><span class='line'>&#9;//ack的序列号必须一致
</span><span class='line'>&#9;flush |= (__force int)(th-&gt;ack_seq ^ th2-&gt;ack_seq);
</span><span class='line'>&#9;//tcp的option头必须一致
</span><span class='line'>&#9;for (i = sizeof(*th); i &lt; thlen; i += 4)
</span><span class='line'>&#9;&#9;flush |= *(u32 *)((u8 *)th + i) ^
</span><span class='line'>&#9;&#9;&#9; *(u32 *)((u8 *)th2 + i);
</span><span class='line'> 
</span><span class='line'>&#9;mss = skb_shinfo(p)-&gt;gso_size;
</span><span class='line'>&#9;// 0-1 = 0xFFFFFFFF, 所以skb的数据部分长度为0的包是不会被合并的
</span><span class='line'>&#9;flush |= (len - 1) &gt;= mss;
</span><span class='line'>&#9;flush |= (ntohl(th2-&gt;seq) + skb_gro_len(p)) ^ ntohl(th-&gt;seq);
</span><span class='line'>&#9;//如果flush有设置则不会调用 skb_gro_receive，也就是不需要进行合并，否则调用skb_gro_receive进行数据包合并
</span><span class='line'>&#9;if (flush || skb_gro_receive(head, skb)) {
</span><span class='line'>&#9;&#9;mss = 1;
</span><span class='line'>&#9;&#9;goto out_check_final;
</span><span class='line'>&#9;}
</span><span class='line'> 
</span><span class='line'>&#9;p = *head;
</span><span class='line'>&#9;th2 = tcp_hdr(p);
</span><span class='line'>&#9;//更新p的头。到达这里说明合并完毕，因此需要更新合并完的新包的头。
</span><span class='line'>&#9;tcp_flag_word(th2) |= flags & (TCP_FLAG_FIN | TCP_FLAG_PSH);</span></code></pre></td></tr></table></div></figure>


<p>从上面我们可以看到如果tcp的包被设置了一些特殊的flag比如PSH，SYN这类的就必须马上把数据包刷出到协议栈。</p>

<p>下面就是最终的一些flags判断,比如第一个数据包进来都会到这里来判断。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>out_check_final:
</span><span class='line'>&#9;flush = len &lt; mss;
</span><span class='line'>&#9;//根据flag得到flush
</span><span class='line'>&#9;flush |= (__force int)(flags & (TCP_FLAG_URG | TCP_FLAG_PSH |
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;TCP_FLAG_RST | TCP_FLAG_SYN |
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;TCP_FLAG_FIN));
</span><span class='line'> 
</span><span class='line'>&#9;if (p && (!NAPI_GRO_CB(skb)-&gt;same_flow || flush))
</span><span class='line'>&#9;&#9;pp = head;
</span><span class='line'> 
</span><span class='line'>out:
</span><span class='line'>&#9;NAPI_GRO_CB(skb)-&gt;flush |= flush;</span></code></pre></td></tr></table></div></figure>


<p>这里要知道每次我们只会刷出gro list中的一个skb节点，这是因为每次进来的数据包我们也只会匹配一个。因此如果遇到需要刷出的数据包，会在dev_gro_receive中先刷出gro list中的，然后再将当前的skb feed进协议栈。</p>

<p>最后就是gro最核心的一个函数skb_gro_receive，它的主要工作就是合并，它有2个参数，第一个是gro list中和当前处理的skb是same flow的skb，第二个就是我们需要合并的skb。</p>

<p>这里要注意就是farg_list,其实gro对待skb_shared_info和ip层切片，组包很类似，就是frags放Scatter-Gather I/O的数据包，frag_list放线性数据。这里gro 也是这样的，如果过来的skb支持Scatter-Gather I/O并且数据是只放在frags中，则会合并frags，如果过来的skb不支持Scatter-Gather I/O(数据头还是保存在skb中)，则合并很简单，就是新建一个skb然后拷贝当前的skb，并将gro list中的skb直接挂载到farg_list。</p>

<p>先来看支持Scatter-Gather I/O的处理部分。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//一些需要用到的变量
</span><span class='line'>struct sk_buff *p = *head;
</span><span class='line'>struct sk_buff *nskb;
</span><span class='line'>//当前的skb的 share_ino
</span><span class='line'>struct skb_shared_info *skbinfo = skb_shinfo(skb);
</span><span class='line'>//当前的gro list中的要合并的skb的share_info
</span><span class='line'>struct skb_shared_info *pinfo = skb_shinfo(p);
</span><span class='line'>unsigned int headroom;
</span><span class='line'>unsigned int len = skb_gro_len(skb);
</span><span class='line'>unsigned int offset = skb_gro_offset(skb);
</span><span class='line'>unsigned int headlen = skb_headlen(skb);
</span><span class='line'>//如果有frag_list的话，则直接去非Scatter-Gather I/O部分处理，也就是合并到frag_list.
</span><span class='line'>if (pinfo-&gt;frag_list)
</span><span class='line'>&#9;goto merge;
</span><span class='line'>else if (headlen &lt;= offset) {
</span><span class='line'>&#9;//支持Scatter-Gather I/O的处理
</span><span class='line'>&#9;skb_frag_t *frag;
</span><span class='line'>&#9;skb_frag_t *frag2;
</span><span class='line'>&#9;int i = skbinfo-&gt;nr_frags;
</span><span class='line'>&#9;//这里遍历是从后向前。
</span><span class='line'>&#9;int nr_frags = pinfo-&gt;nr_frags + i;
</span><span class='line'> 
</span><span class='line'>&#9;offset -= headlen;
</span><span class='line'> 
</span><span class='line'>&#9;if (nr_frags &gt; MAX_SKB_FRAGS)
</span><span class='line'>&#9;&#9;return -E2BIG;
</span><span class='line'>&#9;//设置pinfo的frags的大小，可以看到就是加上skb的frags的大小
</span><span class='line'>&#9;pinfo-&gt;nr_frags = nr_frags;
</span><span class='line'>&#9;skbinfo-&gt;nr_frags = 0;
</span><span class='line'> 
</span><span class='line'>&#9;frag = pinfo-&gt;frags + nr_frags;
</span><span class='line'>&#9;frag2 = skbinfo-&gt;frags + i;
</span><span class='line'>&#9;//遍历赋值，其实就是地址赋值，这里就是将skb的frag加到pinfo的frgas后面。
</span><span class='line'>&#9;do {
</span><span class='line'>&#9;&#9;*--frag = *--frag2;
</span><span class='line'>&#9;} while (--i);
</span><span class='line'>&#9;//更改page_offet的值
</span><span class='line'>&#9;frag-&gt;page_offset += offset;
</span><span class='line'>&#9;//修改size大小
</span><span class='line'>&#9;frag-&gt;size -= offset;
</span><span class='line'>&#9;//更新skb的相关值
</span><span class='line'>&#9;skb-&gt;truesize -= skb-&gt;data_len;
</span><span class='line'>&#9;skb-&gt;len -= skb-&gt;data_len;
</span><span class='line'>&#9;skb-&gt;data_len = 0;
</span><span class='line'> 
</span><span class='line'>&#9;NAPI_GRO_CB(skb)-&gt;free = 1;
</span><span class='line'>&#9;//最终完成
</span><span class='line'>&#9;goto done;
</span><span class='line'>} else if (skb_gro_len(p) != pinfo-&gt;gso_size)
</span><span class='line'>&#9;return -E2BIG;</span></code></pre></td></tr></table></div></figure>


<p>这里gro list中的要被合并的skb我们叫做skb_s.</p>

<p>接下来就是不支持支持Scatter-Gather I/O(skb的头放在skb中)的处理。这里处理也比较简单，就是复制一个新的nskb，然后它的头和skb_s一样，然后将skb_s挂载到nskb的frag_list上，并且把新建的nskb挂在到gro list中，代替skb_s的位置，而当前的skb</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&#9;headroom = skb_headroom(p);
</span><span class='line'>&#9;nskb = alloc_skb(headroom + skb_gro_offset(p), GFP_ATOMIC);
</span><span class='line'>&#9;if (unlikely(!nskb))
</span><span class='line'>&#9;&#9;return -ENOMEM;
</span><span class='line'>&#9;//复制头
</span><span class='line'>&#9;__copy_skb_header(nskb, p);
</span><span class='line'>&#9;nskb-&gt;mac_len = p-&gt;mac_len;
</span><span class='line'> 
</span><span class='line'>&#9;skb_reserve(nskb, headroom);
</span><span class='line'>&#9;__skb_put(nskb, skb_gro_offset(p));
</span><span class='line'>&#9;//设置各层的头
</span><span class='line'>&#9;skb_set_mac_header(nskb, skb_mac_header(p) - p-&gt;data);
</span><span class='line'>&#9;skb_set_network_header(nskb, skb_network_offset(p));
</span><span class='line'>&#9;skb_set_transport_header(nskb, skb_transport_offset(p));
</span><span class='line'> 
</span><span class='line'>&#9;__skb_pull(p, skb_gro_offset(p));
</span><span class='line'>&#9;//复制数据
</span><span class='line'>&#9;memcpy(skb_mac_header(nskb), skb_mac_header(p),
</span><span class='line'>&#9;&#9;   p-&gt;data - skb_mac_header(p));
</span><span class='line'>&#9;//对应的gro 域的赋值
</span><span class='line'>&#9;*NAPI_GRO_CB(nskb) = *NAPI_GRO_CB(p);
</span><span class='line'>&#9;//可以看到frag_list被赋值
</span><span class='line'>&#9;skb_shinfo(nskb)-&gt;frag_list = p;
</span><span class='line'>&#9;skb_shinfo(nskb)-&gt;gso_size = pinfo-&gt;gso_size;
</span><span class='line'>&#9;pinfo-&gt;gso_size = 0;
</span><span class='line'>&#9;skb_header_release(p);
</span><span class='line'>&#9;nskb-&gt;prev = p;
</span><span class='line'>&#9;//更新新的skb的数据段
</span><span class='line'>&#9;nskb-&gt;data_len += p-&gt;len;
</span><span class='line'>&#9;nskb-&gt;truesize += p-&gt;len;  // 应该改成 nskb-&gt;truesize += p-&gt;truesize; 更准确
</span><span class='line'>&#9;nskb-&gt;len += p-&gt;len;
</span><span class='line'>&#9;//将新的skb插入到gro list中
</span><span class='line'>&#9;*head = nskb;
</span><span class='line'>&#9;nskb-&gt;next = p-&gt;next;
</span><span class='line'>&#9;p-&gt;next = NULL;
</span><span class='line'> 
</span><span class='line'>&#9;p = nskb;
</span><span class='line'> 
</span><span class='line'>merge:
</span><span class='line'>&#9;if (offset &gt; headlen) {
</span><span class='line'>&#9;&#9;skbinfo-&gt;frags[0].page_offset += offset - headlen;
</span><span class='line'>&#9;&#9;skbinfo-&gt;frags[0].size -= offset - headlen;
</span><span class='line'>&#9;&#9;offset = headlen;
</span><span class='line'>&#9;}
</span><span class='line'> 
</span><span class='line'>&#9;__skb_pull(skb, offset);
</span><span class='line'>&#9;//将skb插入新的skb的(或者老的skb，当frag list本身存在)fraglist
</span><span class='line'>&#9;// 这里是用p-&gt;prev来记录了p-&gt;fraglist的最后一个包，所以在gro向协议栈提交时最好加一句skb-&gt;prev = NULL;
</span><span class='line'>&#9;p-&gt;prev-&gt;next = skb;
</span><span class='line'>&#9;p-&gt;prev = skb;
</span><span class='line'>&#9;skb_header_release(skb);</span></code></pre></td></tr></table></div></figure>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-04-18T15:48:00+08:00'><span class='date'>2015-04-18</span> <span class='time'>15:48:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~net/'>net</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/04/15/debug-mark-cong/" title="Previous Post: 拥塞控制模块注意">&laquo; 拥塞控制模块注意</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/04/18/kernel-net-tcp-state/" title="Next Post: TCP状态转换">TCP状态转换 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
