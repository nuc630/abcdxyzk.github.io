
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>TCP校验和的原理和实现 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>学习中......</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">TCP校验和的原理和实现</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-15T14:07:00+08:00'><span class='date'>2015-04-15</span> <span class='time'>14:07:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.csdn.net/zhangskd/article/details/11770647">http://blog.csdn.net/zhangskd/article/details/11770647</a></p>

<h4>概述</h4>

<p>TCP校验和是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。</p>

<p>TCP校验和覆盖TCP首部和TCP数据，而IP首部中的校验和只覆盖IP的首部，不覆盖IP数据报中的任何数据。</p>

<p>TCP的校验和是必需的，而UDP的校验和是可选的。</p>

<p>TCP和UDP计算校验和时，都要加上一个12字节的伪首部。</p>

<h4>伪首部</h4>

<p><img src="/images/kernel/2015-04-15-1.jpeg" alt="" /></p>

<p>伪首部共有12字节，包含如下信息：源IP地址、目的IP地址、保留字节(置0)、传输层协议号(TCP是6)、TCP报文长度(报头+数据)。</p>

<p>伪首部是为了增加TCP校验和的检错能力：如检查TCP报文是否收错了(目的IP地址)、传输层协议是否选对了(传输层协议号)等。</p>

<h4>定义</h4>

<h5>(1) RFC 793的TCP校验和定义</h5>

<p>The checksum field is the 16 bit one&rsquo;s complement of the one&rsquo;s complement sum of all 16-bit words in the header and text. If a segment contains an odd number of header and text octets to be checksummed, the last octet is padded on the right with zeros to form a 16-bit word for checksum purposes. The pad is not transmitted as part of the segment. While computing the checksum, the checksum field itself is replaced with zeros.</p>

<p>上述的定义说得很明确：<br/>
首先，把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。把TCP报头中的校验和字段置为0（否则就陷入鸡生蛋还是蛋生鸡的问题）。</p>

<p>其次，用反码相加法累加所有的16位字（进位也要累加）。</p>

<p>最后，对计算结果取反，作为TCP的校验和。</p>

<h5>(2) RFC 1071的IP校验和定义</h5>

<p>1.Adjacent octets to be checksummed are paired to form 16-bit integers, and the 1&rsquo;s complement sum of these 16-bit integers is formed.</p>

<p>2.To generate a checksum, the checksum field itself is cleared, the 16-bit 1&rsquo;s complement sum is computed over the octets concerned, and the 1&rsquo;s complement of this sum is placed in the checksum field.</p>

<p>3.To check a checksum, the 1&rsquo;s complement sum is computed over the same set of octets, including the checksum field. If the result is all 1 bits (-0 in 1&rsquo;s complement arithmetic), the check succeeds.</p>

<p>可以看到，TCP校验和、IP校验和的计算方法是基本一致的，除了计算的范围不同。</p>

<h4>实现</h4>

<p>基于2.6.18、x86_64。</p>

<p>csum_tcpudp_nofold()按4字节累加伪首部到sum中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline unsigned long csum_tcpudp_nofold (unsigned long saddr, unsigned long daddr,  
</span><span class='line'>                                                unsigned short len, unsigned short proto,  
</span><span class='line'>                                                unsigned int sum)  
</span><span class='line'>{  
</span><span class='line'>    asm("addl %1, %0\n"    /* 累加daddr */  
</span><span class='line'>        "adcl %2, %0\n"    /* 累加saddr */  
</span><span class='line'>        "adcl %3, %0\n"    /* 累加len(2字节), proto, 0*/  
</span><span class='line'>        "adcl $0, %0\n"    /*加上进位 */  
</span><span class='line'>        : "=r" (sum)  
</span><span class='line'>        : "g" (daddr), "g" (saddr), "g" ((ntohs(len) &lt;&lt; 16) + proto*256), "0" (sum));  
</span><span class='line'>    return sum;  
</span><span class='line'>}   </span></code></pre></td></tr></table></div></figure>


<p>csum_tcpudp_magic()产生最终的校验和。</p>

<p>首先，按4字节累加伪首部到sum中。</p>

<p>其次，累加sum的低16位、sum的高16位，并且对累加的结果取反。</p>

<p>最后，截取sum的高16位，作为校验和。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline unsigned short int csum_tcpudp_magic(unsigned long saddr, unsigned long daddr,  
</span><span class='line'>                                                   unsigned short len, unsigned short proto,  
</span><span class='line'>                                                   unsigned int sum)  
</span><span class='line'>{  
</span><span class='line'>    return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>static inline unsigned int csum_fold(unsigned int sum)  
</span><span class='line'>{  
</span><span class='line'>    __asm__(  
</span><span class='line'>        "addl %1, %0\n"  
</span><span class='line'>        "adcl 0xffff, %0"  
</span><span class='line'>        : "=r" (sum)  
</span><span class='line'>        : "r" (sum &lt;&lt; 16), "0" (sum & 0xffff0000)   
</span><span class='line'>  
</span><span class='line'>        /* 将sum的低16位，作为寄存器1的高16位，寄存器1的低16位补0。 
</span><span class='line'>          * 将sum的高16位，作为寄存器0的高16位，寄存器0的低16位补0。 
</span><span class='line'>          * 这样，addl %1, %0就累加了sum的高16位和低16位。 
</span><span class='line'>          * 
</span><span class='line'>         * 还要考虑进位。如果有进位，adcl 0xfff, %0为：0x1 + 0xffff + %0，寄存器0的高16位加1。 
</span><span class='line'>          * 如果没有进位，adcl 0xffff, %0为：0xffff + %0，对寄存器0的高16位无影响。 
</span><span class='line'>          */  
</span><span class='line'>  
</span><span class='line'>    );  
</span><span class='line'>  
</span><span class='line'>    return (~sum) &gt;&gt; 16; /* 对sum取反，返回它的高16位，作为最终的校验和 */  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h4>发送校验</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define CHECKSUM_NONE 0 /* 不使用校验和，UDP可选 */  
</span><span class='line'>#define CHECKSUM_HW 1 /* 由硬件计算报头和首部的校验和 */  
</span><span class='line'>#define CHECKSUM_UNNECESSARY 2 /* 表示不需要校验，或者已经成功校验了 */  
</span><span class='line'>#define CHECKSUM_PARTIAL CHECKSUM_HW  
</span><span class='line'>#define CHECKSUM_COMPLETE CHECKSUM_HW  </span></code></pre></td></tr></table></div></figure>


<h5>@tcp_transmit_skb()</h5>

<pre><code>icsk-&gt;icsk_af_ops-&gt;send_check(sk, skb-&gt;len, skb); /* 计算校验和 */
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_v4_send_check(struct sock *sk, int len, struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>    struct inet_sock *inet = inet_sk(sk);  
</span><span class='line'>    struct tcphdr *th = skb-&gt;h.th;  
</span><span class='line'>   
</span><span class='line'>    if (skb-&gt;ip_summed == CHECKSUM_HW) {  
</span><span class='line'>        /* 只计算伪首部，TCP报头和TCP数据的累加由硬件完成 */  
</span><span class='line'>        th-&gt;check = ~tcp_v4_check(th, len, inet-&gt;saddr, inet-&gt;daddr, 0);  
</span><span class='line'>        skb-&gt;csum = offsetof(struct tcphdr, check); /* 校验和值在TCP首部的偏移 */  
</span><span class='line'>  
</span><span class='line'>    } else {  
</span><span class='line'>        /* tcp_v4_check累加伪首部，获取最终的校验和。 
</span><span class='line'>         * csum_partial累加TCP报头。 
</span><span class='line'>         * 那么skb-&gt;csum应该是TCP数据部分的累加，这是在从用户空间复制时顺便累加的。 
</span><span class='line'>         */  
</span><span class='line'>        th-&gt;check = tcp_v4_check(th, len, inet-&gt;saddr, inet-&gt;daddr,  
</span><span class='line'>                                 csum_partial((char *)th, th-&gt;doff &lt;&lt; 2, skb-&gt;csum));  
</span><span class='line'>    }  
</span><span class='line'>}  
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned csum_partial(const unsigned char *buff, unsigned len, unsigned sum)  
</span><span class='line'>{  
</span><span class='line'>    return add32_with_carry(do_csum(buff, len), sum);  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>static inline unsigned add32_with_carry(unsigned a, unsigned b)  
</span><span class='line'>{  
</span><span class='line'>    asm("addl %2, %0\n\t"  
</span><span class='line'>             "adcl $0, %0"  
</span><span class='line'>             : "=r" (a)  
</span><span class='line'>             : "0" (a), "r" (b));  
</span><span class='line'>    return a;  
</span><span class='line'>}   </span></code></pre></td></tr></table></div></figure>


<p>do_csum()用于计算一段内存的校验和，这里用于累加TCP报头。</p>

<p>具体计算时用到一些技巧：<br/>
1.反码累加时，按16位、32位、64位来累加的效果是一样的。<br/>
2.使用内存对齐，减少内存操作的次数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static __force_inline unsigned do_csum(const unsigned char *buff, unsigned len)  
</span><span class='line'>{  
</span><span class='line'>    unsigned odd, count;  
</span><span class='line'>    unsigned long result = 0;  
</span><span class='line'>  
</span><span class='line'>    if (unlikely(len == 0))  
</span><span class='line'>        return result;  
</span><span class='line'>  
</span><span class='line'>    /* 使起始地址为XXX0，接下来可按2字节对齐 */  
</span><span class='line'>    odd = 1 & (unsigned long) buff;  
</span><span class='line'>    if (unlikely(odd)) {  
</span><span class='line'>        result = *buff &lt;&lt; 8; /* 因为机器是小端的 */  
</span><span class='line'>        len--;  
</span><span class='line'>        buff++;  
</span><span class='line'>    }  
</span><span class='line'>    count = len &gt;&gt; 1; /* nr of 16-bit words，这里可能余下1字节未算，最后会处理*/  
</span><span class='line'>  
</span><span class='line'>    if (count) {  
</span><span class='line'>        /* 使起始地址为XX00，接下来可按4字节对齐 */  
</span><span class='line'>        if (2 & (unsigned long) buff) {  
</span><span class='line'>            result += *(unsigned short *)buff;  
</span><span class='line'>            count--;  
</span><span class='line'>            len -= 2;  
</span><span class='line'>            buff += 2;  
</span><span class='line'>        }  
</span><span class='line'>        count &gt;&gt;= 1; /* nr of 32-bit words，这里可能余下2字节未算，最后会处理 */  
</span><span class='line'>  
</span><span class='line'>        if (count) {  
</span><span class='line'>            unsigned long zero;  
</span><span class='line'>            unsigned count64;  
</span><span class='line'>            /* 使起始地址为X000，接下来可按8字节对齐 */  
</span><span class='line'>            if (4 & (unsigned long)buff) {  
</span><span class='line'>                result += *(unsigned int *)buff;  
</span><span class='line'>                count--;  
</span><span class='line'>                len -= 4;  
</span><span class='line'>                buff += 4;  
</span><span class='line'>            }  
</span><span class='line'>            count &gt;&gt;= 1; /* nr of 64-bit words，这里可能余下4字节未算，最后会处理*/  
</span><span class='line'>  
</span><span class='line'>            /* main loop using 64byte blocks */  
</span><span class='line'>            zero = 0;  
</span><span class='line'>            count64 = count &gt;&gt; 3; /* 64字节的块数，这里可能余下56字节未算，最后会处理 */  
</span><span class='line'>            while (count64) { /* 反码累加所有的64字节块 */  
</span><span class='line'>                asm ("addq 0*8(%[src]), %[res]\n\t"    /* b、w、l、q分别对应8、16、32、64位操作 */  
</span><span class='line'>                          "addq 1*8(%[src]), %[res]\n\t"    /* [src]为指定寄存器的别名，效果应该等同于0、1等 */  
</span><span class='line'>                          "adcq 2*8(%[src]), %[res]\n\t"  
</span><span class='line'>                          "adcq 3*8(%[src]), %[res]\n\t"  
</span><span class='line'>                          "adcq 4*8(%[src]), %[res]\n\t"  
</span><span class='line'>                          "adcq 5*8(%[src]), %[res]\n\t"  
</span><span class='line'>                          "adcq 6*8(%[src]), %[res]\n\t"  
</span><span class='line'>                          "adcq 7*8(%[src]), %[res]\n\t"  
</span><span class='line'>                          "adcq %[zero], %[res]"  
</span><span class='line'>                          : [res] "=r" (result)  
</span><span class='line'>                          : [src] "r" (buff), [zero] "r" (zero), "[res]" (result));  
</span><span class='line'>                buff += 64;  
</span><span class='line'>                count64--;  
</span><span class='line'>            }  
</span><span class='line'>  
</span><span class='line'>            /* 从这里开始，反序处理之前可能漏算的字节 */  
</span><span class='line'>  
</span><span class='line'>            /* last upto 7 8byte blocks，前面按8个8字节做计算单位，所以最多可能剩下7个8字节 */  
</span><span class='line'>            count %= 8;  
</span><span class='line'>            while (count) {  
</span><span class='line'>                asm ("addq %1, %0\n\t"  
</span><span class='line'>                     "adcq %2, %0\n"  
</span><span class='line'>                     : "=r" (result)  
</span><span class='line'>                     : "m" (*(unsigned long *)buff), "r" (zero), "0" (result));  
</span><span class='line'>                --count;  
</span><span class='line'>                buff += 8;  
</span><span class='line'>            }  
</span><span class='line'>  
</span><span class='line'>            /* 带进位累加result的高32位和低32位 */  
</span><span class='line'>            result = add32_with_carry(result&gt;&gt;32, result&0xffffffff);  
</span><span class='line'>  
</span><span class='line'>            /* 之前始按8字节对齐，可能有4字节剩下 */  
</span><span class='line'>            if (len & 4) {  
</span><span class='line'>                result += *(unsigned int *) buff;  
</span><span class='line'>                buff += 4;  
</span><span class='line'>            }  
</span><span class='line'>        }  
</span><span class='line'>  
</span><span class='line'>       /* 更早前按4字节对齐，可能有2字节剩下 */  
</span><span class='line'>        if (len & 2) {  
</span><span class='line'>            result += *(unsigned short *) buff;  
</span><span class='line'>            buff += 2;  
</span><span class='line'>        }  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    /* 最早之前按2字节对齐，可能有1字节剩下 */  
</span><span class='line'>    if (len & 1)  
</span><span class='line'>        result += *buff;  
</span><span class='line'>  
</span><span class='line'>    /* 再次带进位累加result的高32位和低32位 */  
</span><span class='line'>    result = add32_with_carry(result&gt;&gt;32, result & 0xffffffff);   
</span><span class='line'>  
</span><span class='line'>    /* 这里涉及到一个技巧，用于处理初始地址为奇数的情况 */  
</span><span class='line'>    if (unlikely(odd)) {  
</span><span class='line'>        result = from32to16(result); /* 累加到result的低16位 */  
</span><span class='line'>        /* result为：0 0 a b 
</span><span class='line'>         * 然后交换a和b，result变为：0 0 b a 
</span><span class='line'>         */  
</span><span class='line'>        result = ((result &gt;&gt; 8) & 0xff) | ((result & oxff) &lt;&lt; 8);  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    return result; /* 返回result的低32位 */  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline unsigned short from32to16(unsigned a)  
</span><span class='line'>{  
</span><span class='line'>    unsigned short b = a &gt;&gt; 16;  
</span><span class='line'>    asm ("addw %w2, %w0\n\t"  
</span><span class='line'>              "adcw $0, %w0\n"  
</span><span class='line'>              : "=r" (b)  
</span><span class='line'>              : "0" (b), "r" (a));  
</span><span class='line'>    return b;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>csum_partial_copy_from_user()用于拷贝用户空间数据到内核空间，同时计算用户数据的校验和，结果保存到skb->csum中（X86_64）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** 
</span><span class='line'> * csum_partial_copy_from_user - Copy and checksum from user space. 
</span><span class='line'> * @src: source address (user space) 
</span><span class='line'> * @dst: destination address 
</span><span class='line'> * @len: number of bytes to be copied. 
</span><span class='line'> * @isum: initial sum that is added into the result (32bit unfolded) 
</span><span class='line'> * @errp: set to -EFAULT for an bad source address. 
</span><span class='line'> * 
</span><span class='line'> * Returns an 32bit unfolded checksum of the buffer. 
</span><span class='line'> * src and dst are best aligned to 64bits. 
</span><span class='line'> */  
</span><span class='line'>  
</span><span class='line'>unsigned int csum_partial_copy_from_user(const unsigned char __user *src,  
</span><span class='line'>                                  unsigned char *dst, int len, unsigned int isum, int *errp)  
</span><span class='line'>{  
</span><span class='line'>    might_sleep();  
</span><span class='line'>    *errp = 0;  
</span><span class='line'>  
</span><span class='line'>    if (likely(access_ok(VERIFY_READ, src, len))) {  
</span><span class='line'>  
</span><span class='line'>        /* Why 6, not 7? To handle odd addresses aligned we would need to do considerable 
</span><span class='line'>         * complications to fix the checksum which is defined as an 16bit accumulator. The fix 
</span><span class='line'>         * alignment code is primarily for performance compatibility with 32bit and that will handle 
</span><span class='line'>         * odd addresses slowly too. 
</span><span class='line'>         * 处理X010、X100、X110的起始地址。不处理X001，因为这会使复杂度大增加。 
</span><span class='line'>         */  
</span><span class='line'>        if (unlikely((unsigned long)src & 6)) {  
</span><span class='line'>            while (((unsigned long)src & 6) && len &gt;= 2) {  
</span><span class='line'>                __u16 val16;  
</span><span class='line'>                *errp = __get_user(val16, (__u16 __user *)src);  
</span><span class='line'>                if (*errp)  
</span><span class='line'>                    return isum;  
</span><span class='line'>                *(__u16 *)dst = val16;  
</span><span class='line'>                isum = add32_with_carry(isum, val16);  
</span><span class='line'>                src += 2;  
</span><span class='line'>                dst += 2;  
</span><span class='line'>                len -= 2;  
</span><span class='line'>            }  
</span><span class='line'>        }  
</span><span class='line'>  
</span><span class='line'>        /* 计算函数是用纯汇编实现的，应该是因为效率吧 */  
</span><span class='line'>        isum = csum_parial_copy_generic((__force void *)src, dst, len, isum, errp, NULL);  
</span><span class='line'>  
</span><span class='line'>        if (likely(*errp == 0))  
</span><span class='line'>            return isum; /* 成功 */  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    *errp = -EFAULT;  
</span><span class='line'>    memset(dst, 0, len);  
</span><span class='line'>    return isum;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>上述的实现比较复杂，来看下最简单的csum_partial_copy_from_user()实现（um）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned int csum_partial_copy_from_user(const unsigned char *src,  
</span><span class='line'>                                         unsigned char *dst, int len, int sum,  
</span><span class='line'>                                         int *err_ptr)  
</span><span class='line'>{  
</span><span class='line'>    if (copy_from_user(dst, src, len)) { /* 拷贝用户空间数据到内核空间 */  
</span><span class='line'>        *err_ptr = -EFAULT; /* bad address */  
</span><span class='line'>        return (-1);  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    return csum_partial(dst, len, sum); /* 计算用户数据的校验和，会存到skb-&gt;csum中 */  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h4>接收校验</h4>

<h5>@tcp_v4_rcv</h5>

<pre><code>/* 检查校验和 */
if (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY &amp;&amp; tcp_v4_checksum_init(skb))  
    goto bad_packet;   
</code></pre>

<p>接收校验的第一部分，主要是计算伪首部。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_v4_checksum_init(struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>    /* 如果TCP报头、TCP数据的反码累加已经由硬件完成 */  
</span><span class='line'>    if (skb-&gt;ip_summed == CHECKSUM_HW) {  
</span><span class='line'>  
</span><span class='line'>        /* 现在只需要再累加上伪首部，取反获取最终的校验和。 
</span><span class='line'>         * 校验和为0时，表示TCP数据报正确。 
</span><span class='line'>         */  
</span><span class='line'>        if (! tcp_v4_check(skb-&gt;h.th, skb-&gt;len, skb-&gt;nh.iph-&gt;saddr, skb-&gt;nh.iph-&gt;daddr, skb-&gt;csum)) {  
</span><span class='line'>            skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;  
</span><span class='line'>            return 0; /* 校验成功 */  
</span><span class='line'>  
</span><span class='line'>        } /* 没有else失败退出吗？*/  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    /* 对伪首部进行反码累加，主要用于软件方法 */  
</span><span class='line'>    skb-&gt;csum = csum_tcpudp_nofold(skb-&gt;nh.iph-&gt;saddr, skb-&gt;nh.iph-&gt;daddr, skb-&gt;len, IPPROTO_TCP, 0);  
</span><span class='line'>   
</span><span class='line'>  
</span><span class='line'>    /* 对于长度小于76字节的小包，接着累加TCP报头和报文，完成校验；否则，以后再完成检验。*/  
</span><span class='line'>    if (skb-&gt;len &lt;= 76) {  
</span><span class='line'>        return __skb_checksum_complete(skb);  
</span><span class='line'>    }  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>接收校验的第二部分，计算报头和报文。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_v4_rcv、tcp_v4_do_rcv()
</span><span class='line'>
</span><span class='line'>    | --&gt; tcp_checksum_complete()
</span><span class='line'>
</span><span class='line'>                | --&gt; __tcp_checksum_complete()
</span><span class='line'>
</span><span class='line'>                            | --&gt; __skb_checksum_complete()
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>tcp_rcv_established()
</span><span class='line'>
</span><span class='line'>    | --&gt; tcp_checksum_complete_user()
</span><span class='line'>
</span><span class='line'>                | --&gt; __tcp_checksum_complete_user()
</span><span class='line'>
</span><span class='line'>                            | --&gt; __tcp_checksum_complete()
</span><span class='line'>
</span><span class='line'>                                        | --&gt; __skb_checksum_complete()</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned int __skb_checksum_complete(struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>    unsigned int sum;  
</span><span class='line'>  
</span><span class='line'>    sum = (u16) csum_fold(skb_checksum(skb, 0, skb-&gt;len, skb-&gt;csum));  
</span><span class='line'>  
</span><span class='line'>    if (likely(!sum)) { /* sum为0表示成功了 */  
</span><span class='line'>        /* 硬件检测失败，软件检测成功了，说明硬件检测有误 */  
</span><span class='line'>        if (unlikely(skb-&gt;ip_summed == CHECKSUM_HW))  
</span><span class='line'>            netdev_rx_csum_fault(skb-&gt;dev);  
</span><span class='line'>        skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;  
</span><span class='line'>    }  
</span><span class='line'>    return sum;  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<p>计算skb包的校验和时，可以指定相对于skb->data的偏移量offset。由于skb包可能由分页和分段，所以需要考虑skb->data + offset是位于此skb段的线性区中、还是此skb的分页中，或者位于其它分段中。这个函数逻辑比较复杂。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Checksum skb data. */  
</span><span class='line'>unsigned int skb_checksum(const struct sk_buff *skb, int offset, int len, unsigned int csum)  
</span><span class='line'>{  
</span><span class='line'>    int start = skb_headlen(skb); /* 线性区域长度 */  
</span><span class='line'>    /* copy &gt; 0，说明offset在线性区域中。 
</span><span class='line'>     * copy &lt; 0，说明offset在此skb的分页数据中，或者在其它分段skb中。 
</span><span class='line'>     */  
</span><span class='line'>    int i, copy = start - offset;  
</span><span class='line'>    int pos = 0; /* 表示校验了多少数据 */  
</span><span class='line'>  
</span><span class='line'>    /* Checksum header. */  
</span><span class='line'>    if (copy &gt; 0) { /* 说明offset在本skb的线性区域中 */  
</span><span class='line'>        if (copy &gt; len)  
</span><span class='line'>            copy = len; /* 不能超过指定的校验长度 */  
</span><span class='line'>  
</span><span class='line'>        /* 累加copy长度的线性区校验 */  
</span><span class='line'>        csum = csum_partial(skb-&gt;data + offset, copy, csum);  
</span><span class='line'>  
</span><span class='line'>        if ((len -= copy) == 0)  
</span><span class='line'>            return csum;  
</span><span class='line'>  
</span><span class='line'>        offset += copy; /* 接下来从这里继续处理 */  
</span><span class='line'>        pos = copy; /* 已处理数据长 */  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    /* 累加本skb分页数据的校验和 */  
</span><span class='line'>    for (i = 0; i &lt; skb_shinfo(skb)-&gt;nr_frags; i++) {  
</span><span class='line'>        int end;  
</span><span class='line'>        BUG_TRAP(start &lt;= offset + len);  
</span><span class='line'>      
</span><span class='line'>        end = start + skb_shinfo(skb)-&gt;frags[i].size;  
</span><span class='line'>  
</span><span class='line'>        if ((copy = end - offset) &gt; 0) { /* 如果offset位于本页中，或者线性区中 */  
</span><span class='line'>            unsigned int csum2;  
</span><span class='line'>            u8 *vaddr; /* 8位够吗？*/  
</span><span class='line'>            skb_frag_t *frag = &skb_shinfo(skb)-&gt;frags[i];  
</span><span class='line'>   
</span><span class='line'>            if (copy &gt; len)  
</span><span class='line'>                copy = len;  
</span><span class='line'>  
</span><span class='line'>            vaddr = kmap_skb_frag(frag); /* 把物理页映射到内核空间 */  
</span><span class='line'>            csum2 = csum_partial(vaddr + frag-&gt;page_offset + offset - start, copy, 0);  
</span><span class='line'>            kunmap_skb_frag(vaddr); /* 解除映射 */  
</span><span class='line'>  
</span><span class='line'>            /* 如果pos为奇数，需要对csum2进行处理。 
</span><span class='line'>             * csum2：a, b, c, d =&gt; b, a, d, c 
</span><span class='line'>             */  
</span><span class='line'>            csum = csum_block_add(csum, csum2, pos);  
</span><span class='line'>  
</span><span class='line'>            if (! (len -= copy))  
</span><span class='line'>                return csum;  
</span><span class='line'>  
</span><span class='line'>            offset += copy;  
</span><span class='line'>            pos += copy;  
</span><span class='line'>        }  
</span><span class='line'>        start = end; /* 接下来从这里处理 */  
</span><span class='line'>    }  
</span><span class='line'>   
</span><span class='line'>    /* 如果此skb是个大包，还有其它分段 */  
</span><span class='line'>    if (skb_shinfo(skb)-&gt;frag_list) {  
</span><span class='line'>        struct sk_buff *list = skb_shinfo(skb)-&gt;frag_list;  
</span><span class='line'>  
</span><span class='line'>        for (; list; list = list-&gt;next) {  
</span><span class='line'>            int end;  
</span><span class='line'>            BUG_TRAP(start &lt;= offset + len);  
</span><span class='line'>   
</span><span class='line'>            end = start + list-&gt;len;  
</span><span class='line'>  
</span><span class='line'>            if ((copy = end - offset) &gt; 0) { /* 如果offset位于此skb分段中，或者分页，或者线性区 */  
</span><span class='line'>                unsigned int csum2;  
</span><span class='line'>                if (copy &gt; len)  
</span><span class='line'>                    copy = len;  
</span><span class='line'>  
</span><span class='line'>                csum2 = skb_checksum(list, offset - start, copy, 0); /* 递归调用 */  
</span><span class='line'>                csum = csum_block_add(csum, csum2, pos);  
</span><span class='line'>                if ((len -= copy) == 0)  
</span><span class='line'>                    return csum;  
</span><span class='line'>  
</span><span class='line'>                offset += copy;  
</span><span class='line'>                pos += copy;  
</span><span class='line'>            }  
</span><span class='line'>            start = end;  
</span><span class='line'>        }  
</span><span class='line'>    }  
</span><span class='line'>  
</span><span class='line'>    BUG_ON(len);  
</span><span class='line'>    return csum;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-04-15T14:07:00+08:00'><span class='date'>2015-04-15</span> <span class='time'>14:07:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~net/'>net</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/04/14/kernel-net-sock-raw/" title="Previous Post:  Linux网络编程：原始套接字 SOCK_RAW">&laquo;  Linux网络编程：原始套接字 SOCK_RAW</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/04/15/debug-mark-cong/" title="Next Post: 拥塞控制模块注意">拥塞控制模块注意 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
