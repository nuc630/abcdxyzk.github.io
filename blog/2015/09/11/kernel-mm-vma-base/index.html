
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>linux进程地址空间--vma的基本操作 - kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>date [-d @int|str] [+%s|"+%F %T"]</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h2 class="entry-title">linux进程地址空间--vma的基本操作</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-09-11T16:39:00+08:00'><span class='date'>2015-09-11</span> <span class='time'>16:39:00</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://blog.csdn.net/vanbreaker/article/details/7855007">http://blog.csdn.net/vanbreaker/article/details/7855007</a></p>

<p>在32位的系统上，线性地址空间可达到4GB，这4GB一般按照3:1的比例进行分配，也就是说用户进程享有前3GB线性地址空间，而内核独享最后1GB线性地址空间。由于虚拟内存的引入，每个进程都可拥有3GB的虚拟内存，并且用户进程之间的地址空间是互不可见、互不影响的，也就是说即使两个进程对同一个地址进行操作，也不会产生问题。在前面介绍的一些分配内存的途径中，无论是伙伴系统中分配页的函数，还是slab分配器中分配对象的函数，它们都会尽量快速地响应内核的分配请求，将相应的内存提交给内核使用，而内核对待用户空间显然不能如此。用户空间动态申请内存时往往只是获得一块线性地址的使用权，而并没有将这块线性地址区域与实际的物理内存对应上，只有当用户空间真正操作申请的内存时，才会触发一次缺页异常，这时内核才会分配实际的物理内存给用户空间。</p>

<p>用户进程的虚拟地址空间包含了若干区域，这些区域的分布方式是特定于体系结构的，不过所有的方式都包含下列成分：</p>

<p>  可执行文件的二进制代码，也就是程序的代码段<br/>
  存储全局变量的数据段<br/>
  用于保存局部变量和实现函数调用的栈<br/>
  环境变量和命令行参数<br/>
  程序使用的动态库的代码<br/>
  用于映射文件内容的区域</p>

<p>由此可以看到进程的虚拟内存空间会被分成不同的若干区域，每个区域都有其相关的属性和用途，一个合法的地址总是落在某个区域当中的，这些区域也不会重叠。在linux内核中，这样的区域被称之为虚拟内存区域(virtual memory areas),简称vma。一个vma就是一块连续的线性地址空间的抽象，它拥有自身的权限(可读，可写，可执行等等) ，每一个虚拟内存区域都由一个相关的struct vm_area_struct结构来描述</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct vm_area_struct {
</span><span class='line'>&#9;struct mm_struct * vm_mm;   /* 所属的内存描述符 */
</span><span class='line'>&#9;unsigned long vm_start;    /* vma的起始地址 */
</span><span class='line'>&#9;unsigned long vm_end;       /* vma的结束地址 */
</span><span class='line'>
</span><span class='line'>&#9;/* 该vma的在一个进程的vma链表中的前驱vma和后驱vma指针，链表中的vma都是按地址来排序的*/
</span><span class='line'>&#9;struct vm_area_struct *vm_next, *vm_prev;
</span><span class='line'>
</span><span class='line'>&#9;pgprot_t vm_page_prot;      /* vma的访问权限 */
</span><span class='line'>&#9;unsigned long vm_flags;    /* 标识集 */
</span><span class='line'>
</span><span class='line'>&#9;struct rb_node vm_rb;      /* 红黑树中对应的节点 */
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * For areas with an address space and backing store,
</span><span class='line'>&#9; * linkage into the address_space-&gt;i_mmap prio tree, or
</span><span class='line'>&#9; * linkage to the list of like vmas hanging off its node, or
</span><span class='line'>&#9; * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/* shared联合体用于和address space关联 */
</span><span class='line'>&#9;union {
</span><span class='line'>&#9;&#9;struct {
</span><span class='line'>&#9;&#9;&#9;struct list_head list;/* 用于链入非线性映射的链表 */
</span><span class='line'>&#9;&#9;&#9;void *parent;   /* aligns with prio_tree_node parent */
</span><span class='line'>&#9;&#9;&#9;struct vm_area_struct *head;
</span><span class='line'>&#9;&#9;} vm_set;
</span><span class='line'>
</span><span class='line'>&#9;&#9;struct raw_prio_tree_node prio_tree_node;/*线性映射则链入i_mmap优先树*/
</span><span class='line'>&#9;} shared;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma
</span><span class='line'>&#9; * list, after a COW of one of the file pages.  A MAP_SHARED vma
</span><span class='line'>&#9; * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack
</span><span class='line'>&#9; * or brk vma (with NULL file) can only be in an anon_vma list.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;/*anno_vma_node和annon_vma用于管理源自匿名映射的共享页*/
</span><span class='line'>&#9;struct list_head anon_vma_node; /* Serialized by anon_vma-&gt;lock */
</span><span class='line'>&#9;struct anon_vma *anon_vma;  /* Serialized by page_table_lock */
</span><span class='line'>
</span><span class='line'>&#9;/* Function pointers to deal with this struct. */
</span><span class='line'>&#9;/*该vma上的各种标准操作函数指针集*/
</span><span class='line'>&#9;const struct vm_operations_struct *vm_ops;
</span><span class='line'>
</span><span class='line'>&#9;/* Information about our backing store: */
</span><span class='line'>&#9;unsigned long vm_pgoff;     /* 映射文件的偏移量，以PAGE_SIZE为单位 */
</span><span class='line'>&#9;struct file * vm_file;          /* 映射的文件，没有则为NULL */
</span><span class='line'>&#9;void * vm_private_data;     /* was vm_pte (shared mem) */
</span><span class='line'>&#9;unsigned long vm_truncate_count;/* truncate_count or restart_addr */
</span><span class='line'>
</span><span class='line'>#ifndef CONFIG_MMU
</span><span class='line'>&#9;struct vm_region *vm_region;    /* NOMMU mapping region */
</span><span class='line'>#endif
</span><span class='line'>#ifdef CONFIG_NUMA
</span><span class='line'>&#9;struct mempolicy *vm_policy;    /* NUMA policy for the VMA */
</span><span class='line'>#endif
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>进程的若干个vma区域都得按一定的形式组织在一起，这些vma都包含在进程的内存描述符中，也就是struct mm_struct中，这些vma在mm_struct以两种方式进行组织，一种是链表方式，对应于mm_struct中的mmap链表头，一种是红黑树方式，对应于mm_struct中的mm_rb根节点，和内核其他地方一样，链表用于遍历，红黑树用于查找。</p>

<p>下面以文件映射为例，来阐述文件的address_space和与其建立映射关系的vma是如何联系上的。首先来看看struct address_space中与vma相关的变量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct address_space {
</span><span class='line'>&#9;struct inode        *host;      /* owner: inode, block_device */
</span><span class='line'>&#9;...
</span><span class='line'>&#9;struct prio_tree_root   i_mmap;     /* tree of private and shared mappings */
</span><span class='line'>&#9;struct list_head    i_mmap_nonlinear;          /*list VM_NONLINEAR mappings */
</span><span class='line'>&#9;...
</span><span class='line'>} __attr</span></code></pre></td></tr></table></div></figure>


<p>与此同时，struct file和struct inode中都包含有一个struct address_space的指针，分别为f_mapping和i_mapping。struct file是一个特定于进程的数据结构，而struct inode则是一个特定于文件的数据结构。每当进程打开一个文件时，都会将file->f_mapping设置到inode->i_mapping,下图则给出了文件和与其建立映射关系的vma的联系</p>

<p><img src="/images/kernel/2015-09-11-1.png" alt="" /></p>

<p>下面来看几个vma的基本操作函数，这些函数都是后面实现具体功能的基础</p>

<p>find_vma()用来寻找一个针对于指定地址的vma，该vma要么包含了指定的地址，要么位于该地址之后并且离该地址最近，或者说寻找第一个满足addr&lt;vma_end的vma</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)
</span><span class='line'>{
</span><span class='line'>&#9;struct vm_area_struct *vma = NULL;
</span><span class='line'>
</span><span class='line'>&#9;if (mm) {
</span><span class='line'>&#9;&#9;/* Check the cache first. */
</span><span class='line'>&#9;&#9;/* (Cache hit rate is typically around 35%.) */
</span><span class='line'>&#9;&#9;vma = mm-&gt;mmap_cache; //首先尝试mmap_cache中缓存的vma
</span><span class='line'>&#9;&#9;/*如果不满足下列条件中的任意一个则从红黑树中查找合适的vma
</span><span class='line'>&#9;&#9;  1.缓存vma不存在
</span><span class='line'>&#9;&#9;  2.缓存vma的结束地址小于给定的地址
</span><span class='line'>&#9;&#9;  3.缓存vma的起始地址大于给定的地址*/
</span><span class='line'>&#9;&#9;if (!(vma && vma-&gt;vm_end &gt; addr && vma-&gt;vm_start &lt;= addr)) {
</span><span class='line'>&#9;&#9;&#9;struct rb_node * rb_node;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;rb_node = mm-&gt;mm_rb.rb_node;//获取红黑树根节点
</span><span class='line'>&#9;&#9;&#9;vma = NULL;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;while (rb_node) {
</span><span class='line'>&#9;&#9;&#9;&#9;struct vm_area_struct * vma_tmp;
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;vma_tmp = rb_entry(rb_node,   //获取节点对应的vma
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;struct vm_area_struct, vm_rb);
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;&#9;/*首先确定vma的结束地址是否大于给定地址，如果是的话，再确定
</span><span class='line'>&#9;&#9;&#9;&#9;  vma的起始地址是否小于给定地址，也就是优先保证给定的地址是
</span><span class='line'>&#9;&#9;&#9;&#9;  处于vma的范围之内的，如果无法保证这点，则只能找到一个距离
</span><span class='line'>&#9;&#9;&#9;&#9;  给定地址最近的vma并且该vma的结束地址要大于给定地址*/
</span><span class='line'>&#9;&#9;&#9;&#9;if (vma_tmp-&gt;vm_end &gt; addr) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;vma = vma_tmp;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;if (vma_tmp-&gt;vm_start &lt;= addr)
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;break;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;rb_node = rb_node-&gt;rb_left;
</span><span class='line'>&#9;&#9;&#9;&#9;} else
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;rb_node = rb_node-&gt;rb_right;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;if (vma)
</span><span class='line'>&#9;&#9;&#9;&#9;mm-&gt;mmap_cache = vma;//将结果保存在缓存中
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>&#9;return vma;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当一个新区域被加到进程的地址空间时，内核会检查它是否可以与一个或多个现存区域合并，vma_merge()函数在可能的情况下，将一个新区域与周边区域进行合并。参数：</p>

<p>mm:新区域所属的进程地址空间<br/>
prev:在地址上紧接着新区域的前面一个vma<br/>
addr:新区域的起始地址<br/>
end:新区域的结束地址<br/>
vm_flags:新区域的标识集<br/>
anon_vma:新区域所属的匿名映射<br/>
file:新区域映射的文件<br/>
pgoff:新区域映射文件的偏移<br/>
policy:和NUMA相关</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct vm_area_struct *vma_merge(struct mm_struct *mm,
</span><span class='line'>&#9;&#9;&#9;struct vm_area_struct *prev, unsigned long addr,
</span><span class='line'>&#9;&#9;&#9;unsigned long end, unsigned long vm_flags,
</span><span class='line'>&#9;&#9;&#9;struct anon_vma *anon_vma, struct file *file,
</span><span class='line'>&#9;&#9;&#9;pgoff_t pgoff, struct mempolicy *policy)
</span><span class='line'>{
</span><span class='line'>&#9;pgoff_t pglen = (end - addr) &gt;&gt; PAGE_SHIFT;
</span><span class='line'>&#9;struct vm_area_struct *area, *next;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * We later require that vma-&gt;vm_flags == vm_flags,
</span><span class='line'>&#9; * so this tests vma-&gt;vm_flags & VM_SPECIAL, too.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (vm_flags & VM_SPECIAL)
</span><span class='line'>&#9;&#9;return NULL;
</span><span class='line'>
</span><span class='line'>&#9;if (prev)//指定了先驱vma，则获取先驱vma的后驱vma
</span><span class='line'>&#9;&#9;next = prev-&gt;vm_next;
</span><span class='line'>&#9;else     //否则指定mm的vma链表中的第一个元素为后驱vma
</span><span class='line'>&#9;&#9;next = mm-&gt;mmap;
</span><span class='line'>&#9;area = next;
</span><span class='line'>
</span><span class='line'>&#9;/*后驱节点存在，并且后驱vma的结束地址和给定区域的结束地址相同，
</span><span class='line'>&#9;  也就是说两者有重叠，那么调整后驱vma*/
</span><span class='line'>&#9;if (next && next-&gt;vm_end == end)     /* cases 6, 7, 8 */
</span><span class='line'>&#9;&#9;next = next-&gt;vm_next;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * 先判断给定的区域能否和前驱vma进行合并，需要判断如下的几个方面:
</span><span class='line'>&#9;   1.前驱vma必须存在
</span><span class='line'>&#9;   2.前驱vma的结束地址正好等于给定区域的起始地址
</span><span class='line'>&#9;   3.两者的struct mempolicy中的相关属性要相同，这项检查只对NUMA架构有意义
</span><span class='line'>&#9;   4.其他相关项必须匹配，包括两者的vm_flags，是否映射同一个文件等等
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (prev && prev-&gt;vm_end == addr &&
</span><span class='line'>&#9;&#9;&#9;mpol_equal(vma_policy(prev), policy) &&
</span><span class='line'>&#9;&#9;&#9;can_vma_merge_after(prev, vm_flags,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;anon_vma, file, pgoff)) {
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; *确定可以和前驱vma合并后再判断是否能和后驱vma合并，判断方式和前面一样，
</span><span class='line'>&#9;&#9;  不过这里多了一项检查，在给定区域能和前驱、后驱vma合并的情况下还要检查
</span><span class='line'>&#9;&#9;  前驱、后驱vma的匿名映射可以合并
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (next && end == next-&gt;vm_start &&
</span><span class='line'>&#9;&#9;&#9;&#9;mpol_equal(policy, vma_policy(next)) &&
</span><span class='line'>&#9;&#9;&#9;&#9;can_vma_merge_before(next, vm_flags,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;anon_vma, file, pgoff+pglen) &&
</span><span class='line'>&#9;&#9;&#9;&#9;is_mergeable_anon_vma(prev-&gt;anon_vma,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;  next-&gt;anon_vma)) {
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;&#9;/* cases 1, 6 */
</span><span class='line'>&#9;&#9;&#9;vma_adjust(prev, prev-&gt;vm_start,
</span><span class='line'>&#9;&#9;&#9;&#9;next-&gt;vm_end, prev-&gt;vm_pgoff, NULL);
</span><span class='line'>&#9;&#9;} else                  /* cases 2, 5, 7 */
</span><span class='line'>&#9;&#9;&#9;vma_adjust(prev, prev-&gt;vm_start,
</span><span class='line'>&#9;&#9;&#9;&#9;end, prev-&gt;vm_pgoff, NULL);
</span><span class='line'>&#9;&#9;return prev;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * Can this new request be merged in front of next?
</span><span class='line'>&#9; */
</span><span class='line'>&#9; /*如果前面的步骤失败，那么则从后驱vma开始进行和上面类似的步骤*/
</span><span class='line'>&#9;if (next && end == next-&gt;vm_start &&
</span><span class='line'>&#9;&#9;&#9;mpol_equal(policy, vma_policy(next)) &&
</span><span class='line'>&#9;&#9;&#9;can_vma_merge_before(next, vm_flags,
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;anon_vma, file, pgoff+pglen)) {
</span><span class='line'>&#9;&#9;if (prev && addr &lt; prev-&gt;vm_end)  /* case 4 */
</span><span class='line'>&#9;&#9;&#9;vma_adjust(prev, prev-&gt;vm_start,
</span><span class='line'>&#9;&#9;&#9;&#9;addr, prev-&gt;vm_pgoff, NULL);
</span><span class='line'>&#9;&#9;else                    /* cases 3, 8 */
</span><span class='line'>&#9;&#9;&#9;vma_adjust(area, addr, next-&gt;vm_end,
</span><span class='line'>&#9;&#9;&#9;&#9;next-&gt;vm_pgoff - pglen, NULL);
</span><span class='line'>&#9;&#9;return area;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;return NULL;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>vma_adjust会执行具体的合并调整操作</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void vma_adjust(struct vm_area_struct *vma, unsigned long start,
</span><span class='line'>&#9;unsigned long end, pgoff_t pgoff, struct vm_area_struct *insert)
</span><span class='line'>{
</span><span class='line'>&#9;struct mm_struct *mm = vma-&gt;vm_mm;
</span><span class='line'>&#9;struct vm_area_struct *next = vma-&gt;vm_next;
</span><span class='line'>&#9;struct vm_area_struct *importer = NULL;
</span><span class='line'>&#9;struct address_space *mapping = NULL;
</span><span class='line'>&#9;struct prio_tree_root *root = NULL;
</span><span class='line'>&#9;struct file *file = vma-&gt;vm_file;
</span><span class='line'>&#9;struct anon_vma *anon_vma = NULL;
</span><span class='line'>&#9;long adjust_next = 0;
</span><span class='line'>&#9;int remove_next = 0;
</span><span class='line'>
</span><span class='line'>&#9;if (next && !insert) {
</span><span class='line'>&#9;&#9;/*指定的范围已经跨越了整个后驱vma，并且有可能超过后驱vma*/
</span><span class='line'>&#9;&#9;if (end &gt;= next-&gt;vm_end) {
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * vma expands, overlapping all the next, and
</span><span class='line'>&#9;&#9;&#9; * perhaps the one after too (mprotect case 6).
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>again:          remove_next = 1 + (end &gt; next-&gt;vm_end);//确定是否超过了后驱vma
</span><span class='line'>&#9;&#9;&#9;end = next-&gt;vm_end;
</span><span class='line'>&#9;&#9;&#9;anon_vma = next-&gt;anon_vma;
</span><span class='line'>&#9;&#9;&#9;importer = vma;
</span><span class='line'>&#9;&#9;} else if (end &gt; next-&gt;vm_start) {/*指定的区域和后驱vma部分重合*/
</span><span class='line'>
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * vma expands, overlapping part of the next:
</span><span class='line'>&#9;&#9;&#9; * mprotect case 5 shifting the boundary up.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;adjust_next = (end - next-&gt;vm_start) &gt;&gt; PAGE_SHIFT;
</span><span class='line'>&#9;&#9;&#9;anon_vma = next-&gt;anon_vma;
</span><span class='line'>&#9;&#9;&#9;importer = vma;
</span><span class='line'>&#9;&#9;} else if (end &lt; vma-&gt;vm_end) {/*指定的区域没到达后驱vma的结束处*/
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * vma shrinks, and !insert tells it's not
</span><span class='line'>&#9;&#9;&#9; * split_vma inserting another: so it must be
</span><span class='line'>&#9;&#9;&#9; * mprotect case 4 shifting the boundary down.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;adjust_next = - ((vma-&gt;vm_end - end) &gt;&gt; PAGE_SHIFT);
</span><span class='line'>&#9;&#9;&#9;anon_vma = next-&gt;anon_vma;
</span><span class='line'>&#9;&#9;&#9;importer = next;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (file) {//如果有映射文件
</span><span class='line'>&#9;&#9;mapping = file-&gt;f_mapping;//获取文件对应的address_space
</span><span class='line'>&#9;&#9;if (!(vma-&gt;vm_flags & VM_NONLINEAR))
</span><span class='line'>&#9;&#9;&#9;root = &mapping-&gt;i_mmap;
</span><span class='line'>&#9;&#9;spin_lock(&mapping-&gt;i_mmap_lock);
</span><span class='line'>&#9;&#9;if (importer &&
</span><span class='line'>&#9;&#9;&#9;vma-&gt;vm_truncate_count != next-&gt;vm_truncate_count) {
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * unmap_mapping_range might be in progress:
</span><span class='line'>&#9;&#9;&#9; * ensure that the expanding vma is rescanned.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;importer-&gt;vm_truncate_count = 0;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;/*如果指定了待插入的vma，则根据vma是否以非线性的方式映射文件来选择是将
</span><span class='line'>&#9;&#9;vma插入file对应的address_space的优先树(对应线性映射)还是双向链表(非线性映射)*/
</span><span class='line'>&#9;&#9;if (insert) {
</span><span class='line'>&#9;&#9;&#9;insert-&gt;vm_truncate_count = vma-&gt;vm_truncate_count;
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * Put into prio_tree now, so instantiated pages
</span><span class='line'>&#9;&#9;&#9; * are visible to arm/parisc __flush_dcache_page
</span><span class='line'>&#9;&#9;&#9; * throughout; but we cannot insert into address
</span><span class='line'>&#9;&#9;&#9; * space until vma start or end is updated.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;__vma_link_file(insert);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * When changing only vma-&gt;vm_end, we don't really need
</span><span class='line'>&#9; * anon_vma lock.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (vma-&gt;anon_vma && (insert || importer || start != vma-&gt;vm_start))
</span><span class='line'>&#9;&#9;anon_vma = vma-&gt;anon_vma;
</span><span class='line'>&#9;if (anon_vma) {
</span><span class='line'>&#9;&#9;spin_lock(&anon_vma-&gt;lock);
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * Easily overlooked: when mprotect shifts the boundary,
</span><span class='line'>&#9;&#9; * make sure the expanding vma has anon_vma set if the
</span><span class='line'>&#9;&#9; * shrinking vma had, to cover any anon pages imported.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (importer && !importer-&gt;anon_vma) {
</span><span class='line'>&#9;&#9;&#9;importer-&gt;anon_vma = anon_vma;
</span><span class='line'>&#9;&#9;&#9;__anon_vma_link(importer);//将importer插入importer的anon_vma匿名映射链表中
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (root) {
</span><span class='line'>&#9;&#9;flush_dcache_mmap_lock(mapping);
</span><span class='line'>&#9;&#9;vma_prio_tree_remove(vma, root);
</span><span class='line'>&#9;&#9;if (adjust_next)
</span><span class='line'>&#9;&#9;&#9;vma_prio_tree_remove(next, root);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;/*调整vma的相关量*/
</span><span class='line'>&#9;vma-&gt;vm_start = start;
</span><span class='line'>&#9;vma-&gt;vm_end = end;
</span><span class='line'>&#9;vma-&gt;vm_pgoff = pgoff;
</span><span class='line'>&#9;if (adjust_next) {//调整后驱vma的相关量
</span><span class='line'>&#9;&#9;next-&gt;vm_start += adjust_next &lt;&lt; PAGE_SHIFT;
</span><span class='line'>&#9;&#9;next-&gt;vm_pgoff += adjust_next;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (root) {
</span><span class='line'>&#9;&#9;if (adjust_next)//如果后驱vma被调整了，则重新插入到优先树中
</span><span class='line'>&#9;&#9;&#9;vma_prio_tree_insert(next, root);
</span><span class='line'>&#9;&#9;vma_prio_tree_insert(vma, root);//将vma插入到优先树中
</span><span class='line'>&#9;&#9;flush_dcache_mmap_unlock(mapping);
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (remove_next) {//给定区域与后驱vma有重合
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * vma_merge has merged next into vma, and needs
</span><span class='line'>&#9;&#9; * us to remove next before dropping the locks.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;__vma_unlink(mm, next, vma);//将后驱vma从红黑树中删除
</span><span class='line'>&#9;&#9;if (file)//将后驱vma从文件对应的address space中删除
</span><span class='line'>&#9;&#9;&#9;__remove_shared_vm_struct(next, file, mapping);
</span><span class='line'>&#9;&#9;if (next-&gt;anon_vma)//将后驱vma从匿名映射链表中删除
</span><span class='line'>&#9;&#9;&#9;__anon_vma_merge(vma, next);
</span><span class='line'>&#9;} else if (insert) {
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * split_vma has split insert from vma, and needs
</span><span class='line'>&#9;&#9; * us to insert it before dropping the locks
</span><span class='line'>&#9;&#9; * (it may either follow vma or precede it).
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;__insert_vm_struct(mm, insert);//将待插入的vma插入mm的红黑树，双向链表以及
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;&#9;//匿名映射链表
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;if (anon_vma)
</span><span class='line'>&#9;&#9;spin_unlock(&anon_vma-&gt;lock);
</span><span class='line'>&#9;if (mapping)
</span><span class='line'>&#9;&#9;spin_unlock(&mapping-&gt;i_mmap_lock);
</span><span class='line'>
</span><span class='line'>&#9;if (remove_next) {
</span><span class='line'>&#9;&#9;if (file) {
</span><span class='line'>&#9;&#9;&#9;fput(file);
</span><span class='line'>&#9;&#9;&#9;if (next-&gt;vm_flags & VM_EXECUTABLE)
</span><span class='line'>&#9;&#9;&#9;&#9;removed_exe_file_vma(mm);
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;mm-&gt;map_count--;
</span><span class='line'>&#9;&#9;mpol_put(vma_policy(next));
</span><span class='line'>&#9;&#9;kmem_cache_free(vm_area_cachep, next);
</span><span class='line'>&#9;&#9;/*
</span><span class='line'>&#9;&#9; * In mprotect's case 6 (see comments on vma_merge),
</span><span class='line'>&#9;&#9; * we must remove another next too. It would clutter
</span><span class='line'>&#9;&#9; * up the code too much to do both in one go.
</span><span class='line'>&#9;&#9; */
</span><span class='line'>&#9;&#9;if (remove_next == 2) {//还有待删除的区域
</span><span class='line'>&#9;&#9;&#9;next = vma-&gt;vm_next;
</span><span class='line'>&#9;&#9;&#9;goto again;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>&#9;validate_mm(mm);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>insert_vm_struct()函数用于插入一块新区域</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int insert_vm_struct(struct mm_struct * mm, struct vm_area_struct * vma)
</span><span class='line'>{
</span><span class='line'>&#9;struct vm_area_struct * __vma, * prev;
</span><span class='line'>&#9;struct rb_node ** rb_link, * rb_parent;
</span><span class='line'>
</span><span class='line'>&#9;/*
</span><span class='line'>&#9; * The vm_pgoff of a purely anonymous vma should be irrelevant
</span><span class='line'>&#9; * until its first write fault, when page's anon_vma and index
</span><span class='line'>&#9; * are set.  But now set the vm_pgoff it will almost certainly
</span><span class='line'>&#9; * end up with (unless mremap moves it elsewhere before that
</span><span class='line'>&#9; * first wfault), so /proc/pid/maps tells a consistent story.
</span><span class='line'>&#9; *
</span><span class='line'>&#9; * By setting it to reflect the virtual start address of the
</span><span class='line'>&#9; * vma, merges and splits can happen in a seamless way, just
</span><span class='line'>&#9; * using the existing file pgoff checks and manipulations.
</span><span class='line'>&#9; * Similarly in do_mmap_pgoff and in do_brk.
</span><span class='line'>&#9; */
</span><span class='line'>&#9;if (!vma-&gt;vm_file) {
</span><span class='line'>&#9;&#9;BUG_ON(vma-&gt;anon_vma);
</span><span class='line'>&#9;&#9;vma-&gt;vm_pgoff = vma-&gt;vm_start &gt;&gt; PAGE_SHIFT;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/*__vma用来保存和vma-&gt;start对应的vma(与find_vma()一样)，同时获取以下信息:
</span><span class='line'>&#9;  1.prev用来保存对应的前驱vma
</span><span class='line'>&#9;  2.rb_link保存该vma区域插入对应的红黑树节点
</span><span class='line'>&#9;  3.rb_parent保存该vma区域对应的父节点*/
</span><span class='line'>&#9;__vma = find_vma_prepare(mm,vma-&gt;vm_start,&prev,&rb_link,&rb_parent);
</span><span class='line'>&#9;if (__vma && __vma-&gt;vm_start &lt; vma-&gt;vm_end)
</span><span class='line'>&#9;&#9;return -ENOMEM;
</span><span class='line'>&#9;if ((vma-&gt;vm_flags & VM_ACCOUNT) &&
</span><span class='line'>&#9;&#9; security_vm_enough_memory_mm(mm, vma_pages(vma)))
</span><span class='line'>&#9;&#9;return -ENOMEM;
</span><span class='line'>&#9;vma_link(mm, vma, prev, rb_link, rb_parent);//将vma关联到所有的数据结构中
</span><span class='line'>&#9;return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,
</span><span class='line'>&#9;&#9;&#9;struct vm_area_struct *prev, struct rb_node **rb_link,
</span><span class='line'>&#9;&#9;&#9;struct rb_node *rb_parent)
</span><span class='line'>{
</span><span class='line'>&#9;struct address_space *mapping = NULL;
</span><span class='line'>
</span><span class='line'>&#9;if (vma-&gt;vm_file)//如果存在文件映射则获取文件对应的地址空间
</span><span class='line'>&#9;&#9;mapping = vma-&gt;vm_file-&gt;f_mapping;
</span><span class='line'>
</span><span class='line'>&#9;if (mapping) {
</span><span class='line'>&#9;&#9;spin_lock(&mapping-&gt;i_mmap_lock);
</span><span class='line'>&#9;&#9;vma-&gt;vm_truncate_count = mapping-&gt;truncate_count;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;anon_vma_lock(vma);
</span><span class='line'>
</span><span class='line'>&#9;/*将vma插入到相应的数据结构中--双向链表，红黑树和匿名映射链表*/
</span><span class='line'>&#9;__vma_link(mm, vma, prev, rb_link, rb_parent);
</span><span class='line'>&#9;__vma_link_file(vma);//将vma插入到文件地址空间的相应数据结构中
</span><span class='line'>
</span><span class='line'>&#9;anon_vma_unlock(vma);
</span><span class='line'>&#9;if (mapping)
</span><span class='line'>&#9;&#9;spin_unlock(&mapping-&gt;i_mmap_lock);
</span><span class='line'>
</span><span class='line'>&#9;mm-&gt;map_count++;
</span><span class='line'>&#9;validate_mm(mm);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在创建新的vma区域之前先要寻找一块足够大小的空闲区域，该项工作由get_unmapped_area()函数完成，而实际的工作将会由mm_struct中定义的辅助函数来完成。根据进程虚拟地址空间的布局，会选择使用不同的映射函数，在这里考虑大多数系统上采用的标准函数arch_get_unmapped_area();</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned long
</span><span class='line'>arch_get_unmapped_area(struct file *filp, unsigned long addr,
</span><span class='line'>&#9;&#9;unsigned long len, unsigned long pgoff, unsigned long flags)
</span><span class='line'>{
</span><span class='line'>&#9;struct mm_struct *mm = current-&gt;mm;
</span><span class='line'>&#9;struct vm_area_struct *vma;
</span><span class='line'>&#9;unsigned long start_addr;
</span><span class='line'>
</span><span class='line'>&#9;if (len &gt; TASK_SIZE)
</span><span class='line'>&#9;&#9;return -ENOMEM;
</span><span class='line'>
</span><span class='line'>&#9;if (flags & MAP_FIXED)
</span><span class='line'>&#9;&#9;return addr;
</span><span class='line'>
</span><span class='line'>&#9;if (addr) {
</span><span class='line'>&#9;&#9;addr = PAGE_ALIGN(addr);//将地址按页对齐
</span><span class='line'>&#9;&#9;vma = find_vma(mm, addr);//获取一个vma，该vma可能包含了addr也可能在addr后面并且离addr最近
</span><span class='line'>&#9;&#9;/*这里确定是否有一块适合的空闲区域，先要保证addr+len不会
</span><span class='line'>&#9;&#9;  超过进程地址空间的最大允许范围，然后如果前面vma获取成功的话则要保证
</span><span class='line'>&#9;&#9;  vma位于addr的后面并且addr+len不会延伸到该vma的区域*/
</span><span class='line'>&#9;&#9;if (TASK_SIZE - len &gt;= addr &&
</span><span class='line'>&#9;&#9;&#9;(!vma || addr + len &lt;= vma-&gt;vm_start))
</span><span class='line'>&#9;&#9;&#9;return addr;
</span><span class='line'>&#9;}
</span><span class='line'>&#9;/*前面获取不成功的话则要调整起始地址了，根据情况选择缓存的空闲区域地址
</span><span class='line'>&#9;  或者TASK_UNMAPPED_BASE=TASK_SIZE/3*/
</span><span class='line'>&#9;if (len &gt; mm-&gt;cached_hole_size) {
</span><span class='line'>&#9;&#9;&#9;start_addr = addr = mm-&gt;free_area_cache;
</span><span class='line'>&#9;} else {
</span><span class='line'>&#9;&#9;&#9;start_addr = addr = TASK_UNMAPPED_BASE;
</span><span class='line'>&#9;&#9;&#9;mm-&gt;cached_hole_size = 0;
</span><span class='line'>&#9;}
</span><span class='line'>
</span><span class='line'>full_search:
</span><span class='line'>&#9;/*从addr开始遍历用户地址空间*/
</span><span class='line'>&#9;for (vma = find_vma(mm, addr); ; vma = vma-&gt;vm_next) {
</span><span class='line'>&#9;&#9;/* At this point:  (!vma || addr &lt; vma-&gt;vm_end). */
</span><span class='line'>&#9;&#9;if (TASK_SIZE - len &lt; addr) {//这里判断是否已经遍历到了用户地址空间的末端
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; * Start a new search - just in case we missed
</span><span class='line'>&#9;&#9;&#9; * some holes.
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9; //如果上次不是从TAKS_UNMAPPED_BASE开始遍历的，则尝试从TASK_UNMAPPED_BASE开始遍历
</span><span class='line'>&#9;&#9;&#9;if (start_addr != TASK_UNMAPPED_BASE) {
</span><span class='line'>&#9;&#9;&#9;&#9;addr = TASK_UNMAPPED_BASE;
</span><span class='line'>&#9;&#9;&#9;&#9;&#9;start_addr = addr;
</span><span class='line'>&#9;&#9;&#9;&#9;mm-&gt;cached_hole_size = 0;
</span><span class='line'>&#9;&#9;&#9;&#9;goto full_search;
</span><span class='line'>&#9;&#9;&#9;}
</span><span class='line'>&#9;&#9;&#9;return -ENOMEM;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;if (!vma || addr + len &lt;= vma-&gt;vm_start) {//判断是否有空闲区域
</span><span class='line'>&#9;&#9;&#9;/*
</span><span class='line'>&#9;&#9;&#9; *找到空闲区域的话则记住我们搜索的结束处，以便下次搜索
</span><span class='line'>&#9;&#9;&#9; */
</span><span class='line'>&#9;&#9;&#9;mm-&gt;free_area_cache = addr + len;
</span><span class='line'>&#9;&#9;&#9;return addr;
</span><span class='line'>&#9;&#9;}
</span><span class='line'>&#9;&#9;/*该空闲区域不符合大小要求，但是如果这个空闲区域大于之前保存的最大值的话
</span><span class='line'>&#9;&#9;  则将这个空闲区域保存，这样便于前面确定从哪里开始搜索*/
</span><span class='line'>&#9;&#9;if (addr + mm-&gt;cached_hole_size &lt; vma-&gt;vm_start)
</span><span class='line'>&#9;&#9;&#9;&#9;mm-&gt;cached_hole_size = vma-&gt;vm_start - addr;
</span><span class='line'>&#9;&#9;addr = vma-&gt;vm_end;
</span><span class='line'>&#9;}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">kk</span></span>

      




<time class='entry-date' datetime='2015-09-11T16:39:00+08:00'><span class='date'>2015-09-11</span> <span class='time'>16:39:00</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/cats/kernel/'>kernel</a>, <a class='category' href='/blog/cats/kernel~mm/'>mm</a>
  
</span>


    </p>
    
      
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/09/09/kernel-mm-find-page/" title="Previous Post: 查看某进程内存">&laquo; 查看某进程内存</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/09/11/kernel-mm-mmap/" title="Next Post: linux mmap 详解">linux mmap 详解 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>
<aside class="sidebar" id='load_sidebar'>
</aside>
<script type="text/javascript">
  $('#load_sidebar').load('/sidebar.html');
</script>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  





</body>
</html>
