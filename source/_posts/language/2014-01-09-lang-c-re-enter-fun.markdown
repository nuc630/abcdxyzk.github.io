---
layout: post
title: "可重入函数与不可重入函数"
date: 2014-01-09 17:29:00 +0800
comments: false
categories:
- 2014
- 2014~01
- language
- language~c
tags:
---
可重入函数主要用于多任务环境中，简单来说就是可以被中断的函数，即在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代 码，返回控制时不会出现什么错误；也意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是 purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。而不可重入的函数由于使用了一些系 统资源，比如全局变量区、中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。

可重入函数确实需要访问全局变量（包括 static），一定要注意实施互斥手段。它在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态。

示例：假设Exam是 int型全局变量，函数Squre_Exam返回Exam平方值。那么如下函数不具有可重入性。
```
	int Exam = 0;
	unsigned int example( int para )
	{
		unsigned int temp;
		Exam = para; // （**）
		 temp = Square_Exam( );
		return temp;  
	}
```
此函数若被多个进程调用的话，其结果可能是未知的，因为当（**）语句刚执行完后，另外一个使用本函数的进程可能正好被激活，那么当新激活的进程执行到此 函数时，将使Exam赋与另一个不同的para值，所以当控制重新回到“temp = Square_Exam( )”后，计算出的temp很可能不是预想中的结果。此函数应如下改进。
```
	int Exam = 0;
	unsigned int example( int para )
	{
		unsigned int temp;  
		[申请信号量操作] //(1)  加锁  
		Exam = para;  
		temp = Square_Exam( );  
		[释放信号量操作] //	 解锁   
		return temp;  
	}
```
申请不到“信号量”，说明另外的进程正处于给Exam赋值并计算其平方过程中（即正在使用此信号）,本进程必须等待其释放信号后，才可继续执行。若申请到 信号，则可继续执行，但其它进程必须等待本进程释放信号量后，才能再使用本信号。保证函数的可重入性的方法：  
  1、在写函数时候尽量使用局部变量（例如寄存器、堆栈中的变量）；  
  2、对于要使用的全局变量要加以保护（如采取关中断、信号量等方法），这样构成的函数就一定是一个可重入的函数。

满足下列条件的函数多数是不可重入的：  
  1、函数体内使用了静态的数据结构；  
  2、函数体内调用了malloc()或者free()函数；  
  3、函数体内调用了标准I/O函数。

如何将一个不可重入的函数改写成可重入函数呢？把一个不可重入函数变成可重入的唯一方法是用可重入规则来重写它。其实很简单，只要遵守了几条很容易理解的规则，那么写出来的函数就是可重入的：  
  1、不要使用全局变量。因为别的代码很可能覆盖这些变量值。  
  2、在和硬件发生交互的时候，切记执行类似disinterrupt()之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/ 退出核心”。  
  3、不能调用其它任何不可重入的函数。  
  4、谨慎使用堆栈。最好先在使用前先OS_ENTER_KERNAL。

