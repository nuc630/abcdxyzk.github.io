---
layout: post
title: "dup()和dup2()函数"
date: 2011-12-01 23:26:00 +0800
comments: false
categories:
- 2011
- 2011~12
- language
- language~c
tags:
- koj
- judge
---
dup和dup2也是两个非常有用的调用，它们的作用都是用来复制一个文件的描述符。  
它们经常用来重定向进程的stdin、stdout和stderr。  

这两个函数的 原形如下：
```
 #include<unistd.h>
 int dup( int oldfd );
 int dup2( int oldfd, int targetfd )
```

利用函数dup，我们可以复制一个描述符。传给该函数一个既有的描述符，它就会返回一个新的描述符，
这个新的描述符是传给它的描述符的拷贝。这意味着，这两个描述符共享同一个数据结构。例如，
如果我们对一个文件描述符执行lseek操作，得到的第一个文件的位置和第二个是一样的。
下面是用来说明dup函数使用方法的代码片段：
```
 int fd1, fd2;
    ...
 fd2 = dup( fd1 );
```
需要注意的是，我们可以在调用fork之前建立一个描述符，这与调用dup建立描述符的效果是一样的，
子进程也同样会收到一个复制出来的描述符。

  dup2函数跟dup函数相似，但dup2函数允许调用者规定一个有效描述符和目标描述符的id。dup2函数成功返回时，目标描述符（dup2函数的第二个参数）将变成源描述符（dup2函数的第一个参数）的复制品，换句话说，两个文件描述符现在都指向同一个文件，并且是函数第一个参数指向的文件。下面我们用一段代码加以说明：     
```
 int oldfd，newfd;
 oldfd = open("app_log", (O_RDWR | O_CREATE), 0644);
 newfd=dup2( oldfd, 1);//因为目的是重定向标准输出，所以一般不用保存复制出的描述符。
 close( oldfd );
```
本例中，我们打开了一个新文件，称为“app_log”，并收到一个文件描述符，该描述符叫做oldfd。我们调用dup2函数，参数为oldfd和1，这会导致用我们新打开的文件描述符替换掉由1代表的文件描述符（即stdout，因为标准输出文件的id为1）。任何写到stdout的东西，现在都将改为写入名为“app_log”的文件中。

需要注意的是，dup2函数在复制了oldfd之后，会立即将其关闭，但不会关掉新近打开的文件描述符，因为文件描述符1现在也指向它。

代码测试：
```
	#include<stdio.h>
	#include<fcntl.h>
	int main()
	{
		int fd1,fd2,fd3;
		fd1=open("./bcd",O_CREAT|O_RDWR,0644);
		write(fd1,"bcd\n",4);
		fd2=dup(fd1);
		write(fd2,"new\n",4);
		fd3=dup2(fd1,1);
		printf("dup2 test 1\n");
		write(fd3,"ok\n",3);
		printf("dup2 test 2 \n");
		return 1;
	}
```
运行之后，查看bcd中可以看到如下内容：
```
bcd
new
ok
dup2 test 1
dup2 test 2
```
有个疑问：为什么ok在dup2 test 1之后显示呢？

下面的内容还没看懂呢，以后继续：  
  下面我们介绍一个更加深入的示例代码。回忆一下本文前面讲的命令行管道，在那里，我们将ls –1命令的标准输出作为标准输入连接到wc–l命令。接下来，我们就用一个C程序来加以说明这个过程的实现。代码如下面的示例代码3所示。  
  在示例代码3中，首先在第9行代码中建立一个管道，然后将应用程序分成两个进程：一个子进程（第13–16行）和一个父进程（第20–23行）。接下来，在子进程中首先关闭stdout描述符（第13行），然后提供了ls–1命令功能，不过它不是写到stdout（第13行），而是写到我们建立的管道的输入端，这是通过dup函数来完成重定向的。在第14行，使用dup2函数把stdout重定向到管道（pfds[1]）。之后，马上关掉管道的输入端。然后，使用execlp函数把子进程的映像替换为命令ls–1的进程映像，一旦该命令执行，它的任何输出都将发给管道的输入端。

  现在来研究一下管道的接收端。从代码中可以看出，管道的接收端是由父进程来担当的。首先关闭stdin描述符（第20行），因为我们不会从机器的键盘等标准设备文件来接收数据的输入，而是从其它程序的输出中接收数据。然后，再一次用到dup2函数（第21行），让stdin变成管道的输出端，这是通过让文件描述符0（即常规的stdin）等于pfds[0]来实现的。关闭管道的stdout端（pfds[1]），因为在这里用不到它。最后，使用execlp函数把父进程的映像替换为命令wc -1的进程映像，命令wc -1把管道的内容作为它的输入（第23行）。

示例代码3：利用C实现命令的流水线操作的代码
```
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>

	int main()
	{
		int pfds[2];
		if ( pipe(pfds) == 0 ){  //建立一个管道
			if ( fork() == 0 ) {  //子进程
				close(1);    //关闭stdout描述符
				dup2( pfds[1], 1);  //把stdout重定向到管道（pfds[1]）
				close( pfds[0]);   //关掉管道的输入端
				execlp( "ls", "ls", "-1", NULL ); //把子进程的映像替换为命令ls–1的进程映像
			} else{    //父进程
				close(0);    //关闭stdin描述符
				dup2( pfds[0], 0);  //让stdin变成管道的输出端
				close( pfds[1]);   //关闭管道的stdout端（pfds[1]）
				execlp( "wc", "wc", "-l", NULL ); //把父进程的映像替换为命令wc-1的进程映像
			}
		}
		return 0;
	}
```

在该程序中，需要格外关注的是，我们的子进程把它的输出重定向的管道的输入，然后，父进程将它的输入重定向到管道的输出。

这在实际的应用程序开发中是非常有用的一种技术。

##### 1. 文件描述符在内核中数据结构  
  在具体说dup/dup2之前，　我认为有必要先了解一下文件描述符在内核中的形态。  
  一个进程在此存在期间，会有一些文件被打开，从而会返回一些文件描述符，从shell
中运行一个进程，默认会有3个文件描述符存在(0、１、2), 0与进程的标准输入相关联，
１与进程的标准输出相关联，2与进程的标准错误输出相关联，一个进程当前有哪些打开
的文件描述符可以通过/proc/进程ID/fd目录查看。　下图可以清楚的说明问题：
```
 　　进程表项 
 ————————————————
 　　　fd标志　文件指针
      _____________________ 
 fd0:|________|____________|------------>文件表 
 fd1:|________|____________| 
 fd2:|________|____________|
 fd3:|________|____________|
     |    .........        | 
     |_____________________|
 
               图１
```
文件表中包含:文件状态标志、当前文件偏移量、v节点指针，这些不是本文讨论的
重点，我们只需要知道每个打开的文件描述符(fd标志)在进程表中都有自己的文件表
项，由文件指针指向。

##### 2. dup/dup2函数
APUE和man文档都用一句话简明的说出了这两个函数的作用：复制一个现存的文件描述符。
```
 #include<unistd.h>
 int dup(int oldfd);
 int dup2(int oldfd, int newfd);
```
从图１来分析这个过程，当调用dup函数时，内核在进程中创建一个新的文件描述符，此
描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。
```
 　　进程表项 
 ———————————————— 
 　　　fd标志　文件指针 

      _____________________ 
 fd0:|________|____________|                  ______ 
 fd1:|________|____________|---------------->|      | 
 fd2:|________|____________|                 |文件表 | 
 fd3:|________|____________|---------------->|______| 
     |    .........        | 
     |_____________________|
               图2：调用dup后的示意图
```
如图2 所示，假如oldfd的值为1, 当前文件描述符的最小值为3,　那么新描述符3指向描述符１所拥有的文件表项。

dup2和dup的区别就是可以用newfd参数指定新描述符的数值，如果newfd已经打开，则先将其关闭。如果newfd等于oldfd，则dup2返回newfd,而不关闭它。dup2函数返回的新文件描述符同样与参数oldfd共享同一文件表项。

APUE用另外一个种方法说明了这个问题：
实际上，调用dup(oldfd)；
等效与
```
       fcntl(oldfd, F_DUPFD, 0)
```
而调用dup2(oldfd, newfd)；
等效与
```
       close(oldfd)；
       fcntl(oldfd, F_DUPFD, newfd)；
```

